pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_labs = @import("std").zig.c_builtins.__builtin_labs;
pub const __builtin_llabs = @import("std").zig.c_builtins.__builtin_llabs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const __int8_t = i8;
pub const __uint8_t = u8;
pub const __int16_t = c_short;
pub const __uint16_t = c_ushort;
pub const __int32_t = c_int;
pub const __uint32_t = c_uint;
pub const __int64_t = c_longlong;
pub const __uint64_t = c_ulonglong;
pub const __darwin_intptr_t = c_long;
pub const __darwin_natural_t = c_uint;
pub const __darwin_ct_rune_t = c_int;
pub const __mbstate_t = extern union {
    __mbstate8: [128]u8,
    _mbstateL: c_longlong,
};
pub const __darwin_mbstate_t = __mbstate_t;
pub const __darwin_ptrdiff_t = c_long;
pub const __darwin_size_t = c_ulong;
pub const __builtin_va_list = [*c]u8;
pub const __darwin_va_list = __builtin_va_list;
pub const __darwin_wchar_t = c_int;
pub const __darwin_rune_t = __darwin_wchar_t;
pub const __darwin_wint_t = c_int;
pub const __darwin_clock_t = c_ulong;
pub const __darwin_socklen_t = __uint32_t;
pub const __darwin_ssize_t = c_long;
pub const __darwin_time_t = c_long;
pub const u_int8_t = u8;
pub const u_int16_t = c_ushort;
pub const u_int32_t = c_uint;
pub const u_int64_t = c_ulonglong;
pub const register_t = i64;
pub const user_addr_t = u_int64_t;
pub const user_size_t = u_int64_t;
pub const user_ssize_t = i64;
pub const user_long_t = i64;
pub const user_ulong_t = u_int64_t;
pub const user_time_t = i64;
pub const user_off_t = i64;
pub const syscall_arg_t = u_int64_t;
pub const __darwin_blkcnt_t = __int64_t;
pub const __darwin_blksize_t = __int32_t;
pub const __darwin_dev_t = __int32_t;
pub const __darwin_fsblkcnt_t = c_uint;
pub const __darwin_fsfilcnt_t = c_uint;
pub const __darwin_gid_t = __uint32_t;
pub const __darwin_id_t = __uint32_t;
pub const __darwin_ino64_t = __uint64_t;
pub const __darwin_ino_t = __darwin_ino64_t;
pub const __darwin_mach_port_name_t = __darwin_natural_t;
pub const __darwin_mach_port_t = __darwin_mach_port_name_t;
pub const __darwin_mode_t = __uint16_t;
pub const __darwin_off_t = __int64_t;
pub const __darwin_pid_t = __int32_t;
pub const __darwin_sigset_t = __uint32_t;
pub const __darwin_suseconds_t = __int32_t;
pub const __darwin_uid_t = __uint32_t;
pub const __darwin_useconds_t = __uint32_t;
pub const __darwin_uuid_t = [16]u8;
pub const __darwin_uuid_string_t = [37]u8;
pub const struct___darwin_pthread_handler_rec = extern struct {
    __routine: ?*const fn (?*anyopaque) callconv(.C) void = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.C) void),
    __arg: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    __next: [*c]struct___darwin_pthread_handler_rec = @import("std").mem.zeroes([*c]struct___darwin_pthread_handler_rec),
};
pub const struct__opaque_pthread_attr_t = extern struct {
    __sig: c_long = @import("std").mem.zeroes(c_long),
    __opaque: [56]u8 = @import("std").mem.zeroes([56]u8),
};
pub const struct__opaque_pthread_cond_t = extern struct {
    __sig: c_long = @import("std").mem.zeroes(c_long),
    __opaque: [40]u8 = @import("std").mem.zeroes([40]u8),
};
pub const struct__opaque_pthread_condattr_t = extern struct {
    __sig: c_long = @import("std").mem.zeroes(c_long),
    __opaque: [8]u8 = @import("std").mem.zeroes([8]u8),
};
pub const struct__opaque_pthread_mutex_t = extern struct {
    __sig: c_long = @import("std").mem.zeroes(c_long),
    __opaque: [56]u8 = @import("std").mem.zeroes([56]u8),
};
pub const struct__opaque_pthread_mutexattr_t = extern struct {
    __sig: c_long = @import("std").mem.zeroes(c_long),
    __opaque: [8]u8 = @import("std").mem.zeroes([8]u8),
};
pub const struct__opaque_pthread_once_t = extern struct {
    __sig: c_long = @import("std").mem.zeroes(c_long),
    __opaque: [8]u8 = @import("std").mem.zeroes([8]u8),
};
pub const struct__opaque_pthread_rwlock_t = extern struct {
    __sig: c_long = @import("std").mem.zeroes(c_long),
    __opaque: [192]u8 = @import("std").mem.zeroes([192]u8),
};
pub const struct__opaque_pthread_rwlockattr_t = extern struct {
    __sig: c_long = @import("std").mem.zeroes(c_long),
    __opaque: [16]u8 = @import("std").mem.zeroes([16]u8),
};
pub const struct__opaque_pthread_t = extern struct {
    __sig: c_long = @import("std").mem.zeroes(c_long),
    __cleanup_stack: [*c]struct___darwin_pthread_handler_rec = @import("std").mem.zeroes([*c]struct___darwin_pthread_handler_rec),
    __opaque: [8176]u8 = @import("std").mem.zeroes([8176]u8),
};
pub const __darwin_pthread_attr_t = struct__opaque_pthread_attr_t;
pub const __darwin_pthread_cond_t = struct__opaque_pthread_cond_t;
pub const __darwin_pthread_condattr_t = struct__opaque_pthread_condattr_t;
pub const __darwin_pthread_key_t = c_ulong;
pub const __darwin_pthread_mutex_t = struct__opaque_pthread_mutex_t;
pub const __darwin_pthread_mutexattr_t = struct__opaque_pthread_mutexattr_t;
pub const __darwin_pthread_once_t = struct__opaque_pthread_once_t;
pub const __darwin_pthread_rwlock_t = struct__opaque_pthread_rwlock_t;
pub const __darwin_pthread_rwlockattr_t = struct__opaque_pthread_rwlockattr_t;
pub const __darwin_pthread_t = [*c]struct__opaque_pthread_t;
pub const int_least8_t = i8;
pub const int_least16_t = i16;
pub const int_least32_t = i32;
pub const int_least64_t = i64;
pub const uint_least8_t = u8;
pub const uint_least16_t = u16;
pub const uint_least32_t = u32;
pub const uint_least64_t = u64;
pub const int_fast8_t = i8;
pub const int_fast16_t = i16;
pub const int_fast32_t = i32;
pub const int_fast64_t = i64;
pub const uint_fast8_t = u8;
pub const uint_fast16_t = u16;
pub const uint_fast32_t = u32;
pub const uint_fast64_t = u64;
pub const intmax_t = c_long;
pub const uintmax_t = c_ulong;
pub fn _OSSwapInt16(arg__data: u16) callconv(.C) u16 {
    var _data = arg__data;
    _ = &_data;
    return @as(u16, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, _data))) << @intCast(8)) | (@as(c_int, @bitCast(@as(c_uint, _data))) >> @intCast(8))))));
}
pub fn _OSSwapInt32(arg__data: u32) callconv(.C) u32 {
    var _data = arg__data;
    _ = &_data;
    _data = __builtin_bswap32(_data);
    return _data;
}
pub fn _OSSwapInt64(arg__data: u64) callconv(.C) u64 {
    var _data = arg__data;
    _ = &_data;
    return __builtin_bswap64(_data);
}
pub const struct__OSUnalignedU16 = extern struct {
    __val: u16 align(1) = @import("std").mem.zeroes(u16),
};
pub const struct__OSUnalignedU32 = extern struct {
    __val: u32 align(1) = @import("std").mem.zeroes(u32),
};
pub const struct__OSUnalignedU64 = extern struct {
    __val: u64 align(1) = @import("std").mem.zeroes(u64),
};
pub fn OSReadSwapInt16(arg__base: ?*const volatile anyopaque, arg__offset: usize) callconv(.C) u16 {
    var _base = arg__base;
    _ = &_base;
    var _offset = arg__offset;
    _ = &_offset;
    return _OSSwapInt16(@as([*c]struct__OSUnalignedU16, @ptrFromInt(@as(usize, @intCast(@intFromPtr(_base))) +% _offset)).*.__val);
}
pub fn OSReadSwapInt32(arg__base: ?*const volatile anyopaque, arg__offset: usize) callconv(.C) u32 {
    var _base = arg__base;
    _ = &_base;
    var _offset = arg__offset;
    _ = &_offset;
    return _OSSwapInt32(@as([*c]struct__OSUnalignedU32, @ptrFromInt(@as(usize, @intCast(@intFromPtr(_base))) +% _offset)).*.__val);
}
pub fn OSReadSwapInt64(arg__base: ?*const volatile anyopaque, arg__offset: usize) callconv(.C) u64 {
    var _base = arg__base;
    _ = &_base;
    var _offset = arg__offset;
    _ = &_offset;
    return _OSSwapInt64(@as([*c]struct__OSUnalignedU64, @ptrFromInt(@as(usize, @intCast(@intFromPtr(_base))) +% _offset)).*.__val);
}
pub fn OSWriteSwapInt16(arg__base: ?*volatile anyopaque, arg__offset: usize, arg__data: u16) callconv(.C) void {
    var _base = arg__base;
    _ = &_base;
    var _offset = arg__offset;
    _ = &_offset;
    var _data = arg__data;
    _ = &_data;
    @as([*c]struct__OSUnalignedU16, @ptrFromInt(@as(usize, @intCast(@intFromPtr(_base))) +% _offset)).*.__val = _OSSwapInt16(_data);
}
pub fn OSWriteSwapInt32(arg__base: ?*volatile anyopaque, arg__offset: usize, arg__data: u32) callconv(.C) void {
    var _base = arg__base;
    _ = &_base;
    var _offset = arg__offset;
    _ = &_offset;
    var _data = arg__data;
    _ = &_data;
    @as([*c]struct__OSUnalignedU32, @ptrFromInt(@as(usize, @intCast(@intFromPtr(_base))) +% _offset)).*.__val = _OSSwapInt32(_data);
}
pub fn OSWriteSwapInt64(arg__base: ?*volatile anyopaque, arg__offset: usize, arg__data: u64) callconv(.C) void {
    var _base = arg__base;
    _ = &_base;
    var _offset = arg__offset;
    _ = &_offset;
    var _data = arg__data;
    _ = &_data;
    @as([*c]struct__OSUnalignedU64, @ptrFromInt(@as(usize, @intCast(@intFromPtr(_base))) +% _offset)).*.__val = _OSSwapInt64(_data);
}
pub const u_char = u8;
pub const u_short = c_ushort;
pub const u_int = c_uint;
pub const u_long = c_ulong;
pub const ushort = c_ushort;
pub const uint = c_uint;
pub const u_quad_t = u_int64_t;
pub const quad_t = i64;
pub const qaddr_t = [*c]quad_t;
pub const caddr_t = [*c]u8;
pub const daddr_t = i32;
pub const dev_t = __darwin_dev_t;
pub const fixpt_t = u_int32_t;
pub const blkcnt_t = __darwin_blkcnt_t;
pub const blksize_t = __darwin_blksize_t;
pub const gid_t = __darwin_gid_t;
pub const in_addr_t = __uint32_t;
pub const in_port_t = __uint16_t;
pub const ino_t = __darwin_ino_t;
pub const ino64_t = __darwin_ino64_t;
pub const key_t = __int32_t;
pub const mode_t = __darwin_mode_t;
pub const nlink_t = __uint16_t;
pub const id_t = __darwin_id_t;
pub const pid_t = __darwin_pid_t;
pub const off_t = __darwin_off_t;
pub const segsz_t = i32;
pub const swblk_t = i32;
pub const uid_t = __darwin_uid_t;
pub const clock_t = __darwin_clock_t;
pub const time_t = __darwin_time_t;
pub const useconds_t = __darwin_useconds_t;
pub const suseconds_t = __darwin_suseconds_t;
pub const rsize_t = __darwin_size_t;
pub const errno_t = c_int;
pub const struct_fd_set = extern struct {
    fds_bits: [32]__int32_t = @import("std").mem.zeroes([32]__int32_t),
};
pub const fd_set = struct_fd_set;
pub extern fn __darwin_check_fd_set_overflow(c_int, ?*const anyopaque, c_int) c_int;
pub inline fn __darwin_check_fd_set(arg__a: c_int, arg__b: ?*const anyopaque) c_int {
    var _a = arg__a;
    _ = &_a;
    var _b = arg__b;
    _ = &_b;
    if (@as(usize, @intCast(@intFromPtr(&__darwin_check_fd_set_overflow))) != @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) {
        return __darwin_check_fd_set_overflow(_a, _b, @as(c_int, 0));
    } else {
        return 1;
    }
    return 0;
}
pub inline fn __darwin_fd_isset(arg__fd: c_int, arg__p: [*c]const struct_fd_set) c_int {
    var _fd = arg__fd;
    _ = &_fd;
    var _p = arg__p;
    _ = &_p;
    if (__darwin_check_fd_set(_fd, @as(?*const anyopaque, @ptrCast(_p))) != 0) {
        return _p.*.fds_bits[@as(c_ulong, @bitCast(@as(c_long, _fd))) / (@sizeOf(__int32_t) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))))] & @as(__int32_t, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(c_ulong, @bitCast(@as(c_long, _fd))) % (@sizeOf(__int32_t) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))))))));
    }
    return 0;
}
pub inline fn __darwin_fd_set(arg__fd: c_int, _p: [*c]struct_fd_set) void {
    var _fd = arg__fd;
    _ = &_fd;
    _ = &_p;
    if (__darwin_check_fd_set(_fd, @as(?*const anyopaque, @ptrCast(_p))) != 0) {
        _ = blk: {
            const ref = &_p.*.fds_bits[@as(c_ulong, @bitCast(@as(c_long, _fd))) / (@sizeOf(__int32_t) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))))];
            ref.* |= @as(__int32_t, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(c_ulong, @bitCast(@as(c_long, _fd))) % (@sizeOf(__int32_t) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))))))));
            break :blk ref.*;
        };
    }
}
pub inline fn __darwin_fd_clr(arg__fd: c_int, _p: [*c]struct_fd_set) void {
    var _fd = arg__fd;
    _ = &_fd;
    _ = &_p;
    if (__darwin_check_fd_set(_fd, @as(?*const anyopaque, @ptrCast(_p))) != 0) {
        _ = blk: {
            const ref = &_p.*.fds_bits[@as(c_ulong, @bitCast(@as(c_long, _fd))) / (@sizeOf(__int32_t) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))))];
            ref.* &= ~@as(__int32_t, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(c_ulong, @bitCast(@as(c_long, _fd))) % (@sizeOf(__int32_t) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))))))));
            break :blk ref.*;
        };
    }
}
pub const fd_mask = __int32_t;
pub const pthread_attr_t = __darwin_pthread_attr_t;
pub const pthread_cond_t = __darwin_pthread_cond_t;
pub const pthread_condattr_t = __darwin_pthread_condattr_t;
pub const pthread_mutex_t = __darwin_pthread_mutex_t;
pub const pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub const pthread_once_t = __darwin_pthread_once_t;
pub const pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub const pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub const pthread_t = __darwin_pthread_t;
pub const pthread_key_t = __darwin_pthread_key_t;
pub const fsblkcnt_t = __darwin_fsblkcnt_t;
pub const fsfilcnt_t = __darwin_fsfilcnt_t;
pub const __darwin_nl_item = c_int;
pub const __darwin_wctrans_t = c_int;
pub const __darwin_wctype_t = __uint32_t;
pub const wchar_t = __darwin_wchar_t;
pub extern fn imaxabs(j: intmax_t) intmax_t;
pub const imaxdiv_t = extern struct {
    quot: intmax_t = @import("std").mem.zeroes(intmax_t),
    rem: intmax_t = @import("std").mem.zeroes(intmax_t),
};
pub extern fn imaxdiv(__numer: intmax_t, __denom: intmax_t) imaxdiv_t;
pub extern fn strtoimax(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) intmax_t;
pub extern fn strtoumax(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) uintmax_t;
pub extern fn wcstoimax(noalias __nptr: [*c]const wchar_t, noalias __endptr: [*c][*c]wchar_t, __base: c_int) intmax_t;
pub extern fn wcstoumax(noalias __nptr: [*c]const wchar_t, noalias __endptr: [*c][*c]wchar_t, __base: c_int) uintmax_t;
pub const ossl_intmax_t = intmax_t;
pub const ossl_uintmax_t = uintmax_t;
pub const struct_timespec = extern struct {
    tv_sec: __darwin_time_t = @import("std").mem.zeroes(__darwin_time_t),
    tv_nsec: c_long = @import("std").mem.zeroes(c_long),
};
pub const struct_timeval = extern struct {
    tv_sec: __darwin_time_t = @import("std").mem.zeroes(__darwin_time_t),
    tv_usec: __darwin_suseconds_t = @import("std").mem.zeroes(__darwin_suseconds_t),
};
pub const struct_timeval64 = extern struct {
    tv_sec: __int64_t = @import("std").mem.zeroes(__int64_t),
    tv_usec: __int64_t = @import("std").mem.zeroes(__int64_t),
};
pub const struct_itimerval = extern struct {
    it_interval: struct_timeval = @import("std").mem.zeroes(struct_timeval),
    it_value: struct_timeval = @import("std").mem.zeroes(struct_timeval),
};
pub const struct_timezone = extern struct {
    tz_minuteswest: c_int = @import("std").mem.zeroes(c_int),
    tz_dsttime: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_clockinfo = extern struct {
    hz: c_int = @import("std").mem.zeroes(c_int),
    tick: c_int = @import("std").mem.zeroes(c_int),
    tickadj: c_int = @import("std").mem.zeroes(c_int),
    stathz: c_int = @import("std").mem.zeroes(c_int),
    profhz: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_tm = extern struct {
    tm_sec: c_int = @import("std").mem.zeroes(c_int),
    tm_min: c_int = @import("std").mem.zeroes(c_int),
    tm_hour: c_int = @import("std").mem.zeroes(c_int),
    tm_mday: c_int = @import("std").mem.zeroes(c_int),
    tm_mon: c_int = @import("std").mem.zeroes(c_int),
    tm_year: c_int = @import("std").mem.zeroes(c_int),
    tm_wday: c_int = @import("std").mem.zeroes(c_int),
    tm_yday: c_int = @import("std").mem.zeroes(c_int),
    tm_isdst: c_int = @import("std").mem.zeroes(c_int),
    tm_gmtoff: c_long = @import("std").mem.zeroes(c_long),
    tm_zone: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const tzname: [*c][*c]u8 = @extern([*c][*c]u8, .{
    .name = "tzname",
});
pub extern var getdate_err: c_int;
pub extern var timezone: c_long;
pub extern var daylight: c_int;
pub extern fn asctime([*c]const struct_tm) [*c]u8;
pub extern fn clock() clock_t;
pub extern fn ctime([*c]const time_t) [*c]u8;
pub extern fn difftime(time_t, time_t) f64;
pub extern fn getdate([*c]const u8) [*c]struct_tm;
pub extern fn gmtime([*c]const time_t) [*c]struct_tm;
pub extern fn localtime([*c]const time_t) [*c]struct_tm;
pub extern fn mktime([*c]struct_tm) time_t;
pub extern fn strftime(noalias [*c]u8, usize, noalias [*c]const u8, noalias [*c]const struct_tm) usize;
pub extern fn strptime(noalias [*c]const u8, noalias [*c]const u8, noalias [*c]struct_tm) [*c]u8;
pub extern fn time([*c]time_t) time_t;
pub extern fn tzset() void;
pub extern fn asctime_r(noalias [*c]const struct_tm, noalias [*c]u8) [*c]u8;
pub extern fn ctime_r([*c]const time_t, [*c]u8) [*c]u8;
pub extern fn gmtime_r(noalias [*c]const time_t, noalias [*c]struct_tm) [*c]struct_tm;
pub extern fn localtime_r(noalias [*c]const time_t, noalias [*c]struct_tm) [*c]struct_tm;
pub extern fn posix2time(time_t) time_t;
pub extern fn tzsetwall() void;
pub extern fn time2posix(time_t) time_t;
pub extern fn timelocal([*c]struct_tm) time_t;
pub extern fn timegm([*c]struct_tm) time_t;
pub extern fn nanosleep(__rqtp: [*c]const struct_timespec, __rmtp: [*c]struct_timespec) c_int;
pub const _CLOCK_REALTIME: c_int = 0;
pub const _CLOCK_MONOTONIC: c_int = 6;
pub const _CLOCK_MONOTONIC_RAW: c_int = 4;
pub const _CLOCK_MONOTONIC_RAW_APPROX: c_int = 5;
pub const _CLOCK_UPTIME_RAW: c_int = 8;
pub const _CLOCK_UPTIME_RAW_APPROX: c_int = 9;
pub const _CLOCK_PROCESS_CPUTIME_ID: c_int = 12;
pub const _CLOCK_THREAD_CPUTIME_ID: c_int = 16;
pub const clockid_t = c_uint;
pub extern fn clock_getres(__clock_id: clockid_t, __res: [*c]struct_timespec) c_int;
pub extern fn clock_gettime(__clock_id: clockid_t, __tp: [*c]struct_timespec) c_int;
pub extern fn clock_gettime_nsec_np(__clock_id: clockid_t) __uint64_t;
pub extern fn clock_settime(__clock_id: clockid_t, __tp: [*c]const struct_timespec) c_int;
pub extern fn timespec_get(ts: [*c]struct_timespec, base: c_int) c_int;
pub extern fn adjtime([*c]const struct_timeval, [*c]struct_timeval) c_int;
pub extern fn futimes(c_int, [*c]const struct_timeval) c_int;
pub extern fn lutimes([*c]const u8, [*c]const struct_timeval) c_int;
pub extern fn settimeofday([*c]const struct_timeval, [*c]const struct_timezone) c_int;
pub extern fn getitimer(c_int, [*c]struct_itimerval) c_int;
pub extern fn gettimeofday(noalias [*c]struct_timeval, noalias ?*anyopaque) c_int;
pub extern fn select(c_int, noalias [*c]fd_set, noalias [*c]fd_set, noalias [*c]fd_set, noalias [*c]struct_timeval) c_int;
pub extern fn setitimer(c_int, noalias [*c]const struct_itimerval, noalias [*c]struct_itimerval) c_int;
pub extern fn utimes([*c]const u8, [*c]const struct_timeval) c_int;
pub const P_ALL: c_int = 0;
pub const P_PID: c_int = 1;
pub const P_PGID: c_int = 2;
pub const idtype_t = c_uint;
pub const sig_atomic_t = c_int;
pub const struct___darwin_arm_exception_state = extern struct {
    __exception: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __fsr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __far: __uint32_t = @import("std").mem.zeroes(__uint32_t),
};
pub const struct___darwin_arm_exception_state64 = extern struct {
    __far: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    __esr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __exception: __uint32_t = @import("std").mem.zeroes(__uint32_t),
};
pub const struct___darwin_arm_thread_state = extern struct {
    __r: [13]__uint32_t = @import("std").mem.zeroes([13]__uint32_t),
    __sp: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __lr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __pc: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __cpsr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
};
pub const struct___darwin_arm_thread_state64 = extern struct {
    __x: [29]__uint64_t = @import("std").mem.zeroes([29]__uint64_t),
    __fp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    __lr: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    __sp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    __pc: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    __cpsr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __pad: __uint32_t = @import("std").mem.zeroes(__uint32_t),
};
pub const struct___darwin_arm_vfp_state = extern struct {
    __r: [64]__uint32_t = @import("std").mem.zeroes([64]__uint32_t),
    __fpscr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
};
pub const __uint128_t = u128;
pub const struct___darwin_arm_neon_state64 = extern struct {
    __v: [32]__uint128_t = @import("std").mem.zeroes([32]__uint128_t),
    __fpsr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __fpcr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
};
pub const struct___darwin_arm_neon_state = extern struct {
    __v: [16]__uint128_t = @import("std").mem.zeroes([16]__uint128_t),
    __fpsr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __fpcr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
};
pub const struct___arm_pagein_state = extern struct {
    __pagein_error: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct___arm_legacy_debug_state = extern struct {
    __bvr: [16]__uint32_t = @import("std").mem.zeroes([16]__uint32_t),
    __bcr: [16]__uint32_t = @import("std").mem.zeroes([16]__uint32_t),
    __wvr: [16]__uint32_t = @import("std").mem.zeroes([16]__uint32_t),
    __wcr: [16]__uint32_t = @import("std").mem.zeroes([16]__uint32_t),
};
pub const struct___darwin_arm_debug_state32 = extern struct {
    __bvr: [16]__uint32_t = @import("std").mem.zeroes([16]__uint32_t),
    __bcr: [16]__uint32_t = @import("std").mem.zeroes([16]__uint32_t),
    __wvr: [16]__uint32_t = @import("std").mem.zeroes([16]__uint32_t),
    __wcr: [16]__uint32_t = @import("std").mem.zeroes([16]__uint32_t),
    __mdscr_el1: __uint64_t = @import("std").mem.zeroes(__uint64_t),
};
pub const struct___darwin_arm_debug_state64 = extern struct {
    __bvr: [16]__uint64_t = @import("std").mem.zeroes([16]__uint64_t),
    __bcr: [16]__uint64_t = @import("std").mem.zeroes([16]__uint64_t),
    __wvr: [16]__uint64_t = @import("std").mem.zeroes([16]__uint64_t),
    __wcr: [16]__uint64_t = @import("std").mem.zeroes([16]__uint64_t),
    __mdscr_el1: __uint64_t = @import("std").mem.zeroes(__uint64_t),
};
pub const struct___darwin_arm_cpmu_state64 = extern struct {
    __ctrs: [16]__uint64_t = @import("std").mem.zeroes([16]__uint64_t),
};
pub const struct___darwin_mcontext32 = extern struct {
    __es: struct___darwin_arm_exception_state = @import("std").mem.zeroes(struct___darwin_arm_exception_state),
    __ss: struct___darwin_arm_thread_state = @import("std").mem.zeroes(struct___darwin_arm_thread_state),
    __fs: struct___darwin_arm_vfp_state = @import("std").mem.zeroes(struct___darwin_arm_vfp_state),
};
pub const struct___darwin_mcontext64 = extern struct {
    __es: struct___darwin_arm_exception_state64 = @import("std").mem.zeroes(struct___darwin_arm_exception_state64),
    __ss: struct___darwin_arm_thread_state64 = @import("std").mem.zeroes(struct___darwin_arm_thread_state64),
    __ns: struct___darwin_arm_neon_state64 = @import("std").mem.zeroes(struct___darwin_arm_neon_state64),
};
pub const mcontext_t = [*c]struct___darwin_mcontext64;
pub const struct___darwin_sigaltstack = extern struct {
    ss_sp: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    ss_size: __darwin_size_t = @import("std").mem.zeroes(__darwin_size_t),
    ss_flags: c_int = @import("std").mem.zeroes(c_int),
};
pub const stack_t = struct___darwin_sigaltstack;
pub const struct___darwin_ucontext = extern struct {
    uc_onstack: c_int = @import("std").mem.zeroes(c_int),
    uc_sigmask: __darwin_sigset_t = @import("std").mem.zeroes(__darwin_sigset_t),
    uc_stack: struct___darwin_sigaltstack = @import("std").mem.zeroes(struct___darwin_sigaltstack),
    uc_link: [*c]struct___darwin_ucontext = @import("std").mem.zeroes([*c]struct___darwin_ucontext),
    uc_mcsize: __darwin_size_t = @import("std").mem.zeroes(__darwin_size_t),
    uc_mcontext: [*c]struct___darwin_mcontext64 = @import("std").mem.zeroes([*c]struct___darwin_mcontext64),
};
pub const ucontext_t = struct___darwin_ucontext;
pub const sigset_t = __darwin_sigset_t;
pub const union_sigval = extern union {
    sival_int: c_int,
    sival_ptr: ?*anyopaque,
};
pub const struct_sigevent = extern struct {
    sigev_notify: c_int = @import("std").mem.zeroes(c_int),
    sigev_signo: c_int = @import("std").mem.zeroes(c_int),
    sigev_value: union_sigval = @import("std").mem.zeroes(union_sigval),
    sigev_notify_function: ?*const fn (union_sigval) callconv(.C) void = @import("std").mem.zeroes(?*const fn (union_sigval) callconv(.C) void),
    sigev_notify_attributes: [*c]pthread_attr_t = @import("std").mem.zeroes([*c]pthread_attr_t),
};
pub const struct___siginfo = extern struct {
    si_signo: c_int = @import("std").mem.zeroes(c_int),
    si_errno: c_int = @import("std").mem.zeroes(c_int),
    si_code: c_int = @import("std").mem.zeroes(c_int),
    si_pid: pid_t = @import("std").mem.zeroes(pid_t),
    si_uid: uid_t = @import("std").mem.zeroes(uid_t),
    si_status: c_int = @import("std").mem.zeroes(c_int),
    si_addr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    si_value: union_sigval = @import("std").mem.zeroes(union_sigval),
    si_band: c_long = @import("std").mem.zeroes(c_long),
    __pad: [7]c_ulong = @import("std").mem.zeroes([7]c_ulong),
};
pub const siginfo_t = struct___siginfo;
pub const union___sigaction_u = extern union {
    __sa_handler: ?*const fn (c_int) callconv(.C) void,
    __sa_sigaction: ?*const fn (c_int, [*c]struct___siginfo, ?*anyopaque) callconv(.C) void,
};
pub const struct___sigaction = extern struct {
    __sigaction_u: union___sigaction_u = @import("std").mem.zeroes(union___sigaction_u),
    sa_tramp: ?*const fn (?*anyopaque, c_int, c_int, [*c]siginfo_t, ?*anyopaque) callconv(.C) void = @import("std").mem.zeroes(?*const fn (?*anyopaque, c_int, c_int, [*c]siginfo_t, ?*anyopaque) callconv(.C) void),
    sa_mask: sigset_t = @import("std").mem.zeroes(sigset_t),
    sa_flags: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_sigaction = extern struct {
    __sigaction_u: union___sigaction_u = @import("std").mem.zeroes(union___sigaction_u),
    sa_mask: sigset_t = @import("std").mem.zeroes(sigset_t),
    sa_flags: c_int = @import("std").mem.zeroes(c_int),
};
pub const sig_t = ?*const fn (c_int) callconv(.C) void;
pub const struct_sigvec = extern struct {
    sv_handler: ?*const fn (c_int) callconv(.C) void = @import("std").mem.zeroes(?*const fn (c_int) callconv(.C) void),
    sv_mask: c_int = @import("std").mem.zeroes(c_int),
    sv_flags: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_sigstack = extern struct {
    ss_sp: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    ss_onstack: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn signal(c_int, ?*const fn (c_int) callconv(.C) void) ?*const fn (c_int) callconv(.C) void;
pub const rlim_t = __uint64_t;
pub const struct_rusage = extern struct {
    ru_utime: struct_timeval = @import("std").mem.zeroes(struct_timeval),
    ru_stime: struct_timeval = @import("std").mem.zeroes(struct_timeval),
    ru_maxrss: c_long = @import("std").mem.zeroes(c_long),
    ru_ixrss: c_long = @import("std").mem.zeroes(c_long),
    ru_idrss: c_long = @import("std").mem.zeroes(c_long),
    ru_isrss: c_long = @import("std").mem.zeroes(c_long),
    ru_minflt: c_long = @import("std").mem.zeroes(c_long),
    ru_majflt: c_long = @import("std").mem.zeroes(c_long),
    ru_nswap: c_long = @import("std").mem.zeroes(c_long),
    ru_inblock: c_long = @import("std").mem.zeroes(c_long),
    ru_oublock: c_long = @import("std").mem.zeroes(c_long),
    ru_msgsnd: c_long = @import("std").mem.zeroes(c_long),
    ru_msgrcv: c_long = @import("std").mem.zeroes(c_long),
    ru_nsignals: c_long = @import("std").mem.zeroes(c_long),
    ru_nvcsw: c_long = @import("std").mem.zeroes(c_long),
    ru_nivcsw: c_long = @import("std").mem.zeroes(c_long),
};
pub const rusage_info_t = ?*anyopaque;
pub const struct_rusage_info_v0 = extern struct {
    ri_uuid: [16]u8 = @import("std").mem.zeroes([16]u8),
    ri_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_wired_size: u64 = @import("std").mem.zeroes(u64),
    ri_resident_size: u64 = @import("std").mem.zeroes(u64),
    ri_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_proc_start_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_proc_exit_abstime: u64 = @import("std").mem.zeroes(u64),
};
pub const struct_rusage_info_v1 = extern struct {
    ri_uuid: [16]u8 = @import("std").mem.zeroes([16]u8),
    ri_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_wired_size: u64 = @import("std").mem.zeroes(u64),
    ri_resident_size: u64 = @import("std").mem.zeroes(u64),
    ri_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_proc_start_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_proc_exit_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_child_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_child_elapsed_abstime: u64 = @import("std").mem.zeroes(u64),
};
pub const struct_rusage_info_v2 = extern struct {
    ri_uuid: [16]u8 = @import("std").mem.zeroes([16]u8),
    ri_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_wired_size: u64 = @import("std").mem.zeroes(u64),
    ri_resident_size: u64 = @import("std").mem.zeroes(u64),
    ri_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_proc_start_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_proc_exit_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_child_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_child_elapsed_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_bytesread: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_byteswritten: u64 = @import("std").mem.zeroes(u64),
};
pub const struct_rusage_info_v3 = extern struct {
    ri_uuid: [16]u8 = @import("std").mem.zeroes([16]u8),
    ri_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_wired_size: u64 = @import("std").mem.zeroes(u64),
    ri_resident_size: u64 = @import("std").mem.zeroes(u64),
    ri_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_proc_start_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_proc_exit_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_child_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_child_elapsed_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_bytesread: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_byteswritten: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_default: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_maintenance: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_background: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_utility: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_legacy: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_user_initiated: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_user_interactive: u64 = @import("std").mem.zeroes(u64),
    ri_billed_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_serviced_system_time: u64 = @import("std").mem.zeroes(u64),
};
pub const struct_rusage_info_v4 = extern struct {
    ri_uuid: [16]u8 = @import("std").mem.zeroes([16]u8),
    ri_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_wired_size: u64 = @import("std").mem.zeroes(u64),
    ri_resident_size: u64 = @import("std").mem.zeroes(u64),
    ri_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_proc_start_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_proc_exit_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_child_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_child_elapsed_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_bytesread: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_byteswritten: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_default: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_maintenance: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_background: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_utility: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_legacy: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_user_initiated: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_user_interactive: u64 = @import("std").mem.zeroes(u64),
    ri_billed_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_serviced_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_logical_writes: u64 = @import("std").mem.zeroes(u64),
    ri_lifetime_max_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_instructions: u64 = @import("std").mem.zeroes(u64),
    ri_cycles: u64 = @import("std").mem.zeroes(u64),
    ri_billed_energy: u64 = @import("std").mem.zeroes(u64),
    ri_serviced_energy: u64 = @import("std").mem.zeroes(u64),
    ri_interval_max_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_runnable_time: u64 = @import("std").mem.zeroes(u64),
};
pub const struct_rusage_info_v5 = extern struct {
    ri_uuid: [16]u8 = @import("std").mem.zeroes([16]u8),
    ri_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_wired_size: u64 = @import("std").mem.zeroes(u64),
    ri_resident_size: u64 = @import("std").mem.zeroes(u64),
    ri_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_proc_start_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_proc_exit_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_child_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_child_elapsed_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_bytesread: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_byteswritten: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_default: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_maintenance: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_background: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_utility: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_legacy: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_user_initiated: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_user_interactive: u64 = @import("std").mem.zeroes(u64),
    ri_billed_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_serviced_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_logical_writes: u64 = @import("std").mem.zeroes(u64),
    ri_lifetime_max_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_instructions: u64 = @import("std").mem.zeroes(u64),
    ri_cycles: u64 = @import("std").mem.zeroes(u64),
    ri_billed_energy: u64 = @import("std").mem.zeroes(u64),
    ri_serviced_energy: u64 = @import("std").mem.zeroes(u64),
    ri_interval_max_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_runnable_time: u64 = @import("std").mem.zeroes(u64),
    ri_flags: u64 = @import("std").mem.zeroes(u64),
};
pub const struct_rusage_info_v6 = extern struct {
    ri_uuid: [16]u8 = @import("std").mem.zeroes([16]u8),
    ri_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_wired_size: u64 = @import("std").mem.zeroes(u64),
    ri_resident_size: u64 = @import("std").mem.zeroes(u64),
    ri_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_proc_start_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_proc_exit_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_child_user_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_child_pkg_idle_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_interrupt_wkups: u64 = @import("std").mem.zeroes(u64),
    ri_child_pageins: u64 = @import("std").mem.zeroes(u64),
    ri_child_elapsed_abstime: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_bytesread: u64 = @import("std").mem.zeroes(u64),
    ri_diskio_byteswritten: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_default: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_maintenance: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_background: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_utility: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_legacy: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_user_initiated: u64 = @import("std").mem.zeroes(u64),
    ri_cpu_time_qos_user_interactive: u64 = @import("std").mem.zeroes(u64),
    ri_billed_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_serviced_system_time: u64 = @import("std").mem.zeroes(u64),
    ri_logical_writes: u64 = @import("std").mem.zeroes(u64),
    ri_lifetime_max_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_instructions: u64 = @import("std").mem.zeroes(u64),
    ri_cycles: u64 = @import("std").mem.zeroes(u64),
    ri_billed_energy: u64 = @import("std").mem.zeroes(u64),
    ri_serviced_energy: u64 = @import("std").mem.zeroes(u64),
    ri_interval_max_phys_footprint: u64 = @import("std").mem.zeroes(u64),
    ri_runnable_time: u64 = @import("std").mem.zeroes(u64),
    ri_flags: u64 = @import("std").mem.zeroes(u64),
    ri_user_ptime: u64 = @import("std").mem.zeroes(u64),
    ri_system_ptime: u64 = @import("std").mem.zeroes(u64),
    ri_pinstructions: u64 = @import("std").mem.zeroes(u64),
    ri_pcycles: u64 = @import("std").mem.zeroes(u64),
    ri_energy_nj: u64 = @import("std").mem.zeroes(u64),
    ri_penergy_nj: u64 = @import("std").mem.zeroes(u64),
    ri_secure_time_in_system: u64 = @import("std").mem.zeroes(u64),
    ri_secure_ptime_in_system: u64 = @import("std").mem.zeroes(u64),
    ri_reserved: [12]u64 = @import("std").mem.zeroes([12]u64),
};
pub const rusage_info_current = struct_rusage_info_v6;
pub const struct_rlimit = extern struct {
    rlim_cur: rlim_t = @import("std").mem.zeroes(rlim_t),
    rlim_max: rlim_t = @import("std").mem.zeroes(rlim_t),
};
pub const struct_proc_rlimit_control_wakeupmon = extern struct {
    wm_flags: u32 = @import("std").mem.zeroes(u32),
    wm_rate: i32 = @import("std").mem.zeroes(i32),
};
pub extern fn getpriority(c_int, id_t) c_int;
pub extern fn getiopolicy_np(c_int, c_int) c_int;
pub extern fn getrlimit(c_int, [*c]struct_rlimit) c_int;
pub extern fn getrusage(c_int, [*c]struct_rusage) c_int;
pub extern fn setpriority(c_int, id_t, c_int) c_int;
pub extern fn setiopolicy_np(c_int, c_int, c_int) c_int;
pub extern fn setrlimit(c_int, [*c]const struct_rlimit) c_int;
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/wait.h:201:19: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_1 = opaque {};
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/wait.h:220:19: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_2 = opaque {};
pub const union_wait = extern union {
    w_status: c_int,
    w_T: struct_unnamed_1,
    w_S: struct_unnamed_2,
};
pub extern fn wait([*c]c_int) pid_t;
pub extern fn waitpid(pid_t, [*c]c_int, c_int) pid_t;
pub extern fn waitid(idtype_t, id_t, [*c]siginfo_t, c_int) c_int;
pub extern fn wait3([*c]c_int, c_int, [*c]struct_rusage) pid_t;
pub extern fn wait4(pid_t, [*c]c_int, c_int, [*c]struct_rusage) pid_t;
pub extern fn alloca(c_ulong) ?*anyopaque;
pub const ct_rune_t = __darwin_ct_rune_t;
pub const rune_t = __darwin_rune_t;
pub const div_t = extern struct {
    quot: c_int = @import("std").mem.zeroes(c_int),
    rem: c_int = @import("std").mem.zeroes(c_int),
};
pub const ldiv_t = extern struct {
    quot: c_long = @import("std").mem.zeroes(c_long),
    rem: c_long = @import("std").mem.zeroes(c_long),
};
pub const lldiv_t = extern struct {
    quot: c_longlong = @import("std").mem.zeroes(c_longlong),
    rem: c_longlong = @import("std").mem.zeroes(c_longlong),
};
pub extern var __mb_cur_max: c_int;
pub const malloc_type_id_t = c_ulonglong;
pub extern fn malloc_type_malloc(size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc_type_calloc(count: usize, size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc_type_free(ptr: ?*anyopaque, type_id: malloc_type_id_t) void;
pub extern fn malloc_type_realloc(ptr: ?*anyopaque, size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc_type_valloc(size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc_type_aligned_alloc(alignment: usize, size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc_type_posix_memalign(memptr: [*c]?*anyopaque, alignment: usize, size: usize, type_id: malloc_type_id_t) c_int;
pub const struct__malloc_zone_t = opaque {};
pub const malloc_zone_t = struct__malloc_zone_t;
pub extern fn malloc_type_zone_malloc(zone: ?*malloc_zone_t, size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc_type_zone_calloc(zone: ?*malloc_zone_t, count: usize, size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc_type_zone_free(zone: ?*malloc_zone_t, ptr: ?*anyopaque, type_id: malloc_type_id_t) void;
pub extern fn malloc_type_zone_realloc(zone: ?*malloc_zone_t, ptr: ?*anyopaque, size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc_type_zone_valloc(zone: ?*malloc_zone_t, size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc_type_zone_memalign(zone: ?*malloc_zone_t, alignment: usize, size: usize, type_id: malloc_type_id_t) ?*anyopaque;
pub extern fn malloc(__size: c_ulong) ?*anyopaque;
pub extern fn calloc(__count: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn free(?*anyopaque) void;
pub extern fn realloc(__ptr: ?*anyopaque, __size: c_ulong) ?*anyopaque;
pub extern fn reallocf(__ptr: ?*anyopaque, __size: usize) ?*anyopaque;
pub extern fn valloc(usize) ?*anyopaque;
pub extern fn aligned_alloc(__alignment: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn posix_memalign(__memptr: [*c]?*anyopaque, __alignment: usize, __size: usize) c_int;
pub extern fn abort() noreturn;
pub extern fn abs(c_int) c_int;
pub extern fn atexit(?*const fn () callconv(.C) void) c_int;
pub extern fn atof([*c]const u8) f64;
pub extern fn atoi([*c]const u8) c_int;
pub extern fn atol([*c]const u8) c_long;
pub extern fn atoll([*c]const u8) c_longlong;
pub extern fn bsearch(__key: ?*const anyopaque, __base: ?*const anyopaque, __nel: usize, __width: usize, __compar: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) ?*anyopaque;
pub extern fn div(c_int, c_int) div_t;
pub extern fn exit(c_int) noreturn;
pub extern fn getenv([*c]const u8) [*c]u8;
pub extern fn labs(c_long) c_long;
pub extern fn ldiv(c_long, c_long) ldiv_t;
pub extern fn llabs(c_longlong) c_longlong;
pub extern fn lldiv(c_longlong, c_longlong) lldiv_t;
pub extern fn mblen(__s: [*c]const u8, __n: usize) c_int;
pub extern fn mbstowcs(noalias [*c]wchar_t, noalias [*c]const u8, usize) usize;
pub extern fn mbtowc(noalias [*c]wchar_t, noalias [*c]const u8, usize) c_int;
pub extern fn qsort(__base: ?*anyopaque, __nel: usize, __width: usize, __compar: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) void;
pub extern fn rand() c_int;
pub extern fn srand(c_uint) void;
pub extern fn strtod([*c]const u8, [*c][*c]u8) f64;
pub extern fn strtof([*c]const u8, [*c][*c]u8) f32;
pub extern fn strtol(__str: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_long;
pub extern fn strtold([*c]const u8, [*c][*c]u8) c_longdouble;
pub extern fn strtoll(__str: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtoul(__str: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulong;
pub extern fn strtoull(__str: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn system([*c]const u8) c_int;
pub extern fn wcstombs(noalias [*c]u8, noalias [*c]const wchar_t, usize) usize;
pub extern fn wctomb([*c]u8, wchar_t) c_int;
pub extern fn _Exit(c_int) noreturn;
pub extern fn a64l([*c]const u8) c_long;
pub extern fn drand48() f64;
pub extern fn ecvt(f64, c_int, noalias [*c]c_int, noalias [*c]c_int) [*c]u8;
pub extern fn erand48([*c]c_ushort) f64;
pub extern fn fcvt(f64, c_int, noalias [*c]c_int, noalias [*c]c_int) [*c]u8;
pub extern fn gcvt(f64, c_int, [*c]u8) [*c]u8;
pub extern fn getsubopt([*c][*c]u8, [*c]const [*c]u8, [*c][*c]u8) c_int;
pub extern fn grantpt(c_int) c_int;
pub extern fn initstate(c_uint, [*c]u8, usize) [*c]u8;
pub extern fn jrand48([*c]c_ushort) c_long;
pub extern fn l64a(c_long) [*c]u8;
pub extern fn lcong48([*c]c_ushort) void;
pub extern fn lrand48() c_long;
pub extern fn mktemp([*c]u8) [*c]u8;
pub extern fn mkstemp([*c]u8) c_int;
pub extern fn mrand48() c_long;
pub extern fn nrand48([*c]c_ushort) c_long;
pub extern fn posix_openpt(c_int) c_int;
pub extern fn ptsname(c_int) [*c]u8;
pub extern fn ptsname_r(fildes: c_int, buffer: [*c]u8, buflen: usize) c_int;
pub extern fn putenv([*c]u8) c_int;
pub extern fn random() c_long;
pub extern fn rand_r([*c]c_uint) c_int;
pub extern fn realpath(noalias [*c]const u8, noalias [*c]u8) [*c]u8;
pub extern fn seed48([*c]c_ushort) [*c]c_ushort;
pub extern fn setenv(__name: [*c]const u8, __value: [*c]const u8, __overwrite: c_int) c_int;
pub extern fn setkey([*c]const u8) void;
pub extern fn setstate([*c]const u8) [*c]u8;
pub extern fn srand48(c_long) void;
pub extern fn srandom(c_uint) void;
pub extern fn unlockpt(c_int) c_int;
pub extern fn unsetenv([*c]const u8) c_int;
pub extern fn arc4random() u32;
pub extern fn arc4random_addrandom([*c]u8, c_int) void;
pub extern fn arc4random_buf(__buf: ?*anyopaque, __nbytes: usize) void;
pub extern fn arc4random_stir() void;
pub extern fn arc4random_uniform(__upper_bound: u32) u32;
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:273:6: warning: unsupported type: 'BlockPointer'
pub const atexit_b = @compileError("unable to resolve prototype of function");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:273:6

// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:282:7: warning: unsupported type: 'BlockPointer'
pub const bsearch_b = @compileError("unable to resolve prototype of function");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:282:7
pub extern fn cgetcap([*c]u8, [*c]const u8, c_int) [*c]u8;
pub extern fn cgetclose() c_int;
pub extern fn cgetent([*c][*c]u8, [*c][*c]u8, [*c]const u8) c_int;
pub extern fn cgetfirst([*c][*c]u8, [*c][*c]u8) c_int;
pub extern fn cgetmatch([*c]const u8, [*c]const u8) c_int;
pub extern fn cgetnext([*c][*c]u8, [*c][*c]u8) c_int;
pub extern fn cgetnum([*c]u8, [*c]const u8, [*c]c_long) c_int;
pub extern fn cgetset([*c]const u8) c_int;
pub extern fn cgetstr([*c]u8, [*c]const u8, [*c][*c]u8) c_int;
pub extern fn cgetustr([*c]u8, [*c]const u8, [*c][*c]u8) c_int;
pub extern fn daemon(c_int, c_int) c_int;
pub extern fn devname(dev_t, mode_t) [*c]u8;
pub extern fn devname_r(dev_t, mode_t, buf: [*c]u8, len: c_int) [*c]u8;
pub extern fn getbsize([*c]c_int, [*c]c_long) [*c]u8;
pub extern fn getloadavg([*c]f64, c_int) c_int;
pub extern fn getprogname() [*c]const u8;
pub extern fn setprogname([*c]const u8) void;
pub extern fn heapsort(__base: ?*anyopaque, __nel: usize, __width: usize, __compar: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) c_int;
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:319:6: warning: unsupported type: 'BlockPointer'
pub const heapsort_b = @compileError("unable to resolve prototype of function");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:319:6
pub extern fn mergesort(__base: ?*anyopaque, __nel: usize, __width: usize, __compar: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) c_int;
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:326:6: warning: unsupported type: 'BlockPointer'
pub const mergesort_b = @compileError("unable to resolve prototype of function");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:326:6
pub extern fn psort(__base: ?*anyopaque, __nel: usize, __width: usize, __compar: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) void;
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:334:7: warning: unsupported type: 'BlockPointer'
pub const psort_b = @compileError("unable to resolve prototype of function");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:334:7
pub extern fn psort_r(__base: ?*anyopaque, __nel: usize, __width: usize, ?*anyopaque, __compar: ?*const fn (?*anyopaque, ?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) void;
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:342:7: warning: unsupported type: 'BlockPointer'
pub const qsort_b = @compileError("unable to resolve prototype of function");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:342:7
pub extern fn qsort_r(__base: ?*anyopaque, __nel: usize, __width: usize, ?*anyopaque, __compar: ?*const fn (?*anyopaque, ?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) void;
pub extern fn radixsort(__base: [*c][*c]const u8, __nel: c_int, __table: [*c]const u8, __endbyte: c_uint) c_int;
pub extern fn rpmatch([*c]const u8) c_int;
pub extern fn sradixsort(__base: [*c][*c]const u8, __nel: c_int, __table: [*c]const u8, __endbyte: c_uint) c_int;
pub extern fn sranddev() void;
pub extern fn srandomdev() void;
pub extern fn strtonum(__numstr: [*c]const u8, __minval: c_longlong, __maxval: c_longlong, __errstrp: [*c][*c]const u8) c_longlong;
pub extern fn strtoq(__str: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtouq(__str: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern var suboptarg: [*c]u8;
pub const va_list = __darwin_va_list;
pub extern fn renameat(c_int, [*c]const u8, c_int, [*c]const u8) c_int;
pub extern fn renamex_np([*c]const u8, [*c]const u8, c_uint) c_int;
pub extern fn renameatx_np(c_int, [*c]const u8, c_int, [*c]const u8, c_uint) c_int;
pub const fpos_t = __darwin_off_t;
pub const struct___sbuf = extern struct {
    _base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _size: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct___sFILEX = opaque {};
pub const struct___sFILE = extern struct {
    _p: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _r: c_int = @import("std").mem.zeroes(c_int),
    _w: c_int = @import("std").mem.zeroes(c_int),
    _flags: c_short = @import("std").mem.zeroes(c_short),
    _file: c_short = @import("std").mem.zeroes(c_short),
    _bf: struct___sbuf = @import("std").mem.zeroes(struct___sbuf),
    _lbfsize: c_int = @import("std").mem.zeroes(c_int),
    _cookie: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    _close: ?*const fn (?*anyopaque) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.C) c_int),
    _read: ?*const fn (?*anyopaque, [*c]u8, c_int) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]u8, c_int) callconv(.C) c_int),
    _seek: ?*const fn (?*anyopaque, fpos_t, c_int) callconv(.C) fpos_t = @import("std").mem.zeroes(?*const fn (?*anyopaque, fpos_t, c_int) callconv(.C) fpos_t),
    _write: ?*const fn (?*anyopaque, [*c]const u8, c_int) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]const u8, c_int) callconv(.C) c_int),
    _ub: struct___sbuf = @import("std").mem.zeroes(struct___sbuf),
    _extra: ?*struct___sFILEX = @import("std").mem.zeroes(?*struct___sFILEX),
    _ur: c_int = @import("std").mem.zeroes(c_int),
    _ubuf: [3]u8 = @import("std").mem.zeroes([3]u8),
    _nbuf: [1]u8 = @import("std").mem.zeroes([1]u8),
    _lb: struct___sbuf = @import("std").mem.zeroes(struct___sbuf),
    _blksize: c_int = @import("std").mem.zeroes(c_int),
    _offset: fpos_t = @import("std").mem.zeroes(fpos_t),
};
pub const FILE = struct___sFILE;
pub extern var __stdinp: [*c]FILE;
pub extern var __stdoutp: [*c]FILE;
pub extern var __stderrp: [*c]FILE;
pub extern fn clearerr([*c]FILE) void;
pub extern fn fclose([*c]FILE) c_int;
pub extern fn feof([*c]FILE) c_int;
pub extern fn ferror([*c]FILE) c_int;
pub extern fn fflush([*c]FILE) c_int;
pub extern fn fgetc([*c]FILE) c_int;
pub extern fn fgetpos(noalias [*c]FILE, [*c]fpos_t) c_int;
pub extern fn fgets(noalias [*c]u8, c_int, [*c]FILE) [*c]u8;
pub extern fn fopen(__filename: [*c]const u8, __mode: [*c]const u8) [*c]FILE;
pub extern fn fprintf([*c]FILE, [*c]const u8, ...) c_int;
pub extern fn fputc(c_int, [*c]FILE) c_int;
pub extern fn fputs(noalias [*c]const u8, noalias [*c]FILE) c_int;
pub extern fn fread(__ptr: ?*anyopaque, __size: c_ulong, __nitems: c_ulong, __stream: [*c]FILE) c_ulong;
pub extern fn freopen(noalias [*c]const u8, noalias [*c]const u8, noalias [*c]FILE) [*c]FILE;
pub extern fn fscanf(noalias [*c]FILE, noalias [*c]const u8, ...) c_int;
pub extern fn fseek([*c]FILE, c_long, c_int) c_int;
pub extern fn fsetpos([*c]FILE, [*c]const fpos_t) c_int;
pub extern fn ftell([*c]FILE) c_long;
pub extern fn fwrite(__ptr: ?*const anyopaque, __size: c_ulong, __nitems: c_ulong, __stream: [*c]FILE) c_ulong;
pub extern fn getc([*c]FILE) c_int;
pub extern fn getchar() c_int;
pub extern fn gets([*c]u8) [*c]u8;
pub extern fn perror([*c]const u8) void;
pub extern fn printf([*c]const u8, ...) c_int;
pub extern fn putc(c_int, [*c]FILE) c_int;
pub extern fn putchar(c_int) c_int;
pub extern fn puts([*c]const u8) c_int;
pub extern fn remove([*c]const u8) c_int;
pub extern fn rename(__old: [*c]const u8, __new: [*c]const u8) c_int;
pub extern fn rewind([*c]FILE) void;
pub extern fn scanf(noalias [*c]const u8, ...) c_int;
pub extern fn setbuf(noalias [*c]FILE, noalias [*c]u8) void;
pub extern fn setvbuf(noalias [*c]FILE, noalias [*c]u8, c_int, usize) c_int;
pub extern fn sprintf([*c]u8, [*c]const u8, ...) c_int;
pub extern fn sscanf(noalias [*c]const u8, noalias [*c]const u8, ...) c_int;
pub extern fn tmpfile() [*c]FILE;
pub extern fn tmpnam([*c]u8) [*c]u8;
pub extern fn ungetc(c_int, [*c]FILE) c_int;
pub extern fn vfprintf([*c]FILE, [*c]const u8, __builtin_va_list) c_int;
pub extern fn vprintf([*c]const u8, __builtin_va_list) c_int;
pub extern fn vsprintf([*c]u8, [*c]const u8, __builtin_va_list) c_int;
pub extern fn ctermid([*c]u8) [*c]u8;
pub extern fn fdopen(c_int, [*c]const u8) [*c]FILE;
pub extern fn fileno([*c]FILE) c_int;
pub extern fn pclose([*c]FILE) c_int;
pub extern fn popen([*c]const u8, [*c]const u8) [*c]FILE;
pub extern fn __srget([*c]FILE) c_int;
pub extern fn __svfscanf([*c]FILE, [*c]const u8, va_list) c_int;
pub extern fn __swbuf(c_int, [*c]FILE) c_int;
pub inline fn __sputc(arg__c: c_int, arg__p: [*c]FILE) c_int {
    var _c = arg__c;
    _ = &_c;
    var _p = arg__p;
    _ = &_p;
    if (((blk: {
        const ref = &_p.*._w;
        ref.* -= 1;
        break :blk ref.*;
    }) >= @as(c_int, 0)) or ((_p.*._w >= _p.*._lbfsize) and (@as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(_c))))))) != @as(c_int, '\n')))) return @as(c_int, @bitCast(@as(c_uint, blk: {
        const tmp = @as(u8, @bitCast(@as(i8, @truncate(_c))));
        (blk_1: {
            const ref = &_p.*._p;
            const tmp_2 = ref.*;
            ref.* += 1;
            break :blk_1 tmp_2;
        }).* = tmp;
        break :blk tmp;
    }))) else return __swbuf(_c, _p);
    return 0;
}
pub extern fn flockfile([*c]FILE) void;
pub extern fn ftrylockfile([*c]FILE) c_int;
pub extern fn funlockfile([*c]FILE) void;
pub extern fn getc_unlocked([*c]FILE) c_int;
pub extern fn getchar_unlocked() c_int;
pub extern fn putc_unlocked(c_int, [*c]FILE) c_int;
pub extern fn putchar_unlocked(c_int) c_int;
pub extern fn getw([*c]FILE) c_int;
pub extern fn putw(c_int, [*c]FILE) c_int;
pub extern fn tempnam(__dir: [*c]const u8, __prefix: [*c]const u8) [*c]u8;
pub extern fn fseeko(__stream: [*c]FILE, __offset: off_t, __whence: c_int) c_int;
pub extern fn ftello(__stream: [*c]FILE) off_t;
pub extern fn snprintf(__str: [*c]u8, __size: c_ulong, __format: [*c]const u8, ...) c_int;
pub extern fn vfscanf(noalias __stream: [*c]FILE, noalias __format: [*c]const u8, __builtin_va_list) c_int;
pub extern fn vscanf(noalias __format: [*c]const u8, __builtin_va_list) c_int;
pub extern fn vsnprintf(__str: [*c]u8, __size: c_ulong, __format: [*c]const u8, __builtin_va_list) c_int;
pub extern fn vsscanf(noalias __str: [*c]const u8, noalias __format: [*c]const u8, __builtin_va_list) c_int;
pub extern fn dprintf(c_int, noalias [*c]const u8, ...) c_int;
pub extern fn vdprintf(c_int, noalias [*c]const u8, va_list) c_int;
pub extern fn getdelim(noalias __linep: [*c][*c]u8, noalias __linecapp: [*c]usize, __delimiter: c_int, noalias __stream: [*c]FILE) isize;
pub extern fn getline(noalias __linep: [*c][*c]u8, noalias __linecapp: [*c]usize, noalias __stream: [*c]FILE) isize;
pub extern fn fmemopen(noalias __buf: ?*anyopaque, __size: usize, noalias __mode: [*c]const u8) [*c]FILE;
pub extern fn open_memstream(__bufp: [*c][*c]u8, __sizep: [*c]usize) [*c]FILE;
pub extern const sys_nerr: c_int;
pub const sys_errlist: [*c]const [*c]const u8 = @extern([*c]const [*c]const u8, .{
    .name = "sys_errlist",
});
pub extern fn asprintf(noalias [*c][*c]u8, noalias [*c]const u8, ...) c_int;
pub extern fn ctermid_r([*c]u8) [*c]u8;
pub extern fn fgetln([*c]FILE, [*c]usize) [*c]u8;
pub extern fn fmtcheck([*c]const u8, [*c]const u8) [*c]const u8;
pub extern fn fpurge([*c]FILE) c_int;
pub extern fn setbuffer([*c]FILE, [*c]u8, c_int) void;
pub extern fn setlinebuf([*c]FILE) c_int;
pub extern fn vasprintf(noalias [*c][*c]u8, noalias [*c]const u8, va_list) c_int;
pub extern fn funopen(?*const anyopaque, ?*const fn (?*anyopaque, [*c]u8, c_int) callconv(.C) c_int, ?*const fn (?*anyopaque, [*c]const u8, c_int) callconv(.C) c_int, ?*const fn (?*anyopaque, fpos_t, c_int) callconv(.C) fpos_t, ?*const fn (?*anyopaque) callconv(.C) c_int) [*c]FILE;
pub extern fn __sprintf_chk(noalias [*c]u8, c_int, usize, noalias [*c]const u8, ...) c_int;
pub extern fn __snprintf_chk(noalias [*c]u8, usize, c_int, usize, noalias [*c]const u8, ...) c_int;
pub extern fn __vsprintf_chk(noalias [*c]u8, c_int, usize, noalias [*c]const u8, va_list) c_int;
pub extern fn __vsnprintf_chk(noalias [*c]u8, usize, c_int, usize, noalias [*c]const u8, va_list) c_int;
pub const struct_stack_st = opaque {};
pub const OPENSSL_STACK = struct_stack_st;
pub const OPENSSL_sk_compfunc = ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int;
pub const OPENSSL_sk_freefunc = ?*const fn (?*anyopaque) callconv(.C) void;
pub const OPENSSL_sk_copyfunc = ?*const fn (?*const anyopaque) callconv(.C) ?*anyopaque;
pub extern fn OPENSSL_sk_num(?*const OPENSSL_STACK) c_int;
pub extern fn OPENSSL_sk_value(?*const OPENSSL_STACK, c_int) ?*anyopaque;
pub extern fn OPENSSL_sk_set(st: ?*OPENSSL_STACK, i: c_int, data: ?*const anyopaque) ?*anyopaque;
pub extern fn OPENSSL_sk_new(cmp: OPENSSL_sk_compfunc) ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_new_null() ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_new_reserve(c: OPENSSL_sk_compfunc, n: c_int) ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_reserve(st: ?*OPENSSL_STACK, n: c_int) c_int;
pub extern fn OPENSSL_sk_free(?*OPENSSL_STACK) void;
pub extern fn OPENSSL_sk_pop_free(st: ?*OPENSSL_STACK, func: ?*const fn (?*anyopaque) callconv(.C) void) void;
pub extern fn OPENSSL_sk_deep_copy(?*const OPENSSL_STACK, c: OPENSSL_sk_copyfunc, f: OPENSSL_sk_freefunc) ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_insert(sk: ?*OPENSSL_STACK, data: ?*const anyopaque, where: c_int) c_int;
pub extern fn OPENSSL_sk_delete(st: ?*OPENSSL_STACK, loc: c_int) ?*anyopaque;
pub extern fn OPENSSL_sk_delete_ptr(st: ?*OPENSSL_STACK, p: ?*const anyopaque) ?*anyopaque;
pub extern fn OPENSSL_sk_find(st: ?*OPENSSL_STACK, data: ?*const anyopaque) c_int;
pub extern fn OPENSSL_sk_find_ex(st: ?*OPENSSL_STACK, data: ?*const anyopaque) c_int;
pub extern fn OPENSSL_sk_find_all(st: ?*OPENSSL_STACK, data: ?*const anyopaque, pnum: [*c]c_int) c_int;
pub extern fn OPENSSL_sk_push(st: ?*OPENSSL_STACK, data: ?*const anyopaque) c_int;
pub extern fn OPENSSL_sk_unshift(st: ?*OPENSSL_STACK, data: ?*const anyopaque) c_int;
pub extern fn OPENSSL_sk_shift(st: ?*OPENSSL_STACK) ?*anyopaque;
pub extern fn OPENSSL_sk_pop(st: ?*OPENSSL_STACK) ?*anyopaque;
pub extern fn OPENSSL_sk_zero(st: ?*OPENSSL_STACK) void;
pub extern fn OPENSSL_sk_set_cmp_func(sk: ?*OPENSSL_STACK, cmp: OPENSSL_sk_compfunc) OPENSSL_sk_compfunc;
pub extern fn OPENSSL_sk_dup(st: ?*const OPENSSL_STACK) ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_sort(st: ?*OPENSSL_STACK) void;
pub extern fn OPENSSL_sk_is_sorted(st: ?*const OPENSSL_STACK) c_int;
pub const OPENSSL_STRING = [*c]u8;
pub const OPENSSL_CSTRING = [*c]const u8;
pub const struct_stack_st_OPENSSL_STRING = opaque {};
pub const sk_OPENSSL_STRING_compfunc = ?*const fn ([*c]const [*c]const u8, [*c]const [*c]const u8) callconv(.C) c_int;
pub const sk_OPENSSL_STRING_freefunc = ?*const fn ([*c]u8) callconv(.C) void;
pub const sk_OPENSSL_STRING_copyfunc = ?*const fn ([*c]const u8) callconv(.C) [*c]u8;
pub fn ossl_check_OPENSSL_STRING_type(arg_ptr: [*c]u8) callconv(.C) [*c]u8 {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_STRING_sk_type(arg_sk: ?*const struct_stack_st_OPENSSL_STRING) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_STRING_sk_type(arg_sk: ?*struct_stack_st_OPENSSL_STRING) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_STRING_compfunc_type(arg_cmp: sk_OPENSSL_STRING_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_STRING_copyfunc_type(arg_cpy: sk_OPENSSL_STRING_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OPENSSL_STRING_freefunc_type(arg_fr: sk_OPENSSL_STRING_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_OPENSSL_CSTRING = opaque {};
pub const sk_OPENSSL_CSTRING_compfunc = ?*const fn ([*c]const [*c]const u8, [*c]const [*c]const u8) callconv(.C) c_int;
pub const sk_OPENSSL_CSTRING_freefunc = ?*const fn ([*c]u8) callconv(.C) void;
pub const sk_OPENSSL_CSTRING_copyfunc = ?*const fn ([*c]const u8) callconv(.C) [*c]u8;
pub fn ossl_check_OPENSSL_CSTRING_type(arg_ptr: [*c]const u8) callconv(.C) [*c]const u8 {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_CSTRING_sk_type(arg_sk: ?*const struct_stack_st_OPENSSL_CSTRING) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_CSTRING_sk_type(arg_sk: ?*struct_stack_st_OPENSSL_CSTRING) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_CSTRING_compfunc_type(arg_cmp: sk_OPENSSL_CSTRING_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_CSTRING_copyfunc_type(arg_cpy: sk_OPENSSL_CSTRING_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OPENSSL_CSTRING_freefunc_type(arg_fr: sk_OPENSSL_CSTRING_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const OPENSSL_BLOCK = ?*anyopaque;
pub const struct_stack_st_OPENSSL_BLOCK = opaque {};
pub const sk_OPENSSL_BLOCK_compfunc = ?*const fn ([*c]const ?*const anyopaque, [*c]const ?*const anyopaque) callconv(.C) c_int;
pub const sk_OPENSSL_BLOCK_freefunc = ?*const fn (?*anyopaque) callconv(.C) void;
pub const sk_OPENSSL_BLOCK_copyfunc = ?*const fn (?*const anyopaque) callconv(.C) ?*anyopaque;
pub fn ossl_check_OPENSSL_BLOCK_type(arg_ptr: ?*anyopaque) callconv(.C) ?*anyopaque {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_BLOCK_sk_type(arg_sk: ?*const struct_stack_st_OPENSSL_BLOCK) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_BLOCK_sk_type(arg_sk: ?*struct_stack_st_OPENSSL_BLOCK) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_BLOCK_compfunc_type(arg_cmp: sk_OPENSSL_BLOCK_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_BLOCK_copyfunc_type(arg_cpy: sk_OPENSSL_BLOCK_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OPENSSL_BLOCK_freefunc_type(arg_fr: sk_OPENSSL_BLOCK_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ossl_provider_st = opaque {};
pub const OSSL_PROVIDER = struct_ossl_provider_st;
pub const struct_asn1_string_st = extern struct {
    length: c_int = @import("std").mem.zeroes(c_int),
    type: c_int = @import("std").mem.zeroes(c_int),
    data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    flags: c_long = @import("std").mem.zeroes(c_long),
};
pub const ASN1_INTEGER = struct_asn1_string_st;
pub const ASN1_ENUMERATED = struct_asn1_string_st;
pub const ASN1_BIT_STRING = struct_asn1_string_st;
pub const ASN1_OCTET_STRING = struct_asn1_string_st;
pub const ASN1_PRINTABLESTRING = struct_asn1_string_st;
pub const ASN1_T61STRING = struct_asn1_string_st;
pub const ASN1_IA5STRING = struct_asn1_string_st;
pub const ASN1_GENERALSTRING = struct_asn1_string_st;
pub const ASN1_UNIVERSALSTRING = struct_asn1_string_st;
pub const ASN1_BMPSTRING = struct_asn1_string_st;
pub const ASN1_UTCTIME = struct_asn1_string_st;
pub const ASN1_TIME = struct_asn1_string_st;
pub const ASN1_GENERALIZEDTIME = struct_asn1_string_st;
pub const ASN1_VISIBLESTRING = struct_asn1_string_st;
pub const ASN1_UTF8STRING = struct_asn1_string_st;
pub const ASN1_STRING = struct_asn1_string_st;
pub const ASN1_BOOLEAN = c_int;
pub const ASN1_NULL = c_int;
pub const struct_asn1_object_st = opaque {};
pub const ASN1_OBJECT = struct_asn1_object_st;
pub const struct_ASN1_VALUE_st = opaque {};
pub const ASN1_VALUE = struct_ASN1_VALUE_st;
const union_unnamed_3 = extern union {
    ptr: [*c]u8,
    boolean: ASN1_BOOLEAN,
    asn1_string: [*c]ASN1_STRING,
    object: ?*ASN1_OBJECT,
    integer: [*c]ASN1_INTEGER,
    enumerated: [*c]ASN1_ENUMERATED,
    bit_string: [*c]ASN1_BIT_STRING,
    octet_string: [*c]ASN1_OCTET_STRING,
    printablestring: [*c]ASN1_PRINTABLESTRING,
    t61string: [*c]ASN1_T61STRING,
    ia5string: [*c]ASN1_IA5STRING,
    generalstring: [*c]ASN1_GENERALSTRING,
    bmpstring: [*c]ASN1_BMPSTRING,
    universalstring: [*c]ASN1_UNIVERSALSTRING,
    utctime: [*c]ASN1_UTCTIME,
    generalizedtime: [*c]ASN1_GENERALIZEDTIME,
    visiblestring: [*c]ASN1_VISIBLESTRING,
    utf8string: [*c]ASN1_UTF8STRING,
    set: [*c]ASN1_STRING,
    sequence: [*c]ASN1_STRING,
    asn1_value: ?*ASN1_VALUE,
};
pub const struct_asn1_type_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    value: union_unnamed_3 = @import("std").mem.zeroes(union_unnamed_3),
};
pub const ASN1_TYPE = struct_asn1_type_st;
pub const struct_asn1_string_table_st = extern struct {
    nid: c_int = @import("std").mem.zeroes(c_int),
    minsize: c_long = @import("std").mem.zeroes(c_long),
    maxsize: c_long = @import("std").mem.zeroes(c_long),
    mask: c_ulong = @import("std").mem.zeroes(c_ulong),
    flags: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub const ASN1_STRING_TABLE = struct_asn1_string_table_st;
pub const struct_ASN1_ITEM_st = opaque {};
pub const ASN1_ITEM = struct_ASN1_ITEM_st;
pub const struct_asn1_pctx_st = opaque {};
pub const ASN1_PCTX = struct_asn1_pctx_st;
pub const struct_asn1_sctx_st = opaque {};
pub const ASN1_SCTX = struct_asn1_sctx_st;
pub const struct_bio_st = opaque {};
pub const BIO = struct_bio_st;
pub const struct_bignum_st = opaque {};
pub const BIGNUM = struct_bignum_st;
pub const struct_bignum_ctx = opaque {};
pub const BN_CTX = struct_bignum_ctx;
pub const struct_bn_blinding_st = opaque {};
pub const BN_BLINDING = struct_bn_blinding_st;
pub const struct_bn_mont_ctx_st = opaque {};
pub const BN_MONT_CTX = struct_bn_mont_ctx_st;
pub const struct_bn_recp_ctx_st = opaque {};
pub const BN_RECP_CTX = struct_bn_recp_ctx_st;
pub const struct_bn_gencb_st = opaque {};
pub const BN_GENCB = struct_bn_gencb_st;
pub const struct_buf_mem_st = extern struct {
    length: usize = @import("std").mem.zeroes(usize),
    data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    max: usize = @import("std").mem.zeroes(usize),
    flags: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub const BUF_MEM = struct_buf_mem_st;
pub const struct_stack_st_BIGNUM = opaque {};
pub const struct_stack_st_BIGNUM_const = opaque {};
pub const struct_err_state_st = extern struct {
    err_flags: [16]c_int = @import("std").mem.zeroes([16]c_int),
    err_marks: [16]c_int = @import("std").mem.zeroes([16]c_int),
    err_buffer: [16]c_ulong = @import("std").mem.zeroes([16]c_ulong),
    err_data: [16][*c]u8 = @import("std").mem.zeroes([16][*c]u8),
    err_data_size: [16]usize = @import("std").mem.zeroes([16]usize),
    err_data_flags: [16]c_int = @import("std").mem.zeroes([16]c_int),
    err_file: [16][*c]u8 = @import("std").mem.zeroes([16][*c]u8),
    err_line: [16]c_int = @import("std").mem.zeroes([16]c_int),
    err_func: [16][*c]u8 = @import("std").mem.zeroes([16][*c]u8),
    top: c_int = @import("std").mem.zeroes(c_int),
    bottom: c_int = @import("std").mem.zeroes(c_int),
};
pub const ERR_STATE = struct_err_state_st;
pub const struct_evp_cipher_st = opaque {};
pub const EVP_CIPHER = struct_evp_cipher_st;
pub const struct_evp_cipher_ctx_st = opaque {};
pub const EVP_CIPHER_CTX = struct_evp_cipher_ctx_st;
pub const struct_evp_md_st = opaque {};
pub const EVP_MD = struct_evp_md_st;
pub const struct_evp_md_ctx_st = opaque {};
pub const EVP_MD_CTX = struct_evp_md_ctx_st;
pub const struct_evp_mac_st = opaque {};
pub const EVP_MAC = struct_evp_mac_st;
pub const struct_evp_mac_ctx_st = opaque {};
pub const EVP_MAC_CTX = struct_evp_mac_ctx_st;
pub const struct_evp_pkey_st = opaque {};
pub const EVP_PKEY = struct_evp_pkey_st;
pub const struct_evp_pkey_asn1_method_st = opaque {};
pub const EVP_PKEY_ASN1_METHOD = struct_evp_pkey_asn1_method_st;
pub const struct_evp_pkey_method_st = opaque {};
pub const EVP_PKEY_METHOD = struct_evp_pkey_method_st;
pub const struct_evp_pkey_ctx_st = opaque {};
pub const EVP_PKEY_CTX = struct_evp_pkey_ctx_st;
pub const struct_evp_keymgmt_st = opaque {};
pub const EVP_KEYMGMT = struct_evp_keymgmt_st;
pub const struct_evp_kdf_st = opaque {};
pub const EVP_KDF = struct_evp_kdf_st;
pub const struct_evp_kdf_ctx_st = opaque {};
pub const EVP_KDF_CTX = struct_evp_kdf_ctx_st;
pub const struct_evp_rand_st = opaque {};
pub const EVP_RAND = struct_evp_rand_st;
pub const struct_evp_rand_ctx_st = opaque {};
pub const EVP_RAND_CTX = struct_evp_rand_ctx_st;
pub const struct_evp_keyexch_st = opaque {};
pub const EVP_KEYEXCH = struct_evp_keyexch_st;
pub const struct_evp_signature_st = opaque {};
pub const EVP_SIGNATURE = struct_evp_signature_st;
pub const struct_evp_asym_cipher_st = opaque {};
pub const EVP_ASYM_CIPHER = struct_evp_asym_cipher_st;
pub const struct_evp_kem_st = opaque {};
pub const EVP_KEM = struct_evp_kem_st;
pub const struct_evp_Encode_Ctx_st = opaque {};
pub const EVP_ENCODE_CTX = struct_evp_Encode_Ctx_st;
pub const struct_hmac_ctx_st = opaque {};
pub const HMAC_CTX = struct_hmac_ctx_st;
pub const struct_dh_st = opaque {};
pub const DH = struct_dh_st;
pub const struct_dh_method = opaque {};
pub const DH_METHOD = struct_dh_method;
pub const struct_dsa_st = opaque {};
pub const DSA = struct_dsa_st;
pub const struct_dsa_method = opaque {};
pub const DSA_METHOD = struct_dsa_method;
pub const struct_rsa_st = opaque {};
pub const RSA = struct_rsa_st;
pub const struct_rsa_meth_st = opaque {};
pub const RSA_METHOD = struct_rsa_meth_st;
pub const struct_X509_algor_st = extern struct {
    algorithm: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    parameter: [*c]ASN1_TYPE = @import("std").mem.zeroes([*c]ASN1_TYPE),
};
pub const X509_ALGOR = struct_X509_algor_st;
pub const struct_rsa_pss_params_st = extern struct {
    hashAlgorithm: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    maskGenAlgorithm: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    saltLength: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    trailerField: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    maskHash: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const RSA_PSS_PARAMS = struct_rsa_pss_params_st;
pub const struct_ec_key_st = opaque {};
pub const EC_KEY = struct_ec_key_st;
pub const struct_ec_key_method_st = opaque {};
pub const EC_KEY_METHOD = struct_ec_key_method_st;
pub const struct_rand_meth_st = opaque {};
pub const RAND_METHOD = struct_rand_meth_st;
pub const struct_rand_drbg_st = opaque {};
pub const RAND_DRBG = struct_rand_drbg_st;
pub const struct_ssl_dane_st = opaque {};
pub const SSL_DANE = struct_ssl_dane_st;
pub const struct_x509_st = opaque {};
pub const X509 = struct_x509_st;
pub const struct_X509_crl_st = opaque {};
pub const X509_CRL = struct_X509_crl_st;
pub const struct_x509_crl_method_st = opaque {};
pub const X509_CRL_METHOD = struct_x509_crl_method_st;
pub const struct_x509_revoked_st = opaque {};
pub const X509_REVOKED = struct_x509_revoked_st;
pub const struct_X509_name_st = opaque {};
pub const X509_NAME = struct_X509_name_st;
pub const struct_X509_pubkey_st = opaque {};
pub const X509_PUBKEY = struct_X509_pubkey_st;
pub const struct_x509_store_st = opaque {};
pub const X509_STORE = struct_x509_store_st;
pub const struct_x509_store_ctx_st = opaque {};
pub const X509_STORE_CTX = struct_x509_store_ctx_st;
pub const struct_x509_object_st = opaque {};
pub const X509_OBJECT = struct_x509_object_st;
pub const struct_x509_lookup_st = opaque {};
pub const X509_LOOKUP = struct_x509_lookup_st;
pub const struct_x509_lookup_method_st = opaque {};
pub const X509_LOOKUP_METHOD = struct_x509_lookup_method_st;
pub const struct_X509_VERIFY_PARAM_st = opaque {};
pub const X509_VERIFY_PARAM = struct_X509_VERIFY_PARAM_st;
pub const struct_x509_sig_info_st = opaque {};
pub const X509_SIG_INFO = struct_x509_sig_info_st;
pub const struct_pkcs8_priv_key_info_st = opaque {};
pub const PKCS8_PRIV_KEY_INFO = struct_pkcs8_priv_key_info_st;
pub const struct_v3_ext_ctx = opaque {};
pub const X509V3_CTX = struct_v3_ext_ctx;
pub const CONF = struct_conf_st;
pub const struct_conf_method_st = extern struct {
    name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    create: ?*const fn ([*c]CONF_METHOD) callconv(.C) [*c]CONF = @import("std").mem.zeroes(?*const fn ([*c]CONF_METHOD) callconv(.C) [*c]CONF),
    init: ?*const fn ([*c]CONF) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF) callconv(.C) c_int),
    destroy: ?*const fn ([*c]CONF) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF) callconv(.C) c_int),
    destroy_data: ?*const fn ([*c]CONF) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF) callconv(.C) c_int),
    load_bio: ?*const fn ([*c]CONF, ?*BIO, [*c]c_long) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF, ?*BIO, [*c]c_long) callconv(.C) c_int),
    dump: ?*const fn ([*c]const CONF, ?*BIO) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn ([*c]const CONF, ?*BIO) callconv(.C) c_int),
    is_number: ?*const fn ([*c]const CONF, u8) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn ([*c]const CONF, u8) callconv(.C) c_int),
    to_int: ?*const fn ([*c]const CONF, u8) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn ([*c]const CONF, u8) callconv(.C) c_int),
    load: ?*const fn ([*c]CONF, [*c]const u8, [*c]c_long) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF, [*c]const u8, [*c]c_long) callconv(.C) c_int),
};
pub const CONF_METHOD = struct_conf_method_st;
pub const union_lh_CONF_VALUE_dummy_4 = extern union {
    d1: ?*anyopaque,
    d2: c_ulong,
    d3: c_int,
};
pub const struct_lhash_st_CONF_VALUE = extern struct {
    dummy: union_lh_CONF_VALUE_dummy_4 = @import("std").mem.zeroes(union_lh_CONF_VALUE_dummy_4),
};
pub const struct_ossl_lib_ctx_st = opaque {};
pub const OSSL_LIB_CTX = struct_ossl_lib_ctx_st;
pub const struct_conf_st = extern struct {
    meth: [*c]CONF_METHOD = @import("std").mem.zeroes([*c]CONF_METHOD),
    meth_data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    data: [*c]struct_lhash_st_CONF_VALUE = @import("std").mem.zeroes([*c]struct_lhash_st_CONF_VALUE),
    flag_dollarid: c_int = @import("std").mem.zeroes(c_int),
    flag_abspath: c_int = @import("std").mem.zeroes(c_int),
    includedir: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    libctx: ?*OSSL_LIB_CTX = @import("std").mem.zeroes(?*OSSL_LIB_CTX),
};
pub const struct_ossl_init_settings_st = opaque {};
pub const OPENSSL_INIT_SETTINGS = struct_ossl_init_settings_st;
pub const struct_ui_st = opaque {};
pub const UI = struct_ui_st;
pub const struct_ui_method_st = opaque {};
pub const UI_METHOD = struct_ui_method_st;
pub const struct_engine_st = opaque {};
pub const ENGINE = struct_engine_st;
pub const struct_ssl_st = opaque {};
pub const SSL = struct_ssl_st;
pub const struct_ssl_ctx_st = opaque {};
pub const SSL_CTX = struct_ssl_ctx_st;
pub const struct_comp_ctx_st = opaque {};
pub const COMP_CTX = struct_comp_ctx_st;
pub const struct_comp_method_st = opaque {};
pub const COMP_METHOD = struct_comp_method_st;
pub const struct_X509_POLICY_NODE_st = opaque {};
pub const X509_POLICY_NODE = struct_X509_POLICY_NODE_st;
pub const struct_X509_POLICY_LEVEL_st = opaque {};
pub const X509_POLICY_LEVEL = struct_X509_POLICY_LEVEL_st;
pub const struct_X509_POLICY_TREE_st = opaque {};
pub const X509_POLICY_TREE = struct_X509_POLICY_TREE_st;
pub const struct_X509_POLICY_CACHE_st = opaque {};
pub const X509_POLICY_CACHE = struct_X509_POLICY_CACHE_st;
pub const struct_AUTHORITY_KEYID_st = opaque {};
pub const AUTHORITY_KEYID = struct_AUTHORITY_KEYID_st;
pub const struct_DIST_POINT_st = opaque {};
pub const DIST_POINT = struct_DIST_POINT_st;
pub const struct_ISSUING_DIST_POINT_st = opaque {};
pub const ISSUING_DIST_POINT = struct_ISSUING_DIST_POINT_st;
pub const struct_NAME_CONSTRAINTS_st = opaque {};
pub const NAME_CONSTRAINTS = struct_NAME_CONSTRAINTS_st;
pub const struct_stack_st_void = opaque {};
pub const struct_crypto_ex_data_st = extern struct {
    ctx: ?*OSSL_LIB_CTX = @import("std").mem.zeroes(?*OSSL_LIB_CTX),
    sk: ?*struct_stack_st_void = @import("std").mem.zeroes(?*struct_stack_st_void),
};
pub const CRYPTO_EX_DATA = struct_crypto_ex_data_st;
pub const struct_ossl_http_req_ctx_st = opaque {};
pub const OSSL_HTTP_REQ_CTX = struct_ossl_http_req_ctx_st;
pub const struct_ocsp_response_st = opaque {};
pub const OCSP_RESPONSE = struct_ocsp_response_st;
pub const struct_ocsp_responder_id_st = opaque {};
pub const OCSP_RESPID = struct_ocsp_responder_id_st;
pub const struct_sct_st = opaque {};
pub const SCT = struct_sct_st;
pub const struct_sct_ctx_st = opaque {};
pub const SCT_CTX = struct_sct_ctx_st;
pub const struct_ctlog_st = opaque {};
pub const CTLOG = struct_ctlog_st;
pub const struct_ctlog_store_st = opaque {};
pub const CTLOG_STORE = struct_ctlog_store_st;
pub const struct_ct_policy_eval_ctx_st = opaque {};
pub const CT_POLICY_EVAL_CTX = struct_ct_policy_eval_ctx_st;
pub const struct_ossl_store_info_st = opaque {};
pub const OSSL_STORE_INFO = struct_ossl_store_info_st;
pub const struct_ossl_store_search_st = opaque {};
pub const OSSL_STORE_SEARCH = struct_ossl_store_search_st;
pub const struct_ossl_dispatch_st = extern struct {
    function_id: c_int = @import("std").mem.zeroes(c_int),
    function: ?*const fn () callconv(.C) void = @import("std").mem.zeroes(?*const fn () callconv(.C) void),
};
pub const OSSL_DISPATCH = struct_ossl_dispatch_st;
pub const struct_ossl_item_st = extern struct {
    id: c_uint = @import("std").mem.zeroes(c_uint),
    ptr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const OSSL_ITEM = struct_ossl_item_st;
pub const struct_ossl_algorithm_st = extern struct {
    algorithm_names: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    property_definition: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    implementation: [*c]const OSSL_DISPATCH = @import("std").mem.zeroes([*c]const OSSL_DISPATCH),
    algorithm_description: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const OSSL_ALGORITHM = struct_ossl_algorithm_st;
pub const struct_ossl_param_st = extern struct {
    key: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    data_type: c_uint = @import("std").mem.zeroes(c_uint),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    data_size: usize = @import("std").mem.zeroes(usize),
    return_size: usize = @import("std").mem.zeroes(usize),
};
pub const OSSL_PARAM = struct_ossl_param_st;
pub const struct_ossl_param_bld_st = opaque {};
pub const OSSL_PARAM_BLD = struct_ossl_param_bld_st;
pub const pem_password_cb = fn ([*c]u8, c_int, c_int, ?*anyopaque) callconv(.C) c_int;
pub const struct_ossl_encoder_st = opaque {};
pub const OSSL_ENCODER = struct_ossl_encoder_st;
pub const struct_ossl_encoder_ctx_st = opaque {};
pub const OSSL_ENCODER_CTX = struct_ossl_encoder_ctx_st;
pub const struct_ossl_decoder_st = opaque {};
pub const OSSL_DECODER = struct_ossl_decoder_st;
pub const struct_ossl_decoder_ctx_st = opaque {};
pub const OSSL_DECODER_CTX = struct_ossl_decoder_ctx_st;
pub const struct_ossl_self_test_st = opaque {};
pub const OSSL_SELF_TEST = struct_ossl_self_test_st;
pub extern fn ERR_load_ASN1_strings() c_int;
pub extern fn ERR_load_ASYNC_strings() c_int;
pub extern fn ERR_load_BIO_strings() c_int;
pub extern fn ERR_load_BN_strings() c_int;
pub extern fn ERR_load_BUF_strings() c_int;
pub extern fn ERR_load_CMS_strings() c_int;
pub extern fn ERR_load_COMP_strings() c_int;
pub extern fn ERR_load_CONF_strings() c_int;
pub extern fn ERR_load_CRYPTO_strings() c_int;
pub extern fn ERR_load_CT_strings() c_int;
pub extern fn ERR_load_DH_strings() c_int;
pub extern fn ERR_load_DSA_strings() c_int;
pub extern fn ERR_load_EC_strings() c_int;
pub extern fn ERR_load_ENGINE_strings() c_int;
pub extern fn ERR_load_ERR_strings() c_int;
pub extern fn ERR_load_EVP_strings() c_int;
pub extern fn ERR_load_KDF_strings() c_int;
pub extern fn ERR_load_OBJ_strings() c_int;
pub extern fn ERR_load_OCSP_strings() c_int;
pub extern fn ERR_load_PEM_strings() c_int;
pub extern fn ERR_load_PKCS12_strings() c_int;
pub extern fn ERR_load_PKCS7_strings() c_int;
pub extern fn ERR_load_RAND_strings() c_int;
pub extern fn ERR_load_RSA_strings() c_int;
pub extern fn ERR_load_OSSL_STORE_strings() c_int;
pub extern fn ERR_load_TS_strings() c_int;
pub extern fn ERR_load_UI_strings() c_int;
pub extern fn ERR_load_X509_strings() c_int;
pub extern fn ERR_load_X509V3_strings() c_int;
pub const ptrdiff_t = c_long;
pub const max_align_t = c_longdouble;
pub const struct_ossl_core_handle_st = opaque {};
pub const OSSL_CORE_HANDLE = struct_ossl_core_handle_st;
pub const struct_openssl_core_ctx_st = opaque {};
pub const OPENSSL_CORE_CTX = struct_openssl_core_ctx_st;
pub const struct_ossl_core_bio_st = opaque {};
pub const OSSL_CORE_BIO = struct_ossl_core_bio_st;
pub const OSSL_thread_stop_handler_fn = ?*const fn (?*anyopaque) callconv(.C) void;
pub const OSSL_provider_init_fn = fn (?*const OSSL_CORE_HANDLE, [*c]const OSSL_DISPATCH, [*c][*c]const OSSL_DISPATCH, [*c]?*anyopaque) callconv(.C) c_int;
pub const OSSL_provider_init = @compileError("unable to resolve function type clang.TypeClass.Elaborated");
// /opt/homebrew/opt/openssl@3/include/openssl/core.h:201:38
pub const OSSL_CALLBACK = fn ([*c]const OSSL_PARAM, ?*anyopaque) callconv(.C) c_int;
pub const OSSL_INOUT_CALLBACK = fn ([*c]const OSSL_PARAM, [*c]OSSL_PARAM, ?*anyopaque) callconv(.C) c_int;
pub const OSSL_PASSPHRASE_CALLBACK = fn ([*c]u8, usize, [*c]usize, [*c]const OSSL_PARAM, ?*anyopaque) callconv(.C) c_int;
pub const CRYPTO_dynlock = extern struct {
    dummy: c_int = @import("std").mem.zeroes(c_int),
};
pub const CRYPTO_RWLOCK = anyopaque;
pub extern fn CRYPTO_THREAD_lock_new() ?*CRYPTO_RWLOCK;
pub extern fn CRYPTO_THREAD_read_lock(lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_THREAD_write_lock(lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_THREAD_unlock(lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_THREAD_lock_free(lock: ?*CRYPTO_RWLOCK) void;
pub extern fn CRYPTO_atomic_add(val: [*c]c_int, amount: c_int, ret: [*c]c_int, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_add64(val: [*c]u64, op: u64, ret: [*c]u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_and(val: [*c]u64, op: u64, ret: [*c]u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_or(val: [*c]u64, op: u64, ret: [*c]u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_load(val: [*c]u64, ret: [*c]u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_load_int(val: [*c]c_int, ret: [*c]c_int, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_store(dst: [*c]u64, val: u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn OPENSSL_strlcpy(dst: [*c]u8, src: [*c]const u8, siz: usize) usize;
pub extern fn OPENSSL_strlcat(dst: [*c]u8, src: [*c]const u8, siz: usize) usize;
pub extern fn OPENSSL_strnlen(str: [*c]const u8, maxlen: usize) usize;
pub extern fn OPENSSL_strtoul(str: [*c]const u8, endptr: [*c][*c]u8, base: c_int, num: [*c]c_ulong) c_int;
pub extern fn OPENSSL_buf2hexstr_ex(str: [*c]u8, str_n: usize, strlength: [*c]usize, buf: [*c]const u8, buflen: usize, sep: u8) c_int;
pub extern fn OPENSSL_buf2hexstr(buf: [*c]const u8, buflen: c_long) [*c]u8;
pub extern fn OPENSSL_hexstr2buf_ex(buf: [*c]u8, buf_n: usize, buflen: [*c]usize, str: [*c]const u8, sep: u8) c_int;
pub extern fn OPENSSL_hexstr2buf(str: [*c]const u8, buflen: [*c]c_long) [*c]u8;
pub extern fn OPENSSL_hexchar2int(c: u8) c_int;
pub extern fn OPENSSL_strcasecmp(s1: [*c]const u8, s2: [*c]const u8) c_int;
pub extern fn OPENSSL_strncasecmp(s1: [*c]const u8, s2: [*c]const u8, n: usize) c_int;
pub extern fn OPENSSL_version_major() c_uint;
pub extern fn OPENSSL_version_minor() c_uint;
pub extern fn OPENSSL_version_patch() c_uint;
pub extern fn OPENSSL_version_pre_release() [*c]const u8;
pub extern fn OPENSSL_version_build_metadata() [*c]const u8;
pub extern fn OpenSSL_version_num() c_ulong;
pub extern fn OpenSSL_version(@"type": c_int) [*c]const u8;
pub extern fn OPENSSL_info(@"type": c_int) [*c]const u8;
pub extern fn OPENSSL_issetugid() c_int;
pub const sk_void_compfunc = ?*const fn ([*c]const ?*const anyopaque, [*c]const ?*const anyopaque) callconv(.C) c_int;
pub const sk_void_freefunc = ?*const fn (?*anyopaque) callconv(.C) void;
pub const sk_void_copyfunc = ?*const fn (?*const anyopaque) callconv(.C) ?*anyopaque;
pub fn ossl_check_void_type(arg_ptr: ?*anyopaque) callconv(.C) ?*anyopaque {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_void_sk_type(arg_sk: ?*const struct_stack_st_void) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_void_sk_type(arg_sk: ?*struct_stack_st_void) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_void_compfunc_type(arg_cmp: sk_void_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_void_copyfunc_type(arg_cpy: sk_void_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_void_freefunc_type(arg_fr: sk_void_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const CRYPTO_EX_new = fn (?*anyopaque, ?*anyopaque, [*c]CRYPTO_EX_DATA, c_int, c_long, ?*anyopaque) callconv(.C) void;
pub const CRYPTO_EX_free = fn (?*anyopaque, ?*anyopaque, [*c]CRYPTO_EX_DATA, c_int, c_long, ?*anyopaque) callconv(.C) void;
pub const CRYPTO_EX_dup = fn ([*c]CRYPTO_EX_DATA, [*c]const CRYPTO_EX_DATA, [*c]?*anyopaque, c_int, c_long, ?*anyopaque) callconv(.C) c_int;
pub extern fn CRYPTO_get_ex_new_index(class_index: c_int, argl: c_long, argp: ?*anyopaque, new_func: ?*const CRYPTO_EX_new, dup_func: ?*const CRYPTO_EX_dup, free_func: ?*const CRYPTO_EX_free) c_int;
pub extern fn CRYPTO_free_ex_index(class_index: c_int, idx: c_int) c_int;
pub extern fn CRYPTO_new_ex_data(class_index: c_int, obj: ?*anyopaque, ad: [*c]CRYPTO_EX_DATA) c_int;
pub extern fn CRYPTO_dup_ex_data(class_index: c_int, to: [*c]CRYPTO_EX_DATA, from: [*c]const CRYPTO_EX_DATA) c_int;
pub extern fn CRYPTO_free_ex_data(class_index: c_int, obj: ?*anyopaque, ad: [*c]CRYPTO_EX_DATA) void;
pub extern fn CRYPTO_alloc_ex_data(class_index: c_int, obj: ?*anyopaque, ad: [*c]CRYPTO_EX_DATA, idx: c_int) c_int;
pub extern fn CRYPTO_set_ex_data(ad: [*c]CRYPTO_EX_DATA, idx: c_int, val: ?*anyopaque) c_int;
pub extern fn CRYPTO_get_ex_data(ad: [*c]const CRYPTO_EX_DATA, idx: c_int) ?*anyopaque;
pub const struct_crypto_threadid_st = extern struct {
    dummy: c_int = @import("std").mem.zeroes(c_int),
};
pub const CRYPTO_THREADID = struct_crypto_threadid_st;
pub const CRYPTO_malloc_fn = ?*const fn (usize, [*c]const u8, c_int) callconv(.C) ?*anyopaque;
pub const CRYPTO_realloc_fn = ?*const fn (?*anyopaque, usize, [*c]const u8, c_int) callconv(.C) ?*anyopaque;
pub const CRYPTO_free_fn = ?*const fn (?*anyopaque, [*c]const u8, c_int) callconv(.C) void;
pub extern fn CRYPTO_set_mem_functions(malloc_fn: CRYPTO_malloc_fn, realloc_fn: CRYPTO_realloc_fn, free_fn: CRYPTO_free_fn) c_int;
pub extern fn CRYPTO_get_mem_functions(malloc_fn: [*c]CRYPTO_malloc_fn, realloc_fn: [*c]CRYPTO_realloc_fn, free_fn: [*c]CRYPTO_free_fn) void;
pub extern fn CRYPTO_malloc(num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_zalloc(num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_aligned_alloc(num: usize, @"align": usize, freeptr: [*c]?*anyopaque, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_memdup(str: ?*const anyopaque, siz: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_strdup(str: [*c]const u8, file: [*c]const u8, line: c_int) [*c]u8;
pub extern fn CRYPTO_strndup(str: [*c]const u8, s: usize, file: [*c]const u8, line: c_int) [*c]u8;
pub extern fn CRYPTO_free(ptr: ?*anyopaque, file: [*c]const u8, line: c_int) void;
pub extern fn CRYPTO_clear_free(ptr: ?*anyopaque, num: usize, file: [*c]const u8, line: c_int) void;
pub extern fn CRYPTO_realloc(addr: ?*anyopaque, num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_clear_realloc(addr: ?*anyopaque, old_num: usize, num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_secure_malloc_init(sz: usize, minsize: usize) c_int;
pub extern fn CRYPTO_secure_malloc_done() c_int;
pub extern fn CRYPTO_secure_malloc(num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_secure_zalloc(num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_secure_free(ptr: ?*anyopaque, file: [*c]const u8, line: c_int) void;
pub extern fn CRYPTO_secure_clear_free(ptr: ?*anyopaque, num: usize, file: [*c]const u8, line: c_int) void;
pub extern fn CRYPTO_secure_allocated(ptr: ?*const anyopaque) c_int;
pub extern fn CRYPTO_secure_malloc_initialized() c_int;
pub extern fn CRYPTO_secure_actual_size(ptr: ?*anyopaque) usize;
pub extern fn CRYPTO_secure_used() usize;
pub extern fn OPENSSL_cleanse(ptr: ?*anyopaque, len: usize) void;
pub extern fn OPENSSL_die(assertion: [*c]const u8, file: [*c]const u8, line: c_int) void;
pub extern fn OPENSSL_isservice() c_int;
pub extern fn OPENSSL_init() void;
pub extern fn OPENSSL_fork_prepare() void;
pub extern fn OPENSSL_fork_parent() void;
pub extern fn OPENSSL_fork_child() void;
pub extern fn OPENSSL_gmtime(timer: [*c]const time_t, result: [*c]struct_tm) [*c]struct_tm;
pub extern fn OPENSSL_gmtime_adj(tm: [*c]struct_tm, offset_day: c_int, offset_sec: c_long) c_int;
pub extern fn OPENSSL_gmtime_diff(pday: [*c]c_int, psec: [*c]c_int, from: [*c]const struct_tm, to: [*c]const struct_tm) c_int;
pub extern fn CRYPTO_memcmp(in_a: ?*const anyopaque, in_b: ?*const anyopaque, len: usize) c_int;
pub extern fn OPENSSL_cleanup() void;
pub extern fn OPENSSL_init_crypto(opts: u64, settings: ?*const OPENSSL_INIT_SETTINGS) c_int;
pub extern fn OPENSSL_atexit(handler: ?*const fn () callconv(.C) void) c_int;
pub extern fn OPENSSL_thread_stop() void;
pub extern fn OPENSSL_thread_stop_ex(ctx: ?*OSSL_LIB_CTX) void;
pub extern fn OPENSSL_INIT_new() ?*OPENSSL_INIT_SETTINGS;
pub extern fn OPENSSL_INIT_set_config_filename(settings: ?*OPENSSL_INIT_SETTINGS, config_filename: [*c]const u8) c_int;
pub extern fn OPENSSL_INIT_set_config_file_flags(settings: ?*OPENSSL_INIT_SETTINGS, flags: c_ulong) void;
pub extern fn OPENSSL_INIT_set_config_appname(settings: ?*OPENSSL_INIT_SETTINGS, config_appname: [*c]const u8) c_int;
pub extern fn OPENSSL_INIT_free(settings: ?*OPENSSL_INIT_SETTINGS) void;
pub const struct_sched_param = extern struct {
    sched_priority: c_int = @import("std").mem.zeroes(c_int),
    __opaque: [4]u8 = @import("std").mem.zeroes([4]u8),
};
pub extern fn sched_yield() c_int;
pub extern fn sched_get_priority_min(c_int) c_int;
pub extern fn sched_get_priority_max(c_int) c_int;
pub const QOS_CLASS_USER_INTERACTIVE: c_int = 33;
pub const QOS_CLASS_USER_INITIATED: c_int = 25;
pub const QOS_CLASS_DEFAULT: c_int = 21;
pub const QOS_CLASS_UTILITY: c_int = 17;
pub const QOS_CLASS_BACKGROUND: c_int = 9;
pub const QOS_CLASS_UNSPECIFIED: c_int = 0;
const enum_unnamed_5 = c_uint;
pub const qos_class_t = c_uint;
pub extern fn qos_class_self() qos_class_t;
pub extern fn qos_class_main() qos_class_t;
pub extern fn pthread_attr_set_qos_class_np(__attr: [*c]pthread_attr_t, __qos_class: qos_class_t, __relative_priority: c_int) c_int;
pub extern fn pthread_attr_get_qos_class_np(noalias __attr: [*c]pthread_attr_t, noalias __qos_class: [*c]qos_class_t, noalias __relative_priority: [*c]c_int) c_int;
pub extern fn pthread_set_qos_class_self_np(__qos_class: qos_class_t, __relative_priority: c_int) c_int;
pub extern fn pthread_get_qos_class_np(__pthread: pthread_t, noalias __qos_class: [*c]qos_class_t, noalias __relative_priority: [*c]c_int) c_int;
pub const struct_pthread_override_s = opaque {};
pub const pthread_override_t = ?*struct_pthread_override_s;
pub extern fn pthread_override_qos_class_start_np(__pthread: pthread_t, __qos_class: qos_class_t, __relative_priority: c_int) pthread_override_t;
pub extern fn pthread_override_qos_class_end_np(__override: pthread_override_t) c_int;
pub const mach_port_t = __darwin_mach_port_t;
pub extern fn pthread_atfork(?*const fn () callconv(.C) void, ?*const fn () callconv(.C) void, ?*const fn () callconv(.C) void) c_int;
pub extern fn pthread_attr_destroy([*c]pthread_attr_t) c_int;
pub extern fn pthread_attr_getdetachstate([*c]const pthread_attr_t, [*c]c_int) c_int;
pub extern fn pthread_attr_getguardsize(noalias [*c]const pthread_attr_t, noalias [*c]usize) c_int;
pub extern fn pthread_attr_getinheritsched(noalias [*c]const pthread_attr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_attr_getschedparam(noalias [*c]const pthread_attr_t, noalias [*c]struct_sched_param) c_int;
pub extern fn pthread_attr_getschedpolicy(noalias [*c]const pthread_attr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_attr_getscope(noalias [*c]const pthread_attr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_attr_getstack(noalias [*c]const pthread_attr_t, noalias [*c]?*anyopaque, noalias [*c]usize) c_int;
pub extern fn pthread_attr_getstackaddr(noalias [*c]const pthread_attr_t, noalias [*c]?*anyopaque) c_int;
pub extern fn pthread_attr_getstacksize(noalias [*c]const pthread_attr_t, noalias [*c]usize) c_int;
pub extern fn pthread_attr_init([*c]pthread_attr_t) c_int;
pub extern fn pthread_attr_setdetachstate([*c]pthread_attr_t, c_int) c_int;
pub extern fn pthread_attr_setguardsize([*c]pthread_attr_t, usize) c_int;
pub extern fn pthread_attr_setinheritsched([*c]pthread_attr_t, c_int) c_int;
pub extern fn pthread_attr_setschedparam(noalias [*c]pthread_attr_t, noalias [*c]const struct_sched_param) c_int;
pub extern fn pthread_attr_setschedpolicy([*c]pthread_attr_t, c_int) c_int;
pub extern fn pthread_attr_setscope([*c]pthread_attr_t, c_int) c_int;
pub extern fn pthread_attr_setstack([*c]pthread_attr_t, ?*anyopaque, usize) c_int;
pub extern fn pthread_attr_setstackaddr([*c]pthread_attr_t, ?*anyopaque) c_int;
pub extern fn pthread_attr_setstacksize([*c]pthread_attr_t, usize) c_int;
pub extern fn pthread_cancel(pthread_t) c_int;
pub extern fn pthread_cond_broadcast([*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_destroy([*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_init(noalias [*c]pthread_cond_t, noalias [*c]const pthread_condattr_t) c_int;
pub extern fn pthread_cond_signal([*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_timedwait(noalias [*c]pthread_cond_t, noalias [*c]pthread_mutex_t, noalias [*c]const struct_timespec) c_int;
pub extern fn pthread_cond_wait(noalias [*c]pthread_cond_t, noalias [*c]pthread_mutex_t) c_int;
pub extern fn pthread_condattr_destroy([*c]pthread_condattr_t) c_int;
pub extern fn pthread_condattr_init([*c]pthread_condattr_t) c_int;
pub extern fn pthread_condattr_getpshared(noalias [*c]const pthread_condattr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_condattr_setpshared([*c]pthread_condattr_t, c_int) c_int;
pub extern fn pthread_create(noalias [*c]pthread_t, noalias [*c]const pthread_attr_t, ?*const fn (?*anyopaque) callconv(.C) ?*anyopaque, noalias ?*anyopaque) c_int;
pub extern fn pthread_detach(pthread_t) c_int;
pub extern fn pthread_equal(pthread_t, pthread_t) c_int;
pub extern fn pthread_exit(?*anyopaque) noreturn;
pub extern fn pthread_getconcurrency() c_int;
pub extern fn pthread_getschedparam(pthread_t, noalias [*c]c_int, noalias [*c]struct_sched_param) c_int;
pub extern fn pthread_getspecific(pthread_key_t) ?*anyopaque;
pub extern fn pthread_join(pthread_t, [*c]?*anyopaque) c_int;
pub extern fn pthread_key_create([*c]pthread_key_t, ?*const fn (?*anyopaque) callconv(.C) void) c_int;
pub extern fn pthread_key_delete(pthread_key_t) c_int;
pub extern fn pthread_mutex_destroy([*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_getprioceiling(noalias [*c]const pthread_mutex_t, noalias [*c]c_int) c_int;
pub extern fn pthread_mutex_init(noalias [*c]pthread_mutex_t, noalias [*c]const pthread_mutexattr_t) c_int;
pub extern fn pthread_mutex_lock([*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_setprioceiling(noalias [*c]pthread_mutex_t, c_int, noalias [*c]c_int) c_int;
pub extern fn pthread_mutex_trylock([*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_unlock([*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutexattr_destroy([*c]pthread_mutexattr_t) c_int;
pub extern fn pthread_mutexattr_getprioceiling(noalias [*c]const pthread_mutexattr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_mutexattr_getprotocol(noalias [*c]const pthread_mutexattr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_mutexattr_getpshared(noalias [*c]const pthread_mutexattr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_mutexattr_gettype(noalias [*c]const pthread_mutexattr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_mutexattr_getpolicy_np(noalias [*c]const pthread_mutexattr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_mutexattr_init([*c]pthread_mutexattr_t) c_int;
pub extern fn pthread_mutexattr_setprioceiling([*c]pthread_mutexattr_t, c_int) c_int;
pub extern fn pthread_mutexattr_setprotocol([*c]pthread_mutexattr_t, c_int) c_int;
pub extern fn pthread_mutexattr_setpshared([*c]pthread_mutexattr_t, c_int) c_int;
pub extern fn pthread_mutexattr_settype([*c]pthread_mutexattr_t, c_int) c_int;
pub extern fn pthread_mutexattr_setpolicy_np([*c]pthread_mutexattr_t, c_int) c_int;
pub extern fn pthread_once([*c]pthread_once_t, ?*const fn () callconv(.C) void) c_int;
pub extern fn pthread_rwlock_destroy([*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_init(noalias [*c]pthread_rwlock_t, noalias [*c]const pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlock_rdlock([*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_tryrdlock([*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_trywrlock([*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_wrlock([*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_unlock([*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlockattr_destroy([*c]pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlockattr_getpshared(noalias [*c]const pthread_rwlockattr_t, noalias [*c]c_int) c_int;
pub extern fn pthread_rwlockattr_init([*c]pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlockattr_setpshared([*c]pthread_rwlockattr_t, c_int) c_int;
pub extern fn pthread_self() pthread_t;
pub extern fn pthread_setcancelstate(c_int, [*c]c_int) c_int;
pub extern fn pthread_setcanceltype(c_int, [*c]c_int) c_int;
pub extern fn pthread_setconcurrency(c_int) c_int;
pub extern fn pthread_setschedparam(pthread_t, c_int, [*c]const struct_sched_param) c_int;
pub extern fn pthread_setspecific(pthread_key_t, ?*const anyopaque) c_int;
pub extern fn pthread_testcancel() void;
pub extern fn pthread_is_threaded_np() c_int;
pub extern fn pthread_threadid_np(pthread_t, [*c]__uint64_t) c_int;
pub extern fn pthread_getname_np(pthread_t, [*c]u8, usize) c_int;
pub extern fn pthread_setname_np([*c]const u8) c_int;
pub extern fn pthread_main_np() c_int;
pub extern fn pthread_mach_thread_np(pthread_t) mach_port_t;
pub extern fn pthread_get_stacksize_np(pthread_t) usize;
pub extern fn pthread_get_stackaddr_np(pthread_t) ?*anyopaque;
pub extern fn pthread_cond_signal_thread_np([*c]pthread_cond_t, pthread_t) c_int;
pub extern fn pthread_cond_timedwait_relative_np([*c]pthread_cond_t, [*c]pthread_mutex_t, [*c]const struct_timespec) c_int;
pub extern fn pthread_create_suspended_np([*c]pthread_t, [*c]const pthread_attr_t, ?*const fn (?*anyopaque) callconv(.C) ?*anyopaque, ?*anyopaque) c_int;
pub extern fn pthread_kill(pthread_t, c_int) c_int;
pub extern fn pthread_from_mach_thread_np(mach_port_t) pthread_t;
pub extern fn pthread_sigmask(c_int, [*c]const sigset_t, [*c]sigset_t) c_int;
pub extern fn pthread_yield_np() void;
pub extern fn pthread_jit_write_protect_np(enabled: c_int) void;
pub extern fn pthread_jit_write_protect_supported_np() c_int;
pub const pthread_jit_write_callback_t = ?*const fn (?*anyopaque) callconv(.C) c_int;
pub extern fn pthread_jit_write_with_callback_np(callback: pthread_jit_write_callback_t, ctx: ?*anyopaque) c_int;
pub extern fn pthread_jit_write_freeze_callbacks_np() void;
pub extern fn pthread_cpu_number_np(cpu_number_out: [*c]usize) c_int;
pub const CRYPTO_ONCE = pthread_once_t;
pub const CRYPTO_THREAD_LOCAL = pthread_key_t;
pub const CRYPTO_THREAD_ID = pthread_t;
pub extern fn CRYPTO_THREAD_run_once(once: [*c]CRYPTO_ONCE, init: ?*const fn () callconv(.C) void) c_int;
pub extern fn CRYPTO_THREAD_init_local(key: [*c]CRYPTO_THREAD_LOCAL, cleanup: ?*const fn (?*anyopaque) callconv(.C) void) c_int;
pub extern fn CRYPTO_THREAD_get_local(key: [*c]CRYPTO_THREAD_LOCAL) ?*anyopaque;
pub extern fn CRYPTO_THREAD_set_local(key: [*c]CRYPTO_THREAD_LOCAL, val: ?*anyopaque) c_int;
pub extern fn CRYPTO_THREAD_cleanup_local(key: [*c]CRYPTO_THREAD_LOCAL) c_int;
pub extern fn CRYPTO_THREAD_get_current_id() CRYPTO_THREAD_ID;
pub extern fn CRYPTO_THREAD_compare_id(a: CRYPTO_THREAD_ID, b: CRYPTO_THREAD_ID) c_int;
pub extern fn OSSL_LIB_CTX_new() ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_new_from_dispatch(handle: ?*const OSSL_CORE_HANDLE, in: [*c]const OSSL_DISPATCH) ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_new_child(handle: ?*const OSSL_CORE_HANDLE, in: [*c]const OSSL_DISPATCH) ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_load_config(ctx: ?*OSSL_LIB_CTX, config_file: [*c]const u8) c_int;
pub extern fn OSSL_LIB_CTX_free(?*OSSL_LIB_CTX) void;
pub extern fn OSSL_LIB_CTX_get0_global_default() ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_set0_default(libctx: ?*OSSL_LIB_CTX) ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_get_conf_diagnostics(ctx: ?*OSSL_LIB_CTX) c_int;
pub extern fn OSSL_LIB_CTX_set_conf_diagnostics(ctx: ?*OSSL_LIB_CTX, value: c_int) void;
pub extern fn OSSL_sleep(millis: u64) void;
pub extern fn OSSL_LIB_CTX_get_data(ctx: ?*OSSL_LIB_CTX, index: c_int) ?*anyopaque;
pub extern fn COMP_CTX_new(meth: ?*COMP_METHOD) ?*COMP_CTX;
pub extern fn COMP_CTX_get_method(ctx: ?*const COMP_CTX) ?*const COMP_METHOD;
pub extern fn COMP_CTX_get_type(comp: ?*const COMP_CTX) c_int;
pub extern fn COMP_get_type(meth: ?*const COMP_METHOD) c_int;
pub extern fn COMP_get_name(meth: ?*const COMP_METHOD) [*c]const u8;
pub extern fn COMP_CTX_free(ctx: ?*COMP_CTX) void;
pub extern fn COMP_compress_block(ctx: ?*COMP_CTX, out: [*c]u8, olen: c_int, in: [*c]u8, ilen: c_int) c_int;
pub extern fn COMP_expand_block(ctx: ?*COMP_CTX, out: [*c]u8, olen: c_int, in: [*c]u8, ilen: c_int) c_int;
pub extern fn COMP_zlib() ?*COMP_METHOD;
pub extern fn COMP_zlib_oneshot() ?*COMP_METHOD;
pub extern fn COMP_brotli() ?*COMP_METHOD;
pub extern fn COMP_brotli_oneshot() ?*COMP_METHOD;
pub extern fn COMP_zstd() ?*COMP_METHOD;
pub extern fn COMP_zstd_oneshot() ?*COMP_METHOD;
pub const struct_ssl_comp_st = opaque {};
pub const SSL_COMP = struct_ssl_comp_st;
pub const struct_stack_st_SSL_COMP = opaque {};
pub const sk_SSL_COMP_compfunc = ?*const fn ([*c]const ?*const SSL_COMP, [*c]const ?*const SSL_COMP) callconv(.C) c_int;
pub const sk_SSL_COMP_freefunc = ?*const fn (?*SSL_COMP) callconv(.C) void;
pub const sk_SSL_COMP_copyfunc = ?*const fn (?*const SSL_COMP) callconv(.C) ?*SSL_COMP;
pub fn ossl_check_SSL_COMP_type(arg_ptr: ?*SSL_COMP) callconv(.C) ?*SSL_COMP {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_SSL_COMP_sk_type(arg_sk: ?*const struct_stack_st_SSL_COMP) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SSL_COMP_sk_type(arg_sk: ?*struct_stack_st_SSL_COMP) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SSL_COMP_compfunc_type(arg_cmp: sk_SSL_COMP_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_SSL_COMP_copyfunc_type(arg_cpy: sk_SSL_COMP_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_SSL_COMP_freefunc_type(arg_fr: sk_SSL_COMP_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const __gnuc_va_list = __builtin_va_list;
pub const union_bio_addr_st = opaque {};
pub const BIO_ADDR = union_bio_addr_st;
pub const struct_bio_addrinfo_st = opaque {};
pub const BIO_ADDRINFO = struct_bio_addrinfo_st;
pub extern fn BIO_get_new_index() c_int;
pub extern fn BIO_set_flags(b: ?*BIO, flags: c_int) void;
pub extern fn BIO_test_flags(b: ?*const BIO, flags: c_int) c_int;
pub extern fn BIO_clear_flags(b: ?*BIO, flags: c_int) void;
pub const BIO_callback_fn = ?*const fn (?*BIO, c_int, [*c]const u8, c_int, c_long, c_long) callconv(.C) c_long;
pub extern fn BIO_get_callback(b: ?*const BIO) BIO_callback_fn;
pub extern fn BIO_set_callback(b: ?*BIO, callback: BIO_callback_fn) void;
pub extern fn BIO_debug_callback(bio: ?*BIO, cmd: c_int, argp: [*c]const u8, argi: c_int, argl: c_long, ret: c_long) c_long;
pub const BIO_callback_fn_ex = ?*const fn (?*BIO, c_int, [*c]const u8, usize, c_int, c_long, c_int, [*c]usize) callconv(.C) c_long;
pub extern fn BIO_get_callback_ex(b: ?*const BIO) BIO_callback_fn_ex;
pub extern fn BIO_set_callback_ex(b: ?*BIO, callback: BIO_callback_fn_ex) void;
pub extern fn BIO_debug_callback_ex(bio: ?*BIO, oper: c_int, argp: [*c]const u8, len: usize, argi: c_int, argl: c_long, ret: c_int, processed: [*c]usize) c_long;
pub extern fn BIO_get_callback_arg(b: ?*const BIO) [*c]u8;
pub extern fn BIO_set_callback_arg(b: ?*BIO, arg: [*c]u8) void;
pub const struct_bio_method_st = opaque {};
pub const BIO_METHOD = struct_bio_method_st;
pub extern fn BIO_method_name(b: ?*const BIO) [*c]const u8;
pub extern fn BIO_method_type(b: ?*const BIO) c_int;
pub const BIO_info_cb = fn (?*BIO, c_int, c_int) callconv(.C) c_int;
pub const bio_info_cb = BIO_info_cb;
pub const struct_stack_st_BIO = opaque {};
pub const sk_BIO_compfunc = ?*const fn ([*c]const ?*const BIO, [*c]const ?*const BIO) callconv(.C) c_int;
pub const sk_BIO_freefunc = ?*const fn (?*BIO) callconv(.C) void;
pub const sk_BIO_copyfunc = ?*const fn (?*const BIO) callconv(.C) ?*BIO;
pub fn ossl_check_BIO_type(arg_ptr: ?*BIO) callconv(.C) ?*BIO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_BIO_sk_type(arg_sk: ?*const struct_stack_st_BIO) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_BIO_sk_type(arg_sk: ?*struct_stack_st_BIO) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_BIO_compfunc_type(arg_cmp: sk_BIO_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_BIO_copyfunc_type(arg_cpy: sk_BIO_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_BIO_freefunc_type(arg_fr: sk_BIO_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const asn1_ps_func = fn (?*BIO, [*c][*c]u8, [*c]c_int, ?*anyopaque) callconv(.C) c_int;
pub const BIO_dgram_sctp_notification_handler_fn = ?*const fn (?*BIO, ?*anyopaque, ?*anyopaque) callconv(.C) void;
pub const struct_bio_msg_st = extern struct {
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    data_len: usize = @import("std").mem.zeroes(usize),
    peer: ?*BIO_ADDR = @import("std").mem.zeroes(?*BIO_ADDR),
    local: ?*BIO_ADDR = @import("std").mem.zeroes(?*BIO_ADDR),
    flags: u64 = @import("std").mem.zeroes(u64),
};
pub const BIO_MSG = struct_bio_msg_st;
pub const struct_bio_mmsg_cb_args_st = extern struct {
    msg: [*c]BIO_MSG = @import("std").mem.zeroes([*c]BIO_MSG),
    stride: usize = @import("std").mem.zeroes(usize),
    num_msg: usize = @import("std").mem.zeroes(usize),
    flags: u64 = @import("std").mem.zeroes(u64),
    msgs_processed: [*c]usize = @import("std").mem.zeroes([*c]usize),
};
pub const BIO_MMSG_CB_ARGS = struct_bio_mmsg_cb_args_st;
const union_unnamed_6 = extern union {
    fd: c_int,
    custom: ?*anyopaque,
    custom_ui: usize,
    ssl: ?*SSL,
};
pub const struct_bio_poll_descriptor_st = extern struct {
    type: u32 = @import("std").mem.zeroes(u32),
    value: union_unnamed_6 = @import("std").mem.zeroes(union_unnamed_6),
};
pub const BIO_POLL_DESCRIPTOR = struct_bio_poll_descriptor_st;
pub extern fn BIO_ctrl_pending(b: ?*BIO) usize;
pub extern fn BIO_ctrl_wpending(b: ?*BIO) usize;
pub extern fn BIO_ctrl_get_write_guarantee(b: ?*BIO) usize;
pub extern fn BIO_ctrl_get_read_request(b: ?*BIO) usize;
pub extern fn BIO_ctrl_reset_read_request(b: ?*BIO) c_int;
pub extern fn BIO_set_ex_data(bio: ?*BIO, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn BIO_get_ex_data(bio: ?*const BIO, idx: c_int) ?*anyopaque;
pub extern fn BIO_number_read(bio: ?*BIO) u64;
pub extern fn BIO_number_written(bio: ?*BIO) u64;
pub extern fn BIO_asn1_set_prefix(b: ?*BIO, prefix: ?*const asn1_ps_func, prefix_free: ?*const asn1_ps_func) c_int;
pub extern fn BIO_asn1_get_prefix(b: ?*BIO, pprefix: [*c]?*const asn1_ps_func, pprefix_free: [*c]?*const asn1_ps_func) c_int;
pub extern fn BIO_asn1_set_suffix(b: ?*BIO, suffix: ?*const asn1_ps_func, suffix_free: ?*const asn1_ps_func) c_int;
pub extern fn BIO_asn1_get_suffix(b: ?*BIO, psuffix: [*c]?*const asn1_ps_func, psuffix_free: [*c]?*const asn1_ps_func) c_int;
pub extern fn BIO_s_file() ?*const BIO_METHOD;
pub extern fn BIO_new_file(filename: [*c]const u8, mode: [*c]const u8) ?*BIO;
pub extern fn BIO_new_from_core_bio(libctx: ?*OSSL_LIB_CTX, corebio: ?*OSSL_CORE_BIO) ?*BIO;
pub extern fn BIO_new_fp(stream: [*c]FILE, close_flag: c_int) ?*BIO;
pub extern fn BIO_new_ex(libctx: ?*OSSL_LIB_CTX, method: ?*const BIO_METHOD) ?*BIO;
pub extern fn BIO_new(@"type": ?*const BIO_METHOD) ?*BIO;
pub extern fn BIO_free(a: ?*BIO) c_int;
pub extern fn BIO_set_data(a: ?*BIO, ptr: ?*anyopaque) void;
pub extern fn BIO_get_data(a: ?*BIO) ?*anyopaque;
pub extern fn BIO_set_init(a: ?*BIO, init: c_int) void;
pub extern fn BIO_get_init(a: ?*BIO) c_int;
pub extern fn BIO_set_shutdown(a: ?*BIO, shut: c_int) void;
pub extern fn BIO_get_shutdown(a: ?*BIO) c_int;
pub extern fn BIO_vfree(a: ?*BIO) void;
pub extern fn BIO_up_ref(a: ?*BIO) c_int;
pub extern fn BIO_read(b: ?*BIO, data: ?*anyopaque, dlen: c_int) c_int;
pub extern fn BIO_read_ex(b: ?*BIO, data: ?*anyopaque, dlen: usize, readbytes: [*c]usize) c_int;
pub extern fn BIO_recvmmsg(b: ?*BIO, msg: [*c]BIO_MSG, stride: usize, num_msg: usize, flags: u64, msgs_processed: [*c]usize) c_int;
pub extern fn BIO_gets(bp: ?*BIO, buf: [*c]u8, size: c_int) c_int;
pub extern fn BIO_get_line(bio: ?*BIO, buf: [*c]u8, size: c_int) c_int;
pub extern fn BIO_write(b: ?*BIO, data: ?*const anyopaque, dlen: c_int) c_int;
pub extern fn BIO_write_ex(b: ?*BIO, data: ?*const anyopaque, dlen: usize, written: [*c]usize) c_int;
pub extern fn BIO_sendmmsg(b: ?*BIO, msg: [*c]BIO_MSG, stride: usize, num_msg: usize, flags: u64, msgs_processed: [*c]usize) c_int;
pub extern fn BIO_get_rpoll_descriptor(b: ?*BIO, desc: [*c]BIO_POLL_DESCRIPTOR) c_int;
pub extern fn BIO_get_wpoll_descriptor(b: ?*BIO, desc: [*c]BIO_POLL_DESCRIPTOR) c_int;
pub extern fn BIO_puts(bp: ?*BIO, buf: [*c]const u8) c_int;
pub extern fn BIO_indent(b: ?*BIO, indent: c_int, max: c_int) c_int;
pub extern fn BIO_ctrl(bp: ?*BIO, cmd: c_int, larg: c_long, parg: ?*anyopaque) c_long;
pub extern fn BIO_callback_ctrl(b: ?*BIO, cmd: c_int, fp: ?*const BIO_info_cb) c_long;
pub extern fn BIO_ptr_ctrl(bp: ?*BIO, cmd: c_int, larg: c_long) ?*anyopaque;
pub extern fn BIO_int_ctrl(bp: ?*BIO, cmd: c_int, larg: c_long, iarg: c_int) c_long;
pub extern fn BIO_push(b: ?*BIO, append: ?*BIO) ?*BIO;
pub extern fn BIO_pop(b: ?*BIO) ?*BIO;
pub extern fn BIO_free_all(a: ?*BIO) void;
pub extern fn BIO_find_type(b: ?*BIO, bio_type: c_int) ?*BIO;
pub extern fn BIO_next(b: ?*BIO) ?*BIO;
pub extern fn BIO_set_next(b: ?*BIO, next: ?*BIO) void;
pub extern fn BIO_get_retry_BIO(bio: ?*BIO, reason: [*c]c_int) ?*BIO;
pub extern fn BIO_get_retry_reason(bio: ?*BIO) c_int;
pub extern fn BIO_set_retry_reason(bio: ?*BIO, reason: c_int) void;
pub extern fn BIO_dup_chain(in: ?*BIO) ?*BIO;
pub extern fn BIO_nread0(bio: ?*BIO, buf: [*c][*c]u8) c_int;
pub extern fn BIO_nread(bio: ?*BIO, buf: [*c][*c]u8, num: c_int) c_int;
pub extern fn BIO_nwrite0(bio: ?*BIO, buf: [*c][*c]u8) c_int;
pub extern fn BIO_nwrite(bio: ?*BIO, buf: [*c][*c]u8, num: c_int) c_int;
pub extern fn BIO_s_mem() ?*const BIO_METHOD;
pub extern fn BIO_s_dgram_mem() ?*const BIO_METHOD;
pub extern fn BIO_s_secmem() ?*const BIO_METHOD;
pub extern fn BIO_new_mem_buf(buf: ?*const anyopaque, len: c_int) ?*BIO;
pub extern fn BIO_s_socket() ?*const BIO_METHOD;
pub extern fn BIO_s_connect() ?*const BIO_METHOD;
pub extern fn BIO_s_accept() ?*const BIO_METHOD;
pub extern fn BIO_s_fd() ?*const BIO_METHOD;
pub extern fn BIO_s_log() ?*const BIO_METHOD;
pub extern fn BIO_s_bio() ?*const BIO_METHOD;
pub extern fn BIO_s_null() ?*const BIO_METHOD;
pub extern fn BIO_f_null() ?*const BIO_METHOD;
pub extern fn BIO_f_buffer() ?*const BIO_METHOD;
pub extern fn BIO_f_readbuffer() ?*const BIO_METHOD;
pub extern fn BIO_f_linebuffer() ?*const BIO_METHOD;
pub extern fn BIO_f_nbio_test() ?*const BIO_METHOD;
pub extern fn BIO_f_prefix() ?*const BIO_METHOD;
pub extern fn BIO_s_core() ?*const BIO_METHOD;
pub extern fn BIO_s_dgram_pair() ?*const BIO_METHOD;
pub extern fn BIO_s_datagram() ?*const BIO_METHOD;
pub extern fn BIO_dgram_non_fatal_error(@"error": c_int) c_int;
pub extern fn BIO_new_dgram(fd: c_int, close_flag: c_int) ?*BIO;
pub extern fn BIO_sock_should_retry(i: c_int) c_int;
pub extern fn BIO_sock_non_fatal_error(@"error": c_int) c_int;
pub extern fn BIO_err_is_non_fatal(errcode: c_uint) c_int;
pub extern fn BIO_socket_wait(fd: c_int, for_read: c_int, max_time: time_t) c_int;
pub extern fn BIO_wait(bio: ?*BIO, max_time: time_t, nap_milliseconds: c_uint) c_int;
pub extern fn BIO_do_connect_retry(bio: ?*BIO, timeout: c_int, nap_milliseconds: c_int) c_int;
pub extern fn BIO_fd_should_retry(i: c_int) c_int;
pub extern fn BIO_fd_non_fatal_error(@"error": c_int) c_int;
pub extern fn BIO_dump_cb(cb: ?*const fn (?*const anyopaque, usize, ?*anyopaque) callconv(.C) c_int, u: ?*anyopaque, s: ?*const anyopaque, len: c_int) c_int;
pub extern fn BIO_dump_indent_cb(cb: ?*const fn (?*const anyopaque, usize, ?*anyopaque) callconv(.C) c_int, u: ?*anyopaque, s: ?*const anyopaque, len: c_int, indent: c_int) c_int;
pub extern fn BIO_dump(b: ?*BIO, bytes: ?*const anyopaque, len: c_int) c_int;
pub extern fn BIO_dump_indent(b: ?*BIO, bytes: ?*const anyopaque, len: c_int, indent: c_int) c_int;
pub extern fn BIO_dump_fp(fp: [*c]FILE, s: ?*const anyopaque, len: c_int) c_int;
pub extern fn BIO_dump_indent_fp(fp: [*c]FILE, s: ?*const anyopaque, len: c_int, indent: c_int) c_int;
pub extern fn BIO_hex_string(out: ?*BIO, indent: c_int, width: c_int, data: ?*const anyopaque, datalen: c_int) c_int;
pub extern fn BIO_ADDR_new() ?*BIO_ADDR;
pub extern fn BIO_ADDR_copy(dst: ?*BIO_ADDR, src: ?*const BIO_ADDR) c_int;
pub extern fn BIO_ADDR_dup(ap: ?*const BIO_ADDR) ?*BIO_ADDR;
pub extern fn BIO_ADDR_rawmake(ap: ?*BIO_ADDR, family: c_int, where: ?*const anyopaque, wherelen: usize, port: c_ushort) c_int;
pub extern fn BIO_ADDR_free(?*BIO_ADDR) void;
pub extern fn BIO_ADDR_clear(ap: ?*BIO_ADDR) void;
pub extern fn BIO_ADDR_family(ap: ?*const BIO_ADDR) c_int;
pub extern fn BIO_ADDR_rawaddress(ap: ?*const BIO_ADDR, p: ?*anyopaque, l: [*c]usize) c_int;
pub extern fn BIO_ADDR_rawport(ap: ?*const BIO_ADDR) c_ushort;
pub extern fn BIO_ADDR_hostname_string(ap: ?*const BIO_ADDR, numeric: c_int) [*c]u8;
pub extern fn BIO_ADDR_service_string(ap: ?*const BIO_ADDR, numeric: c_int) [*c]u8;
pub extern fn BIO_ADDR_path_string(ap: ?*const BIO_ADDR) [*c]u8;
pub extern fn BIO_ADDRINFO_next(bai: ?*const BIO_ADDRINFO) ?*const BIO_ADDRINFO;
pub extern fn BIO_ADDRINFO_family(bai: ?*const BIO_ADDRINFO) c_int;
pub extern fn BIO_ADDRINFO_socktype(bai: ?*const BIO_ADDRINFO) c_int;
pub extern fn BIO_ADDRINFO_protocol(bai: ?*const BIO_ADDRINFO) c_int;
pub extern fn BIO_ADDRINFO_address(bai: ?*const BIO_ADDRINFO) ?*const BIO_ADDR;
pub extern fn BIO_ADDRINFO_free(bai: ?*BIO_ADDRINFO) void;
pub const BIO_PARSE_PRIO_HOST: c_int = 0;
pub const BIO_PARSE_PRIO_SERV: c_int = 1;
pub const enum_BIO_hostserv_priorities = c_uint;
pub extern fn BIO_parse_hostserv(hostserv: [*c]const u8, host: [*c][*c]u8, service: [*c][*c]u8, hostserv_prio: enum_BIO_hostserv_priorities) c_int;
pub const BIO_LOOKUP_CLIENT: c_int = 0;
pub const BIO_LOOKUP_SERVER: c_int = 1;
pub const enum_BIO_lookup_type = c_uint;
pub extern fn BIO_lookup(host: [*c]const u8, service: [*c]const u8, lookup_type: enum_BIO_lookup_type, family: c_int, socktype: c_int, res: [*c]?*BIO_ADDRINFO) c_int;
pub extern fn BIO_lookup_ex(host: [*c]const u8, service: [*c]const u8, lookup_type: c_int, family: c_int, socktype: c_int, protocol: c_int, res: [*c]?*BIO_ADDRINFO) c_int;
pub extern fn BIO_sock_error(sock: c_int) c_int;
pub extern fn BIO_socket_ioctl(fd: c_int, @"type": c_long, arg: ?*anyopaque) c_int;
pub extern fn BIO_socket_nbio(fd: c_int, mode: c_int) c_int;
pub extern fn BIO_sock_init() c_int;
pub extern fn BIO_set_tcp_ndelay(sock: c_int, turn_on: c_int) c_int;
pub const struct_hostent = opaque {};
pub extern fn BIO_gethostbyname(name: [*c]const u8) ?*struct_hostent;
pub extern fn BIO_get_port(str: [*c]const u8, port_ptr: [*c]c_ushort) c_int;
pub extern fn BIO_get_host_ip(str: [*c]const u8, ip: [*c]u8) c_int;
pub extern fn BIO_get_accept_socket(host_port: [*c]u8, mode: c_int) c_int;
pub extern fn BIO_accept(sock: c_int, ip_port: [*c][*c]u8) c_int;
pub const union_BIO_sock_info_u = extern union {
    addr: ?*BIO_ADDR,
};
pub const BIO_SOCK_INFO_ADDRESS: c_int = 0;
pub const enum_BIO_sock_info_type = c_uint;
pub extern fn BIO_sock_info(sock: c_int, @"type": enum_BIO_sock_info_type, info: [*c]union_BIO_sock_info_u) c_int;
pub extern fn BIO_socket(domain: c_int, socktype: c_int, protocol: c_int, options: c_int) c_int;
pub extern fn BIO_connect(sock: c_int, addr: ?*const BIO_ADDR, options: c_int) c_int;
pub extern fn BIO_bind(sock: c_int, addr: ?*const BIO_ADDR, options: c_int) c_int;
pub extern fn BIO_listen(sock: c_int, addr: ?*const BIO_ADDR, options: c_int) c_int;
pub extern fn BIO_accept_ex(accept_sock: c_int, addr: ?*BIO_ADDR, options: c_int) c_int;
pub extern fn BIO_closesocket(sock: c_int) c_int;
pub extern fn BIO_new_socket(sock: c_int, close_flag: c_int) ?*BIO;
pub extern fn BIO_new_connect(host_port: [*c]const u8) ?*BIO;
pub extern fn BIO_new_accept(host_port: [*c]const u8) ?*BIO;
pub extern fn BIO_new_fd(fd: c_int, close_flag: c_int) ?*BIO;
pub extern fn BIO_new_bio_pair(bio1: [*c]?*BIO, writebuf1: usize, bio2: [*c]?*BIO, writebuf2: usize) c_int;
pub extern fn BIO_new_bio_dgram_pair(bio1: [*c]?*BIO, writebuf1: usize, bio2: [*c]?*BIO, writebuf2: usize) c_int;
pub extern fn BIO_copy_next_retry(b: ?*BIO) void;
pub extern fn BIO_printf(bio: ?*BIO, format: [*c]const u8, ...) c_int;
pub extern fn BIO_vprintf(bio: ?*BIO, format: [*c]const u8, args: va_list) c_int;
pub extern fn BIO_snprintf(buf: [*c]u8, n: usize, format: [*c]const u8, ...) c_int;
pub extern fn BIO_vsnprintf(buf: [*c]u8, n: usize, format: [*c]const u8, args: va_list) c_int;
pub extern fn BIO_meth_new(@"type": c_int, name: [*c]const u8) ?*BIO_METHOD;
pub extern fn BIO_meth_free(biom: ?*BIO_METHOD) void;
pub extern fn BIO_meth_get_write(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]const u8, c_int) callconv(.C) c_int;
pub extern fn BIO_meth_get_write_ex(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]const u8, usize, [*c]usize) callconv(.C) c_int;
pub extern fn BIO_meth_set_write(biom: ?*BIO_METHOD, write: ?*const fn (?*BIO, [*c]const u8, c_int) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_set_write_ex(biom: ?*BIO_METHOD, bwrite: ?*const fn (?*BIO, [*c]const u8, usize, [*c]usize) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_set_sendmmsg(biom: ?*BIO_METHOD, f: ?*const fn (?*BIO, [*c]BIO_MSG, usize, usize, u64, [*c]usize) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_get_sendmmsg(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]BIO_MSG, usize, usize, u64, [*c]usize) callconv(.C) c_int;
pub extern fn BIO_meth_get_read(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]u8, c_int) callconv(.C) c_int;
pub extern fn BIO_meth_get_read_ex(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]u8, usize, [*c]usize) callconv(.C) c_int;
pub extern fn BIO_meth_set_read(biom: ?*BIO_METHOD, read: ?*const fn (?*BIO, [*c]u8, c_int) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_set_read_ex(biom: ?*BIO_METHOD, bread: ?*const fn (?*BIO, [*c]u8, usize, [*c]usize) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_set_recvmmsg(biom: ?*BIO_METHOD, f: ?*const fn (?*BIO, [*c]BIO_MSG, usize, usize, u64, [*c]usize) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_get_recvmmsg(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]BIO_MSG, usize, usize, u64, [*c]usize) callconv(.C) c_int;
pub extern fn BIO_meth_get_puts(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]const u8) callconv(.C) c_int;
pub extern fn BIO_meth_set_puts(biom: ?*BIO_METHOD, puts: ?*const fn (?*BIO, [*c]const u8) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_get_gets(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]u8, c_int) callconv(.C) c_int;
pub extern fn BIO_meth_set_gets(biom: ?*BIO_METHOD, ossl_gets: ?*const fn (?*BIO, [*c]u8, c_int) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_get_ctrl(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, c_int, c_long, ?*anyopaque) callconv(.C) c_long;
pub extern fn BIO_meth_set_ctrl(biom: ?*BIO_METHOD, ctrl: ?*const fn (?*BIO, c_int, c_long, ?*anyopaque) callconv(.C) c_long) c_int;
pub extern fn BIO_meth_get_create(bion: ?*const BIO_METHOD) ?*const fn (?*BIO) callconv(.C) c_int;
pub extern fn BIO_meth_set_create(biom: ?*BIO_METHOD, create: ?*const fn (?*BIO) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_get_destroy(biom: ?*const BIO_METHOD) ?*const fn (?*BIO) callconv(.C) c_int;
pub extern fn BIO_meth_set_destroy(biom: ?*BIO_METHOD, destroy: ?*const fn (?*BIO) callconv(.C) c_int) c_int;
pub extern fn BIO_meth_get_callback_ctrl(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, c_int, ?*const BIO_info_cb) callconv(.C) c_long;
pub extern fn BIO_meth_set_callback_ctrl(biom: ?*BIO_METHOD, callback_ctrl: ?*const fn (?*BIO, c_int, ?*const BIO_info_cb) callconv(.C) c_long) c_int;
pub extern fn BUF_MEM_new() [*c]BUF_MEM;
pub extern fn BUF_MEM_new_ex(flags: c_ulong) [*c]BUF_MEM;
pub extern fn BUF_MEM_free(a: [*c]BUF_MEM) void;
pub extern fn BUF_MEM_grow(str: [*c]BUF_MEM, len: usize) usize;
pub extern fn BUF_MEM_grow_clean(str: [*c]BUF_MEM, len: usize) usize;
pub extern fn BUF_reverse(out: [*c]u8, in: [*c]const u8, siz: usize) void;
pub extern fn BN_set_flags(b: ?*BIGNUM, n: c_int) void;
pub extern fn BN_get_flags(b: ?*const BIGNUM, n: c_int) c_int;
pub extern fn BN_with_flags(dest: ?*BIGNUM, b: ?*const BIGNUM, flags: c_int) void;
pub extern fn BN_GENCB_call(cb: ?*BN_GENCB, a: c_int, b: c_int) c_int;
pub extern fn BN_GENCB_new() ?*BN_GENCB;
pub extern fn BN_GENCB_free(cb: ?*BN_GENCB) void;
pub extern fn BN_GENCB_set_old(gencb: ?*BN_GENCB, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.C) void, cb_arg: ?*anyopaque) void;
pub extern fn BN_GENCB_set(gencb: ?*BN_GENCB, callback: ?*const fn (c_int, c_int, ?*BN_GENCB) callconv(.C) c_int, cb_arg: ?*anyopaque) void;
pub extern fn BN_GENCB_get_arg(cb: ?*BN_GENCB) ?*anyopaque;
pub extern fn BN_abs_is_word(a: ?*const BIGNUM, w: c_ulong) c_int;
pub extern fn BN_is_zero(a: ?*const BIGNUM) c_int;
pub extern fn BN_is_one(a: ?*const BIGNUM) c_int;
pub extern fn BN_is_word(a: ?*const BIGNUM, w: c_ulong) c_int;
pub extern fn BN_is_odd(a: ?*const BIGNUM) c_int;
pub extern fn BN_zero_ex(a: ?*BIGNUM) void;
pub extern fn BN_value_one() ?*const BIGNUM;
pub extern fn BN_options() [*c]u8;
pub extern fn BN_CTX_new_ex(ctx: ?*OSSL_LIB_CTX) ?*BN_CTX;
pub extern fn BN_CTX_new() ?*BN_CTX;
pub extern fn BN_CTX_secure_new_ex(ctx: ?*OSSL_LIB_CTX) ?*BN_CTX;
pub extern fn BN_CTX_secure_new() ?*BN_CTX;
pub extern fn BN_CTX_free(c: ?*BN_CTX) void;
pub extern fn BN_CTX_start(ctx: ?*BN_CTX) void;
pub extern fn BN_CTX_get(ctx: ?*BN_CTX) ?*BIGNUM;
pub extern fn BN_CTX_end(ctx: ?*BN_CTX) void;
pub extern fn BN_rand_ex(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int, strength: c_uint, ctx: ?*BN_CTX) c_int;
pub extern fn BN_rand(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int) c_int;
pub extern fn BN_priv_rand_ex(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int, strength: c_uint, ctx: ?*BN_CTX) c_int;
pub extern fn BN_priv_rand(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int) c_int;
pub extern fn BN_rand_range_ex(r: ?*BIGNUM, range: ?*const BIGNUM, strength: c_uint, ctx: ?*BN_CTX) c_int;
pub extern fn BN_rand_range(rnd: ?*BIGNUM, range: ?*const BIGNUM) c_int;
pub extern fn BN_priv_rand_range_ex(r: ?*BIGNUM, range: ?*const BIGNUM, strength: c_uint, ctx: ?*BN_CTX) c_int;
pub extern fn BN_priv_rand_range(rnd: ?*BIGNUM, range: ?*const BIGNUM) c_int;
pub extern fn BN_pseudo_rand(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int) c_int;
pub extern fn BN_pseudo_rand_range(rnd: ?*BIGNUM, range: ?*const BIGNUM) c_int;
pub extern fn BN_num_bits(a: ?*const BIGNUM) c_int;
pub extern fn BN_num_bits_word(l: c_ulong) c_int;
pub extern fn BN_security_bits(L: c_int, N: c_int) c_int;
pub extern fn BN_new() ?*BIGNUM;
pub extern fn BN_secure_new() ?*BIGNUM;
pub extern fn BN_clear_free(a: ?*BIGNUM) void;
pub extern fn BN_copy(a: ?*BIGNUM, b: ?*const BIGNUM) ?*BIGNUM;
pub extern fn BN_swap(a: ?*BIGNUM, b: ?*BIGNUM) void;
pub extern fn BN_bin2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_signed_bin2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bn2bin(a: ?*const BIGNUM, to: [*c]u8) c_int;
pub extern fn BN_bn2binpad(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_signed_bn2bin(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_lebin2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_signed_lebin2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bn2lebinpad(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_signed_bn2lebin(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_native2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_signed_native2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bn2nativepad(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_signed_bn2native(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_mpi2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bn2mpi(a: ?*const BIGNUM, to: [*c]u8) c_int;
pub extern fn BN_sub(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_usub(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_uadd(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_add(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_mul(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_sqr(r: ?*BIGNUM, a: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_set_negative(b: ?*BIGNUM, n: c_int) void;
pub extern fn BN_is_negative(b: ?*const BIGNUM) c_int;
pub extern fn BN_div(dv: ?*BIGNUM, rem: ?*BIGNUM, m: ?*const BIGNUM, d: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nnmod(r: ?*BIGNUM, m: ?*const BIGNUM, d: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_add(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_add_quick(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM) c_int;
pub extern fn BN_mod_sub(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_sub_quick(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM) c_int;
pub extern fn BN_mod_mul(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_sqr(r: ?*BIGNUM, a: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_lshift1(r: ?*BIGNUM, a: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_lshift1_quick(r: ?*BIGNUM, a: ?*const BIGNUM, m: ?*const BIGNUM) c_int;
pub extern fn BN_mod_lshift(r: ?*BIGNUM, a: ?*const BIGNUM, n: c_int, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_lshift_quick(r: ?*BIGNUM, a: ?*const BIGNUM, n: c_int, m: ?*const BIGNUM) c_int;
pub extern fn BN_mod_word(a: ?*const BIGNUM, w: c_ulong) c_ulong;
pub extern fn BN_div_word(a: ?*BIGNUM, w: c_ulong) c_ulong;
pub extern fn BN_mul_word(a: ?*BIGNUM, w: c_ulong) c_int;
pub extern fn BN_add_word(a: ?*BIGNUM, w: c_ulong) c_int;
pub extern fn BN_sub_word(a: ?*BIGNUM, w: c_ulong) c_int;
pub extern fn BN_set_word(a: ?*BIGNUM, w: c_ulong) c_int;
pub extern fn BN_get_word(a: ?*const BIGNUM) c_ulong;
pub extern fn BN_cmp(a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_free(a: ?*BIGNUM) void;
pub extern fn BN_is_bit_set(a: ?*const BIGNUM, n: c_int) c_int;
pub extern fn BN_lshift(r: ?*BIGNUM, a: ?*const BIGNUM, n: c_int) c_int;
pub extern fn BN_lshift1(r: ?*BIGNUM, a: ?*const BIGNUM) c_int;
pub extern fn BN_exp(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_exp(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_exp_mont(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX, m_ctx: ?*BN_MONT_CTX) c_int;
pub extern fn BN_mod_exp_mont_consttime(rr: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX, in_mont: ?*BN_MONT_CTX) c_int;
pub extern fn BN_mod_exp_mont_word(r: ?*BIGNUM, a: c_ulong, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX, m_ctx: ?*BN_MONT_CTX) c_int;
pub extern fn BN_mod_exp2_mont(r: ?*BIGNUM, a1: ?*const BIGNUM, p1: ?*const BIGNUM, a2: ?*const BIGNUM, p2: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX, m_ctx: ?*BN_MONT_CTX) c_int;
pub extern fn BN_mod_exp_simple(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_exp_mont_consttime_x2(rr1: ?*BIGNUM, a1: ?*const BIGNUM, p1: ?*const BIGNUM, m1: ?*const BIGNUM, in_mont1: ?*BN_MONT_CTX, rr2: ?*BIGNUM, a2: ?*const BIGNUM, p2: ?*const BIGNUM, m2: ?*const BIGNUM, in_mont2: ?*BN_MONT_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mask_bits(a: ?*BIGNUM, n: c_int) c_int;
pub extern fn BN_print_fp(fp: [*c]FILE, a: ?*const BIGNUM) c_int;
pub extern fn BN_print(bio: ?*BIO, a: ?*const BIGNUM) c_int;
pub extern fn BN_reciprocal(r: ?*BIGNUM, m: ?*const BIGNUM, len: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_rshift(r: ?*BIGNUM, a: ?*const BIGNUM, n: c_int) c_int;
pub extern fn BN_rshift1(r: ?*BIGNUM, a: ?*const BIGNUM) c_int;
pub extern fn BN_clear(a: ?*BIGNUM) void;
pub extern fn BN_dup(a: ?*const BIGNUM) ?*BIGNUM;
pub extern fn BN_ucmp(a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_set_bit(a: ?*BIGNUM, n: c_int) c_int;
pub extern fn BN_clear_bit(a: ?*BIGNUM, n: c_int) c_int;
pub extern fn BN_bn2hex(a: ?*const BIGNUM) [*c]u8;
pub extern fn BN_bn2dec(a: ?*const BIGNUM) [*c]u8;
pub extern fn BN_hex2bn(a: [*c]?*BIGNUM, str: [*c]const u8) c_int;
pub extern fn BN_dec2bn(a: [*c]?*BIGNUM, str: [*c]const u8) c_int;
pub extern fn BN_asc2bn(a: [*c]?*BIGNUM, str: [*c]const u8) c_int;
pub extern fn BN_gcd(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_kronecker(a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_are_coprime(a: ?*BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_inverse(ret: ?*BIGNUM, a: ?*const BIGNUM, n: ?*const BIGNUM, ctx: ?*BN_CTX) ?*BIGNUM;
pub extern fn BN_mod_sqrt(ret: ?*BIGNUM, a: ?*const BIGNUM, n: ?*const BIGNUM, ctx: ?*BN_CTX) ?*BIGNUM;
pub extern fn BN_consttime_swap(swap: c_ulong, a: ?*BIGNUM, b: ?*BIGNUM, nwords: c_int) void;
pub extern fn BN_generate_prime(ret: ?*BIGNUM, bits: c_int, safe: c_int, add: ?*const BIGNUM, rem: ?*const BIGNUM, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.C) void, cb_arg: ?*anyopaque) ?*BIGNUM;
pub extern fn BN_is_prime(p: ?*const BIGNUM, nchecks: c_int, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.C) void, ctx: ?*BN_CTX, cb_arg: ?*anyopaque) c_int;
pub extern fn BN_is_prime_fasttest(p: ?*const BIGNUM, nchecks: c_int, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.C) void, ctx: ?*BN_CTX, cb_arg: ?*anyopaque, do_trial_division: c_int) c_int;
pub extern fn BN_is_prime_ex(p: ?*const BIGNUM, nchecks: c_int, ctx: ?*BN_CTX, cb: ?*BN_GENCB) c_int;
pub extern fn BN_is_prime_fasttest_ex(p: ?*const BIGNUM, nchecks: c_int, ctx: ?*BN_CTX, do_trial_division: c_int, cb: ?*BN_GENCB) c_int;
pub extern fn BN_generate_prime_ex2(ret: ?*BIGNUM, bits: c_int, safe: c_int, add: ?*const BIGNUM, rem: ?*const BIGNUM, cb: ?*BN_GENCB, ctx: ?*BN_CTX) c_int;
pub extern fn BN_generate_prime_ex(ret: ?*BIGNUM, bits: c_int, safe: c_int, add: ?*const BIGNUM, rem: ?*const BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn BN_check_prime(p: ?*const BIGNUM, ctx: ?*BN_CTX, cb: ?*BN_GENCB) c_int;
pub extern fn BN_X931_generate_Xpq(Xp: ?*BIGNUM, Xq: ?*BIGNUM, nbits: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_X931_derive_prime_ex(p: ?*BIGNUM, p1: ?*BIGNUM, p2: ?*BIGNUM, Xp: ?*const BIGNUM, Xp1: ?*const BIGNUM, Xp2: ?*const BIGNUM, e: ?*const BIGNUM, ctx: ?*BN_CTX, cb: ?*BN_GENCB) c_int;
pub extern fn BN_X931_generate_prime_ex(p: ?*BIGNUM, p1: ?*BIGNUM, p2: ?*BIGNUM, Xp1: ?*BIGNUM, Xp2: ?*BIGNUM, Xp: ?*const BIGNUM, e: ?*const BIGNUM, ctx: ?*BN_CTX, cb: ?*BN_GENCB) c_int;
pub extern fn BN_MONT_CTX_new() ?*BN_MONT_CTX;
pub extern fn BN_mod_mul_montgomery(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, mont: ?*BN_MONT_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_to_montgomery(r: ?*BIGNUM, a: ?*const BIGNUM, mont: ?*BN_MONT_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_from_montgomery(r: ?*BIGNUM, a: ?*const BIGNUM, mont: ?*BN_MONT_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_MONT_CTX_free(mont: ?*BN_MONT_CTX) void;
pub extern fn BN_MONT_CTX_set(mont: ?*BN_MONT_CTX, mod: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_MONT_CTX_copy(to: ?*BN_MONT_CTX, from: ?*BN_MONT_CTX) ?*BN_MONT_CTX;
pub extern fn BN_MONT_CTX_set_locked(pmont: [*c]?*BN_MONT_CTX, lock: ?*CRYPTO_RWLOCK, mod: ?*const BIGNUM, ctx: ?*BN_CTX) ?*BN_MONT_CTX;
pub extern fn BN_BLINDING_new(A: ?*const BIGNUM, Ai: ?*const BIGNUM, mod: ?*BIGNUM) ?*BN_BLINDING;
pub extern fn BN_BLINDING_free(b: ?*BN_BLINDING) void;
pub extern fn BN_BLINDING_update(b: ?*BN_BLINDING, ctx: ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_convert(n: ?*BIGNUM, b: ?*BN_BLINDING, ctx: ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_invert(n: ?*BIGNUM, b: ?*BN_BLINDING, ctx: ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_convert_ex(n: ?*BIGNUM, r: ?*BIGNUM, b: ?*BN_BLINDING, ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_invert_ex(n: ?*BIGNUM, r: ?*const BIGNUM, b: ?*BN_BLINDING, ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_is_current_thread(b: ?*BN_BLINDING) c_int;
pub extern fn BN_BLINDING_set_current_thread(b: ?*BN_BLINDING) void;
pub extern fn BN_BLINDING_lock(b: ?*BN_BLINDING) c_int;
pub extern fn BN_BLINDING_unlock(b: ?*BN_BLINDING) c_int;
pub extern fn BN_BLINDING_get_flags(?*const BN_BLINDING) c_ulong;
pub extern fn BN_BLINDING_set_flags(?*BN_BLINDING, c_ulong) void;
pub extern fn BN_BLINDING_create_param(b: ?*BN_BLINDING, e: ?*const BIGNUM, m: ?*BIGNUM, ctx: ?*BN_CTX, bn_mod_exp: ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.C) c_int, m_ctx: ?*BN_MONT_CTX) ?*BN_BLINDING;
pub extern fn BN_set_params(mul: c_int, high: c_int, low: c_int, mont: c_int) void;
pub extern fn BN_get_params(which: c_int) c_int;
pub extern fn BN_RECP_CTX_new() ?*BN_RECP_CTX;
pub extern fn BN_RECP_CTX_free(recp: ?*BN_RECP_CTX) void;
pub extern fn BN_RECP_CTX_set(recp: ?*BN_RECP_CTX, rdiv: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_mul_reciprocal(r: ?*BIGNUM, x: ?*const BIGNUM, y: ?*const BIGNUM, recp: ?*BN_RECP_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_exp_recp(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_div_recp(dv: ?*BIGNUM, rem: ?*BIGNUM, m: ?*const BIGNUM, recp: ?*BN_RECP_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_add(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_GF2m_mod(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM) c_int;
pub extern fn BN_GF2m_mod_mul(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_sqr(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_inv(r: ?*BIGNUM, b: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_div(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_exp(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_sqrt(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_solve_quad(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_arr(r: ?*BIGNUM, a: ?*const BIGNUM, p: [*c]const c_int) c_int;
pub extern fn BN_GF2m_mod_mul_arr(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_sqr_arr(r: ?*BIGNUM, a: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_inv_arr(r: ?*BIGNUM, b: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_div_arr(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_exp_arr(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_sqrt_arr(r: ?*BIGNUM, a: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_solve_quad_arr(r: ?*BIGNUM, a: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_poly2arr(a: ?*const BIGNUM, p: [*c]c_int, max: c_int) c_int;
pub extern fn BN_GF2m_arr2poly(p: [*c]const c_int, a: ?*BIGNUM) c_int;
pub extern fn BN_nist_mod_192(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nist_mod_224(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nist_mod_256(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nist_mod_384(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nist_mod_521(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_get0_nist_prime_192() ?*const BIGNUM;
pub extern fn BN_get0_nist_prime_224() ?*const BIGNUM;
pub extern fn BN_get0_nist_prime_256() ?*const BIGNUM;
pub extern fn BN_get0_nist_prime_384() ?*const BIGNUM;
pub extern fn BN_get0_nist_prime_521() ?*const BIGNUM;
pub extern fn BN_nist_mod_func(p: ?*const BIGNUM) ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX) callconv(.C) c_int;
pub extern fn BN_generate_dsa_nonce(out: ?*BIGNUM, range: ?*const BIGNUM, priv: ?*const BIGNUM, message: [*c]const u8, message_len: usize, ctx: ?*BN_CTX) c_int;
pub extern fn BN_get_rfc2409_prime_768(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc2409_prime_1024(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_1536(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_2048(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_3072(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_4096(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_6144(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_8192(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bntest_rand(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int) c_int;
pub extern fn OSSL_PARAM_locate(p: [*c]OSSL_PARAM, key: [*c]const u8) [*c]OSSL_PARAM;
pub extern fn OSSL_PARAM_locate_const(p: [*c]const OSSL_PARAM, key: [*c]const u8) [*c]const OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_int(key: [*c]const u8, buf: [*c]c_int) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_uint(key: [*c]const u8, buf: [*c]c_uint) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_long(key: [*c]const u8, buf: [*c]c_long) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_ulong(key: [*c]const u8, buf: [*c]c_ulong) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_int32(key: [*c]const u8, buf: [*c]i32) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_uint32(key: [*c]const u8, buf: [*c]u32) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_int64(key: [*c]const u8, buf: [*c]i64) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_uint64(key: [*c]const u8, buf: [*c]u64) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_size_t(key: [*c]const u8, buf: [*c]usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_time_t(key: [*c]const u8, buf: [*c]time_t) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_BN(key: [*c]const u8, buf: [*c]u8, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_double(key: [*c]const u8, buf: [*c]f64) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_utf8_string(key: [*c]const u8, buf: [*c]u8, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_utf8_ptr(key: [*c]const u8, buf: [*c][*c]u8, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_octet_string(key: [*c]const u8, buf: ?*anyopaque, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_octet_ptr(key: [*c]const u8, buf: [*c]?*anyopaque, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_end() OSSL_PARAM;
pub extern fn OSSL_PARAM_allocate_from_text(to: [*c]OSSL_PARAM, paramdefs: [*c]const OSSL_PARAM, key: [*c]const u8, value: [*c]const u8, value_n: usize, found: [*c]c_int) c_int;
pub extern fn OSSL_PARAM_get_int(p: [*c]const OSSL_PARAM, val: [*c]c_int) c_int;
pub extern fn OSSL_PARAM_get_uint(p: [*c]const OSSL_PARAM, val: [*c]c_uint) c_int;
pub extern fn OSSL_PARAM_get_long(p: [*c]const OSSL_PARAM, val: [*c]c_long) c_int;
pub extern fn OSSL_PARAM_get_ulong(p: [*c]const OSSL_PARAM, val: [*c]c_ulong) c_int;
pub extern fn OSSL_PARAM_get_int32(p: [*c]const OSSL_PARAM, val: [*c]i32) c_int;
pub extern fn OSSL_PARAM_get_uint32(p: [*c]const OSSL_PARAM, val: [*c]u32) c_int;
pub extern fn OSSL_PARAM_get_int64(p: [*c]const OSSL_PARAM, val: [*c]i64) c_int;
pub extern fn OSSL_PARAM_get_uint64(p: [*c]const OSSL_PARAM, val: [*c]u64) c_int;
pub extern fn OSSL_PARAM_get_size_t(p: [*c]const OSSL_PARAM, val: [*c]usize) c_int;
pub extern fn OSSL_PARAM_get_time_t(p: [*c]const OSSL_PARAM, val: [*c]time_t) c_int;
pub extern fn OSSL_PARAM_set_int(p: [*c]OSSL_PARAM, val: c_int) c_int;
pub extern fn OSSL_PARAM_set_uint(p: [*c]OSSL_PARAM, val: c_uint) c_int;
pub extern fn OSSL_PARAM_set_long(p: [*c]OSSL_PARAM, val: c_long) c_int;
pub extern fn OSSL_PARAM_set_ulong(p: [*c]OSSL_PARAM, val: c_ulong) c_int;
pub extern fn OSSL_PARAM_set_int32(p: [*c]OSSL_PARAM, val: i32) c_int;
pub extern fn OSSL_PARAM_set_uint32(p: [*c]OSSL_PARAM, val: u32) c_int;
pub extern fn OSSL_PARAM_set_int64(p: [*c]OSSL_PARAM, val: i64) c_int;
pub extern fn OSSL_PARAM_set_uint64(p: [*c]OSSL_PARAM, val: u64) c_int;
pub extern fn OSSL_PARAM_set_size_t(p: [*c]OSSL_PARAM, val: usize) c_int;
pub extern fn OSSL_PARAM_set_time_t(p: [*c]OSSL_PARAM, val: time_t) c_int;
pub extern fn OSSL_PARAM_get_double(p: [*c]const OSSL_PARAM, val: [*c]f64) c_int;
pub extern fn OSSL_PARAM_set_double(p: [*c]OSSL_PARAM, val: f64) c_int;
pub extern fn OSSL_PARAM_get_BN(p: [*c]const OSSL_PARAM, val: [*c]?*BIGNUM) c_int;
pub extern fn OSSL_PARAM_set_BN(p: [*c]OSSL_PARAM, val: ?*const BIGNUM) c_int;
pub extern fn OSSL_PARAM_get_utf8_string(p: [*c]const OSSL_PARAM, val: [*c][*c]u8, max_len: usize) c_int;
pub extern fn OSSL_PARAM_set_utf8_string(p: [*c]OSSL_PARAM, val: [*c]const u8) c_int;
pub extern fn OSSL_PARAM_get_octet_string(p: [*c]const OSSL_PARAM, val: [*c]?*anyopaque, max_len: usize, used_len: [*c]usize) c_int;
pub extern fn OSSL_PARAM_set_octet_string(p: [*c]OSSL_PARAM, val: ?*const anyopaque, len: usize) c_int;
pub extern fn OSSL_PARAM_get_utf8_ptr(p: [*c]const OSSL_PARAM, val: [*c][*c]const u8) c_int;
pub extern fn OSSL_PARAM_set_utf8_ptr(p: [*c]OSSL_PARAM, val: [*c]const u8) c_int;
pub extern fn OSSL_PARAM_get_octet_ptr(p: [*c]const OSSL_PARAM, val: [*c]?*const anyopaque, used_len: [*c]usize) c_int;
pub extern fn OSSL_PARAM_set_octet_ptr(p: [*c]OSSL_PARAM, val: ?*const anyopaque, used_len: usize) c_int;
pub extern fn OSSL_PARAM_get_utf8_string_ptr(p: [*c]const OSSL_PARAM, val: [*c][*c]const u8) c_int;
pub extern fn OSSL_PARAM_get_octet_string_ptr(p: [*c]const OSSL_PARAM, val: [*c]?*const anyopaque, used_len: [*c]usize) c_int;
pub extern fn OSSL_PARAM_modified(p: [*c]const OSSL_PARAM) c_int;
pub extern fn OSSL_PARAM_set_all_unmodified(p: [*c]OSSL_PARAM) void;
pub extern fn OSSL_PARAM_dup(p: [*c]const OSSL_PARAM) [*c]OSSL_PARAM;
pub extern fn OSSL_PARAM_merge(p1: [*c]const OSSL_PARAM, p2: [*c]const OSSL_PARAM) [*c]OSSL_PARAM;
pub extern fn OSSL_PARAM_free(p: [*c]OSSL_PARAM) void;
pub const OSSL_INDICATOR_CALLBACK = fn ([*c]const u8, [*c]const u8, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub extern fn OSSL_INDICATOR_set_callback(libctx: ?*OSSL_LIB_CTX, cb: ?*const OSSL_INDICATOR_CALLBACK) void;
pub extern fn OSSL_INDICATOR_get_callback(libctx: ?*OSSL_LIB_CTX, cb: [*c]?*const OSSL_INDICATOR_CALLBACK) void;
pub const OSSL_FUNC_core_gettable_params_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_core_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_get_params_fn = fn (?*const OSSL_CORE_HANDLE, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_core_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_thread_start_fn = fn (?*const OSSL_CORE_HANDLE, OSSL_thread_stop_handler_fn, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_core_thread_start(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_thread_start_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_thread_start_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_get_libctx_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) ?*OPENSSL_CORE_CTX;
pub fn OSSL_FUNC_core_get_libctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_get_libctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_get_libctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_new_error_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) void;
pub fn OSSL_FUNC_core_new_error(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_new_error_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_new_error_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_set_error_debug_fn = fn (?*const OSSL_CORE_HANDLE, [*c]const u8, c_int, [*c]const u8) callconv(.C) void;
pub fn OSSL_FUNC_core_set_error_debug(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_set_error_debug_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_set_error_debug_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_vset_error_fn = fn (?*const OSSL_CORE_HANDLE, u32, [*c]const u8, va_list) callconv(.C) void;
pub fn OSSL_FUNC_core_vset_error(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_vset_error_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_vset_error_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_set_error_mark_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) c_int;
pub fn OSSL_FUNC_core_set_error_mark(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_set_error_mark_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_set_error_mark_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_clear_last_error_mark_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) c_int;
pub fn OSSL_FUNC_core_clear_last_error_mark(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_clear_last_error_mark_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_clear_last_error_mark_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_pop_error_to_mark_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) c_int;
pub fn OSSL_FUNC_core_pop_error_to_mark(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_pop_error_to_mark_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_pop_error_to_mark_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_obj_add_sigid_fn = fn (?*const OSSL_CORE_HANDLE, [*c]const u8, [*c]const u8, [*c]const u8) callconv(.C) c_int;
pub fn OSSL_FUNC_core_obj_add_sigid(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_obj_add_sigid_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_obj_add_sigid_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_obj_create_fn = fn (?*const OSSL_CORE_HANDLE, [*c]const u8, [*c]const u8, [*c]const u8) callconv(.C) c_int;
pub fn OSSL_FUNC_core_obj_create(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_core_obj_create_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_obj_create_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_malloc_fn = fn (usize, [*c]const u8, c_int) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_malloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_malloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_malloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_zalloc_fn = fn (usize, [*c]const u8, c_int) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_zalloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_zalloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_zalloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_free_fn = fn (?*anyopaque, [*c]const u8, c_int) callconv(.C) void;
pub fn OSSL_FUNC_CRYPTO_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_clear_free_fn = fn (?*anyopaque, usize, [*c]const u8, c_int) callconv(.C) void;
pub fn OSSL_FUNC_CRYPTO_clear_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_clear_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_clear_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_realloc_fn = fn (?*anyopaque, usize, [*c]const u8, c_int) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_realloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_realloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_realloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_clear_realloc_fn = fn (?*anyopaque, usize, usize, [*c]const u8, c_int) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_clear_realloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_clear_realloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_clear_realloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_malloc_fn = fn (usize, [*c]const u8, c_int) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_secure_malloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_secure_malloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_malloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_zalloc_fn = fn (usize, [*c]const u8, c_int) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_secure_zalloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_secure_zalloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_zalloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_free_fn = fn (?*anyopaque, [*c]const u8, c_int) callconv(.C) void;
pub fn OSSL_FUNC_CRYPTO_secure_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_secure_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_clear_free_fn = fn (?*anyopaque, usize, [*c]const u8, c_int) callconv(.C) void;
pub fn OSSL_FUNC_CRYPTO_secure_clear_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_secure_clear_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_clear_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_allocated_fn = fn (?*const anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_CRYPTO_secure_allocated(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_CRYPTO_secure_allocated_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_allocated_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_OPENSSL_cleanse_fn = fn (?*anyopaque, usize) callconv(.C) void;
pub fn OSSL_FUNC_OPENSSL_cleanse(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_OPENSSL_cleanse_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_OPENSSL_cleanse_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_new_file_fn = fn ([*c]const u8, [*c]const u8) callconv(.C) ?*OSSL_CORE_BIO;
pub fn OSSL_FUNC_BIO_new_file(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_new_file_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_new_file_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_new_membuf_fn = fn (?*const anyopaque, c_int) callconv(.C) ?*OSSL_CORE_BIO;
pub fn OSSL_FUNC_BIO_new_membuf(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_new_membuf_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_new_membuf_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_read_ex_fn = fn (?*OSSL_CORE_BIO, ?*anyopaque, usize, [*c]usize) callconv(.C) c_int;
pub fn OSSL_FUNC_BIO_read_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_read_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_read_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_write_ex_fn = fn (?*OSSL_CORE_BIO, ?*const anyopaque, usize, [*c]usize) callconv(.C) c_int;
pub fn OSSL_FUNC_BIO_write_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_write_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_write_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_gets_fn = fn (?*OSSL_CORE_BIO, [*c]u8, c_int) callconv(.C) c_int;
pub fn OSSL_FUNC_BIO_gets(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_gets_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_gets_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_puts_fn = fn (?*OSSL_CORE_BIO, [*c]const u8) callconv(.C) c_int;
pub fn OSSL_FUNC_BIO_puts(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_puts_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_puts_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_up_ref_fn = fn (?*OSSL_CORE_BIO) callconv(.C) c_int;
pub fn OSSL_FUNC_BIO_up_ref(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_up_ref_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_up_ref_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_free_fn = fn (?*OSSL_CORE_BIO) callconv(.C) c_int;
pub fn OSSL_FUNC_BIO_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_vprintf_fn = fn (?*OSSL_CORE_BIO, [*c]const u8, va_list) callconv(.C) c_int;
pub fn OSSL_FUNC_BIO_vprintf(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_vprintf_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_vprintf_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_vsnprintf_fn = fn ([*c]u8, usize, [*c]const u8, va_list) callconv(.C) c_int;
pub fn OSSL_FUNC_BIO_vsnprintf(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_vsnprintf_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_vsnprintf_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_ctrl_fn = fn (?*OSSL_CORE_BIO, c_int, c_long, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_BIO_ctrl(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_BIO_ctrl_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_ctrl_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_indicator_cb_fn = fn (?*OPENSSL_CORE_CTX, [*c]?*const OSSL_INDICATOR_CALLBACK) callconv(.C) void;
pub fn OSSL_FUNC_indicator_cb(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_indicator_cb_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_indicator_cb_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_self_test_cb_fn = fn (?*OPENSSL_CORE_CTX, [*c]?*const OSSL_CALLBACK, [*c]?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_self_test_cb(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_self_test_cb_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_self_test_cb_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_get_entropy_fn = fn (?*const OSSL_CORE_HANDLE, [*c][*c]u8, c_int, usize, usize) callconv(.C) usize;
pub fn OSSL_FUNC_get_entropy(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_get_entropy_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_get_entropy_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_get_user_entropy_fn = fn (?*const OSSL_CORE_HANDLE, [*c][*c]u8, c_int, usize, usize) callconv(.C) usize;
pub fn OSSL_FUNC_get_user_entropy(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_get_user_entropy_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_get_user_entropy_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cleanup_entropy_fn = fn (?*const OSSL_CORE_HANDLE, [*c]u8, usize) callconv(.C) void;
pub fn OSSL_FUNC_cleanup_entropy(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cleanup_entropy_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cleanup_entropy_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cleanup_user_entropy_fn = fn (?*const OSSL_CORE_HANDLE, [*c]u8, usize) callconv(.C) void;
pub fn OSSL_FUNC_cleanup_user_entropy(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cleanup_user_entropy_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cleanup_user_entropy_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_get_nonce_fn = fn (?*const OSSL_CORE_HANDLE, [*c][*c]u8, usize, usize, ?*const anyopaque, usize) callconv(.C) usize;
pub fn OSSL_FUNC_get_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_get_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_get_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_get_user_nonce_fn = fn (?*const OSSL_CORE_HANDLE, [*c][*c]u8, usize, usize, ?*const anyopaque, usize) callconv(.C) usize;
pub fn OSSL_FUNC_get_user_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_get_user_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_get_user_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cleanup_nonce_fn = fn (?*const OSSL_CORE_HANDLE, [*c]u8, usize) callconv(.C) void;
pub fn OSSL_FUNC_cleanup_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cleanup_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cleanup_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cleanup_user_nonce_fn = fn (?*const OSSL_CORE_HANDLE, [*c]u8, usize) callconv(.C) void;
pub fn OSSL_FUNC_cleanup_user_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cleanup_user_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cleanup_user_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_register_child_cb_fn = fn (?*const OSSL_CORE_HANDLE, ?*const fn (?*const OSSL_CORE_HANDLE, ?*anyopaque) callconv(.C) c_int, ?*const fn (?*const OSSL_CORE_HANDLE, ?*anyopaque) callconv(.C) c_int, ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) c_int, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_provider_register_child_cb(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_register_child_cb_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_register_child_cb_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_deregister_child_cb_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) void;
pub fn OSSL_FUNC_provider_deregister_child_cb(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_deregister_child_cb_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_deregister_child_cb_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_name_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) [*c]const u8;
pub fn OSSL_FUNC_provider_name(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_name_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_name_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get0_provider_ctx_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_provider_get0_provider_ctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_get0_provider_ctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get0_provider_ctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get0_dispatch_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.C) [*c]const OSSL_DISPATCH;
pub fn OSSL_FUNC_provider_get0_dispatch(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_get0_dispatch_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get0_dispatch_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_up_ref_fn = fn (?*const OSSL_CORE_HANDLE, c_int) callconv(.C) c_int;
pub fn OSSL_FUNC_provider_up_ref(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_up_ref_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_up_ref_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_free_fn = fn (?*const OSSL_CORE_HANDLE, c_int) callconv(.C) c_int;
pub fn OSSL_FUNC_provider_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_teardown_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_provider_teardown(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_teardown_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_teardown_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_gettable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_provider_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_provider_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_query_operation_fn = fn (?*anyopaque, c_int, [*c]c_int) callconv(.C) [*c]const OSSL_ALGORITHM;
pub fn OSSL_FUNC_provider_query_operation(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_query_operation_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_query_operation_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_unquery_operation_fn = fn (?*anyopaque, c_int, [*c]const OSSL_ALGORITHM) callconv(.C) void;
pub fn OSSL_FUNC_provider_unquery_operation(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_unquery_operation_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_unquery_operation_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get_reason_strings_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_ITEM;
pub fn OSSL_FUNC_provider_get_reason_strings(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_get_reason_strings_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get_reason_strings_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get_capabilities_fn = fn (?*anyopaque, [*c]const u8, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_provider_get_capabilities(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_get_capabilities_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get_capabilities_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_self_test_fn = fn (?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_provider_self_test(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_provider_self_test_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_self_test_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_newctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_digest_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_init_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_digest_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_digest_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_digest_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_squeeze_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_digest_squeeze(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_squeeze_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_squeeze_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_digest_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]u8, [*c]usize, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_digest_digest(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_digest_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_digest_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_digest_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_dupctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_digest_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_digest_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_digest_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_digest_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_gettable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_digest_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_digest_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_digest_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_digest_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_newctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_cipher_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_encrypt_init_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const u8, usize, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_cipher_encrypt_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_encrypt_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_encrypt_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_decrypt_init_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const u8, usize, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_cipher_decrypt_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_decrypt_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_decrypt_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_update_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_cipher_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_cipher_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_cipher_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_cipher_cipher(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_cipher_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_cipher_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_cipher_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_dupctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_cipher_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_cipher_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_cipher_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_cipher_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_gettable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_cipher_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_cipher_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_cipher_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_cipher_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_newctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_mac_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_dupctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_mac_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_mac_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_init_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_mac_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_mac_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_mac_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_gettable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_mac_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_mac_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_mac_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_mac_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_mac_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_mac_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_mac_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_newctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_kdf_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_dupctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_kdf_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_kdf_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_reset_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_kdf_reset(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_reset_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_reset_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_derive_fn = fn (?*anyopaque, [*c]u8, usize, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kdf_derive(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_derive_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_derive_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_gettable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kdf_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kdf_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kdf_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kdf_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kdf_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kdf_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kdf_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_newctx_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_DISPATCH) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_rand_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_rand_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_instantiate_fn = fn (?*anyopaque, c_uint, c_int, [*c]const u8, usize, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_instantiate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_instantiate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_instantiate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_uninstantiate_fn = fn (?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_uninstantiate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_uninstantiate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_uninstantiate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_generate_fn = fn (?*anyopaque, [*c]u8, usize, c_uint, c_int, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_generate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_generate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_generate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_reseed_fn = fn (?*anyopaque, c_int, [*c]const u8, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_reseed(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_reseed_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_reseed_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_nonce_fn = fn (?*anyopaque, [*c]u8, c_uint, usize, usize) callconv(.C) usize;
pub fn OSSL_FUNC_rand_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_enable_locking_fn = fn (?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_enable_locking(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_enable_locking_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_enable_locking_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_lock_fn = fn (?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_lock(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_lock_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_lock_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_unlock_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_rand_unlock(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_unlock_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_unlock_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_gettable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_rand_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_rand_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_rand_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_set_callbacks_fn = fn (?*anyopaque, ?*const OSSL_INOUT_CALLBACK, ?*const OSSL_CALLBACK, ?*const OSSL_INOUT_CALLBACK, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_rand_set_callbacks(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_set_callbacks_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_set_callbacks_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_verify_zeroization_fn = fn (?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_rand_verify_zeroization(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_verify_zeroization_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_verify_zeroization_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_get_seed_fn = fn (?*anyopaque, [*c][*c]u8, c_int, usize, usize, c_int, [*c]const u8, usize) callconv(.C) usize;
pub fn OSSL_FUNC_rand_get_seed(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_get_seed_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_get_seed_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_clear_seed_fn = fn (?*anyopaque, [*c]u8, usize) callconv(.C) void;
pub fn OSSL_FUNC_rand_clear_seed(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_rand_clear_seed_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_clear_seed_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_new_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_new(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_new_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_new_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_init_fn = fn (?*anyopaque, c_int, [*c]const OSSL_PARAM) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_gen_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_gen_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_set_template_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_gen_set_template(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_gen_set_template_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_set_template_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_set_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_gen_set_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_gen_set_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_set_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_settable_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_gen_settable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_gen_settable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_settable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_get_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_gen_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_gen_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_gettable_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_gen_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_gen_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_fn = fn (?*anyopaque, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_gen(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_gen_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_cleanup_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_keymgmt_gen_cleanup(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_gen_cleanup_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_cleanup_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_load_fn = fn (?*const anyopaque, usize) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_load(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_load_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_load_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_free_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_keymgmt_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_get_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gettable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_set_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_set_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_set_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_set_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_settable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_settable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_settable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_settable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_query_operation_name_fn = fn (c_int) callconv(.C) [*c]const u8;
pub fn OSSL_FUNC_keymgmt_query_operation_name(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_query_operation_name_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_query_operation_name_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_has_fn = fn (?*const anyopaque, c_int) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_has(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_has_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_has_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_validate_fn = fn (?*const anyopaque, c_int, c_int) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_validate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_validate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_validate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_match_fn = fn (?*const anyopaque, ?*const anyopaque, c_int) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_match(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_match_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_match_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_import_fn = fn (?*anyopaque, c_int, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_import(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_import_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_import_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_import_types_fn = fn (c_int) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_import_types(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_import_types_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_import_types_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_export_fn = fn (?*anyopaque, c_int, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_keymgmt_export(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_export_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_export_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_export_types_fn = fn (c_int) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_export_types(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_export_types_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_export_types_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_dup_fn = fn (?*const anyopaque, c_int) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_dup(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_dup_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_dup_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_import_types_ex_fn = fn (?*anyopaque, c_int) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_import_types_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_import_types_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_import_types_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_export_types_ex_fn = fn (?*anyopaque, c_int) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_export_types_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keymgmt_export_types_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_export_types_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_newctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_keyexch_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_keyexch_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_derive_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_keyexch_derive(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_derive_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_derive_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_set_peer_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_keyexch_set_peer(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_set_peer_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_set_peer_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_keyexch_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_dupctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_keyexch_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_keyexch_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keyexch_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_keyexch_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keyexch_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_keyexch_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_newctx_fn = fn (?*anyopaque, [*c]const u8) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_signature_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_sign_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_sign_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_sign(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_sign_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_message_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_sign_message_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_sign_message_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_message_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_message_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_sign_message_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_sign_message_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_message_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_message_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_sign_message_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_sign_message_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_message_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_verify_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_verify_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_verify(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_verify_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_message_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_verify_message_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_verify_message_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_message_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_message_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_verify_message_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_verify_message_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_message_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_message_final_fn = fn (?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_verify_message_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_verify_message_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_message_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_recover_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_verify_recover_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_verify_recover_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_recover_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_recover_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_verify_recover(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_verify_recover_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_recover_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_sign_init_fn = fn (?*anyopaque, [*c]const u8, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_digest_sign_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_digest_sign_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_sign_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_sign_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_digest_sign_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_digest_sign_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_sign_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_sign_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_digest_sign_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_digest_sign_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_sign_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_sign_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_digest_sign(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_digest_sign_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_sign_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_verify_init_fn = fn (?*anyopaque, [*c]const u8, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_digest_verify_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_digest_verify_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_verify_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_verify_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_digest_verify_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_digest_verify_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_verify_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_verify_final_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_digest_verify_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_digest_verify_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_verify_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_verify_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_digest_verify(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_digest_verify_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_verify_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_signature_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_dupctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_signature_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_signature_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_signature_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_get_ctx_md_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_get_ctx_md_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_get_ctx_md_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_get_ctx_md_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_gettable_ctx_md_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_signature_gettable_ctx_md_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_gettable_ctx_md_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_gettable_ctx_md_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_set_ctx_md_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_signature_set_ctx_md_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_set_ctx_md_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_set_ctx_md_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_settable_ctx_md_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_signature_settable_ctx_md_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_settable_ctx_md_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_settable_ctx_md_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_query_key_types_fn = fn () callconv(.C) [*c][*c]const u8;
pub fn OSSL_FUNC_signature_query_key_types(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_signature_query_key_types_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_query_key_types_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_newctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_asym_cipher_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_encrypt_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_asym_cipher_encrypt_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_encrypt_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_encrypt_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_encrypt_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_asym_cipher_encrypt(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_encrypt_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_encrypt_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_decrypt_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_asym_cipher_decrypt_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_decrypt_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_decrypt_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_decrypt_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_asym_cipher_decrypt(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_decrypt_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_decrypt_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_asym_cipher_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_dupctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_asym_cipher_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_asym_cipher_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_asym_cipher_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_asym_cipher_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_asym_cipher_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_asym_cipher_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_newctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_kem_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_encapsulate_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kem_encapsulate_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_encapsulate_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_encapsulate_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_auth_encapsulate_init_fn = fn (?*anyopaque, ?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kem_auth_encapsulate_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_auth_encapsulate_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_auth_encapsulate_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_encapsulate_fn = fn (?*anyopaque, [*c]u8, [*c]usize, [*c]u8, [*c]usize) callconv(.C) c_int;
pub fn OSSL_FUNC_kem_encapsulate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_encapsulate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_encapsulate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_decapsulate_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kem_decapsulate_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_decapsulate_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_decapsulate_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_auth_decapsulate_init_fn = fn (?*anyopaque, ?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kem_auth_decapsulate_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_auth_decapsulate_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_auth_decapsulate_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_decapsulate_fn = fn (?*anyopaque, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int;
pub fn OSSL_FUNC_kem_decapsulate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_decapsulate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_decapsulate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_kem_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_dupctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_kem_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kem_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kem_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_kem_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kem_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_kem_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_newctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_encoder_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_encoder_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_encoder_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_gettable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_encoder_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_encoder_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_settable_ctx_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_encoder_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_does_selection_fn = fn (?*anyopaque, c_int) callconv(.C) c_int;
pub fn OSSL_FUNC_encoder_does_selection(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_does_selection_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_does_selection_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_encode_fn = fn (?*anyopaque, ?*OSSL_CORE_BIO, ?*const anyopaque, [*c]const OSSL_PARAM, c_int, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_encoder_encode(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_encode_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_encode_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_import_object_fn = fn (?*anyopaque, c_int, [*c]const OSSL_PARAM) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_encoder_import_object(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_import_object_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_import_object_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_free_object_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_encoder_free_object(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_encoder_free_object_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_free_object_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_newctx_fn = fn (?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_decoder_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_decoder_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_freectx_fn = fn (?*anyopaque) callconv(.C) void;
pub fn OSSL_FUNC_decoder_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_decoder_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_decoder_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_decoder_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_gettable_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_decoder_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_decoder_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_decoder_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_decoder_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_settable_ctx_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_decoder_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_decoder_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_does_selection_fn = fn (?*anyopaque, c_int) callconv(.C) c_int;
pub fn OSSL_FUNC_decoder_does_selection(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_decoder_does_selection_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_does_selection_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_decode_fn = fn (?*anyopaque, ?*OSSL_CORE_BIO, c_int, ?*const OSSL_CALLBACK, ?*anyopaque, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_decoder_decode(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_decoder_decode_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_decode_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_export_object_fn = fn (?*anyopaque, ?*const anyopaque, usize, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_decoder_export_object(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_decoder_export_object_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_export_object_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_open_fn = fn (?*anyopaque, [*c]const u8) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_store_open(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_open_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_open_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_attach_fn = fn (?*anyopaque, ?*OSSL_CORE_BIO) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_store_attach(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_attach_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_attach_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_settable_ctx_params_fn = fn (?*anyopaque) callconv(.C) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_store_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.C) c_int;
pub fn OSSL_FUNC_store_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_load_fn = fn (?*anyopaque, ?*const OSSL_CALLBACK, ?*anyopaque, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_store_load(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_load_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_load_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_eof_fn = fn (?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_store_eof(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_eof_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_eof_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_close_fn = fn (?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_store_close(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_close_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_close_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_export_object_fn = fn (?*anyopaque, ?*const anyopaque, usize, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_store_export_object(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_export_object_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_export_object_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_delete_fn = fn (?*anyopaque, [*c]const u8, [*c]const OSSL_PARAM, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.C) c_int;
pub fn OSSL_FUNC_store_delete(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_delete_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_delete_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_open_ex_fn = fn (?*anyopaque, [*c]const u8, [*c]const OSSL_PARAM, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.C) ?*anyopaque;
pub fn OSSL_FUNC_store_open_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.C) ?*const OSSL_FUNC_store_open_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_open_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const struct_stack_st_X509_ALGOR = opaque {};
pub const sk_X509_ALGOR_compfunc = ?*const fn ([*c]const [*c]const X509_ALGOR, [*c]const [*c]const X509_ALGOR) callconv(.C) c_int;
pub const sk_X509_ALGOR_freefunc = ?*const fn ([*c]X509_ALGOR) callconv(.C) void;
pub const sk_X509_ALGOR_copyfunc = ?*const fn ([*c]const X509_ALGOR) callconv(.C) [*c]X509_ALGOR;
pub fn ossl_check_X509_ALGOR_type(arg_ptr: [*c]X509_ALGOR) callconv(.C) [*c]X509_ALGOR {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_ALGOR_sk_type(arg_sk: ?*const struct_stack_st_X509_ALGOR) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_ALGOR_sk_type(arg_sk: ?*struct_stack_st_X509_ALGOR) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_ALGOR_compfunc_type(arg_cmp: sk_X509_ALGOR_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_ALGOR_copyfunc_type(arg_cpy: sk_X509_ALGOR_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_ALGOR_freefunc_type(arg_fr: sk_X509_ALGOR_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ASN1_ENCODING_st = extern struct {
    enc: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    len: c_long = @import("std").mem.zeroes(c_long),
    modified: c_int = @import("std").mem.zeroes(c_int),
};
pub const ASN1_ENCODING = struct_ASN1_ENCODING_st;
pub const struct_stack_st_ASN1_STRING_TABLE = opaque {};
pub const sk_ASN1_STRING_TABLE_compfunc = ?*const fn ([*c]const [*c]const ASN1_STRING_TABLE, [*c]const [*c]const ASN1_STRING_TABLE) callconv(.C) c_int;
pub const sk_ASN1_STRING_TABLE_freefunc = ?*const fn ([*c]ASN1_STRING_TABLE) callconv(.C) void;
pub const sk_ASN1_STRING_TABLE_copyfunc = ?*const fn ([*c]const ASN1_STRING_TABLE) callconv(.C) [*c]ASN1_STRING_TABLE;
pub fn ossl_check_ASN1_STRING_TABLE_type(arg_ptr: [*c]ASN1_STRING_TABLE) callconv(.C) [*c]ASN1_STRING_TABLE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_STRING_TABLE_sk_type(arg_sk: ?*const struct_stack_st_ASN1_STRING_TABLE) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_STRING_TABLE_sk_type(arg_sk: ?*struct_stack_st_ASN1_STRING_TABLE) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_STRING_TABLE_compfunc_type(arg_cmp: sk_ASN1_STRING_TABLE_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_STRING_TABLE_copyfunc_type(arg_cpy: sk_ASN1_STRING_TABLE_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_STRING_TABLE_freefunc_type(arg_fr: sk_ASN1_STRING_TABLE_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ASN1_TEMPLATE_st = opaque {};
pub const ASN1_TEMPLATE = struct_ASN1_TEMPLATE_st;
pub const struct_ASN1_TLC_st = opaque {};
pub const ASN1_TLC = struct_ASN1_TLC_st;
pub const d2i_of_void = fn ([*c]?*anyopaque, [*c][*c]const u8, c_long) callconv(.C) ?*anyopaque;
pub const i2d_of_void = fn (?*const anyopaque, [*c][*c]u8) callconv(.C) c_int;
pub const ASN1_ITEM_EXP = fn () callconv(.C) ?*const ASN1_ITEM;
pub const struct_stack_st_ASN1_TYPE = opaque {};
pub const sk_ASN1_TYPE_compfunc = ?*const fn ([*c]const [*c]const ASN1_TYPE, [*c]const [*c]const ASN1_TYPE) callconv(.C) c_int;
pub const sk_ASN1_TYPE_freefunc = ?*const fn ([*c]ASN1_TYPE) callconv(.C) void;
pub const sk_ASN1_TYPE_copyfunc = ?*const fn ([*c]const ASN1_TYPE) callconv(.C) [*c]ASN1_TYPE;
pub fn ossl_check_ASN1_TYPE_type(arg_ptr: [*c]ASN1_TYPE) callconv(.C) [*c]ASN1_TYPE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_TYPE_sk_type(arg_sk: ?*const struct_stack_st_ASN1_TYPE) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_TYPE_sk_type(arg_sk: ?*struct_stack_st_ASN1_TYPE) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_TYPE_compfunc_type(arg_cmp: sk_ASN1_TYPE_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_TYPE_copyfunc_type(arg_cpy: sk_ASN1_TYPE_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_TYPE_freefunc_type(arg_fr: sk_ASN1_TYPE_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const ASN1_SEQUENCE_ANY = struct_stack_st_ASN1_TYPE;
pub extern fn d2i_ASN1_SEQUENCE_ANY(a: [*c]?*ASN1_SEQUENCE_ANY, in: [*c][*c]const u8, len: c_long) ?*ASN1_SEQUENCE_ANY;
pub extern fn i2d_ASN1_SEQUENCE_ANY(a: ?*const ASN1_SEQUENCE_ANY, out: [*c][*c]u8) c_int;
pub extern fn ASN1_SEQUENCE_ANY_it() ?*const ASN1_ITEM;
pub extern fn d2i_ASN1_SET_ANY(a: [*c]?*ASN1_SEQUENCE_ANY, in: [*c][*c]const u8, len: c_long) ?*ASN1_SEQUENCE_ANY;
pub extern fn i2d_ASN1_SET_ANY(a: ?*const ASN1_SEQUENCE_ANY, out: [*c][*c]u8) c_int;
pub extern fn ASN1_SET_ANY_it() ?*const ASN1_ITEM;
pub const struct_BIT_STRING_BITNAME_st = extern struct {
    bitnum: c_int = @import("std").mem.zeroes(c_int),
    lname: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    sname: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const BIT_STRING_BITNAME = struct_BIT_STRING_BITNAME_st;
pub extern fn ASN1_TYPE_new() [*c]ASN1_TYPE;
pub extern fn ASN1_TYPE_free(a: [*c]ASN1_TYPE) void;
pub extern fn d2i_ASN1_TYPE(a: [*c][*c]ASN1_TYPE, in: [*c][*c]const u8, len: c_long) [*c]ASN1_TYPE;
pub extern fn i2d_ASN1_TYPE(a: [*c]const ASN1_TYPE, out: [*c][*c]u8) c_int;
pub extern fn ASN1_ANY_it() ?*const ASN1_ITEM;
pub extern fn ASN1_TYPE_get(a: [*c]const ASN1_TYPE) c_int;
pub extern fn ASN1_TYPE_set(a: [*c]ASN1_TYPE, @"type": c_int, value: ?*anyopaque) void;
pub extern fn ASN1_TYPE_set1(a: [*c]ASN1_TYPE, @"type": c_int, value: ?*const anyopaque) c_int;
pub extern fn ASN1_TYPE_cmp(a: [*c]const ASN1_TYPE, b: [*c]const ASN1_TYPE) c_int;
pub extern fn ASN1_TYPE_pack_sequence(it: ?*const ASN1_ITEM, s: ?*anyopaque, t: [*c][*c]ASN1_TYPE) [*c]ASN1_TYPE;
pub extern fn ASN1_TYPE_unpack_sequence(it: ?*const ASN1_ITEM, t: [*c]const ASN1_TYPE) ?*anyopaque;
pub const struct_stack_st_ASN1_OBJECT = opaque {};
pub const sk_ASN1_OBJECT_compfunc = ?*const fn ([*c]const ?*const ASN1_OBJECT, [*c]const ?*const ASN1_OBJECT) callconv(.C) c_int;
pub const sk_ASN1_OBJECT_freefunc = ?*const fn (?*ASN1_OBJECT) callconv(.C) void;
pub const sk_ASN1_OBJECT_copyfunc = ?*const fn (?*const ASN1_OBJECT) callconv(.C) ?*ASN1_OBJECT;
pub fn ossl_check_ASN1_OBJECT_type(arg_ptr: ?*ASN1_OBJECT) callconv(.C) ?*ASN1_OBJECT {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_OBJECT_sk_type(arg_sk: ?*const struct_stack_st_ASN1_OBJECT) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_OBJECT_sk_type(arg_sk: ?*struct_stack_st_ASN1_OBJECT) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_OBJECT_compfunc_type(arg_cmp: sk_ASN1_OBJECT_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_OBJECT_copyfunc_type(arg_cpy: sk_ASN1_OBJECT_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_OBJECT_freefunc_type(arg_fr: sk_ASN1_OBJECT_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn ASN1_OBJECT_new() ?*ASN1_OBJECT;
pub extern fn ASN1_OBJECT_free(a: ?*ASN1_OBJECT) void;
pub extern fn d2i_ASN1_OBJECT(a: [*c]?*ASN1_OBJECT, in: [*c][*c]const u8, len: c_long) ?*ASN1_OBJECT;
pub extern fn i2d_ASN1_OBJECT(a: ?*const ASN1_OBJECT, out: [*c][*c]u8) c_int;
pub extern fn ASN1_OBJECT_it() ?*const ASN1_ITEM;
pub extern fn ASN1_STRING_new() [*c]ASN1_STRING;
pub extern fn ASN1_STRING_free(a: [*c]ASN1_STRING) void;
pub extern fn ASN1_STRING_clear_free(a: [*c]ASN1_STRING) void;
pub extern fn ASN1_STRING_copy(dst: [*c]ASN1_STRING, str: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_dup(a: [*c]const ASN1_STRING) [*c]ASN1_STRING;
pub extern fn ASN1_STRING_type_new(@"type": c_int) [*c]ASN1_STRING;
pub extern fn ASN1_STRING_cmp(a: [*c]const ASN1_STRING, b: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_set(str: [*c]ASN1_STRING, data: ?*const anyopaque, len: c_int) c_int;
pub extern fn ASN1_STRING_set0(str: [*c]ASN1_STRING, data: ?*anyopaque, len: c_int) void;
pub extern fn ASN1_STRING_length(x: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_length_set(x: [*c]ASN1_STRING, n: c_int) void;
pub extern fn ASN1_STRING_type(x: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_data(x: [*c]ASN1_STRING) [*c]u8;
pub extern fn ASN1_STRING_get0_data(x: [*c]const ASN1_STRING) [*c]const u8;
pub extern fn ASN1_BIT_STRING_new() [*c]ASN1_BIT_STRING;
pub extern fn ASN1_BIT_STRING_free(a: [*c]ASN1_BIT_STRING) void;
pub extern fn d2i_ASN1_BIT_STRING(a: [*c][*c]ASN1_BIT_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_BIT_STRING;
pub extern fn i2d_ASN1_BIT_STRING(a: [*c]const ASN1_BIT_STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_BIT_STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_BIT_STRING_set(a: [*c]ASN1_BIT_STRING, d: [*c]u8, length: c_int) c_int;
pub extern fn ASN1_BIT_STRING_set_bit(a: [*c]ASN1_BIT_STRING, n: c_int, value: c_int) c_int;
pub extern fn ASN1_BIT_STRING_get_bit(a: [*c]const ASN1_BIT_STRING, n: c_int) c_int;
pub extern fn ASN1_BIT_STRING_check(a: [*c]const ASN1_BIT_STRING, flags: [*c]const u8, flags_len: c_int) c_int;
pub extern fn ASN1_BIT_STRING_name_print(out: ?*BIO, bs: [*c]ASN1_BIT_STRING, tbl: [*c]BIT_STRING_BITNAME, indent: c_int) c_int;
pub extern fn ASN1_BIT_STRING_num_asc(name: [*c]const u8, tbl: [*c]BIT_STRING_BITNAME) c_int;
pub extern fn ASN1_BIT_STRING_set_asc(bs: [*c]ASN1_BIT_STRING, name: [*c]const u8, value: c_int, tbl: [*c]BIT_STRING_BITNAME) c_int;
pub const struct_stack_st_ASN1_INTEGER = opaque {};
pub const sk_ASN1_INTEGER_compfunc = ?*const fn ([*c]const [*c]const ASN1_INTEGER, [*c]const [*c]const ASN1_INTEGER) callconv(.C) c_int;
pub const sk_ASN1_INTEGER_freefunc = ?*const fn ([*c]ASN1_INTEGER) callconv(.C) void;
pub const sk_ASN1_INTEGER_copyfunc = ?*const fn ([*c]const ASN1_INTEGER) callconv(.C) [*c]ASN1_INTEGER;
pub fn ossl_check_ASN1_INTEGER_type(arg_ptr: [*c]ASN1_INTEGER) callconv(.C) [*c]ASN1_INTEGER {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_INTEGER_sk_type(arg_sk: ?*const struct_stack_st_ASN1_INTEGER) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_INTEGER_sk_type(arg_sk: ?*struct_stack_st_ASN1_INTEGER) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_INTEGER_compfunc_type(arg_cmp: sk_ASN1_INTEGER_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_INTEGER_copyfunc_type(arg_cpy: sk_ASN1_INTEGER_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_INTEGER_freefunc_type(arg_fr: sk_ASN1_INTEGER_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn ASN1_INTEGER_new() [*c]ASN1_INTEGER;
pub extern fn ASN1_INTEGER_free(a: [*c]ASN1_INTEGER) void;
pub extern fn d2i_ASN1_INTEGER(a: [*c][*c]ASN1_INTEGER, in: [*c][*c]const u8, len: c_long) [*c]ASN1_INTEGER;
pub extern fn i2d_ASN1_INTEGER(a: [*c]const ASN1_INTEGER, out: [*c][*c]u8) c_int;
pub extern fn ASN1_INTEGER_it() ?*const ASN1_ITEM;
pub extern fn d2i_ASN1_UINTEGER(a: [*c][*c]ASN1_INTEGER, pp: [*c][*c]const u8, length: c_long) [*c]ASN1_INTEGER;
pub extern fn ASN1_INTEGER_dup(a: [*c]const ASN1_INTEGER) [*c]ASN1_INTEGER;
pub extern fn ASN1_INTEGER_cmp(x: [*c]const ASN1_INTEGER, y: [*c]const ASN1_INTEGER) c_int;
pub extern fn ASN1_ENUMERATED_new() [*c]ASN1_ENUMERATED;
pub extern fn ASN1_ENUMERATED_free(a: [*c]ASN1_ENUMERATED) void;
pub extern fn d2i_ASN1_ENUMERATED(a: [*c][*c]ASN1_ENUMERATED, in: [*c][*c]const u8, len: c_long) [*c]ASN1_ENUMERATED;
pub extern fn i2d_ASN1_ENUMERATED(a: [*c]const ASN1_ENUMERATED, out: [*c][*c]u8) c_int;
pub extern fn ASN1_ENUMERATED_it() ?*const ASN1_ITEM;
pub extern fn ASN1_UTCTIME_check(a: [*c]const ASN1_UTCTIME) c_int;
pub extern fn ASN1_UTCTIME_set(s: [*c]ASN1_UTCTIME, t: time_t) [*c]ASN1_UTCTIME;
pub extern fn ASN1_UTCTIME_adj(s: [*c]ASN1_UTCTIME, t: time_t, offset_day: c_int, offset_sec: c_long) [*c]ASN1_UTCTIME;
pub extern fn ASN1_UTCTIME_set_string(s: [*c]ASN1_UTCTIME, str: [*c]const u8) c_int;
pub extern fn ASN1_UTCTIME_cmp_time_t(s: [*c]const ASN1_UTCTIME, t: time_t) c_int;
pub extern fn ASN1_GENERALIZEDTIME_check(a: [*c]const ASN1_GENERALIZEDTIME) c_int;
pub extern fn ASN1_GENERALIZEDTIME_set(s: [*c]ASN1_GENERALIZEDTIME, t: time_t) [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_GENERALIZEDTIME_adj(s: [*c]ASN1_GENERALIZEDTIME, t: time_t, offset_day: c_int, offset_sec: c_long) [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_GENERALIZEDTIME_set_string(s: [*c]ASN1_GENERALIZEDTIME, str: [*c]const u8) c_int;
pub extern fn ASN1_TIME_diff(pday: [*c]c_int, psec: [*c]c_int, from: [*c]const ASN1_TIME, to: [*c]const ASN1_TIME) c_int;
pub extern fn ASN1_OCTET_STRING_new() [*c]ASN1_OCTET_STRING;
pub extern fn ASN1_OCTET_STRING_free(a: [*c]ASN1_OCTET_STRING) void;
pub extern fn d2i_ASN1_OCTET_STRING(a: [*c][*c]ASN1_OCTET_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_OCTET_STRING;
pub extern fn i2d_ASN1_OCTET_STRING(a: [*c]const ASN1_OCTET_STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_OCTET_STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_OCTET_STRING_dup(a: [*c]const ASN1_OCTET_STRING) [*c]ASN1_OCTET_STRING;
pub extern fn ASN1_OCTET_STRING_cmp(a: [*c]const ASN1_OCTET_STRING, b: [*c]const ASN1_OCTET_STRING) c_int;
pub extern fn ASN1_OCTET_STRING_set(str: [*c]ASN1_OCTET_STRING, data: [*c]const u8, len: c_int) c_int;
pub const struct_stack_st_ASN1_UTF8STRING = opaque {};
pub const sk_ASN1_UTF8STRING_compfunc = ?*const fn ([*c]const [*c]const ASN1_UTF8STRING, [*c]const [*c]const ASN1_UTF8STRING) callconv(.C) c_int;
pub const sk_ASN1_UTF8STRING_freefunc = ?*const fn ([*c]ASN1_UTF8STRING) callconv(.C) void;
pub const sk_ASN1_UTF8STRING_copyfunc = ?*const fn ([*c]const ASN1_UTF8STRING) callconv(.C) [*c]ASN1_UTF8STRING;
pub fn ossl_check_ASN1_UTF8STRING_type(arg_ptr: [*c]ASN1_UTF8STRING) callconv(.C) [*c]ASN1_UTF8STRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_UTF8STRING_sk_type(arg_sk: ?*const struct_stack_st_ASN1_UTF8STRING) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_UTF8STRING_sk_type(arg_sk: ?*struct_stack_st_ASN1_UTF8STRING) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_UTF8STRING_compfunc_type(arg_cmp: sk_ASN1_UTF8STRING_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_UTF8STRING_copyfunc_type(arg_cpy: sk_ASN1_UTF8STRING_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_UTF8STRING_freefunc_type(arg_fr: sk_ASN1_UTF8STRING_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn ASN1_VISIBLESTRING_new() [*c]ASN1_VISIBLESTRING;
pub extern fn ASN1_VISIBLESTRING_free(a: [*c]ASN1_VISIBLESTRING) void;
pub extern fn d2i_ASN1_VISIBLESTRING(a: [*c][*c]ASN1_VISIBLESTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_VISIBLESTRING;
pub extern fn i2d_ASN1_VISIBLESTRING(a: [*c]const ASN1_VISIBLESTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_VISIBLESTRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_UNIVERSALSTRING_new() [*c]ASN1_UNIVERSALSTRING;
pub extern fn ASN1_UNIVERSALSTRING_free(a: [*c]ASN1_UNIVERSALSTRING) void;
pub extern fn d2i_ASN1_UNIVERSALSTRING(a: [*c][*c]ASN1_UNIVERSALSTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_UNIVERSALSTRING;
pub extern fn i2d_ASN1_UNIVERSALSTRING(a: [*c]const ASN1_UNIVERSALSTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_UNIVERSALSTRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_UTF8STRING_new() [*c]ASN1_UTF8STRING;
pub extern fn ASN1_UTF8STRING_free(a: [*c]ASN1_UTF8STRING) void;
pub extern fn d2i_ASN1_UTF8STRING(a: [*c][*c]ASN1_UTF8STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_UTF8STRING;
pub extern fn i2d_ASN1_UTF8STRING(a: [*c]const ASN1_UTF8STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_UTF8STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_NULL_new() [*c]ASN1_NULL;
pub extern fn ASN1_NULL_free(a: [*c]ASN1_NULL) void;
pub extern fn d2i_ASN1_NULL(a: [*c][*c]ASN1_NULL, in: [*c][*c]const u8, len: c_long) [*c]ASN1_NULL;
pub extern fn i2d_ASN1_NULL(a: [*c]const ASN1_NULL, out: [*c][*c]u8) c_int;
pub extern fn ASN1_NULL_it() ?*const ASN1_ITEM;
pub extern fn ASN1_BMPSTRING_new() [*c]ASN1_BMPSTRING;
pub extern fn ASN1_BMPSTRING_free(a: [*c]ASN1_BMPSTRING) void;
pub extern fn d2i_ASN1_BMPSTRING(a: [*c][*c]ASN1_BMPSTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_BMPSTRING;
pub extern fn i2d_ASN1_BMPSTRING(a: [*c]const ASN1_BMPSTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_BMPSTRING_it() ?*const ASN1_ITEM;
pub extern fn UTF8_getc(str: [*c]const u8, len: c_int, val: [*c]c_ulong) c_int;
pub extern fn UTF8_putc(str: [*c]u8, len: c_int, value: c_ulong) c_int;
pub const struct_stack_st_ASN1_GENERALSTRING = opaque {};
pub const sk_ASN1_GENERALSTRING_compfunc = ?*const fn ([*c]const [*c]const ASN1_GENERALSTRING, [*c]const [*c]const ASN1_GENERALSTRING) callconv(.C) c_int;
pub const sk_ASN1_GENERALSTRING_freefunc = ?*const fn ([*c]ASN1_GENERALSTRING) callconv(.C) void;
pub const sk_ASN1_GENERALSTRING_copyfunc = ?*const fn ([*c]const ASN1_GENERALSTRING) callconv(.C) [*c]ASN1_GENERALSTRING;
pub fn ossl_check_ASN1_GENERALSTRING_type(arg_ptr: [*c]ASN1_GENERALSTRING) callconv(.C) [*c]ASN1_GENERALSTRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_GENERALSTRING_sk_type(arg_sk: ?*const struct_stack_st_ASN1_GENERALSTRING) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_GENERALSTRING_sk_type(arg_sk: ?*struct_stack_st_ASN1_GENERALSTRING) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_GENERALSTRING_compfunc_type(arg_cmp: sk_ASN1_GENERALSTRING_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_GENERALSTRING_copyfunc_type(arg_cpy: sk_ASN1_GENERALSTRING_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_GENERALSTRING_freefunc_type(arg_fr: sk_ASN1_GENERALSTRING_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn ASN1_PRINTABLE_new() [*c]ASN1_STRING;
pub extern fn ASN1_PRINTABLE_free(a: [*c]ASN1_STRING) void;
pub extern fn d2i_ASN1_PRINTABLE(a: [*c][*c]ASN1_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_STRING;
pub extern fn i2d_ASN1_PRINTABLE(a: [*c]const ASN1_STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_PRINTABLE_it() ?*const ASN1_ITEM;
pub extern fn DIRECTORYSTRING_new() [*c]ASN1_STRING;
pub extern fn DIRECTORYSTRING_free(a: [*c]ASN1_STRING) void;
pub extern fn d2i_DIRECTORYSTRING(a: [*c][*c]ASN1_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_STRING;
pub extern fn i2d_DIRECTORYSTRING(a: [*c]const ASN1_STRING, out: [*c][*c]u8) c_int;
pub extern fn DIRECTORYSTRING_it() ?*const ASN1_ITEM;
pub extern fn DISPLAYTEXT_new() [*c]ASN1_STRING;
pub extern fn DISPLAYTEXT_free(a: [*c]ASN1_STRING) void;
pub extern fn d2i_DISPLAYTEXT(a: [*c][*c]ASN1_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_STRING;
pub extern fn i2d_DISPLAYTEXT(a: [*c]const ASN1_STRING, out: [*c][*c]u8) c_int;
pub extern fn DISPLAYTEXT_it() ?*const ASN1_ITEM;
pub extern fn ASN1_PRINTABLESTRING_new() [*c]ASN1_PRINTABLESTRING;
pub extern fn ASN1_PRINTABLESTRING_free(a: [*c]ASN1_PRINTABLESTRING) void;
pub extern fn d2i_ASN1_PRINTABLESTRING(a: [*c][*c]ASN1_PRINTABLESTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_PRINTABLESTRING;
pub extern fn i2d_ASN1_PRINTABLESTRING(a: [*c]const ASN1_PRINTABLESTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_PRINTABLESTRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_T61STRING_new() [*c]ASN1_T61STRING;
pub extern fn ASN1_T61STRING_free(a: [*c]ASN1_T61STRING) void;
pub extern fn d2i_ASN1_T61STRING(a: [*c][*c]ASN1_T61STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_T61STRING;
pub extern fn i2d_ASN1_T61STRING(a: [*c]const ASN1_T61STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_T61STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_IA5STRING_new() [*c]ASN1_IA5STRING;
pub extern fn ASN1_IA5STRING_free(a: [*c]ASN1_IA5STRING) void;
pub extern fn d2i_ASN1_IA5STRING(a: [*c][*c]ASN1_IA5STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_IA5STRING;
pub extern fn i2d_ASN1_IA5STRING(a: [*c]const ASN1_IA5STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_IA5STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_GENERALSTRING_new() [*c]ASN1_GENERALSTRING;
pub extern fn ASN1_GENERALSTRING_free(a: [*c]ASN1_GENERALSTRING) void;
pub extern fn d2i_ASN1_GENERALSTRING(a: [*c][*c]ASN1_GENERALSTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_GENERALSTRING;
pub extern fn i2d_ASN1_GENERALSTRING(a: [*c]const ASN1_GENERALSTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_GENERALSTRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_UTCTIME_new() [*c]ASN1_UTCTIME;
pub extern fn ASN1_UTCTIME_free(a: [*c]ASN1_UTCTIME) void;
pub extern fn d2i_ASN1_UTCTIME(a: [*c][*c]ASN1_UTCTIME, in: [*c][*c]const u8, len: c_long) [*c]ASN1_UTCTIME;
pub extern fn i2d_ASN1_UTCTIME(a: [*c]const ASN1_UTCTIME, out: [*c][*c]u8) c_int;
pub extern fn ASN1_UTCTIME_it() ?*const ASN1_ITEM;
pub extern fn ASN1_GENERALIZEDTIME_new() [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_GENERALIZEDTIME_free(a: [*c]ASN1_GENERALIZEDTIME) void;
pub extern fn d2i_ASN1_GENERALIZEDTIME(a: [*c][*c]ASN1_GENERALIZEDTIME, in: [*c][*c]const u8, len: c_long) [*c]ASN1_GENERALIZEDTIME;
pub extern fn i2d_ASN1_GENERALIZEDTIME(a: [*c]const ASN1_GENERALIZEDTIME, out: [*c][*c]u8) c_int;
pub extern fn ASN1_GENERALIZEDTIME_it() ?*const ASN1_ITEM;
pub extern fn ASN1_TIME_new() [*c]ASN1_TIME;
pub extern fn ASN1_TIME_free(a: [*c]ASN1_TIME) void;
pub extern fn d2i_ASN1_TIME(a: [*c][*c]ASN1_TIME, in: [*c][*c]const u8, len: c_long) [*c]ASN1_TIME;
pub extern fn i2d_ASN1_TIME(a: [*c]const ASN1_TIME, out: [*c][*c]u8) c_int;
pub extern fn ASN1_TIME_it() ?*const ASN1_ITEM;
pub extern fn ASN1_TIME_dup(a: [*c]const ASN1_TIME) [*c]ASN1_TIME;
pub extern fn ASN1_UTCTIME_dup(a: [*c]const ASN1_UTCTIME) [*c]ASN1_UTCTIME;
pub extern fn ASN1_GENERALIZEDTIME_dup(a: [*c]const ASN1_GENERALIZEDTIME) [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_OCTET_STRING_NDEF_it() ?*const ASN1_ITEM;
pub extern fn ASN1_TIME_set(s: [*c]ASN1_TIME, t: time_t) [*c]ASN1_TIME;
pub extern fn ASN1_TIME_adj(s: [*c]ASN1_TIME, t: time_t, offset_day: c_int, offset_sec: c_long) [*c]ASN1_TIME;
pub extern fn ASN1_TIME_check(t: [*c]const ASN1_TIME) c_int;
pub extern fn ASN1_TIME_to_generalizedtime(t: [*c]const ASN1_TIME, out: [*c][*c]ASN1_GENERALIZEDTIME) [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_TIME_set_string(s: [*c]ASN1_TIME, str: [*c]const u8) c_int;
pub extern fn ASN1_TIME_set_string_X509(s: [*c]ASN1_TIME, str: [*c]const u8) c_int;
pub extern fn ASN1_TIME_to_tm(s: [*c]const ASN1_TIME, tm: [*c]struct_tm) c_int;
pub extern fn ASN1_TIME_normalize(s: [*c]ASN1_TIME) c_int;
pub extern fn ASN1_TIME_cmp_time_t(s: [*c]const ASN1_TIME, t: time_t) c_int;
pub extern fn ASN1_TIME_compare(a: [*c]const ASN1_TIME, b: [*c]const ASN1_TIME) c_int;
pub extern fn i2a_ASN1_INTEGER(bp: ?*BIO, a: [*c]const ASN1_INTEGER) c_int;
pub extern fn a2i_ASN1_INTEGER(bp: ?*BIO, bs: [*c]ASN1_INTEGER, buf: [*c]u8, size: c_int) c_int;
pub extern fn i2a_ASN1_ENUMERATED(bp: ?*BIO, a: [*c]const ASN1_ENUMERATED) c_int;
pub extern fn a2i_ASN1_ENUMERATED(bp: ?*BIO, bs: [*c]ASN1_ENUMERATED, buf: [*c]u8, size: c_int) c_int;
pub extern fn i2a_ASN1_OBJECT(bp: ?*BIO, a: ?*const ASN1_OBJECT) c_int;
pub extern fn a2i_ASN1_STRING(bp: ?*BIO, bs: [*c]ASN1_STRING, buf: [*c]u8, size: c_int) c_int;
pub extern fn i2a_ASN1_STRING(bp: ?*BIO, a: [*c]const ASN1_STRING, @"type": c_int) c_int;
pub extern fn i2t_ASN1_OBJECT(buf: [*c]u8, buf_len: c_int, a: ?*const ASN1_OBJECT) c_int;
pub extern fn a2d_ASN1_OBJECT(out: [*c]u8, olen: c_int, buf: [*c]const u8, num: c_int) c_int;
pub extern fn ASN1_OBJECT_create(nid: c_int, data: [*c]u8, len: c_int, sn: [*c]const u8, ln: [*c]const u8) ?*ASN1_OBJECT;
pub extern fn ASN1_INTEGER_get_int64(pr: [*c]i64, a: [*c]const ASN1_INTEGER) c_int;
pub extern fn ASN1_INTEGER_set_int64(a: [*c]ASN1_INTEGER, r: i64) c_int;
pub extern fn ASN1_INTEGER_get_uint64(pr: [*c]u64, a: [*c]const ASN1_INTEGER) c_int;
pub extern fn ASN1_INTEGER_set_uint64(a: [*c]ASN1_INTEGER, r: u64) c_int;
pub extern fn ASN1_INTEGER_set(a: [*c]ASN1_INTEGER, v: c_long) c_int;
pub extern fn ASN1_INTEGER_get(a: [*c]const ASN1_INTEGER) c_long;
pub extern fn BN_to_ASN1_INTEGER(bn: ?*const BIGNUM, ai: [*c]ASN1_INTEGER) [*c]ASN1_INTEGER;
pub extern fn ASN1_INTEGER_to_BN(ai: [*c]const ASN1_INTEGER, bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn ASN1_ENUMERATED_get_int64(pr: [*c]i64, a: [*c]const ASN1_ENUMERATED) c_int;
pub extern fn ASN1_ENUMERATED_set_int64(a: [*c]ASN1_ENUMERATED, r: i64) c_int;
pub extern fn ASN1_ENUMERATED_set(a: [*c]ASN1_ENUMERATED, v: c_long) c_int;
pub extern fn ASN1_ENUMERATED_get(a: [*c]const ASN1_ENUMERATED) c_long;
pub extern fn BN_to_ASN1_ENUMERATED(bn: ?*const BIGNUM, ai: [*c]ASN1_ENUMERATED) [*c]ASN1_ENUMERATED;
pub extern fn ASN1_ENUMERATED_to_BN(ai: [*c]const ASN1_ENUMERATED, bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn ASN1_PRINTABLE_type(s: [*c]const u8, max: c_int) c_int;
pub extern fn ASN1_tag2bit(tag: c_int) c_ulong;
pub extern fn ASN1_get_object(pp: [*c][*c]const u8, plength: [*c]c_long, ptag: [*c]c_int, pclass: [*c]c_int, omax: c_long) c_int;
pub extern fn ASN1_check_infinite_end(p: [*c][*c]u8, len: c_long) c_int;
pub extern fn ASN1_const_check_infinite_end(p: [*c][*c]const u8, len: c_long) c_int;
pub extern fn ASN1_put_object(pp: [*c][*c]u8, constructed: c_int, length: c_int, tag: c_int, xclass: c_int) void;
pub extern fn ASN1_put_eoc(pp: [*c][*c]u8) c_int;
pub extern fn ASN1_object_size(constructed: c_int, length: c_int, tag: c_int) c_int;
pub extern fn ASN1_dup(i2d: ?*const i2d_of_void, d2i: ?*const d2i_of_void, x: ?*const anyopaque) ?*anyopaque;
pub extern fn ASN1_item_dup(it: ?*const ASN1_ITEM, x: ?*const anyopaque) ?*anyopaque;
pub extern fn ASN1_item_sign_ex(it: ?*const ASN1_ITEM, algor1: [*c]X509_ALGOR, algor2: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: ?*const anyopaque, id: [*c]const ASN1_OCTET_STRING, pkey: ?*EVP_PKEY, md: ?*const EVP_MD, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn ASN1_item_verify_ex(it: ?*const ASN1_ITEM, alg: [*c]const X509_ALGOR, signature: [*c]const ASN1_BIT_STRING, data: ?*const anyopaque, id: [*c]const ASN1_OCTET_STRING, pkey: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn ASN1_d2i_fp(xnew: ?*const fn () callconv(.C) ?*anyopaque, d2i: ?*const d2i_of_void, in: [*c]FILE, x: [*c]?*anyopaque) ?*anyopaque;
pub extern fn ASN1_item_d2i_fp_ex(it: ?*const ASN1_ITEM, in: [*c]FILE, x: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*anyopaque;
pub extern fn ASN1_item_d2i_fp(it: ?*const ASN1_ITEM, in: [*c]FILE, x: ?*anyopaque) ?*anyopaque;
pub extern fn ASN1_i2d_fp(i2d: ?*const i2d_of_void, out: [*c]FILE, x: ?*const anyopaque) c_int;
pub extern fn ASN1_item_i2d_fp(it: ?*const ASN1_ITEM, out: [*c]FILE, x: ?*const anyopaque) c_int;
pub extern fn ASN1_STRING_print_ex_fp(fp: [*c]FILE, str: [*c]const ASN1_STRING, flags: c_ulong) c_int;
pub extern fn ASN1_STRING_to_UTF8(out: [*c][*c]u8, in: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_d2i_bio(xnew: ?*const fn () callconv(.C) ?*anyopaque, d2i: ?*const d2i_of_void, in: ?*BIO, x: [*c]?*anyopaque) ?*anyopaque;
pub extern fn ASN1_item_d2i_bio_ex(it: ?*const ASN1_ITEM, in: ?*BIO, pval: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*anyopaque;
pub extern fn ASN1_item_d2i_bio(it: ?*const ASN1_ITEM, in: ?*BIO, pval: ?*anyopaque) ?*anyopaque;
pub extern fn ASN1_i2d_bio(i2d: ?*const i2d_of_void, out: ?*BIO, x: ?*const anyopaque) c_int;
pub extern fn ASN1_item_i2d_bio(it: ?*const ASN1_ITEM, out: ?*BIO, x: ?*const anyopaque) c_int;
pub extern fn ASN1_item_i2d_mem_bio(it: ?*const ASN1_ITEM, val: ?*const ASN1_VALUE) ?*BIO;
pub extern fn ASN1_UTCTIME_print(fp: ?*BIO, a: [*c]const ASN1_UTCTIME) c_int;
pub extern fn ASN1_GENERALIZEDTIME_print(fp: ?*BIO, a: [*c]const ASN1_GENERALIZEDTIME) c_int;
pub extern fn ASN1_TIME_print(bp: ?*BIO, tm: [*c]const ASN1_TIME) c_int;
pub extern fn ASN1_TIME_print_ex(bp: ?*BIO, tm: [*c]const ASN1_TIME, flags: c_ulong) c_int;
pub extern fn ASN1_STRING_print(bp: ?*BIO, v: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_print_ex(out: ?*BIO, str: [*c]const ASN1_STRING, flags: c_ulong) c_int;
pub extern fn ASN1_buf_print(bp: ?*BIO, buf: [*c]const u8, buflen: usize, off: c_int) c_int;
pub extern fn ASN1_bn_print(bp: ?*BIO, number: [*c]const u8, num: ?*const BIGNUM, buf: [*c]u8, off: c_int) c_int;
pub extern fn ASN1_parse(bp: ?*BIO, pp: [*c]const u8, len: c_long, indent: c_int) c_int;
pub extern fn ASN1_parse_dump(bp: ?*BIO, pp: [*c]const u8, len: c_long, indent: c_int, dump: c_int) c_int;
pub extern fn ASN1_tag2str(tag: c_int) [*c]const u8;
pub extern fn ASN1_UNIVERSALSTRING_to_string(s: [*c]ASN1_UNIVERSALSTRING) c_int;
pub extern fn ASN1_TYPE_set_octetstring(a: [*c]ASN1_TYPE, data: [*c]u8, len: c_int) c_int;
pub extern fn ASN1_TYPE_get_octetstring(a: [*c]const ASN1_TYPE, data: [*c]u8, max_len: c_int) c_int;
pub extern fn ASN1_TYPE_set_int_octetstring(a: [*c]ASN1_TYPE, num: c_long, data: [*c]u8, len: c_int) c_int;
pub extern fn ASN1_TYPE_get_int_octetstring(a: [*c]const ASN1_TYPE, num: [*c]c_long, data: [*c]u8, max_len: c_int) c_int;
pub extern fn ASN1_item_unpack(oct: [*c]const ASN1_STRING, it: ?*const ASN1_ITEM) ?*anyopaque;
pub extern fn ASN1_item_unpack_ex(oct: [*c]const ASN1_STRING, it: ?*const ASN1_ITEM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*anyopaque;
pub extern fn ASN1_item_pack(obj: ?*anyopaque, it: ?*const ASN1_ITEM, oct: [*c][*c]ASN1_OCTET_STRING) [*c]ASN1_STRING;
pub extern fn ASN1_STRING_set_default_mask(mask: c_ulong) void;
pub extern fn ASN1_STRING_set_default_mask_asc(p: [*c]const u8) c_int;
pub extern fn ASN1_STRING_get_default_mask() c_ulong;
pub extern fn ASN1_mbstring_copy(out: [*c][*c]ASN1_STRING, in: [*c]const u8, len: c_int, inform: c_int, mask: c_ulong) c_int;
pub extern fn ASN1_mbstring_ncopy(out: [*c][*c]ASN1_STRING, in: [*c]const u8, len: c_int, inform: c_int, mask: c_ulong, minsize: c_long, maxsize: c_long) c_int;
pub extern fn ASN1_STRING_set_by_NID(out: [*c][*c]ASN1_STRING, in: [*c]const u8, inlen: c_int, inform: c_int, nid: c_int) [*c]ASN1_STRING;
pub extern fn ASN1_STRING_TABLE_get(nid: c_int) [*c]ASN1_STRING_TABLE;
pub extern fn ASN1_STRING_TABLE_add(c_int, c_long, c_long, c_ulong, c_ulong) c_int;
pub extern fn ASN1_STRING_TABLE_cleanup() void;
pub extern fn ASN1_item_new(it: ?*const ASN1_ITEM) ?*ASN1_VALUE;
pub extern fn ASN1_item_new_ex(it: ?*const ASN1_ITEM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*ASN1_VALUE;
pub extern fn ASN1_item_free(val: ?*ASN1_VALUE, it: ?*const ASN1_ITEM) void;
pub extern fn ASN1_item_d2i_ex(val: [*c]?*ASN1_VALUE, in: [*c][*c]const u8, len: c_long, it: ?*const ASN1_ITEM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*ASN1_VALUE;
pub extern fn ASN1_item_d2i(val: [*c]?*ASN1_VALUE, in: [*c][*c]const u8, len: c_long, it: ?*const ASN1_ITEM) ?*ASN1_VALUE;
pub extern fn ASN1_item_i2d(val: ?*const ASN1_VALUE, out: [*c][*c]u8, it: ?*const ASN1_ITEM) c_int;
pub extern fn ASN1_item_ndef_i2d(val: ?*const ASN1_VALUE, out: [*c][*c]u8, it: ?*const ASN1_ITEM) c_int;
pub extern fn ASN1_add_oid_module() void;
pub extern fn ASN1_add_stable_module() void;
pub extern fn ASN1_generate_nconf(str: [*c]const u8, nconf: [*c]CONF) [*c]ASN1_TYPE;
pub extern fn ASN1_generate_v3(str: [*c]const u8, cnf: ?*X509V3_CTX) [*c]ASN1_TYPE;
pub extern fn ASN1_str2mask(str: [*c]const u8, pmask: [*c]c_ulong) c_int;
pub extern fn ASN1_item_print(out: ?*BIO, ifld: ?*const ASN1_VALUE, indent: c_int, it: ?*const ASN1_ITEM, pctx: ?*const ASN1_PCTX) c_int;
pub extern fn ASN1_PCTX_new() ?*ASN1_PCTX;
pub extern fn ASN1_PCTX_free(p: ?*ASN1_PCTX) void;
pub extern fn ASN1_PCTX_get_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_PCTX_get_nm_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_nm_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_PCTX_get_cert_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_cert_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_PCTX_get_oid_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_oid_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_PCTX_get_str_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_str_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_SCTX_new(scan_cb: ?*const fn (?*ASN1_SCTX) callconv(.C) c_int) ?*ASN1_SCTX;
pub extern fn ASN1_SCTX_free(p: ?*ASN1_SCTX) void;
pub extern fn ASN1_SCTX_get_item(p: ?*ASN1_SCTX) ?*const ASN1_ITEM;
pub extern fn ASN1_SCTX_get_template(p: ?*ASN1_SCTX) ?*const ASN1_TEMPLATE;
pub extern fn ASN1_SCTX_get_flags(p: ?*ASN1_SCTX) c_ulong;
pub extern fn ASN1_SCTX_set_app_data(p: ?*ASN1_SCTX, data: ?*anyopaque) void;
pub extern fn ASN1_SCTX_get_app_data(p: ?*ASN1_SCTX) ?*anyopaque;
pub extern fn BIO_f_asn1() ?*const BIO_METHOD;
pub extern fn BIO_new_NDEF(out: ?*BIO, val: ?*ASN1_VALUE, it: ?*const ASN1_ITEM) ?*BIO;
pub extern fn i2d_ASN1_bio_stream(out: ?*BIO, val: ?*ASN1_VALUE, in: ?*BIO, flags: c_int, it: ?*const ASN1_ITEM) c_int;
pub extern fn PEM_write_bio_ASN1_stream(out: ?*BIO, val: ?*ASN1_VALUE, in: ?*BIO, flags: c_int, hdr: [*c]const u8, it: ?*const ASN1_ITEM) c_int;
pub extern fn SMIME_write_ASN1(bio: ?*BIO, val: ?*ASN1_VALUE, data: ?*BIO, flags: c_int, ctype_nid: c_int, econt_nid: c_int, mdalgs: ?*struct_stack_st_X509_ALGOR, it: ?*const ASN1_ITEM) c_int;
pub extern fn SMIME_write_ASN1_ex(bio: ?*BIO, val: ?*ASN1_VALUE, data: ?*BIO, flags: c_int, ctype_nid: c_int, econt_nid: c_int, mdalgs: ?*struct_stack_st_X509_ALGOR, it: ?*const ASN1_ITEM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn SMIME_read_ASN1(bio: ?*BIO, bcont: [*c]?*BIO, it: ?*const ASN1_ITEM) ?*ASN1_VALUE;
pub extern fn SMIME_read_ASN1_ex(bio: ?*BIO, flags: c_int, bcont: [*c]?*BIO, it: ?*const ASN1_ITEM, x: [*c]?*ASN1_VALUE, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*ASN1_VALUE;
pub extern fn SMIME_crlf_copy(in: ?*BIO, out: ?*BIO, flags: c_int) c_int;
pub extern fn SMIME_text(in: ?*BIO, out: ?*BIO) c_int;
pub extern fn ASN1_ITEM_lookup(name: [*c]const u8) ?*const ASN1_ITEM;
pub extern fn ASN1_ITEM_get(i: usize) ?*const ASN1_ITEM;
pub const struct_obj_name_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    alias: c_int = @import("std").mem.zeroes(c_int),
    name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    data: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const OBJ_NAME = struct_obj_name_st;
pub extern fn OBJ_NAME_init() c_int;
pub extern fn OBJ_NAME_new_index(hash_func: ?*const fn ([*c]const u8) callconv(.C) c_ulong, cmp_func: ?*const fn ([*c]const u8, [*c]const u8) callconv(.C) c_int, free_func: ?*const fn ([*c]const u8, c_int, [*c]const u8) callconv(.C) void) c_int;
pub extern fn OBJ_NAME_get(name: [*c]const u8, @"type": c_int) [*c]const u8;
pub extern fn OBJ_NAME_add(name: [*c]const u8, @"type": c_int, data: [*c]const u8) c_int;
pub extern fn OBJ_NAME_remove(name: [*c]const u8, @"type": c_int) c_int;
pub extern fn OBJ_NAME_cleanup(@"type": c_int) void;
pub extern fn OBJ_NAME_do_all(@"type": c_int, @"fn": ?*const fn ([*c]const OBJ_NAME, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn OBJ_NAME_do_all_sorted(@"type": c_int, @"fn": ?*const fn ([*c]const OBJ_NAME, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn OBJ_dup(a: ?*const ASN1_OBJECT) ?*ASN1_OBJECT;
pub extern fn OBJ_nid2obj(n: c_int) ?*ASN1_OBJECT;
pub extern fn OBJ_nid2ln(n: c_int) [*c]const u8;
pub extern fn OBJ_nid2sn(n: c_int) [*c]const u8;
pub extern fn OBJ_obj2nid(o: ?*const ASN1_OBJECT) c_int;
pub extern fn OBJ_txt2obj(s: [*c]const u8, no_name: c_int) ?*ASN1_OBJECT;
pub extern fn OBJ_obj2txt(buf: [*c]u8, buf_len: c_int, a: ?*const ASN1_OBJECT, no_name: c_int) c_int;
pub extern fn OBJ_txt2nid(s: [*c]const u8) c_int;
pub extern fn OBJ_ln2nid(s: [*c]const u8) c_int;
pub extern fn OBJ_sn2nid(s: [*c]const u8) c_int;
pub extern fn OBJ_cmp(a: ?*const ASN1_OBJECT, b: ?*const ASN1_OBJECT) c_int;
pub extern fn OBJ_bsearch_(key: ?*const anyopaque, base: ?*const anyopaque, num: c_int, size: c_int, cmp: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) ?*const anyopaque;
pub extern fn OBJ_bsearch_ex_(key: ?*const anyopaque, base: ?*const anyopaque, num: c_int, size: c_int, cmp: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int, flags: c_int) ?*const anyopaque;
pub extern fn OBJ_new_nid(num: c_int) c_int;
pub extern fn OBJ_add_object(obj: ?*const ASN1_OBJECT) c_int;
pub extern fn OBJ_create(oid: [*c]const u8, sn: [*c]const u8, ln: [*c]const u8) c_int;
pub extern fn OBJ_create_objects(in: ?*BIO) c_int;
pub extern fn OBJ_length(obj: ?*const ASN1_OBJECT) usize;
pub extern fn OBJ_get0_data(obj: ?*const ASN1_OBJECT) [*c]const u8;
pub extern fn OBJ_find_sigid_algs(signid: c_int, pdig_nid: [*c]c_int, ppkey_nid: [*c]c_int) c_int;
pub extern fn OBJ_find_sigid_by_algs(psignid: [*c]c_int, dig_nid: c_int, pkey_nid: c_int) c_int;
pub extern fn OBJ_add_sigid(signid: c_int, dig_id: c_int, pkey_id: c_int) c_int;
pub extern fn OBJ_sigid_free() void;
pub extern fn EVP_set_default_properties(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_default_properties_is_fips_enabled(libctx: ?*OSSL_LIB_CTX) c_int;
pub extern fn EVP_default_properties_enable_fips(libctx: ?*OSSL_LIB_CTX, enable: c_int) c_int;
pub extern fn EVP_MD_meth_new(md_type: c_int, pkey_type: c_int) ?*EVP_MD;
pub extern fn EVP_MD_meth_dup(md: ?*const EVP_MD) ?*EVP_MD;
pub extern fn EVP_MD_meth_free(md: ?*EVP_MD) void;
pub extern fn EVP_MD_meth_set_input_blocksize(md: ?*EVP_MD, blocksize: c_int) c_int;
pub extern fn EVP_MD_meth_set_result_size(md: ?*EVP_MD, resultsize: c_int) c_int;
pub extern fn EVP_MD_meth_set_app_datasize(md: ?*EVP_MD, datasize: c_int) c_int;
pub extern fn EVP_MD_meth_set_flags(md: ?*EVP_MD, flags: c_ulong) c_int;
pub extern fn EVP_MD_meth_set_init(md: ?*EVP_MD, init: ?*const fn (?*EVP_MD_CTX) callconv(.C) c_int) c_int;
pub extern fn EVP_MD_meth_set_update(md: ?*EVP_MD, update: ?*const fn (?*EVP_MD_CTX, ?*const anyopaque, usize) callconv(.C) c_int) c_int;
pub extern fn EVP_MD_meth_set_final(md: ?*EVP_MD, final: ?*const fn (?*EVP_MD_CTX, [*c]u8) callconv(.C) c_int) c_int;
pub extern fn EVP_MD_meth_set_copy(md: ?*EVP_MD, copy: ?*const fn (?*EVP_MD_CTX, ?*const EVP_MD_CTX) callconv(.C) c_int) c_int;
pub extern fn EVP_MD_meth_set_cleanup(md: ?*EVP_MD, cleanup: ?*const fn (?*EVP_MD_CTX) callconv(.C) c_int) c_int;
pub extern fn EVP_MD_meth_set_ctrl(md: ?*EVP_MD, ctrl: ?*const fn (?*EVP_MD_CTX, c_int, c_int, ?*anyopaque) callconv(.C) c_int) c_int;
pub extern fn EVP_MD_meth_get_input_blocksize(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_meth_get_result_size(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_meth_get_app_datasize(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_meth_get_flags(md: ?*const EVP_MD) c_ulong;
pub extern fn EVP_MD_meth_get_init(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX) callconv(.C) c_int;
pub extern fn EVP_MD_meth_get_update(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX, ?*const anyopaque, usize) callconv(.C) c_int;
pub extern fn EVP_MD_meth_get_final(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX, [*c]u8) callconv(.C) c_int;
pub extern fn EVP_MD_meth_get_copy(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX, ?*const EVP_MD_CTX) callconv(.C) c_int;
pub extern fn EVP_MD_meth_get_cleanup(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX) callconv(.C) c_int;
pub extern fn EVP_MD_meth_get_ctrl(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX, c_int, c_int, ?*anyopaque) callconv(.C) c_int;
pub extern fn EVP_CIPHER_meth_new(cipher_type: c_int, block_size: c_int, key_len: c_int) ?*EVP_CIPHER;
pub extern fn EVP_CIPHER_meth_dup(cipher: ?*const EVP_CIPHER) ?*EVP_CIPHER;
pub extern fn EVP_CIPHER_meth_free(cipher: ?*EVP_CIPHER) void;
pub extern fn EVP_CIPHER_meth_set_iv_length(cipher: ?*EVP_CIPHER, iv_len: c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_flags(cipher: ?*EVP_CIPHER, flags: c_ulong) c_int;
pub extern fn EVP_CIPHER_meth_set_impl_ctx_size(cipher: ?*EVP_CIPHER, ctx_size: c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_init(cipher: ?*EVP_CIPHER, init: ?*const fn (?*EVP_CIPHER_CTX, [*c]const u8, [*c]const u8, c_int) callconv(.C) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_do_cipher(cipher: ?*EVP_CIPHER, do_cipher: ?*const fn (?*EVP_CIPHER_CTX, [*c]u8, [*c]const u8, usize) callconv(.C) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_cleanup(cipher: ?*EVP_CIPHER, cleanup: ?*const fn (?*EVP_CIPHER_CTX) callconv(.C) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_set_asn1_params(cipher: ?*EVP_CIPHER, set_asn1_parameters: ?*const fn (?*EVP_CIPHER_CTX, [*c]ASN1_TYPE) callconv(.C) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_get_asn1_params(cipher: ?*EVP_CIPHER, get_asn1_parameters: ?*const fn (?*EVP_CIPHER_CTX, [*c]ASN1_TYPE) callconv(.C) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_ctrl(cipher: ?*EVP_CIPHER, ctrl: ?*const fn (?*EVP_CIPHER_CTX, c_int, c_int, ?*anyopaque) callconv(.C) c_int) c_int;
pub extern fn EVP_CIPHER_meth_get_init(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, [*c]const u8, [*c]const u8, c_int) callconv(.C) c_int;
pub extern fn EVP_CIPHER_meth_get_do_cipher(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, [*c]u8, [*c]const u8, usize) callconv(.C) c_int;
pub extern fn EVP_CIPHER_meth_get_cleanup(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX) callconv(.C) c_int;
pub extern fn EVP_CIPHER_meth_get_set_asn1_params(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, [*c]ASN1_TYPE) callconv(.C) c_int;
pub extern fn EVP_CIPHER_meth_get_get_asn1_params(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, [*c]ASN1_TYPE) callconv(.C) c_int;
pub extern fn EVP_CIPHER_meth_get_ctrl(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, c_int, c_int, ?*anyopaque) callconv(.C) c_int;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM = extern struct {
    out: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    inp: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    len: usize = @import("std").mem.zeroes(usize),
    interleave: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_evp_cipher_info_st = extern struct {
    cipher: ?*const EVP_CIPHER = @import("std").mem.zeroes(?*const EVP_CIPHER),
    iv: [16]u8 = @import("std").mem.zeroes([16]u8),
};
pub const EVP_CIPHER_INFO = struct_evp_cipher_info_st;
pub const EVP_PBE_KEYGEN = fn (?*EVP_CIPHER_CTX, [*c]const u8, c_int, [*c]ASN1_TYPE, ?*const EVP_CIPHER, ?*const EVP_MD, c_int) callconv(.C) c_int;
pub const EVP_PBE_KEYGEN_EX = fn (?*EVP_CIPHER_CTX, [*c]const u8, c_int, [*c]ASN1_TYPE, ?*const EVP_CIPHER, ?*const EVP_MD, c_int, ?*OSSL_LIB_CTX, [*c]const u8) callconv(.C) c_int;
pub extern fn EVP_MD_get_type(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_get0_name(md: ?*const EVP_MD) [*c]const u8;
pub extern fn EVP_MD_get0_description(md: ?*const EVP_MD) [*c]const u8;
pub extern fn EVP_MD_is_a(md: ?*const EVP_MD, name: [*c]const u8) c_int;
pub extern fn EVP_MD_names_do_all(md: ?*const EVP_MD, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_MD_get0_provider(md: ?*const EVP_MD) ?*const OSSL_PROVIDER;
pub extern fn EVP_MD_get_pkey_type(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_get_size(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_get_block_size(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_get_flags(md: ?*const EVP_MD) c_ulong;
pub extern fn EVP_MD_xof(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_CTX_get0_md(ctx: ?*const EVP_MD_CTX) ?*const EVP_MD;
pub extern fn EVP_MD_CTX_get1_md(ctx: ?*EVP_MD_CTX) ?*EVP_MD;
pub extern fn EVP_MD_CTX_md(ctx: ?*const EVP_MD_CTX) ?*const EVP_MD;
pub extern fn EVP_MD_CTX_update_fn(ctx: ?*EVP_MD_CTX) ?*const fn (?*EVP_MD_CTX, ?*const anyopaque, usize) callconv(.C) c_int;
pub extern fn EVP_MD_CTX_set_update_fn(ctx: ?*EVP_MD_CTX, update: ?*const fn (?*EVP_MD_CTX, ?*const anyopaque, usize) callconv(.C) c_int) void;
pub extern fn EVP_MD_CTX_get_size_ex(ctx: ?*const EVP_MD_CTX) c_int;
pub extern fn EVP_MD_CTX_get_pkey_ctx(ctx: ?*const EVP_MD_CTX) ?*EVP_PKEY_CTX;
pub extern fn EVP_MD_CTX_set_pkey_ctx(ctx: ?*EVP_MD_CTX, pctx: ?*EVP_PKEY_CTX) void;
pub extern fn EVP_MD_CTX_get0_md_data(ctx: ?*const EVP_MD_CTX) ?*anyopaque;
pub extern fn EVP_CIPHER_get_nid(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get0_name(cipher: ?*const EVP_CIPHER) [*c]const u8;
pub extern fn EVP_CIPHER_get0_description(cipher: ?*const EVP_CIPHER) [*c]const u8;
pub extern fn EVP_CIPHER_is_a(cipher: ?*const EVP_CIPHER, name: [*c]const u8) c_int;
pub extern fn EVP_CIPHER_names_do_all(cipher: ?*const EVP_CIPHER, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_CIPHER_get0_provider(cipher: ?*const EVP_CIPHER) ?*const OSSL_PROVIDER;
pub extern fn EVP_CIPHER_get_block_size(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_impl_ctx_size(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get_key_length(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get_iv_length(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get_flags(cipher: ?*const EVP_CIPHER) c_ulong;
pub extern fn EVP_CIPHER_get_mode(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get_type(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_CIPHER;
pub extern fn EVP_CIPHER_up_ref(cipher: ?*EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_free(cipher: ?*EVP_CIPHER) void;
pub extern fn EVP_CIPHER_CTX_get0_cipher(ctx: ?*const EVP_CIPHER_CTX) ?*const EVP_CIPHER;
pub extern fn EVP_CIPHER_CTX_get1_cipher(ctx: ?*EVP_CIPHER_CTX) ?*EVP_CIPHER;
pub extern fn EVP_CIPHER_CTX_is_encrypting(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_nid(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_block_size(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_key_length(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_iv_length(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_tag_length(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_cipher(ctx: ?*const EVP_CIPHER_CTX) ?*const EVP_CIPHER;
pub extern fn EVP_CIPHER_CTX_iv(ctx: ?*const EVP_CIPHER_CTX) [*c]const u8;
pub extern fn EVP_CIPHER_CTX_original_iv(ctx: ?*const EVP_CIPHER_CTX) [*c]const u8;
pub extern fn EVP_CIPHER_CTX_iv_noconst(ctx: ?*EVP_CIPHER_CTX) [*c]u8;
pub extern fn EVP_CIPHER_CTX_get_updated_iv(ctx: ?*EVP_CIPHER_CTX, buf: ?*anyopaque, len: usize) c_int;
pub extern fn EVP_CIPHER_CTX_get_original_iv(ctx: ?*EVP_CIPHER_CTX, buf: ?*anyopaque, len: usize) c_int;
pub extern fn EVP_CIPHER_CTX_buf_noconst(ctx: ?*EVP_CIPHER_CTX) [*c]u8;
pub extern fn EVP_CIPHER_CTX_get_num(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_set_num(ctx: ?*EVP_CIPHER_CTX, num: c_int) c_int;
pub extern fn EVP_CIPHER_CTX_dup(in: ?*const EVP_CIPHER_CTX) ?*EVP_CIPHER_CTX;
pub extern fn EVP_CIPHER_CTX_copy(out: ?*EVP_CIPHER_CTX, in: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_app_data(ctx: ?*const EVP_CIPHER_CTX) ?*anyopaque;
pub extern fn EVP_CIPHER_CTX_set_app_data(ctx: ?*EVP_CIPHER_CTX, data: ?*anyopaque) void;
pub extern fn EVP_CIPHER_CTX_get_cipher_data(ctx: ?*const EVP_CIPHER_CTX) ?*anyopaque;
pub extern fn EVP_CIPHER_CTX_set_cipher_data(ctx: ?*EVP_CIPHER_CTX, cipher_data: ?*anyopaque) ?*anyopaque;
pub extern fn EVP_Cipher(c: ?*EVP_CIPHER_CTX, out: [*c]u8, in: [*c]const u8, inl: c_uint) c_int;
pub extern fn EVP_MD_get_params(digest: ?*const EVP_MD, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_MD_CTX_set_params(ctx: ?*EVP_MD_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_MD_CTX_get_params(ctx: ?*EVP_MD_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_MD_gettable_params(digest: ?*const EVP_MD) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_settable_ctx_params(md: ?*const EVP_MD) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_gettable_ctx_params(md: ?*const EVP_MD) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_CTX_settable_params(ctx: ?*EVP_MD_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_CTX_gettable_params(ctx: ?*EVP_MD_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_CTX_ctrl(ctx: ?*EVP_MD_CTX, cmd: c_int, p1: c_int, p2: ?*anyopaque) c_int;
pub extern fn EVP_MD_CTX_new() ?*EVP_MD_CTX;
pub extern fn EVP_MD_CTX_reset(ctx: ?*EVP_MD_CTX) c_int;
pub extern fn EVP_MD_CTX_free(ctx: ?*EVP_MD_CTX) void;
pub extern fn EVP_MD_CTX_dup(in: ?*const EVP_MD_CTX) ?*EVP_MD_CTX;
pub extern fn EVP_MD_CTX_copy_ex(out: ?*EVP_MD_CTX, in: ?*const EVP_MD_CTX) c_int;
pub extern fn EVP_MD_CTX_set_flags(ctx: ?*EVP_MD_CTX, flags: c_int) void;
pub extern fn EVP_MD_CTX_clear_flags(ctx: ?*EVP_MD_CTX, flags: c_int) void;
pub extern fn EVP_MD_CTX_test_flags(ctx: ?*const EVP_MD_CTX, flags: c_int) c_int;
pub extern fn EVP_DigestInit_ex2(ctx: ?*EVP_MD_CTX, @"type": ?*const EVP_MD, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_DigestInit_ex(ctx: ?*EVP_MD_CTX, @"type": ?*const EVP_MD, impl: ?*ENGINE) c_int;
pub extern fn EVP_DigestUpdate(ctx: ?*EVP_MD_CTX, d: ?*const anyopaque, cnt: usize) c_int;
pub extern fn EVP_DigestFinal_ex(ctx: ?*EVP_MD_CTX, md: [*c]u8, s: [*c]c_uint) c_int;
pub extern fn EVP_Digest(data: ?*const anyopaque, count: usize, md: [*c]u8, size: [*c]c_uint, @"type": ?*const EVP_MD, impl: ?*ENGINE) c_int;
pub extern fn EVP_Q_digest(libctx: ?*OSSL_LIB_CTX, name: [*c]const u8, propq: [*c]const u8, data: ?*const anyopaque, datalen: usize, md: [*c]u8, mdlen: [*c]usize) c_int;
pub extern fn EVP_MD_CTX_copy(out: ?*EVP_MD_CTX, in: ?*const EVP_MD_CTX) c_int;
pub extern fn EVP_DigestInit(ctx: ?*EVP_MD_CTX, @"type": ?*const EVP_MD) c_int;
pub extern fn EVP_DigestFinal(ctx: ?*EVP_MD_CTX, md: [*c]u8, s: [*c]c_uint) c_int;
pub extern fn EVP_DigestFinalXOF(ctx: ?*EVP_MD_CTX, out: [*c]u8, outlen: usize) c_int;
pub extern fn EVP_DigestSqueeze(ctx: ?*EVP_MD_CTX, out: [*c]u8, outlen: usize) c_int;
pub extern fn EVP_MD_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_MD;
pub extern fn EVP_MD_up_ref(md: ?*EVP_MD) c_int;
pub extern fn EVP_MD_free(md: ?*EVP_MD) void;
pub extern fn EVP_read_pw_string(buf: [*c]u8, length: c_int, prompt: [*c]const u8, verify: c_int) c_int;
pub extern fn EVP_read_pw_string_min(buf: [*c]u8, minlen: c_int, maxlen: c_int, prompt: [*c]const u8, verify: c_int) c_int;
pub extern fn EVP_set_pw_prompt(prompt: [*c]const u8) void;
pub extern fn EVP_get_pw_prompt() [*c]u8;
pub extern fn EVP_BytesToKey(@"type": ?*const EVP_CIPHER, md: ?*const EVP_MD, salt: [*c]const u8, data: [*c]const u8, datal: c_int, count: c_int, key: [*c]u8, iv: [*c]u8) c_int;
pub extern fn EVP_CIPHER_CTX_set_flags(ctx: ?*EVP_CIPHER_CTX, flags: c_int) void;
pub extern fn EVP_CIPHER_CTX_clear_flags(ctx: ?*EVP_CIPHER_CTX, flags: c_int) void;
pub extern fn EVP_CIPHER_CTX_test_flags(ctx: ?*const EVP_CIPHER_CTX, flags: c_int) c_int;
pub extern fn EVP_EncryptInit(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8) c_int;
pub extern fn EVP_EncryptInit_ex(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, impl: ?*ENGINE, key: [*c]const u8, iv: [*c]const u8) c_int;
pub extern fn EVP_EncryptInit_ex2(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_EncryptUpdate(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_EncryptFinal_ex(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_EncryptFinal(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_DecryptInit(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8) c_int;
pub extern fn EVP_DecryptInit_ex(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, impl: ?*ENGINE, key: [*c]const u8, iv: [*c]const u8) c_int;
pub extern fn EVP_DecryptInit_ex2(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_DecryptUpdate(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_DecryptFinal(ctx: ?*EVP_CIPHER_CTX, outm: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_DecryptFinal_ex(ctx: ?*EVP_CIPHER_CTX, outm: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_CipherInit(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8, enc: c_int) c_int;
pub extern fn EVP_CipherInit_ex(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, impl: ?*ENGINE, key: [*c]const u8, iv: [*c]const u8, enc: c_int) c_int;
pub extern fn EVP_CipherInit_ex2(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8, enc: c_int, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_CipherUpdate(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_CipherFinal(ctx: ?*EVP_CIPHER_CTX, outm: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_CipherFinal_ex(ctx: ?*EVP_CIPHER_CTX, outm: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_SignFinal(ctx: ?*EVP_MD_CTX, md: [*c]u8, s: [*c]c_uint, pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_SignFinal_ex(ctx: ?*EVP_MD_CTX, md: [*c]u8, s: [*c]c_uint, pkey: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_DigestSign(ctx: ?*EVP_MD_CTX, sigret: [*c]u8, siglen: [*c]usize, tbs: [*c]const u8, tbslen: usize) c_int;
pub extern fn EVP_VerifyFinal(ctx: ?*EVP_MD_CTX, sigbuf: [*c]const u8, siglen: c_uint, pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_VerifyFinal_ex(ctx: ?*EVP_MD_CTX, sigbuf: [*c]const u8, siglen: c_uint, pkey: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_DigestVerify(ctx: ?*EVP_MD_CTX, sigret: [*c]const u8, siglen: usize, tbs: [*c]const u8, tbslen: usize) c_int;
pub extern fn EVP_DigestSignInit_ex(ctx: ?*EVP_MD_CTX, pctx: [*c]?*EVP_PKEY_CTX, mdname: [*c]const u8, libctx: ?*OSSL_LIB_CTX, props: [*c]const u8, pkey: ?*EVP_PKEY, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_DigestSignInit(ctx: ?*EVP_MD_CTX, pctx: [*c]?*EVP_PKEY_CTX, @"type": ?*const EVP_MD, e: ?*ENGINE, pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_DigestSignUpdate(ctx: ?*EVP_MD_CTX, data: ?*const anyopaque, dsize: usize) c_int;
pub extern fn EVP_DigestSignFinal(ctx: ?*EVP_MD_CTX, sigret: [*c]u8, siglen: [*c]usize) c_int;
pub extern fn EVP_DigestVerifyInit_ex(ctx: ?*EVP_MD_CTX, pctx: [*c]?*EVP_PKEY_CTX, mdname: [*c]const u8, libctx: ?*OSSL_LIB_CTX, props: [*c]const u8, pkey: ?*EVP_PKEY, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_DigestVerifyInit(ctx: ?*EVP_MD_CTX, pctx: [*c]?*EVP_PKEY_CTX, @"type": ?*const EVP_MD, e: ?*ENGINE, pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_DigestVerifyUpdate(ctx: ?*EVP_MD_CTX, data: ?*const anyopaque, dsize: usize) c_int;
pub extern fn EVP_DigestVerifyFinal(ctx: ?*EVP_MD_CTX, sig: [*c]const u8, siglen: usize) c_int;
pub extern fn EVP_OpenInit(ctx: ?*EVP_CIPHER_CTX, @"type": ?*const EVP_CIPHER, ek: [*c]const u8, ekl: c_int, iv: [*c]const u8, priv: ?*EVP_PKEY) c_int;
pub extern fn EVP_OpenFinal(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_SealInit(ctx: ?*EVP_CIPHER_CTX, @"type": ?*const EVP_CIPHER, ek: [*c][*c]u8, ekl: [*c]c_int, iv: [*c]u8, pubk: [*c]?*EVP_PKEY, npubk: c_int) c_int;
pub extern fn EVP_SealFinal(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_ENCODE_CTX_new() ?*EVP_ENCODE_CTX;
pub extern fn EVP_ENCODE_CTX_free(ctx: ?*EVP_ENCODE_CTX) void;
pub extern fn EVP_ENCODE_CTX_copy(dctx: ?*EVP_ENCODE_CTX, sctx: ?*const EVP_ENCODE_CTX) c_int;
pub extern fn EVP_ENCODE_CTX_num(ctx: ?*EVP_ENCODE_CTX) c_int;
pub extern fn EVP_EncodeInit(ctx: ?*EVP_ENCODE_CTX) void;
pub extern fn EVP_EncodeUpdate(ctx: ?*EVP_ENCODE_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_EncodeFinal(ctx: ?*EVP_ENCODE_CTX, out: [*c]u8, outl: [*c]c_int) void;
pub extern fn EVP_EncodeBlock(t: [*c]u8, f: [*c]const u8, n: c_int) c_int;
pub extern fn EVP_DecodeInit(ctx: ?*EVP_ENCODE_CTX) void;
pub extern fn EVP_DecodeUpdate(ctx: ?*EVP_ENCODE_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_DecodeFinal(ctx: ?*EVP_ENCODE_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_DecodeBlock(t: [*c]u8, f: [*c]const u8, n: c_int) c_int;
pub extern fn EVP_CIPHER_CTX_new() ?*EVP_CIPHER_CTX;
pub extern fn EVP_CIPHER_CTX_reset(c: ?*EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_free(c: ?*EVP_CIPHER_CTX) void;
pub extern fn EVP_CIPHER_CTX_set_key_length(x: ?*EVP_CIPHER_CTX, keylen: c_int) c_int;
pub extern fn EVP_CIPHER_CTX_set_padding(c: ?*EVP_CIPHER_CTX, pad: c_int) c_int;
pub extern fn EVP_CIPHER_CTX_ctrl(ctx: ?*EVP_CIPHER_CTX, @"type": c_int, arg: c_int, ptr: ?*anyopaque) c_int;
pub extern fn EVP_CIPHER_CTX_rand_key(ctx: ?*EVP_CIPHER_CTX, key: [*c]u8) c_int;
pub extern fn EVP_CIPHER_get_params(cipher: ?*EVP_CIPHER, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_CIPHER_CTX_set_params(ctx: ?*EVP_CIPHER_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_CIPHER_CTX_get_params(ctx: ?*EVP_CIPHER_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_CIPHER_gettable_params(cipher: ?*const EVP_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_settable_ctx_params(cipher: ?*const EVP_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_gettable_ctx_params(cipher: ?*const EVP_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_CTX_settable_params(ctx: ?*EVP_CIPHER_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_CTX_gettable_params(ctx: ?*EVP_CIPHER_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_CTX_set_algor_params(ctx: ?*EVP_CIPHER_CTX, alg: [*c]const X509_ALGOR) c_int;
pub extern fn EVP_CIPHER_CTX_get_algor_params(ctx: ?*EVP_CIPHER_CTX, alg: [*c]X509_ALGOR) c_int;
pub extern fn EVP_CIPHER_CTX_get_algor(ctx: ?*EVP_CIPHER_CTX, alg: [*c][*c]X509_ALGOR) c_int;
pub extern fn BIO_f_md() ?*const BIO_METHOD;
pub extern fn BIO_f_base64() ?*const BIO_METHOD;
pub extern fn BIO_f_cipher() ?*const BIO_METHOD;
pub extern fn BIO_f_reliable() ?*const BIO_METHOD;
pub extern fn BIO_set_cipher(b: ?*BIO, c: ?*const EVP_CIPHER, k: [*c]const u8, i: [*c]const u8, enc: c_int) c_int;
pub extern fn EVP_md_null() ?*const EVP_MD;
pub extern fn EVP_md4() ?*const EVP_MD;
pub extern fn EVP_md5() ?*const EVP_MD;
pub extern fn EVP_md5_sha1() ?*const EVP_MD;
pub extern fn EVP_blake2b512() ?*const EVP_MD;
pub extern fn EVP_blake2s256() ?*const EVP_MD;
pub extern fn EVP_sha1() ?*const EVP_MD;
pub extern fn EVP_sha224() ?*const EVP_MD;
pub extern fn EVP_sha256() ?*const EVP_MD;
pub extern fn EVP_sha384() ?*const EVP_MD;
pub extern fn EVP_sha512() ?*const EVP_MD;
pub extern fn EVP_sha512_224() ?*const EVP_MD;
pub extern fn EVP_sha512_256() ?*const EVP_MD;
pub extern fn EVP_sha3_224() ?*const EVP_MD;
pub extern fn EVP_sha3_256() ?*const EVP_MD;
pub extern fn EVP_sha3_384() ?*const EVP_MD;
pub extern fn EVP_sha3_512() ?*const EVP_MD;
pub extern fn EVP_shake128() ?*const EVP_MD;
pub extern fn EVP_shake256() ?*const EVP_MD;
pub extern fn EVP_mdc2() ?*const EVP_MD;
pub extern fn EVP_ripemd160() ?*const EVP_MD;
pub extern fn EVP_whirlpool() ?*const EVP_MD;
pub extern fn EVP_sm3() ?*const EVP_MD;
pub extern fn EVP_enc_null() ?*const EVP_CIPHER;
pub extern fn EVP_des_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_des_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_des_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_des_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_des_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_des_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_desx_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_wrap() ?*const EVP_CIPHER;
pub extern fn EVP_rc4() ?*const EVP_CIPHER;
pub extern fn EVP_rc4_40() ?*const EVP_CIPHER;
pub extern fn EVP_rc4_hmac_md5() ?*const EVP_CIPHER;
pub extern fn EVP_idea_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_idea_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_idea_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_idea_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_40_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_64_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_bf_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_bf_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_bf_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_bf_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_cast5_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_cast5_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_cast5_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_cast5_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_xts() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_wrap() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_wrap_pad() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ocb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_wrap() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_wrap_pad() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ocb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_xts() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_wrap() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_wrap_pad() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ocb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cbc_hmac_sha1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cbc_hmac_sha1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cbc_hmac_sha256() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cbc_hmac_sha256() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_chacha20() ?*const EVP_CIPHER;
pub extern fn EVP_chacha20_poly1305() ?*const EVP_CIPHER;
pub extern fn EVP_seed_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_seed_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_seed_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_seed_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_add_cipher(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_add_digest(digest: ?*const EVP_MD) c_int;
pub extern fn EVP_get_cipherbyname(name: [*c]const u8) ?*const EVP_CIPHER;
pub extern fn EVP_get_digestbyname(name: [*c]const u8) ?*const EVP_MD;
pub extern fn EVP_CIPHER_do_all(@"fn": ?*const fn (?*const EVP_CIPHER, [*c]const u8, [*c]const u8, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_CIPHER_do_all_sorted(@"fn": ?*const fn (?*const EVP_CIPHER, [*c]const u8, [*c]const u8, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_CIPHER_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_CIPHER, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_MD_do_all(@"fn": ?*const fn (?*const EVP_MD, [*c]const u8, [*c]const u8, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_MD_do_all_sorted(@"fn": ?*const fn (?*const EVP_MD, [*c]const u8, [*c]const u8, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_MD_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_MD, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_MAC_fetch(libctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_MAC;
pub extern fn EVP_MAC_up_ref(mac: ?*EVP_MAC) c_int;
pub extern fn EVP_MAC_free(mac: ?*EVP_MAC) void;
pub extern fn EVP_MAC_get0_name(mac: ?*const EVP_MAC) [*c]const u8;
pub extern fn EVP_MAC_get0_description(mac: ?*const EVP_MAC) [*c]const u8;
pub extern fn EVP_MAC_is_a(mac: ?*const EVP_MAC, name: [*c]const u8) c_int;
pub extern fn EVP_MAC_get0_provider(mac: ?*const EVP_MAC) ?*const OSSL_PROVIDER;
pub extern fn EVP_MAC_get_params(mac: ?*EVP_MAC, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_MAC_CTX_new(mac: ?*EVP_MAC) ?*EVP_MAC_CTX;
pub extern fn EVP_MAC_CTX_free(ctx: ?*EVP_MAC_CTX) void;
pub extern fn EVP_MAC_CTX_dup(src: ?*const EVP_MAC_CTX) ?*EVP_MAC_CTX;
pub extern fn EVP_MAC_CTX_get0_mac(ctx: ?*EVP_MAC_CTX) ?*EVP_MAC;
pub extern fn EVP_MAC_CTX_get_params(ctx: ?*EVP_MAC_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_MAC_CTX_set_params(ctx: ?*EVP_MAC_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_MAC_CTX_get_mac_size(ctx: ?*EVP_MAC_CTX) usize;
pub extern fn EVP_MAC_CTX_get_block_size(ctx: ?*EVP_MAC_CTX) usize;
pub extern fn EVP_Q_mac(libctx: ?*OSSL_LIB_CTX, name: [*c]const u8, propq: [*c]const u8, subalg: [*c]const u8, params: [*c]const OSSL_PARAM, key: ?*const anyopaque, keylen: usize, data: [*c]const u8, datalen: usize, out: [*c]u8, outsize: usize, outlen: [*c]usize) [*c]u8;
pub extern fn EVP_MAC_init(ctx: ?*EVP_MAC_CTX, key: [*c]const u8, keylen: usize, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_MAC_update(ctx: ?*EVP_MAC_CTX, data: [*c]const u8, datalen: usize) c_int;
pub extern fn EVP_MAC_final(ctx: ?*EVP_MAC_CTX, out: [*c]u8, outl: [*c]usize, outsize: usize) c_int;
pub extern fn EVP_MAC_finalXOF(ctx: ?*EVP_MAC_CTX, out: [*c]u8, outsize: usize) c_int;
pub extern fn EVP_MAC_gettable_params(mac: ?*const EVP_MAC) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_gettable_ctx_params(mac: ?*const EVP_MAC) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_settable_ctx_params(mac: ?*const EVP_MAC) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_CTX_gettable_params(ctx: ?*EVP_MAC_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_CTX_settable_params(ctx: ?*EVP_MAC_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_MAC, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_MAC_names_do_all(mac: ?*const EVP_MAC, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_RAND_fetch(libctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_RAND;
pub extern fn EVP_RAND_up_ref(rand: ?*EVP_RAND) c_int;
pub extern fn EVP_RAND_free(rand: ?*EVP_RAND) void;
pub extern fn EVP_RAND_get0_name(rand: ?*const EVP_RAND) [*c]const u8;
pub extern fn EVP_RAND_get0_description(md: ?*const EVP_RAND) [*c]const u8;
pub extern fn EVP_RAND_is_a(rand: ?*const EVP_RAND, name: [*c]const u8) c_int;
pub extern fn EVP_RAND_get0_provider(rand: ?*const EVP_RAND) ?*const OSSL_PROVIDER;
pub extern fn EVP_RAND_get_params(rand: ?*EVP_RAND, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_RAND_CTX_new(rand: ?*EVP_RAND, parent: ?*EVP_RAND_CTX) ?*EVP_RAND_CTX;
pub extern fn EVP_RAND_CTX_up_ref(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_RAND_CTX_free(ctx: ?*EVP_RAND_CTX) void;
pub extern fn EVP_RAND_CTX_get0_rand(ctx: ?*EVP_RAND_CTX) ?*EVP_RAND;
pub extern fn EVP_RAND_CTX_get_params(ctx: ?*EVP_RAND_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_RAND_CTX_set_params(ctx: ?*EVP_RAND_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_RAND_gettable_params(rand: ?*const EVP_RAND) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_gettable_ctx_params(rand: ?*const EVP_RAND) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_settable_ctx_params(rand: ?*const EVP_RAND) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_CTX_gettable_params(ctx: ?*EVP_RAND_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_CTX_settable_params(ctx: ?*EVP_RAND_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_RAND, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_RAND_names_do_all(rand: ?*const EVP_RAND, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_RAND_instantiate(ctx: ?*EVP_RAND_CTX, strength: c_uint, prediction_resistance: c_int, pstr: [*c]const u8, pstr_len: usize, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_RAND_uninstantiate(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_RAND_generate(ctx: ?*EVP_RAND_CTX, out: [*c]u8, outlen: usize, strength: c_uint, prediction_resistance: c_int, addin: [*c]const u8, addin_len: usize) c_int;
pub extern fn EVP_RAND_reseed(ctx: ?*EVP_RAND_CTX, prediction_resistance: c_int, ent: [*c]const u8, ent_len: usize, addin: [*c]const u8, addin_len: usize) c_int;
pub extern fn EVP_RAND_nonce(ctx: ?*EVP_RAND_CTX, out: [*c]u8, outlen: usize) c_int;
pub extern fn EVP_RAND_enable_locking(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_RAND_verify_zeroization(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_RAND_get_strength(ctx: ?*EVP_RAND_CTX) c_uint;
pub extern fn EVP_RAND_get_state(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_PKEY_decrypt_old(dec_key: [*c]u8, enc_key: [*c]const u8, enc_key_len: c_int, private_key: ?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_encrypt_old(enc_key: [*c]u8, key: [*c]const u8, key_len: c_int, pub_key: ?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_is_a(pkey: ?*const EVP_PKEY, name: [*c]const u8) c_int;
pub extern fn EVP_PKEY_type_names_do_all(pkey: ?*const EVP_PKEY, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_type(@"type": c_int) c_int;
pub extern fn EVP_PKEY_get_id(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_base_id(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_bits(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_security_bits(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_size(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_can_sign(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_set_type(pkey: ?*EVP_PKEY, @"type": c_int) c_int;
pub extern fn EVP_PKEY_set_type_str(pkey: ?*EVP_PKEY, str: [*c]const u8, len: c_int) c_int;
pub extern fn EVP_PKEY_set_type_by_keymgmt(pkey: ?*EVP_PKEY, keymgmt: ?*EVP_KEYMGMT) c_int;
pub extern fn EVP_PKEY_set1_engine(pkey: ?*EVP_PKEY, e: ?*ENGINE) c_int;
pub extern fn EVP_PKEY_get0_engine(pkey: ?*const EVP_PKEY) ?*ENGINE;
pub extern fn EVP_PKEY_assign(pkey: ?*EVP_PKEY, @"type": c_int, key: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_get0(pkey: ?*const EVP_PKEY) ?*anyopaque;
pub extern fn EVP_PKEY_get0_hmac(pkey: ?*const EVP_PKEY, len: [*c]usize) [*c]const u8;
pub extern fn EVP_PKEY_get0_poly1305(pkey: ?*const EVP_PKEY, len: [*c]usize) [*c]const u8;
pub extern fn EVP_PKEY_get0_siphash(pkey: ?*const EVP_PKEY, len: [*c]usize) [*c]const u8;
pub extern fn EVP_PKEY_set1_RSA(pkey: ?*EVP_PKEY, key: ?*struct_rsa_st) c_int;
pub extern fn EVP_PKEY_get0_RSA(pkey: ?*const EVP_PKEY) ?*const struct_rsa_st;
pub extern fn EVP_PKEY_get1_RSA(pkey: ?*EVP_PKEY) ?*struct_rsa_st;
pub extern fn EVP_PKEY_set1_DSA(pkey: ?*EVP_PKEY, key: ?*struct_dsa_st) c_int;
pub extern fn EVP_PKEY_get0_DSA(pkey: ?*const EVP_PKEY) ?*const struct_dsa_st;
pub extern fn EVP_PKEY_get1_DSA(pkey: ?*EVP_PKEY) ?*struct_dsa_st;
pub extern fn EVP_PKEY_set1_DH(pkey: ?*EVP_PKEY, key: ?*struct_dh_st) c_int;
pub extern fn EVP_PKEY_get0_DH(pkey: ?*const EVP_PKEY) ?*const struct_dh_st;
pub extern fn EVP_PKEY_get1_DH(pkey: ?*EVP_PKEY) ?*struct_dh_st;
pub extern fn EVP_PKEY_set1_EC_KEY(pkey: ?*EVP_PKEY, key: ?*struct_ec_key_st) c_int;
pub extern fn EVP_PKEY_get0_EC_KEY(pkey: ?*const EVP_PKEY) ?*const struct_ec_key_st;
pub extern fn EVP_PKEY_get1_EC_KEY(pkey: ?*EVP_PKEY) ?*struct_ec_key_st;
pub extern fn EVP_PKEY_new() ?*EVP_PKEY;
pub extern fn EVP_PKEY_up_ref(pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_dup(pkey: ?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn EVP_PKEY_free(pkey: ?*EVP_PKEY) void;
pub extern fn EVP_PKEY_get0_description(pkey: ?*const EVP_PKEY) [*c]const u8;
pub extern fn EVP_PKEY_get0_provider(key: ?*const EVP_PKEY) ?*const OSSL_PROVIDER;
pub extern fn d2i_PublicKey(@"type": c_int, a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn i2d_PublicKey(a: ?*const EVP_PKEY, pp: [*c][*c]u8) c_int;
pub extern fn d2i_PrivateKey_ex(@"type": c_int, a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PrivateKey(@"type": c_int, a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn d2i_AutoPrivateKey_ex(a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_AutoPrivateKey(a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn i2d_PrivateKey(a: ?*const EVP_PKEY, pp: [*c][*c]u8) c_int;
pub extern fn i2d_KeyParams(a: ?*const EVP_PKEY, pp: [*c][*c]u8) c_int;
pub extern fn d2i_KeyParams(@"type": c_int, a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn i2d_KeyParams_bio(bp: ?*BIO, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_KeyParams_bio(@"type": c_int, a: [*c]?*EVP_PKEY, in: ?*BIO) ?*EVP_PKEY;
pub extern fn EVP_PKEY_copy_parameters(to: ?*EVP_PKEY, from: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_missing_parameters(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_save_parameters(pkey: ?*EVP_PKEY, mode: c_int) c_int;
pub extern fn EVP_PKEY_parameters_eq(a: ?*const EVP_PKEY, b: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_eq(a: ?*const EVP_PKEY, b: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_cmp_parameters(a: ?*const EVP_PKEY, b: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_cmp(a: ?*const EVP_PKEY, b: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_print_public(out: ?*BIO, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_private(out: ?*BIO, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_params(out: ?*BIO, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_public_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_private_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_params_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_get_default_digest_nid(pkey: ?*EVP_PKEY, pnid: [*c]c_int) c_int;
pub extern fn EVP_PKEY_get_default_digest_name(pkey: ?*EVP_PKEY, mdname: [*c]u8, mdname_sz: usize) c_int;
pub extern fn EVP_PKEY_digestsign_supports_digest(pkey: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, name: [*c]const u8, propq: [*c]const u8) c_int;
pub extern fn EVP_PKEY_set1_encoded_public_key(pkey: ?*EVP_PKEY, @"pub": [*c]const u8, publen: usize) c_int;
pub extern fn EVP_PKEY_get1_encoded_public_key(pkey: ?*EVP_PKEY, ppub: [*c][*c]u8) usize;
pub extern fn EVP_CIPHER_param_to_asn1(c: ?*EVP_CIPHER_CTX, @"type": [*c]ASN1_TYPE) c_int;
pub extern fn EVP_CIPHER_asn1_to_param(c: ?*EVP_CIPHER_CTX, @"type": [*c]ASN1_TYPE) c_int;
pub extern fn EVP_CIPHER_set_asn1_iv(c: ?*EVP_CIPHER_CTX, @"type": [*c]ASN1_TYPE) c_int;
pub extern fn EVP_CIPHER_get_asn1_iv(c: ?*EVP_CIPHER_CTX, @"type": [*c]ASN1_TYPE) c_int;
pub extern fn PKCS5_PBE_keyivgen(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int) c_int;
pub extern fn PKCS5_PBE_keyivgen_ex(cctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PKCS5_PBKDF2_HMAC_SHA1(pass: [*c]const u8, passlen: c_int, salt: [*c]const u8, saltlen: c_int, iter: c_int, keylen: c_int, out: [*c]u8) c_int;
pub extern fn PKCS5_PBKDF2_HMAC(pass: [*c]const u8, passlen: c_int, salt: [*c]const u8, saltlen: c_int, iter: c_int, digest: ?*const EVP_MD, keylen: c_int, out: [*c]u8) c_int;
pub extern fn PKCS5_v2_PBE_keyivgen(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int) c_int;
pub extern fn PKCS5_v2_PBE_keyivgen_ex(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_PBE_scrypt(pass: [*c]const u8, passlen: usize, salt: [*c]const u8, saltlen: usize, N: u64, r: u64, p: u64, maxmem: u64, key: [*c]u8, keylen: usize) c_int;
pub extern fn EVP_PBE_scrypt_ex(pass: [*c]const u8, passlen: usize, salt: [*c]const u8, saltlen: usize, N: u64, r: u64, p: u64, maxmem: u64, key: [*c]u8, keylen: usize, ctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PKCS5_v2_scrypt_keyivgen(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, c: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int) c_int;
pub extern fn PKCS5_v2_scrypt_keyivgen_ex(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, c: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PKCS5_PBE_add() void;
pub extern fn EVP_PBE_CipherInit(pbe_obj: ?*ASN1_OBJECT, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, ctx: ?*EVP_CIPHER_CTX, en_de: c_int) c_int;
pub extern fn EVP_PBE_CipherInit_ex(pbe_obj: ?*ASN1_OBJECT, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, ctx: ?*EVP_CIPHER_CTX, en_de: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_PBE_alg_add_type(pbe_type: c_int, pbe_nid: c_int, cipher_nid: c_int, md_nid: c_int, keygen: ?*const EVP_PBE_KEYGEN) c_int;
pub extern fn EVP_PBE_alg_add(nid: c_int, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, keygen: ?*const EVP_PBE_KEYGEN) c_int;
pub extern fn EVP_PBE_find(@"type": c_int, pbe_nid: c_int, pcnid: [*c]c_int, pmnid: [*c]c_int, pkeygen: [*c]?*const EVP_PBE_KEYGEN) c_int;
pub extern fn EVP_PBE_find_ex(@"type": c_int, pbe_nid: c_int, pcnid: [*c]c_int, pmnid: [*c]c_int, pkeygen: [*c]?*const EVP_PBE_KEYGEN, pkeygen_ex: [*c]?*const EVP_PBE_KEYGEN_EX) c_int;
pub extern fn EVP_PBE_cleanup() void;
pub extern fn EVP_PBE_get(ptype: [*c]c_int, ppbe_nid: [*c]c_int, num: usize) c_int;
pub extern fn EVP_PKEY_asn1_get_count() c_int;
pub extern fn EVP_PKEY_asn1_get0(idx: c_int) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_find(pe: [*c]?*ENGINE, @"type": c_int) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_find_str(pe: [*c]?*ENGINE, str: [*c]const u8, len: c_int) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_add0(ameth: ?*const EVP_PKEY_ASN1_METHOD) c_int;
pub extern fn EVP_PKEY_asn1_add_alias(to: c_int, from: c_int) c_int;
pub extern fn EVP_PKEY_asn1_get0_info(ppkey_id: [*c]c_int, pkey_base_id: [*c]c_int, ppkey_flags: [*c]c_int, pinfo: [*c][*c]const u8, ppem_str: [*c][*c]const u8, ameth: ?*const EVP_PKEY_ASN1_METHOD) c_int;
pub extern fn EVP_PKEY_get0_asn1(pkey: ?*const EVP_PKEY) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_new(id: c_int, flags: c_int, pem_str: [*c]const u8, info: [*c]const u8) ?*EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_copy(dst: ?*EVP_PKEY_ASN1_METHOD, src: ?*const EVP_PKEY_ASN1_METHOD) void;
pub extern fn EVP_PKEY_asn1_free(ameth: ?*EVP_PKEY_ASN1_METHOD) void;
pub extern fn EVP_PKEY_asn1_set_public(ameth: ?*EVP_PKEY_ASN1_METHOD, pub_decode: ?*const fn (?*EVP_PKEY, ?*const X509_PUBKEY) callconv(.C) c_int, pub_encode: ?*const fn (?*X509_PUBKEY, ?*const EVP_PKEY) callconv(.C) c_int, pub_cmp: ?*const fn (?*const EVP_PKEY, ?*const EVP_PKEY) callconv(.C) c_int, pub_print: ?*const fn (?*BIO, ?*const EVP_PKEY, c_int, ?*ASN1_PCTX) callconv(.C) c_int, pkey_size: ?*const fn (?*const EVP_PKEY) callconv(.C) c_int, pkey_bits: ?*const fn (?*const EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_private(ameth: ?*EVP_PKEY_ASN1_METHOD, priv_decode: ?*const fn (?*EVP_PKEY, ?*const PKCS8_PRIV_KEY_INFO) callconv(.C) c_int, priv_encode: ?*const fn (?*PKCS8_PRIV_KEY_INFO, ?*const EVP_PKEY) callconv(.C) c_int, priv_print: ?*const fn (?*BIO, ?*const EVP_PKEY, c_int, ?*ASN1_PCTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_param(ameth: ?*EVP_PKEY_ASN1_METHOD, param_decode: ?*const fn (?*EVP_PKEY, [*c][*c]const u8, c_int) callconv(.C) c_int, param_encode: ?*const fn (?*const EVP_PKEY, [*c][*c]u8) callconv(.C) c_int, param_missing: ?*const fn (?*const EVP_PKEY) callconv(.C) c_int, param_copy: ?*const fn (?*EVP_PKEY, ?*const EVP_PKEY) callconv(.C) c_int, param_cmp: ?*const fn (?*const EVP_PKEY, ?*const EVP_PKEY) callconv(.C) c_int, param_print: ?*const fn (?*BIO, ?*const EVP_PKEY, c_int, ?*ASN1_PCTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_free(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_free: ?*const fn (?*EVP_PKEY) callconv(.C) void) void;
pub extern fn EVP_PKEY_asn1_set_ctrl(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_ctrl: ?*const fn (?*EVP_PKEY, c_int, c_long, ?*anyopaque) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_item(ameth: ?*EVP_PKEY_ASN1_METHOD, item_verify: ?*const fn (?*EVP_MD_CTX, ?*const ASN1_ITEM, ?*const anyopaque, [*c]const X509_ALGOR, [*c]const ASN1_BIT_STRING, ?*EVP_PKEY) callconv(.C) c_int, item_sign: ?*const fn (?*EVP_MD_CTX, ?*const ASN1_ITEM, ?*const anyopaque, [*c]X509_ALGOR, [*c]X509_ALGOR, [*c]ASN1_BIT_STRING) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_siginf(ameth: ?*EVP_PKEY_ASN1_METHOD, siginf_set: ?*const fn (?*X509_SIG_INFO, [*c]const X509_ALGOR, [*c]const ASN1_STRING) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_check(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_check: ?*const fn (?*const EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_public_check(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_pub_check: ?*const fn (?*const EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_param_check(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_param_check: ?*const fn (?*const EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_set_priv_key(ameth: ?*EVP_PKEY_ASN1_METHOD, set_priv_key: ?*const fn (?*EVP_PKEY, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_set_pub_key(ameth: ?*EVP_PKEY_ASN1_METHOD, set_pub_key: ?*const fn (?*EVP_PKEY, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_get_priv_key(ameth: ?*EVP_PKEY_ASN1_METHOD, get_priv_key: ?*const fn (?*const EVP_PKEY, [*c]u8, [*c]usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_get_pub_key(ameth: ?*EVP_PKEY_ASN1_METHOD, get_pub_key: ?*const fn (?*const EVP_PKEY, [*c]u8, [*c]usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_asn1_set_security_bits(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_security_bits: ?*const fn (?*const EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_CTX_get_signature_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_signature_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set1_id(ctx: ?*EVP_PKEY_CTX, id: ?*const anyopaque, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get1_id(ctx: ?*EVP_PKEY_CTX, id: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_CTX_get1_id_len(ctx: ?*EVP_PKEY_CTX, id_len: [*c]usize) c_int;
pub extern fn EVP_PKEY_CTX_set_kem_op(ctx: ?*EVP_PKEY_CTX, op: [*c]const u8) c_int;
pub extern fn EVP_PKEY_get0_type_name(key: ?*const EVP_PKEY) [*c]const u8;
pub extern fn EVP_PKEY_CTX_set_mac_key(ctx: ?*EVP_PKEY_CTX, key: [*c]const u8, keylen: c_int) c_int;
pub extern fn EVP_PKEY_meth_find(@"type": c_int) ?*const EVP_PKEY_METHOD;
pub extern fn EVP_PKEY_meth_new(id: c_int, flags: c_int) ?*EVP_PKEY_METHOD;
pub extern fn EVP_PKEY_meth_get0_info(ppkey_id: [*c]c_int, pflags: [*c]c_int, meth: ?*const EVP_PKEY_METHOD) void;
pub extern fn EVP_PKEY_meth_copy(dst: ?*EVP_PKEY_METHOD, src: ?*const EVP_PKEY_METHOD) void;
pub extern fn EVP_PKEY_meth_free(pmeth: ?*EVP_PKEY_METHOD) void;
pub extern fn EVP_PKEY_meth_add0(pmeth: ?*const EVP_PKEY_METHOD) c_int;
pub extern fn EVP_PKEY_meth_remove(pmeth: ?*const EVP_PKEY_METHOD) c_int;
pub extern fn EVP_PKEY_meth_get_count() usize;
pub extern fn EVP_PKEY_meth_get0(idx: usize) ?*const EVP_PKEY_METHOD;
pub extern fn EVP_KEYMGMT_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_KEYMGMT;
pub extern fn EVP_KEYMGMT_up_ref(keymgmt: ?*EVP_KEYMGMT) c_int;
pub extern fn EVP_KEYMGMT_free(keymgmt: ?*EVP_KEYMGMT) void;
pub extern fn EVP_KEYMGMT_get0_provider(keymgmt: ?*const EVP_KEYMGMT) ?*const OSSL_PROVIDER;
pub extern fn EVP_KEYMGMT_get0_name(keymgmt: ?*const EVP_KEYMGMT) [*c]const u8;
pub extern fn EVP_KEYMGMT_get0_description(keymgmt: ?*const EVP_KEYMGMT) [*c]const u8;
pub extern fn EVP_KEYMGMT_is_a(keymgmt: ?*const EVP_KEYMGMT, name: [*c]const u8) c_int;
pub extern fn EVP_KEYMGMT_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_KEYMGMT, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_KEYMGMT_names_do_all(keymgmt: ?*const EVP_KEYMGMT, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_KEYMGMT_gettable_params(keymgmt: ?*const EVP_KEYMGMT) [*c]const OSSL_PARAM;
pub extern fn EVP_KEYMGMT_settable_params(keymgmt: ?*const EVP_KEYMGMT) [*c]const OSSL_PARAM;
pub extern fn EVP_KEYMGMT_gen_settable_params(keymgmt: ?*const EVP_KEYMGMT) [*c]const OSSL_PARAM;
pub extern fn EVP_KEYMGMT_gen_gettable_params(keymgmt: ?*const EVP_KEYMGMT) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_CTX_new(pkey: ?*EVP_PKEY, e: ?*ENGINE) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_new_id(id: c_int, e: ?*ENGINE) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_new_from_name(libctx: ?*OSSL_LIB_CTX, name: [*c]const u8, propquery: [*c]const u8) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_new_from_pkey(libctx: ?*OSSL_LIB_CTX, pkey: ?*EVP_PKEY, propquery: [*c]const u8) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_dup(ctx: ?*const EVP_PKEY_CTX) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_free(ctx: ?*EVP_PKEY_CTX) void;
pub extern fn EVP_PKEY_CTX_is_a(ctx: ?*EVP_PKEY_CTX, keytype: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_params(ctx: ?*EVP_PKEY_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_CTX_gettable_params(ctx: ?*const EVP_PKEY_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_CTX_set_params(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_CTX_settable_params(ctx: ?*const EVP_PKEY_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_CTX_set_algor_params(ctx: ?*EVP_PKEY_CTX, alg: [*c]const X509_ALGOR) c_int;
pub extern fn EVP_PKEY_CTX_get_algor_params(ctx: ?*EVP_PKEY_CTX, alg: [*c]X509_ALGOR) c_int;
pub extern fn EVP_PKEY_CTX_get_algor(ctx: ?*EVP_PKEY_CTX, alg: [*c][*c]X509_ALGOR) c_int;
pub extern fn EVP_PKEY_CTX_ctrl(ctx: ?*EVP_PKEY_CTX, keytype: c_int, optype: c_int, cmd: c_int, p1: c_int, p2: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_CTX_ctrl_str(ctx: ?*EVP_PKEY_CTX, @"type": [*c]const u8, value: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_ctrl_uint64(ctx: ?*EVP_PKEY_CTX, keytype: c_int, optype: c_int, cmd: c_int, value: u64) c_int;
pub extern fn EVP_PKEY_CTX_str2ctrl(ctx: ?*EVP_PKEY_CTX, cmd: c_int, str: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_hex2ctrl(ctx: ?*EVP_PKEY_CTX, cmd: c_int, hex: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_md(ctx: ?*EVP_PKEY_CTX, optype: c_int, cmd: c_int, md: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_operation(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_CTX_set0_keygen_info(ctx: ?*EVP_PKEY_CTX, dat: [*c]c_int, datlen: c_int) void;
pub extern fn EVP_PKEY_new_mac_key(@"type": c_int, e: ?*ENGINE, key: [*c]const u8, keylen: c_int) ?*EVP_PKEY;
pub extern fn EVP_PKEY_new_raw_private_key_ex(libctx: ?*OSSL_LIB_CTX, keytype: [*c]const u8, propq: [*c]const u8, priv: [*c]const u8, len: usize) ?*EVP_PKEY;
pub extern fn EVP_PKEY_new_raw_private_key(@"type": c_int, e: ?*ENGINE, priv: [*c]const u8, len: usize) ?*EVP_PKEY;
pub extern fn EVP_PKEY_new_raw_public_key_ex(libctx: ?*OSSL_LIB_CTX, keytype: [*c]const u8, propq: [*c]const u8, @"pub": [*c]const u8, len: usize) ?*EVP_PKEY;
pub extern fn EVP_PKEY_new_raw_public_key(@"type": c_int, e: ?*ENGINE, @"pub": [*c]const u8, len: usize) ?*EVP_PKEY;
pub extern fn EVP_PKEY_get_raw_private_key(pkey: ?*const EVP_PKEY, priv: [*c]u8, len: [*c]usize) c_int;
pub extern fn EVP_PKEY_get_raw_public_key(pkey: ?*const EVP_PKEY, @"pub": [*c]u8, len: [*c]usize) c_int;
pub extern fn EVP_PKEY_new_CMAC_key(e: ?*ENGINE, priv: [*c]const u8, len: usize, cipher: ?*const EVP_CIPHER) ?*EVP_PKEY;
pub extern fn EVP_PKEY_CTX_set_data(ctx: ?*EVP_PKEY_CTX, data: ?*anyopaque) void;
pub extern fn EVP_PKEY_CTX_get_data(ctx: ?*const EVP_PKEY_CTX) ?*anyopaque;
pub extern fn EVP_PKEY_CTX_get0_pkey(ctx: ?*EVP_PKEY_CTX) ?*EVP_PKEY;
pub extern fn EVP_PKEY_CTX_get0_peerkey(ctx: ?*EVP_PKEY_CTX) ?*EVP_PKEY;
pub extern fn EVP_PKEY_CTX_set_app_data(ctx: ?*EVP_PKEY_CTX, data: ?*anyopaque) void;
pub extern fn EVP_PKEY_CTX_get_app_data(ctx: ?*EVP_PKEY_CTX) ?*anyopaque;
pub extern fn EVP_PKEY_CTX_set_signature(pctx: ?*EVP_PKEY_CTX, sig: [*c]const u8, siglen: usize) c_int;
pub extern fn EVP_SIGNATURE_free(signature: ?*EVP_SIGNATURE) void;
pub extern fn EVP_SIGNATURE_up_ref(signature: ?*EVP_SIGNATURE) c_int;
pub extern fn EVP_SIGNATURE_get0_provider(signature: ?*const EVP_SIGNATURE) ?*OSSL_PROVIDER;
pub extern fn EVP_SIGNATURE_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_SIGNATURE;
pub extern fn EVP_SIGNATURE_is_a(signature: ?*const EVP_SIGNATURE, name: [*c]const u8) c_int;
pub extern fn EVP_SIGNATURE_get0_name(signature: ?*const EVP_SIGNATURE) [*c]const u8;
pub extern fn EVP_SIGNATURE_get0_description(signature: ?*const EVP_SIGNATURE) [*c]const u8;
pub extern fn EVP_SIGNATURE_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_SIGNATURE, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) void;
pub extern fn EVP_SIGNATURE_names_do_all(signature: ?*const EVP_SIGNATURE, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_SIGNATURE_gettable_ctx_params(sig: ?*const EVP_SIGNATURE) [*c]const OSSL_PARAM;
pub extern fn EVP_SIGNATURE_settable_ctx_params(sig: ?*const EVP_SIGNATURE) [*c]const OSSL_PARAM;
pub extern fn EVP_ASYM_CIPHER_free(cipher: ?*EVP_ASYM_CIPHER) void;
pub extern fn EVP_ASYM_CIPHER_up_ref(cipher: ?*EVP_ASYM_CIPHER) c_int;
pub extern fn EVP_ASYM_CIPHER_get0_provider(cipher: ?*const EVP_ASYM_CIPHER) ?*OSSL_PROVIDER;
pub extern fn EVP_ASYM_CIPHER_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_ASYM_CIPHER;
pub extern fn EVP_ASYM_CIPHER_is_a(cipher: ?*const EVP_ASYM_CIPHER, name: [*c]const u8) c_int;
pub extern fn EVP_ASYM_CIPHER_get0_name(cipher: ?*const EVP_ASYM_CIPHER) [*c]const u8;
pub extern fn EVP_ASYM_CIPHER_get0_description(cipher: ?*const EVP_ASYM_CIPHER) [*c]const u8;
pub extern fn EVP_ASYM_CIPHER_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_ASYM_CIPHER, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_ASYM_CIPHER_names_do_all(cipher: ?*const EVP_ASYM_CIPHER, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_ASYM_CIPHER_gettable_ctx_params(ciph: ?*const EVP_ASYM_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_ASYM_CIPHER_settable_ctx_params(ciph: ?*const EVP_ASYM_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_KEM_free(wrap: ?*EVP_KEM) void;
pub extern fn EVP_KEM_up_ref(wrap: ?*EVP_KEM) c_int;
pub extern fn EVP_KEM_get0_provider(wrap: ?*const EVP_KEM) ?*OSSL_PROVIDER;
pub extern fn EVP_KEM_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_KEM;
pub extern fn EVP_KEM_is_a(wrap: ?*const EVP_KEM, name: [*c]const u8) c_int;
pub extern fn EVP_KEM_get0_name(wrap: ?*const EVP_KEM) [*c]const u8;
pub extern fn EVP_KEM_get0_description(wrap: ?*const EVP_KEM) [*c]const u8;
pub extern fn EVP_KEM_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_KEM, ?*anyopaque) callconv(.C) void, arg: ?*anyopaque) void;
pub extern fn EVP_KEM_names_do_all(wrap: ?*const EVP_KEM, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_KEM_gettable_ctx_params(kem: ?*const EVP_KEM) [*c]const OSSL_PARAM;
pub extern fn EVP_KEM_settable_ctx_params(kem: ?*const EVP_KEM) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_sign_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_sign_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_sign_init_ex2(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_sign(ctx: ?*EVP_PKEY_CTX, sig: [*c]u8, siglen: [*c]usize, tbs: [*c]const u8, tbslen: usize) c_int;
pub extern fn EVP_PKEY_sign_message_init(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_sign_message_update(ctx: ?*EVP_PKEY_CTX, in: [*c]const u8, inlen: usize) c_int;
pub extern fn EVP_PKEY_sign_message_final(ctx: ?*EVP_PKEY_CTX, sig: [*c]u8, siglen: [*c]usize) c_int;
pub extern fn EVP_PKEY_verify_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_verify_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify_init_ex2(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify(ctx: ?*EVP_PKEY_CTX, sig: [*c]const u8, siglen: usize, tbs: [*c]const u8, tbslen: usize) c_int;
pub extern fn EVP_PKEY_verify_message_init(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify_message_update(ctx: ?*EVP_PKEY_CTX, in: [*c]const u8, inlen: usize) c_int;
pub extern fn EVP_PKEY_verify_message_final(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_verify_recover_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_verify_recover_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify_recover_init_ex2(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify_recover(ctx: ?*EVP_PKEY_CTX, rout: [*c]u8, routlen: [*c]usize, sig: [*c]const u8, siglen: usize) c_int;
pub extern fn EVP_PKEY_encrypt_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_encrypt_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_encrypt(ctx: ?*EVP_PKEY_CTX, out: [*c]u8, outlen: [*c]usize, in: [*c]const u8, inlen: usize) c_int;
pub extern fn EVP_PKEY_decrypt_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_decrypt_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_decrypt(ctx: ?*EVP_PKEY_CTX, out: [*c]u8, outlen: [*c]usize, in: [*c]const u8, inlen: usize) c_int;
pub extern fn EVP_PKEY_derive_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_derive_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_derive_set_peer_ex(ctx: ?*EVP_PKEY_CTX, peer: ?*EVP_PKEY, validate_peer: c_int) c_int;
pub extern fn EVP_PKEY_derive_set_peer(ctx: ?*EVP_PKEY_CTX, peer: ?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_derive(ctx: ?*EVP_PKEY_CTX, key: [*c]u8, keylen: [*c]usize) c_int;
pub extern fn EVP_PKEY_encapsulate_init(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_auth_encapsulate_init(ctx: ?*EVP_PKEY_CTX, authpriv: ?*EVP_PKEY, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_encapsulate(ctx: ?*EVP_PKEY_CTX, wrappedkey: [*c]u8, wrappedkeylen: [*c]usize, genkey: [*c]u8, genkeylen: [*c]usize) c_int;
pub extern fn EVP_PKEY_decapsulate_init(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_auth_decapsulate_init(ctx: ?*EVP_PKEY_CTX, authpub: ?*EVP_PKEY, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_decapsulate(ctx: ?*EVP_PKEY_CTX, unwrapped: [*c]u8, unwrappedlen: [*c]usize, wrapped: [*c]const u8, wrappedlen: usize) c_int;
pub const EVP_PKEY_gen_cb = fn (?*EVP_PKEY_CTX) callconv(.C) c_int;
pub extern fn EVP_PKEY_fromdata_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_fromdata(ctx: ?*EVP_PKEY_CTX, ppkey: [*c]?*EVP_PKEY, selection: c_int, param: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_fromdata_settable(ctx: ?*EVP_PKEY_CTX, selection: c_int) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_todata(pkey: ?*const EVP_PKEY, selection: c_int, params: [*c][*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_export(pkey: ?*const EVP_PKEY, selection: c_int, export_cb: ?*const OSSL_CALLBACK, export_cbarg: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_gettable_params(pkey: ?*const EVP_PKEY) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_get_params(pkey: ?*const EVP_PKEY, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_get_int_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, out: [*c]c_int) c_int;
pub extern fn EVP_PKEY_get_size_t_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, out: [*c]usize) c_int;
pub extern fn EVP_PKEY_get_bn_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, bn: [*c]?*BIGNUM) c_int;
pub extern fn EVP_PKEY_get_utf8_string_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, str: [*c]u8, max_buf_sz: usize, out_sz: [*c]usize) c_int;
pub extern fn EVP_PKEY_get_octet_string_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, buf: [*c]u8, max_buf_sz: usize, out_sz: [*c]usize) c_int;
pub extern fn EVP_PKEY_settable_params(pkey: ?*const EVP_PKEY) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_set_params(pkey: ?*EVP_PKEY, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_set_int_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, in: c_int) c_int;
pub extern fn EVP_PKEY_set_size_t_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, in: usize) c_int;
pub extern fn EVP_PKEY_set_bn_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, bn: ?*const BIGNUM) c_int;
pub extern fn EVP_PKEY_set_utf8_string_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, str: [*c]const u8) c_int;
pub extern fn EVP_PKEY_set_octet_string_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, buf: [*c]const u8, bsize: usize) c_int;
pub extern fn EVP_PKEY_get_ec_point_conv_form(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_field_type(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_Q_keygen(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, @"type": [*c]const u8, ...) ?*EVP_PKEY;
pub extern fn EVP_PKEY_paramgen_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_paramgen(ctx: ?*EVP_PKEY_CTX, ppkey: [*c]?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_keygen_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_keygen(ctx: ?*EVP_PKEY_CTX, ppkey: [*c]?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_generate(ctx: ?*EVP_PKEY_CTX, ppkey: [*c]?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_public_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_public_check_quick(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_param_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_param_check_quick(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_private_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_pairwise_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_set_ex_data(key: ?*EVP_PKEY, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_get_ex_data(key: ?*const EVP_PKEY, idx: c_int) ?*anyopaque;
pub extern fn EVP_PKEY_CTX_set_cb(ctx: ?*EVP_PKEY_CTX, cb: ?*const EVP_PKEY_gen_cb) void;
pub extern fn EVP_PKEY_CTX_get_cb(ctx: ?*EVP_PKEY_CTX) ?*const EVP_PKEY_gen_cb;
pub extern fn EVP_PKEY_CTX_get_keygen_info(ctx: ?*EVP_PKEY_CTX, idx: c_int) c_int;
pub extern fn EVP_PKEY_meth_set_init(pmeth: ?*EVP_PKEY_METHOD, init: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_copy(pmeth: ?*EVP_PKEY_METHOD, copy: ?*const fn (?*EVP_PKEY_CTX, ?*const EVP_PKEY_CTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_cleanup(pmeth: ?*EVP_PKEY_METHOD, cleanup: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) void) void;
pub extern fn EVP_PKEY_meth_set_paramgen(pmeth: ?*EVP_PKEY_METHOD, paramgen_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, paramgen: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_keygen(pmeth: ?*EVP_PKEY_METHOD, keygen_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, keygen: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_sign(pmeth: ?*EVP_PKEY_METHOD, sign_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, sign: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_verify(pmeth: ?*EVP_PKEY_METHOD, verify_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, verify: ?*const fn (?*EVP_PKEY_CTX, [*c]const u8, usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_verify_recover(pmeth: ?*EVP_PKEY_METHOD, verify_recover_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, verify_recover: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_signctx(pmeth: ?*EVP_PKEY_METHOD, signctx_init: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.C) c_int, signctx: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, ?*EVP_MD_CTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_verifyctx(pmeth: ?*EVP_PKEY_METHOD, verifyctx_init: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.C) c_int, verifyctx: ?*const fn (?*EVP_PKEY_CTX, [*c]const u8, c_int, ?*EVP_MD_CTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_encrypt(pmeth: ?*EVP_PKEY_METHOD, encrypt_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, encryptfn: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_decrypt(pmeth: ?*EVP_PKEY_METHOD, decrypt_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, decrypt: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_derive(pmeth: ?*EVP_PKEY_METHOD, derive_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, derive: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_ctrl(pmeth: ?*EVP_PKEY_METHOD, ctrl: ?*const fn (?*EVP_PKEY_CTX, c_int, c_int, ?*anyopaque) callconv(.C) c_int, ctrl_str: ?*const fn (?*EVP_PKEY_CTX, [*c]const u8, [*c]const u8) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_digestsign(pmeth: ?*EVP_PKEY_METHOD, digestsign: ?*const fn (?*EVP_MD_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_digestverify(pmeth: ?*EVP_PKEY_METHOD, digestverify: ?*const fn (?*EVP_MD_CTX, [*c]const u8, usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_check(pmeth: ?*EVP_PKEY_METHOD, check: ?*const fn (?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_public_check(pmeth: ?*EVP_PKEY_METHOD, check: ?*const fn (?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_param_check(pmeth: ?*EVP_PKEY_METHOD, check: ?*const fn (?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_set_digest_custom(pmeth: ?*EVP_PKEY_METHOD, digest_custom: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_init(pmeth: ?*const EVP_PKEY_METHOD, pinit: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_copy(pmeth: ?*const EVP_PKEY_METHOD, pcopy: [*c]?*const fn (?*EVP_PKEY_CTX, ?*const EVP_PKEY_CTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_cleanup(pmeth: ?*const EVP_PKEY_METHOD, pcleanup: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) void) void;
pub extern fn EVP_PKEY_meth_get_paramgen(pmeth: ?*const EVP_PKEY_METHOD, pparamgen_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, pparamgen: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_keygen(pmeth: ?*const EVP_PKEY_METHOD, pkeygen_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, pkeygen: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_sign(pmeth: ?*const EVP_PKEY_METHOD, psign_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, psign: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_verify(pmeth: ?*const EVP_PKEY_METHOD, pverify_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, pverify: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]const u8, usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_verify_recover(pmeth: ?*const EVP_PKEY_METHOD, pverify_recover_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, pverify_recover: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_signctx(pmeth: ?*const EVP_PKEY_METHOD, psignctx_init: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.C) c_int, psignctx: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, ?*EVP_MD_CTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_verifyctx(pmeth: ?*const EVP_PKEY_METHOD, pverifyctx_init: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.C) c_int, pverifyctx: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]const u8, c_int, ?*EVP_MD_CTX) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_encrypt(pmeth: ?*const EVP_PKEY_METHOD, pencrypt_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, pencryptfn: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_decrypt(pmeth: ?*const EVP_PKEY_METHOD, pdecrypt_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, pdecrypt: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_derive(pmeth: ?*const EVP_PKEY_METHOD, pderive_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.C) c_int, pderive: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_ctrl(pmeth: ?*const EVP_PKEY_METHOD, pctrl: [*c]?*const fn (?*EVP_PKEY_CTX, c_int, c_int, ?*anyopaque) callconv(.C) c_int, pctrl_str: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]const u8, [*c]const u8) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_digestsign(pmeth: ?*const EVP_PKEY_METHOD, digestsign: [*c]?*const fn (?*EVP_MD_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_digestverify(pmeth: ?*const EVP_PKEY_METHOD, digestverify: [*c]?*const fn (?*EVP_MD_CTX, [*c]const u8, usize, [*c]const u8, usize) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_check(pmeth: ?*const EVP_PKEY_METHOD, pcheck: [*c]?*const fn (?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_public_check(pmeth: ?*const EVP_PKEY_METHOD, pcheck: [*c]?*const fn (?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_param_check(pmeth: ?*const EVP_PKEY_METHOD, pcheck: [*c]?*const fn (?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_meth_get_digest_custom(pmeth: ?*const EVP_PKEY_METHOD, pdigest_custom: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.C) c_int) void;
pub extern fn EVP_KEYEXCH_free(exchange: ?*EVP_KEYEXCH) void;
pub extern fn EVP_KEYEXCH_up_ref(exchange: ?*EVP_KEYEXCH) c_int;
pub extern fn EVP_KEYEXCH_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_KEYEXCH;
pub extern fn EVP_KEYEXCH_get0_provider(exchange: ?*const EVP_KEYEXCH) ?*OSSL_PROVIDER;
pub extern fn EVP_KEYEXCH_is_a(keyexch: ?*const EVP_KEYEXCH, name: [*c]const u8) c_int;
pub extern fn EVP_KEYEXCH_get0_name(keyexch: ?*const EVP_KEYEXCH) [*c]const u8;
pub extern fn EVP_KEYEXCH_get0_description(keyexch: ?*const EVP_KEYEXCH) [*c]const u8;
pub extern fn EVP_KEYEXCH_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_KEYEXCH, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) void;
pub extern fn EVP_KEYEXCH_names_do_all(keyexch: ?*const EVP_KEYEXCH, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.C) void, data: ?*anyopaque) c_int;
pub extern fn EVP_KEYEXCH_gettable_ctx_params(keyexch: ?*const EVP_KEYEXCH) [*c]const OSSL_PARAM;
pub extern fn EVP_KEYEXCH_settable_ctx_params(keyexch: ?*const EVP_KEYEXCH) [*c]const OSSL_PARAM;
pub extern fn EVP_add_alg_module() void;
pub extern fn EVP_PKEY_CTX_set_group_name(ctx: ?*EVP_PKEY_CTX, name: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_group_name(ctx: ?*EVP_PKEY_CTX, name: [*c]u8, namelen: usize) c_int;
pub extern fn EVP_PKEY_get_group_name(pkey: ?*const EVP_PKEY, name: [*c]u8, name_sz: usize, gname_len: [*c]usize) c_int;
pub extern fn EVP_PKEY_CTX_get0_libctx(ctx: ?*EVP_PKEY_CTX) ?*OSSL_LIB_CTX;
pub extern fn EVP_PKEY_CTX_get0_propq(ctx: ?*const EVP_PKEY_CTX) [*c]const u8;
pub extern fn EVP_PKEY_CTX_get0_provider(ctx: ?*const EVP_PKEY_CTX) ?*const OSSL_PROVIDER;
pub extern fn memchr(__s: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn memcpy(__dst: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memmove(__dst: ?*anyopaque, __src: ?*const anyopaque, __len: c_ulong) ?*anyopaque;
pub extern fn memset(__b: ?*anyopaque, __c: c_int, __len: c_ulong) ?*anyopaque;
pub extern fn strcat(__s1: [*c]u8, __s2: [*c]const u8) [*c]u8;
pub extern fn strchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strcmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strcoll(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strcpy(__dst: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strcspn(__s: [*c]const u8, __charset: [*c]const u8) c_ulong;
pub extern fn strerror(__errnum: c_int) [*c]u8;
pub extern fn strlen(__s: [*c]const u8) c_ulong;
pub extern fn strncat(__s1: [*c]u8, __s2: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strncmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strncpy(__dst: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strpbrk(__s: [*c]const u8, __charset: [*c]const u8) [*c]u8;
pub extern fn strrchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strspn(__s: [*c]const u8, __charset: [*c]const u8) c_ulong;
pub extern fn strstr(__big: [*c]const u8, __little: [*c]const u8) [*c]u8;
pub extern fn strtok(__str: [*c]u8, __sep: [*c]const u8) [*c]u8;
pub extern fn strxfrm(__s1: [*c]u8, __s2: [*c]const u8, __n: c_ulong) c_ulong;
pub extern fn strtok_r(__str: [*c]u8, __sep: [*c]const u8, __lasts: [*c][*c]u8) [*c]u8;
pub extern fn strerror_r(__errnum: c_int, __strerrbuf: [*c]u8, __buflen: usize) c_int;
pub extern fn strdup(__s1: [*c]const u8) [*c]u8;
pub extern fn memccpy(__dst: ?*anyopaque, __src: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn stpcpy(__dst: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn stpncpy(__dst: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strndup(__s1: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strnlen(__s1: [*c]const u8, __n: usize) usize;
pub extern fn strsignal(__sig: c_int) [*c]u8;
pub extern fn memset_s(__s: ?*anyopaque, __smax: rsize_t, __c: c_int, __n: rsize_t) errno_t;
pub extern fn memmem(__big: ?*const anyopaque, __big_len: usize, __little: ?*const anyopaque, __little_len: usize) ?*anyopaque;
pub extern fn memset_pattern4(__b: ?*anyopaque, __pattern4: ?*const anyopaque, __len: usize) void;
pub extern fn memset_pattern8(__b: ?*anyopaque, __pattern8: ?*const anyopaque, __len: usize) void;
pub extern fn memset_pattern16(__b: ?*anyopaque, __pattern16: ?*const anyopaque, __len: usize) void;
pub extern fn strcasestr(__big: [*c]const u8, __little: [*c]const u8) [*c]u8;
pub extern fn strnstr(__big: [*c]const u8, __little: [*c]const u8, __len: usize) [*c]u8;
pub extern fn strlcat(__dst: [*c]u8, __source: [*c]const u8, __size: c_ulong) c_ulong;
pub extern fn strlcpy(__dst: [*c]u8, __source: [*c]const u8, __size: c_ulong) c_ulong;
pub extern fn strmode(__mode: c_int, __bp: [*c]u8) void;
pub extern fn strsep(__stringp: [*c][*c]u8, __delim: [*c]const u8) [*c]u8;
pub extern fn swab(noalias ?*const anyopaque, noalias ?*anyopaque, isize) void;
pub extern fn timingsafe_bcmp(__b1: ?*const anyopaque, __b2: ?*const anyopaque, __len: usize) c_int;
pub extern fn strsignal_r(__sig: c_int, __strsignalbuf: [*c]u8, __buflen: usize) c_int;
pub extern fn bcmp(?*const anyopaque, ?*const anyopaque, c_ulong) c_int;
pub extern fn bcopy(?*const anyopaque, ?*anyopaque, c_ulong) void;
pub extern fn bzero(?*anyopaque, c_ulong) void;
pub extern fn index([*c]const u8, c_int) [*c]u8;
pub extern fn rindex([*c]const u8, c_int) [*c]u8;
pub extern fn ffs(c_int) c_int;
pub extern fn strcasecmp([*c]const u8, [*c]const u8) c_int;
pub extern fn strncasecmp([*c]const u8, [*c]const u8, c_ulong) c_int;
pub extern fn ffsl(c_long) c_int;
pub extern fn ffsll(c_longlong) c_int;
pub extern fn fls(c_int) c_int;
pub extern fn flsl(c_long) c_int;
pub extern fn flsll(c_longlong) c_int;
pub extern fn EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx: ?*EVP_PKEY_CTX, nid: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_ec_param_enc(ctx: ?*EVP_PKEY_CTX, param_enc: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_ecdh_cofactor_mode(ctx: ?*EVP_PKEY_CTX, cofactor_mode: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_ecdh_cofactor_mode(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_CTX_set_ecdh_kdf_type(ctx: ?*EVP_PKEY_CTX, kdf: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_ecdh_kdf_type(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_CTX_set_ecdh_kdf_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_get_ecdh_kdf_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_ecdh_kdf_outlen(ctx: ?*EVP_PKEY_CTX, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_ecdh_kdf_outlen(ctx: ?*EVP_PKEY_CTX, len: [*c]c_int) c_int;
pub extern fn EVP_PKEY_CTX_set0_ecdh_kdf_ukm(ctx: ?*EVP_PKEY_CTX, ukm: [*c]u8, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get0_ecdh_kdf_ukm(ctx: ?*EVP_PKEY_CTX, ukm: [*c][*c]u8) c_int;
pub const POINT_CONVERSION_COMPRESSED: c_int = 2;
pub const POINT_CONVERSION_UNCOMPRESSED: c_int = 4;
pub const POINT_CONVERSION_HYBRID: c_int = 6;
pub const point_conversion_form_t = c_uint;
pub extern fn OSSL_EC_curve_nid2name(nid: c_int) [*c]const u8;
pub const struct_ec_method_st = opaque {};
pub const EC_METHOD = struct_ec_method_st;
pub const struct_ec_group_st = opaque {};
pub const EC_GROUP = struct_ec_group_st;
pub const struct_ec_point_st = opaque {};
pub const EC_POINT = struct_ec_point_st;
pub const struct_ecpk_parameters_st = opaque {};
pub const ECPKPARAMETERS = struct_ecpk_parameters_st;
pub const struct_ec_parameters_st = opaque {};
pub const ECPARAMETERS = struct_ec_parameters_st;
pub extern fn EC_GFp_simple_method() ?*const EC_METHOD;
pub extern fn EC_GFp_mont_method() ?*const EC_METHOD;
pub extern fn EC_GFp_nist_method() ?*const EC_METHOD;
pub extern fn EC_GFp_nistp224_method() ?*const EC_METHOD;
pub extern fn EC_GFp_nistp256_method() ?*const EC_METHOD;
pub extern fn EC_GFp_nistp521_method() ?*const EC_METHOD;
pub extern fn EC_GF2m_simple_method() ?*const EC_METHOD;
pub extern fn EC_GROUP_new(meth: ?*const EC_METHOD) ?*EC_GROUP;
pub extern fn EC_GROUP_clear_free(group: ?*EC_GROUP) void;
pub extern fn EC_GROUP_method_of(group: ?*const EC_GROUP) ?*const EC_METHOD;
pub extern fn EC_METHOD_get_field_type(meth: ?*const EC_METHOD) c_int;
pub extern fn EC_GROUP_free(group: ?*EC_GROUP) void;
pub extern fn EC_GROUP_copy(dst: ?*EC_GROUP, src: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_dup(src: ?*const EC_GROUP) ?*EC_GROUP;
pub extern fn EC_GROUP_set_generator(group: ?*EC_GROUP, generator: ?*const EC_POINT, order: ?*const BIGNUM, cofactor: ?*const BIGNUM) c_int;
pub extern fn EC_GROUP_get0_generator(group: ?*const EC_GROUP) ?*const EC_POINT;
pub extern fn EC_GROUP_get_mont_data(group: ?*const EC_GROUP) ?*BN_MONT_CTX;
pub extern fn EC_GROUP_get_order(group: ?*const EC_GROUP, order: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get0_order(group: ?*const EC_GROUP) ?*const BIGNUM;
pub extern fn EC_GROUP_order_bits(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_get_cofactor(group: ?*const EC_GROUP, cofactor: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get0_cofactor(group: ?*const EC_GROUP) ?*const BIGNUM;
pub extern fn EC_GROUP_set_curve_name(group: ?*EC_GROUP, nid: c_int) void;
pub extern fn EC_GROUP_get_curve_name(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_get0_field(group: ?*const EC_GROUP) ?*const BIGNUM;
pub extern fn EC_GROUP_get_field_type(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_set_asn1_flag(group: ?*EC_GROUP, flag: c_int) void;
pub extern fn EC_GROUP_get_asn1_flag(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_set_point_conversion_form(group: ?*EC_GROUP, form: point_conversion_form_t) void;
pub extern fn EC_GROUP_get_point_conversion_form(?*const EC_GROUP) point_conversion_form_t;
pub extern fn EC_GROUP_get0_seed(x: ?*const EC_GROUP) [*c]u8;
pub extern fn EC_GROUP_get_seed_len(?*const EC_GROUP) usize;
pub extern fn EC_GROUP_set_seed(?*EC_GROUP, [*c]const u8, len: usize) usize;
pub extern fn EC_GROUP_set_curve(group: ?*EC_GROUP, p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get_curve(group: ?*const EC_GROUP, p: ?*BIGNUM, a: ?*BIGNUM, b: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_set_curve_GFp(group: ?*EC_GROUP, p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get_curve_GFp(group: ?*const EC_GROUP, p: ?*BIGNUM, a: ?*BIGNUM, b: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_set_curve_GF2m(group: ?*EC_GROUP, p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get_curve_GF2m(group: ?*const EC_GROUP, p: ?*BIGNUM, a: ?*BIGNUM, b: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get_degree(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_check(group: ?*const EC_GROUP, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_check_discriminant(group: ?*const EC_GROUP, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_cmp(a: ?*const EC_GROUP, b: ?*const EC_GROUP, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_new_curve_GFp(p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) ?*EC_GROUP;
pub extern fn EC_GROUP_new_curve_GF2m(p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) ?*EC_GROUP;
pub extern fn EC_GROUP_new_from_params(params: [*c]const OSSL_PARAM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EC_GROUP;
pub extern fn EC_GROUP_to_params(group: ?*const EC_GROUP, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, bnctx: ?*BN_CTX) [*c]OSSL_PARAM;
pub extern fn EC_GROUP_new_by_curve_name_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, nid: c_int) ?*EC_GROUP;
pub extern fn EC_GROUP_new_by_curve_name(nid: c_int) ?*EC_GROUP;
pub extern fn EC_GROUP_new_from_ecparameters(params: ?*const ECPARAMETERS) ?*EC_GROUP;
pub extern fn EC_GROUP_get_ecparameters(group: ?*const EC_GROUP, params: ?*ECPARAMETERS) ?*ECPARAMETERS;
pub extern fn EC_GROUP_new_from_ecpkparameters(params: ?*const ECPKPARAMETERS) ?*EC_GROUP;
pub extern fn EC_GROUP_get_ecpkparameters(group: ?*const EC_GROUP, params: ?*ECPKPARAMETERS) ?*ECPKPARAMETERS;
pub const EC_builtin_curve = extern struct {
    nid: c_int = @import("std").mem.zeroes(c_int),
    comment: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub extern fn EC_get_builtin_curves(r: [*c]EC_builtin_curve, nitems: usize) usize;
pub extern fn EC_curve_nid2nist(nid: c_int) [*c]const u8;
pub extern fn EC_curve_nist2nid(name: [*c]const u8) c_int;
pub extern fn EC_GROUP_check_named_curve(group: ?*const EC_GROUP, nist_only: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_new(group: ?*const EC_GROUP) ?*EC_POINT;
pub extern fn EC_POINT_free(point: ?*EC_POINT) void;
pub extern fn EC_POINT_clear_free(point: ?*EC_POINT) void;
pub extern fn EC_POINT_copy(dst: ?*EC_POINT, src: ?*const EC_POINT) c_int;
pub extern fn EC_POINT_dup(src: ?*const EC_POINT, group: ?*const EC_GROUP) ?*EC_POINT;
pub extern fn EC_POINT_set_to_infinity(group: ?*const EC_GROUP, point: ?*EC_POINT) c_int;
pub extern fn EC_POINT_method_of(point: ?*const EC_POINT) ?*const EC_METHOD;
pub extern fn EC_POINT_set_Jprojective_coordinates_GFp(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y: ?*const BIGNUM, z: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_get_Jprojective_coordinates_GFp(group: ?*const EC_GROUP, p: ?*const EC_POINT, x: ?*BIGNUM, y: ?*BIGNUM, z: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_affine_coordinates(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_get_affine_coordinates(group: ?*const EC_GROUP, p: ?*const EC_POINT, x: ?*BIGNUM, y: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_affine_coordinates_GFp(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_get_affine_coordinates_GFp(group: ?*const EC_GROUP, p: ?*const EC_POINT, x: ?*BIGNUM, y: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_compressed_coordinates(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y_bit: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_compressed_coordinates_GFp(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y_bit: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_affine_coordinates_GF2m(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_get_affine_coordinates_GF2m(group: ?*const EC_GROUP, p: ?*const EC_POINT, x: ?*BIGNUM, y: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_compressed_coordinates_GF2m(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y_bit: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_point2oct(group: ?*const EC_GROUP, p: ?*const EC_POINT, form: point_conversion_form_t, buf: [*c]u8, len: usize, ctx: ?*BN_CTX) usize;
pub extern fn EC_POINT_oct2point(group: ?*const EC_GROUP, p: ?*EC_POINT, buf: [*c]const u8, len: usize, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_point2buf(group: ?*const EC_GROUP, point: ?*const EC_POINT, form: point_conversion_form_t, pbuf: [*c][*c]u8, ctx: ?*BN_CTX) usize;
pub extern fn EC_POINT_point2bn(?*const EC_GROUP, ?*const EC_POINT, form: point_conversion_form_t, ?*BIGNUM, ?*BN_CTX) ?*BIGNUM;
pub extern fn EC_POINT_bn2point(?*const EC_GROUP, ?*const BIGNUM, ?*EC_POINT, ?*BN_CTX) ?*EC_POINT;
pub extern fn EC_POINT_point2hex(?*const EC_GROUP, ?*const EC_POINT, form: point_conversion_form_t, ?*BN_CTX) [*c]u8;
pub extern fn EC_POINT_hex2point(?*const EC_GROUP, [*c]const u8, ?*EC_POINT, ?*BN_CTX) ?*EC_POINT;
pub extern fn EC_POINT_add(group: ?*const EC_GROUP, r: ?*EC_POINT, a: ?*const EC_POINT, b: ?*const EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_dbl(group: ?*const EC_GROUP, r: ?*EC_POINT, a: ?*const EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_invert(group: ?*const EC_GROUP, a: ?*EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_is_at_infinity(group: ?*const EC_GROUP, p: ?*const EC_POINT) c_int;
pub extern fn EC_POINT_is_on_curve(group: ?*const EC_GROUP, point: ?*const EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_cmp(group: ?*const EC_GROUP, a: ?*const EC_POINT, b: ?*const EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_make_affine(group: ?*const EC_GROUP, point: ?*EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINTs_make_affine(group: ?*const EC_GROUP, num: usize, points: [*c]?*EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINTs_mul(group: ?*const EC_GROUP, r: ?*EC_POINT, n: ?*const BIGNUM, num: usize, p: [*c]?*const EC_POINT, m: [*c]?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_mul(group: ?*const EC_GROUP, r: ?*EC_POINT, n: ?*const BIGNUM, q: ?*const EC_POINT, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_precompute_mult(group: ?*EC_GROUP, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_have_precompute_mult(group: ?*const EC_GROUP) c_int;
pub extern fn ECPKPARAMETERS_it() ?*const ASN1_ITEM;
pub extern fn ECPKPARAMETERS_new() ?*ECPKPARAMETERS;
pub extern fn ECPKPARAMETERS_free(a: ?*ECPKPARAMETERS) void;
pub extern fn ECPARAMETERS_it() ?*const ASN1_ITEM;
pub extern fn ECPARAMETERS_new() ?*ECPARAMETERS;
pub extern fn ECPARAMETERS_free(a: ?*ECPARAMETERS) void;
pub extern fn EC_GROUP_get_basis_type(?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_get_trinomial_basis(?*const EC_GROUP, k: [*c]c_uint) c_int;
pub extern fn EC_GROUP_get_pentanomial_basis(?*const EC_GROUP, k1: [*c]c_uint, k2: [*c]c_uint, k3: [*c]c_uint) c_int;
pub extern fn d2i_ECPKParameters([*c]?*EC_GROUP, in: [*c][*c]const u8, len: c_long) ?*EC_GROUP;
pub extern fn i2d_ECPKParameters(?*const EC_GROUP, out: [*c][*c]u8) c_int;
pub extern fn ECPKParameters_print(bp: ?*BIO, x: ?*const EC_GROUP, off: c_int) c_int;
pub extern fn ECPKParameters_print_fp(fp: [*c]FILE, x: ?*const EC_GROUP, off: c_int) c_int;
pub extern fn EC_KEY_new_ex(ctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EC_KEY;
pub extern fn EC_KEY_new() ?*EC_KEY;
pub extern fn EC_KEY_get_flags(key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_set_flags(key: ?*EC_KEY, flags: c_int) void;
pub extern fn EC_KEY_clear_flags(key: ?*EC_KEY, flags: c_int) void;
pub extern fn EC_KEY_decoded_from_explicit_params(key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_new_by_curve_name_ex(ctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, nid: c_int) ?*EC_KEY;
pub extern fn EC_KEY_new_by_curve_name(nid: c_int) ?*EC_KEY;
pub extern fn EC_KEY_free(key: ?*EC_KEY) void;
pub extern fn EC_KEY_copy(dst: ?*EC_KEY, src: ?*const EC_KEY) ?*EC_KEY;
pub extern fn EC_KEY_dup(src: ?*const EC_KEY) ?*EC_KEY;
pub extern fn EC_KEY_up_ref(key: ?*EC_KEY) c_int;
pub extern fn EC_KEY_get0_engine(eckey: ?*const EC_KEY) ?*ENGINE;
pub extern fn EC_KEY_get0_group(key: ?*const EC_KEY) ?*const EC_GROUP;
pub extern fn EC_KEY_set_group(key: ?*EC_KEY, group: ?*const EC_GROUP) c_int;
pub extern fn EC_KEY_get0_private_key(key: ?*const EC_KEY) ?*const BIGNUM;
pub extern fn EC_KEY_set_private_key(key: ?*EC_KEY, prv: ?*const BIGNUM) c_int;
pub extern fn EC_KEY_get0_public_key(key: ?*const EC_KEY) ?*const EC_POINT;
pub extern fn EC_KEY_set_public_key(key: ?*EC_KEY, @"pub": ?*const EC_POINT) c_int;
pub extern fn EC_KEY_get_enc_flags(key: ?*const EC_KEY) c_uint;
pub extern fn EC_KEY_set_enc_flags(eckey: ?*EC_KEY, flags: c_uint) void;
pub extern fn EC_KEY_get_conv_form(key: ?*const EC_KEY) point_conversion_form_t;
pub extern fn EC_KEY_set_conv_form(eckey: ?*EC_KEY, cform: point_conversion_form_t) void;
pub extern fn EC_KEY_set_ex_data(key: ?*EC_KEY, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn EC_KEY_get_ex_data(key: ?*const EC_KEY, idx: c_int) ?*anyopaque;
pub extern fn EC_KEY_set_asn1_flag(eckey: ?*EC_KEY, asn1_flag: c_int) void;
pub extern fn EC_KEY_precompute_mult(key: ?*EC_KEY, ctx: ?*BN_CTX) c_int;
pub extern fn EC_KEY_generate_key(key: ?*EC_KEY) c_int;
pub extern fn EC_KEY_check_key(key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_can_sign(eckey: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_set_public_key_affine_coordinates(key: ?*EC_KEY, x: ?*BIGNUM, y: ?*BIGNUM) c_int;
pub extern fn EC_KEY_key2buf(key: ?*const EC_KEY, form: point_conversion_form_t, pbuf: [*c][*c]u8, ctx: ?*BN_CTX) usize;
pub extern fn EC_KEY_oct2key(key: ?*EC_KEY, buf: [*c]const u8, len: usize, ctx: ?*BN_CTX) c_int;
pub extern fn EC_KEY_oct2priv(key: ?*EC_KEY, buf: [*c]const u8, len: usize) c_int;
pub extern fn EC_KEY_priv2oct(key: ?*const EC_KEY, buf: [*c]u8, len: usize) usize;
pub extern fn EC_KEY_priv2buf(eckey: ?*const EC_KEY, pbuf: [*c][*c]u8) usize;
pub extern fn d2i_ECPrivateKey(key: [*c]?*EC_KEY, in: [*c][*c]const u8, len: c_long) ?*EC_KEY;
pub extern fn i2d_ECPrivateKey(key: ?*const EC_KEY, out: [*c][*c]u8) c_int;
pub extern fn d2i_ECParameters(key: [*c]?*EC_KEY, in: [*c][*c]const u8, len: c_long) ?*EC_KEY;
pub extern fn i2d_ECParameters(key: ?*const EC_KEY, out: [*c][*c]u8) c_int;
pub extern fn o2i_ECPublicKey(key: [*c]?*EC_KEY, in: [*c][*c]const u8, len: c_long) ?*EC_KEY;
pub extern fn i2o_ECPublicKey(key: ?*const EC_KEY, out: [*c][*c]u8) c_int;
pub extern fn ECParameters_print(bp: ?*BIO, key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_print(bp: ?*BIO, key: ?*const EC_KEY, off: c_int) c_int;
pub extern fn ECParameters_print_fp(fp: [*c]FILE, key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_print_fp(fp: [*c]FILE, key: ?*const EC_KEY, off: c_int) c_int;
pub extern fn EC_KEY_OpenSSL() ?*const EC_KEY_METHOD;
pub extern fn EC_KEY_get_default_method() ?*const EC_KEY_METHOD;
pub extern fn EC_KEY_set_default_method(meth: ?*const EC_KEY_METHOD) void;
pub extern fn EC_KEY_get_method(key: ?*const EC_KEY) ?*const EC_KEY_METHOD;
pub extern fn EC_KEY_set_method(key: ?*EC_KEY, meth: ?*const EC_KEY_METHOD) c_int;
pub extern fn EC_KEY_new_method(engine: ?*ENGINE) ?*EC_KEY;
pub extern fn ECDH_KDF_X9_62(out: [*c]u8, outlen: usize, Z: [*c]const u8, Zlen: usize, sinfo: [*c]const u8, sinfolen: usize, md: ?*const EVP_MD) c_int;
pub extern fn ECDH_compute_key(out: ?*anyopaque, outlen: usize, pub_key: ?*const EC_POINT, ecdh: ?*const EC_KEY, KDF: ?*const fn (?*const anyopaque, usize, ?*anyopaque, [*c]usize) callconv(.C) ?*anyopaque) c_int;
pub const struct_ECDSA_SIG_st = opaque {};
pub const ECDSA_SIG = struct_ECDSA_SIG_st;
pub extern fn ECDSA_SIG_new() ?*ECDSA_SIG;
pub extern fn ECDSA_SIG_free(sig: ?*ECDSA_SIG) void;
pub extern fn d2i_ECDSA_SIG(a: [*c]?*ECDSA_SIG, in: [*c][*c]const u8, len: c_long) ?*ECDSA_SIG;
pub extern fn i2d_ECDSA_SIG(a: ?*const ECDSA_SIG, out: [*c][*c]u8) c_int;
pub extern fn ECDSA_SIG_get0(sig: ?*const ECDSA_SIG, pr: [*c]?*const BIGNUM, ps: [*c]?*const BIGNUM) void;
pub extern fn ECDSA_SIG_get0_r(sig: ?*const ECDSA_SIG) ?*const BIGNUM;
pub extern fn ECDSA_SIG_get0_s(sig: ?*const ECDSA_SIG) ?*const BIGNUM;
pub extern fn ECDSA_SIG_set0(sig: ?*ECDSA_SIG, r: ?*BIGNUM, s: ?*BIGNUM) c_int;
pub extern fn ECDSA_do_sign(dgst: [*c]const u8, dgst_len: c_int, eckey: ?*EC_KEY) ?*ECDSA_SIG;
pub extern fn ECDSA_do_sign_ex(dgst: [*c]const u8, dgstlen: c_int, kinv: ?*const BIGNUM, rp: ?*const BIGNUM, eckey: ?*EC_KEY) ?*ECDSA_SIG;
pub extern fn ECDSA_do_verify(dgst: [*c]const u8, dgst_len: c_int, sig: ?*const ECDSA_SIG, eckey: ?*EC_KEY) c_int;
pub extern fn ECDSA_sign_setup(eckey: ?*EC_KEY, ctx: ?*BN_CTX, kinv: [*c]?*BIGNUM, rp: [*c]?*BIGNUM) c_int;
pub extern fn ECDSA_sign(@"type": c_int, dgst: [*c]const u8, dgstlen: c_int, sig: [*c]u8, siglen: [*c]c_uint, eckey: ?*EC_KEY) c_int;
pub extern fn ECDSA_sign_ex(@"type": c_int, dgst: [*c]const u8, dgstlen: c_int, sig: [*c]u8, siglen: [*c]c_uint, kinv: ?*const BIGNUM, rp: ?*const BIGNUM, eckey: ?*EC_KEY) c_int;
pub extern fn ECDSA_verify(@"type": c_int, dgst: [*c]const u8, dgstlen: c_int, sig: [*c]const u8, siglen: c_int, eckey: ?*EC_KEY) c_int;
pub extern fn ECDSA_size(eckey: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_METHOD_new(meth: ?*const EC_KEY_METHOD) ?*EC_KEY_METHOD;
pub extern fn EC_KEY_METHOD_free(meth: ?*EC_KEY_METHOD) void;
pub extern fn EC_KEY_METHOD_set_init(meth: ?*EC_KEY_METHOD, init: ?*const fn (?*EC_KEY) callconv(.C) c_int, finish: ?*const fn (?*EC_KEY) callconv(.C) void, copy: ?*const fn (?*EC_KEY, ?*const EC_KEY) callconv(.C) c_int, set_group: ?*const fn (?*EC_KEY, ?*const EC_GROUP) callconv(.C) c_int, set_private: ?*const fn (?*EC_KEY, ?*const BIGNUM) callconv(.C) c_int, set_public: ?*const fn (?*EC_KEY, ?*const EC_POINT) callconv(.C) c_int) void;
pub extern fn EC_KEY_METHOD_set_keygen(meth: ?*EC_KEY_METHOD, keygen: ?*const fn (?*EC_KEY) callconv(.C) c_int) void;
pub extern fn EC_KEY_METHOD_set_compute_key(meth: ?*EC_KEY_METHOD, ckey: ?*const fn ([*c][*c]u8, [*c]usize, ?*const EC_POINT, ?*const EC_KEY) callconv(.C) c_int) void;
pub extern fn EC_KEY_METHOD_set_sign(meth: ?*EC_KEY_METHOD, sign: ?*const fn (c_int, [*c]const u8, c_int, [*c]u8, [*c]c_uint, ?*const BIGNUM, ?*const BIGNUM, ?*EC_KEY) callconv(.C) c_int, sign_setup: ?*const fn (?*EC_KEY, ?*BN_CTX, [*c]?*BIGNUM, [*c]?*BIGNUM) callconv(.C) c_int, sign_sig: ?*const fn ([*c]const u8, c_int, ?*const BIGNUM, ?*const BIGNUM, ?*EC_KEY) callconv(.C) ?*ECDSA_SIG) void;
pub extern fn EC_KEY_METHOD_set_verify(meth: ?*EC_KEY_METHOD, verify: ?*const fn (c_int, [*c]const u8, c_int, [*c]const u8, c_int, ?*EC_KEY) callconv(.C) c_int, verify_sig: ?*const fn ([*c]const u8, c_int, ?*const ECDSA_SIG, ?*EC_KEY) callconv(.C) c_int) void;
pub extern fn EC_KEY_METHOD_get_init(meth: ?*const EC_KEY_METHOD, pinit: [*c]?*const fn (?*EC_KEY) callconv(.C) c_int, pfinish: [*c]?*const fn (?*EC_KEY) callconv(.C) void, pcopy: [*c]?*const fn (?*EC_KEY, ?*const EC_KEY) callconv(.C) c_int, pset_group: [*c]?*const fn (?*EC_KEY, ?*const EC_GROUP) callconv(.C) c_int, pset_private: [*c]?*const fn (?*EC_KEY, ?*const BIGNUM) callconv(.C) c_int, pset_public: [*c]?*const fn (?*EC_KEY, ?*const EC_POINT) callconv(.C) c_int) void;
pub extern fn EC_KEY_METHOD_get_keygen(meth: ?*const EC_KEY_METHOD, pkeygen: [*c]?*const fn (?*EC_KEY) callconv(.C) c_int) void;
pub extern fn EC_KEY_METHOD_get_compute_key(meth: ?*const EC_KEY_METHOD, pck: [*c]?*const fn ([*c][*c]u8, [*c]usize, ?*const EC_POINT, ?*const EC_KEY) callconv(.C) c_int) void;
pub extern fn EC_KEY_METHOD_get_sign(meth: ?*const EC_KEY_METHOD, psign: [*c]?*const fn (c_int, [*c]const u8, c_int, [*c]u8, [*c]c_uint, ?*const BIGNUM, ?*const BIGNUM, ?*EC_KEY) callconv(.C) c_int, psign_setup: [*c]?*const fn (?*EC_KEY, ?*BN_CTX, [*c]?*BIGNUM, [*c]?*BIGNUM) callconv(.C) c_int, psign_sig: [*c]?*const fn ([*c]const u8, c_int, ?*const BIGNUM, ?*const BIGNUM, ?*EC_KEY) callconv(.C) ?*ECDSA_SIG) void;
pub extern fn EC_KEY_METHOD_get_verify(meth: ?*const EC_KEY_METHOD, pverify: [*c]?*const fn (c_int, [*c]const u8, c_int, [*c]const u8, c_int, ?*EC_KEY) callconv(.C) c_int, pverify_sig: [*c]?*const fn ([*c]const u8, c_int, ?*const ECDSA_SIG, ?*EC_KEY) callconv(.C) c_int) void;
pub extern fn EVP_PKEY_CTX_set_rsa_padding(ctx: ?*EVP_PKEY_CTX, pad_mode: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_padding(ctx: ?*EVP_PKEY_CTX, pad_mode: [*c]c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx: ?*EVP_PKEY_CTX, saltlen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_pss_saltlen(ctx: ?*EVP_PKEY_CTX, saltlen: [*c]c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_keygen_bits(ctx: ?*EVP_PKEY_CTX, bits: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set1_rsa_keygen_pubexp(ctx: ?*EVP_PKEY_CTX, pubexp: ?*BIGNUM) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_keygen_primes(ctx: ?*EVP_PKEY_CTX, primes: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(ctx: ?*EVP_PKEY_CTX, saltlen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx: ?*EVP_PKEY_CTX, pubexp: ?*BIGNUM) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_mgf1_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_mgf1_md_name(ctx: ?*EVP_PKEY_CTX, mdname: [*c]const u8, mdprops: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_mgf1_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_mgf1_md_name(ctx: ?*EVP_PKEY_CTX, name: [*c]u8, namelen: usize) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md_name(ctx: ?*EVP_PKEY_CTX, mdname: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_md_name(ctx: ?*EVP_PKEY_CTX, mdname: [*c]const u8, mdprops: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_oaep_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_oaep_md_name(ctx: ?*EVP_PKEY_CTX, mdname: [*c]const u8, mdprops: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_oaep_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_oaep_md_name(ctx: ?*EVP_PKEY_CTX, name: [*c]u8, namelen: usize) c_int;
pub extern fn EVP_PKEY_CTX_set0_rsa_oaep_label(ctx: ?*EVP_PKEY_CTX, label: ?*anyopaque, llen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get0_rsa_oaep_label(ctx: ?*EVP_PKEY_CTX, label: [*c][*c]u8) c_int;
pub extern fn RSA_new() ?*RSA;
pub extern fn RSA_new_method(engine: ?*ENGINE) ?*RSA;
pub extern fn RSA_bits(rsa: ?*const RSA) c_int;
pub extern fn RSA_size(rsa: ?*const RSA) c_int;
pub extern fn RSA_security_bits(rsa: ?*const RSA) c_int;
pub extern fn RSA_set0_key(r: ?*RSA, n: ?*BIGNUM, e: ?*BIGNUM, d: ?*BIGNUM) c_int;
pub extern fn RSA_set0_factors(r: ?*RSA, p: ?*BIGNUM, q: ?*BIGNUM) c_int;
pub extern fn RSA_set0_crt_params(r: ?*RSA, dmp1: ?*BIGNUM, dmq1: ?*BIGNUM, iqmp: ?*BIGNUM) c_int;
pub extern fn RSA_set0_multi_prime_params(r: ?*RSA, primes: [*c]?*BIGNUM, exps: [*c]?*BIGNUM, coeffs: [*c]?*BIGNUM, pnum: c_int) c_int;
pub extern fn RSA_get0_key(r: ?*const RSA, n: [*c]?*const BIGNUM, e: [*c]?*const BIGNUM, d: [*c]?*const BIGNUM) void;
pub extern fn RSA_get0_factors(r: ?*const RSA, p: [*c]?*const BIGNUM, q: [*c]?*const BIGNUM) void;
pub extern fn RSA_get_multi_prime_extra_count(r: ?*const RSA) c_int;
pub extern fn RSA_get0_multi_prime_factors(r: ?*const RSA, primes: [*c]?*const BIGNUM) c_int;
pub extern fn RSA_get0_crt_params(r: ?*const RSA, dmp1: [*c]?*const BIGNUM, dmq1: [*c]?*const BIGNUM, iqmp: [*c]?*const BIGNUM) void;
pub extern fn RSA_get0_multi_prime_crt_params(r: ?*const RSA, exps: [*c]?*const BIGNUM, coeffs: [*c]?*const BIGNUM) c_int;
pub extern fn RSA_get0_n(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_e(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_d(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_p(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_q(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_dmp1(r: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_dmq1(r: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_iqmp(r: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_pss_params(r: ?*const RSA) [*c]const RSA_PSS_PARAMS;
pub extern fn RSA_clear_flags(r: ?*RSA, flags: c_int) void;
pub extern fn RSA_test_flags(r: ?*const RSA, flags: c_int) c_int;
pub extern fn RSA_set_flags(r: ?*RSA, flags: c_int) void;
pub extern fn RSA_get_version(r: ?*RSA) c_int;
pub extern fn RSA_get0_engine(r: ?*const RSA) ?*ENGINE;
pub extern fn RSA_generate_key(bits: c_int, e: c_ulong, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.C) void, cb_arg: ?*anyopaque) ?*RSA;
pub extern fn RSA_generate_key_ex(rsa: ?*RSA, bits: c_int, e: ?*BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_generate_multi_prime_key(rsa: ?*RSA, bits: c_int, primes: c_int, e: ?*BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_X931_derive_ex(rsa: ?*RSA, p1: ?*BIGNUM, p2: ?*BIGNUM, q1: ?*BIGNUM, q2: ?*BIGNUM, Xp1: ?*const BIGNUM, Xp2: ?*const BIGNUM, Xp: ?*const BIGNUM, Xq1: ?*const BIGNUM, Xq2: ?*const BIGNUM, Xq: ?*const BIGNUM, e: ?*const BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_X931_generate_key_ex(rsa: ?*RSA, bits: c_int, e: ?*const BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_check_key(?*const RSA) c_int;
pub extern fn RSA_check_key_ex(?*const RSA, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_public_encrypt(flen: c_int, from: [*c]const u8, to: [*c]u8, rsa: ?*RSA, padding: c_int) c_int;
pub extern fn RSA_private_encrypt(flen: c_int, from: [*c]const u8, to: [*c]u8, rsa: ?*RSA, padding: c_int) c_int;
pub extern fn RSA_public_decrypt(flen: c_int, from: [*c]const u8, to: [*c]u8, rsa: ?*RSA, padding: c_int) c_int;
pub extern fn RSA_private_decrypt(flen: c_int, from: [*c]const u8, to: [*c]u8, rsa: ?*RSA, padding: c_int) c_int;
pub extern fn RSA_free(r: ?*RSA) void;
pub extern fn RSA_up_ref(r: ?*RSA) c_int;
pub extern fn RSA_flags(r: ?*const RSA) c_int;
pub extern fn RSA_set_default_method(meth: ?*const RSA_METHOD) void;
pub extern fn RSA_get_default_method() ?*const RSA_METHOD;
pub extern fn RSA_null_method() ?*const RSA_METHOD;
pub extern fn RSA_get_method(rsa: ?*const RSA) ?*const RSA_METHOD;
pub extern fn RSA_set_method(rsa: ?*RSA, meth: ?*const RSA_METHOD) c_int;
pub extern fn RSA_PKCS1_OpenSSL() ?*const RSA_METHOD;
pub extern fn d2i_RSAPublicKey(a: [*c]?*RSA, in: [*c][*c]const u8, len: c_long) ?*RSA;
pub extern fn i2d_RSAPublicKey(a: ?*const RSA, out: [*c][*c]u8) c_int;
pub extern fn RSAPublicKey_it() ?*const ASN1_ITEM;
pub extern fn d2i_RSAPrivateKey(a: [*c]?*RSA, in: [*c][*c]const u8, len: c_long) ?*RSA;
pub extern fn i2d_RSAPrivateKey(a: ?*const RSA, out: [*c][*c]u8) c_int;
pub extern fn RSAPrivateKey_it() ?*const ASN1_ITEM;
pub extern fn RSA_pkey_ctx_ctrl(ctx: ?*EVP_PKEY_CTX, optype: c_int, cmd: c_int, p1: c_int, p2: ?*anyopaque) c_int;
pub extern fn RSA_PSS_PARAMS_new() [*c]RSA_PSS_PARAMS;
pub extern fn RSA_PSS_PARAMS_free(a: [*c]RSA_PSS_PARAMS) void;
pub extern fn d2i_RSA_PSS_PARAMS(a: [*c][*c]RSA_PSS_PARAMS, in: [*c][*c]const u8, len: c_long) [*c]RSA_PSS_PARAMS;
pub extern fn i2d_RSA_PSS_PARAMS(a: [*c]const RSA_PSS_PARAMS, out: [*c][*c]u8) c_int;
pub extern fn RSA_PSS_PARAMS_it() ?*const ASN1_ITEM;
pub extern fn RSA_PSS_PARAMS_dup(a: [*c]const RSA_PSS_PARAMS) [*c]RSA_PSS_PARAMS;
pub const struct_rsa_oaep_params_st = extern struct {
    hashFunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    maskGenFunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    pSourceFunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    maskHash: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const RSA_OAEP_PARAMS = struct_rsa_oaep_params_st;
pub extern fn RSA_OAEP_PARAMS_new() [*c]RSA_OAEP_PARAMS;
pub extern fn RSA_OAEP_PARAMS_free(a: [*c]RSA_OAEP_PARAMS) void;
pub extern fn d2i_RSA_OAEP_PARAMS(a: [*c][*c]RSA_OAEP_PARAMS, in: [*c][*c]const u8, len: c_long) [*c]RSA_OAEP_PARAMS;
pub extern fn i2d_RSA_OAEP_PARAMS(a: [*c]const RSA_OAEP_PARAMS, out: [*c][*c]u8) c_int;
pub extern fn RSA_OAEP_PARAMS_it() ?*const ASN1_ITEM;
pub extern fn RSA_print_fp(fp: [*c]FILE, r: ?*const RSA, offset: c_int) c_int;
pub extern fn RSA_print(bp: ?*BIO, r: ?*const RSA, offset: c_int) c_int;
pub extern fn RSA_sign(@"type": c_int, m: [*c]const u8, m_length: c_uint, sigret: [*c]u8, siglen: [*c]c_uint, rsa: ?*RSA) c_int;
pub extern fn RSA_verify(@"type": c_int, m: [*c]const u8, m_length: c_uint, sigbuf: [*c]const u8, siglen: c_uint, rsa: ?*RSA) c_int;
pub extern fn RSA_sign_ASN1_OCTET_STRING(@"type": c_int, m: [*c]const u8, m_length: c_uint, sigret: [*c]u8, siglen: [*c]c_uint, rsa: ?*RSA) c_int;
pub extern fn RSA_verify_ASN1_OCTET_STRING(@"type": c_int, m: [*c]const u8, m_length: c_uint, sigbuf: [*c]u8, siglen: c_uint, rsa: ?*RSA) c_int;
pub extern fn RSA_blinding_on(rsa: ?*RSA, ctx: ?*BN_CTX) c_int;
pub extern fn RSA_blinding_off(rsa: ?*RSA) void;
pub extern fn RSA_setup_blinding(rsa: ?*RSA, ctx: ?*BN_CTX) ?*BN_BLINDING;
pub extern fn RSA_padding_add_PKCS1_type_1(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int) c_int;
pub extern fn RSA_padding_check_PKCS1_type_1(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int) c_int;
pub extern fn RSA_padding_add_PKCS1_type_2(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int) c_int;
pub extern fn RSA_padding_check_PKCS1_type_2(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int) c_int;
pub extern fn PKCS1_MGF1(mask: [*c]u8, len: c_long, seed: [*c]const u8, seedlen: c_long, dgst: ?*const EVP_MD) c_int;
pub extern fn RSA_padding_add_PKCS1_OAEP(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, p: [*c]const u8, pl: c_int) c_int;
pub extern fn RSA_padding_check_PKCS1_OAEP(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int, p: [*c]const u8, pl: c_int) c_int;
pub extern fn RSA_padding_add_PKCS1_OAEP_mgf1(to: [*c]u8, tlen: c_int, from: [*c]const u8, flen: c_int, param: [*c]const u8, plen: c_int, md: ?*const EVP_MD, mgf1md: ?*const EVP_MD) c_int;
pub extern fn RSA_padding_check_PKCS1_OAEP_mgf1(to: [*c]u8, tlen: c_int, from: [*c]const u8, flen: c_int, num: c_int, param: [*c]const u8, plen: c_int, md: ?*const EVP_MD, mgf1md: ?*const EVP_MD) c_int;
pub extern fn RSA_padding_add_none(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int) c_int;
pub extern fn RSA_padding_check_none(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int) c_int;
pub extern fn RSA_padding_add_X931(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int) c_int;
pub extern fn RSA_padding_check_X931(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int) c_int;
pub extern fn RSA_X931_hash_id(nid: c_int) c_int;
pub extern fn RSA_verify_PKCS1_PSS(rsa: ?*RSA, mHash: [*c]const u8, Hash: ?*const EVP_MD, EM: [*c]const u8, sLen: c_int) c_int;
pub extern fn RSA_padding_add_PKCS1_PSS(rsa: ?*RSA, EM: [*c]u8, mHash: [*c]const u8, Hash: ?*const EVP_MD, sLen: c_int) c_int;
pub extern fn RSA_verify_PKCS1_PSS_mgf1(rsa: ?*RSA, mHash: [*c]const u8, Hash: ?*const EVP_MD, mgf1Hash: ?*const EVP_MD, EM: [*c]const u8, sLen: c_int) c_int;
pub extern fn RSA_padding_add_PKCS1_PSS_mgf1(rsa: ?*RSA, EM: [*c]u8, mHash: [*c]const u8, Hash: ?*const EVP_MD, mgf1Hash: ?*const EVP_MD, sLen: c_int) c_int;
pub extern fn RSA_set_ex_data(r: ?*RSA, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn RSA_get_ex_data(r: ?*const RSA, idx: c_int) ?*anyopaque;
pub extern fn RSAPublicKey_dup(a: ?*const RSA) ?*RSA;
pub extern fn RSAPrivateKey_dup(a: ?*const RSA) ?*RSA;
pub extern fn RSA_meth_new(name: [*c]const u8, flags: c_int) ?*RSA_METHOD;
pub extern fn RSA_meth_free(meth: ?*RSA_METHOD) void;
pub extern fn RSA_meth_dup(meth: ?*const RSA_METHOD) ?*RSA_METHOD;
pub extern fn RSA_meth_get0_name(meth: ?*const RSA_METHOD) [*c]const u8;
pub extern fn RSA_meth_set1_name(meth: ?*RSA_METHOD, name: [*c]const u8) c_int;
pub extern fn RSA_meth_get_flags(meth: ?*const RSA_METHOD) c_int;
pub extern fn RSA_meth_set_flags(meth: ?*RSA_METHOD, flags: c_int) c_int;
pub extern fn RSA_meth_get0_app_data(meth: ?*const RSA_METHOD) ?*anyopaque;
pub extern fn RSA_meth_set0_app_data(meth: ?*RSA_METHOD, app_data: ?*anyopaque) c_int;
pub extern fn RSA_meth_get_pub_enc(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.C) c_int;
pub extern fn RSA_meth_set_pub_enc(rsa: ?*RSA_METHOD, pub_enc: ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_pub_dec(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.C) c_int;
pub extern fn RSA_meth_set_pub_dec(rsa: ?*RSA_METHOD, pub_dec: ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_priv_enc(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.C) c_int;
pub extern fn RSA_meth_set_priv_enc(rsa: ?*RSA_METHOD, priv_enc: ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_priv_dec(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.C) c_int;
pub extern fn RSA_meth_set_priv_dec(rsa: ?*RSA_METHOD, priv_dec: ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_mod_exp(meth: ?*const RSA_METHOD) ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*RSA, ?*BN_CTX) callconv(.C) c_int;
pub extern fn RSA_meth_set_mod_exp(rsa: ?*RSA_METHOD, mod_exp: ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*RSA, ?*BN_CTX) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_bn_mod_exp(meth: ?*const RSA_METHOD) ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.C) c_int;
pub extern fn RSA_meth_set_bn_mod_exp(rsa: ?*RSA_METHOD, bn_mod_exp: ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_init(meth: ?*const RSA_METHOD) ?*const fn (?*RSA) callconv(.C) c_int;
pub extern fn RSA_meth_set_init(rsa: ?*RSA_METHOD, init: ?*const fn (?*RSA) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_finish(meth: ?*const RSA_METHOD) ?*const fn (?*RSA) callconv(.C) c_int;
pub extern fn RSA_meth_set_finish(rsa: ?*RSA_METHOD, finish: ?*const fn (?*RSA) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_sign(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, c_uint, [*c]u8, [*c]c_uint, ?*const RSA) callconv(.C) c_int;
pub extern fn RSA_meth_set_sign(rsa: ?*RSA_METHOD, sign: ?*const fn (c_int, [*c]const u8, c_uint, [*c]u8, [*c]c_uint, ?*const RSA) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_verify(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, c_uint, [*c]const u8, c_uint, ?*const RSA) callconv(.C) c_int;
pub extern fn RSA_meth_set_verify(rsa: ?*RSA_METHOD, verify: ?*const fn (c_int, [*c]const u8, c_uint, [*c]const u8, c_uint, ?*const RSA) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_keygen(meth: ?*const RSA_METHOD) ?*const fn (?*RSA, c_int, ?*BIGNUM, ?*BN_GENCB) callconv(.C) c_int;
pub extern fn RSA_meth_set_keygen(rsa: ?*RSA_METHOD, keygen: ?*const fn (?*RSA, c_int, ?*BIGNUM, ?*BN_GENCB) callconv(.C) c_int) c_int;
pub extern fn RSA_meth_get_multi_prime_keygen(meth: ?*const RSA_METHOD) ?*const fn (?*RSA, c_int, c_int, ?*BIGNUM, ?*BN_GENCB) callconv(.C) c_int;
pub extern fn RSA_meth_set_multi_prime_keygen(meth: ?*RSA_METHOD, keygen: ?*const fn (?*RSA, c_int, c_int, ?*BIGNUM, ?*BN_GENCB) callconv(.C) c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_type(ctx: ?*EVP_PKEY_CTX, typ: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_gindex(ctx: ?*EVP_PKEY_CTX, gindex: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_seed(ctx: ?*EVP_PKEY_CTX, seed: [*c]const u8, seedlen: usize) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_prime_len(ctx: ?*EVP_PKEY_CTX, pbits: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_subprime_len(ctx: ?*EVP_PKEY_CTX, qlen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_generator(ctx: ?*EVP_PKEY_CTX, gen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_nid(ctx: ?*EVP_PKEY_CTX, nid: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_rfc5114(ctx: ?*EVP_PKEY_CTX, gen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dhx_rfc5114(ctx: ?*EVP_PKEY_CTX, gen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_pad(ctx: ?*EVP_PKEY_CTX, pad: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_kdf_type(ctx: ?*EVP_PKEY_CTX, kdf: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_dh_kdf_type(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_CTX_set0_dh_kdf_oid(ctx: ?*EVP_PKEY_CTX, oid: ?*ASN1_OBJECT) c_int;
pub extern fn EVP_PKEY_CTX_get0_dh_kdf_oid(ctx: ?*EVP_PKEY_CTX, oid: [*c]?*ASN1_OBJECT) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_kdf_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_get_dh_kdf_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_kdf_outlen(ctx: ?*EVP_PKEY_CTX, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_dh_kdf_outlen(ctx: ?*EVP_PKEY_CTX, len: [*c]c_int) c_int;
pub extern fn EVP_PKEY_CTX_set0_dh_kdf_ukm(ctx: ?*EVP_PKEY_CTX, ukm: [*c]u8, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get0_dh_kdf_ukm(ctx: ?*EVP_PKEY_CTX, ukm: [*c][*c]u8) c_int;
pub extern fn DHparams_it() ?*const ASN1_ITEM;
pub extern fn DHparams_dup(a: ?*const DH) ?*DH;
pub extern fn DH_OpenSSL() ?*const DH_METHOD;
pub extern fn DH_set_default_method(meth: ?*const DH_METHOD) void;
pub extern fn DH_get_default_method() ?*const DH_METHOD;
pub extern fn DH_set_method(dh: ?*DH, meth: ?*const DH_METHOD) c_int;
pub extern fn DH_new_method(engine: ?*ENGINE) ?*DH;
pub extern fn DH_new() ?*DH;
pub extern fn DH_free(dh: ?*DH) void;
pub extern fn DH_up_ref(dh: ?*DH) c_int;
pub extern fn DH_bits(dh: ?*const DH) c_int;
pub extern fn DH_size(dh: ?*const DH) c_int;
pub extern fn DH_security_bits(dh: ?*const DH) c_int;
pub extern fn DH_set_ex_data(d: ?*DH, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn DH_get_ex_data(d: ?*const DH, idx: c_int) ?*anyopaque;
pub extern fn DH_generate_parameters_ex(dh: ?*DH, prime_len: c_int, generator: c_int, cb: ?*BN_GENCB) c_int;
pub extern fn DH_check_params_ex(dh: ?*const DH) c_int;
pub extern fn DH_check_ex(dh: ?*const DH) c_int;
pub extern fn DH_check_pub_key_ex(dh: ?*const DH, pub_key: ?*const BIGNUM) c_int;
pub extern fn DH_check_params(dh: ?*const DH, ret: [*c]c_int) c_int;
pub extern fn DH_check(dh: ?*const DH, codes: [*c]c_int) c_int;
pub extern fn DH_check_pub_key(dh: ?*const DH, pub_key: ?*const BIGNUM, codes: [*c]c_int) c_int;
pub extern fn DH_generate_key(dh: ?*DH) c_int;
pub extern fn DH_compute_key(key: [*c]u8, pub_key: ?*const BIGNUM, dh: ?*DH) c_int;
pub extern fn DH_compute_key_padded(key: [*c]u8, pub_key: ?*const BIGNUM, dh: ?*DH) c_int;
pub extern fn d2i_DHparams(a: [*c]?*DH, in: [*c][*c]const u8, len: c_long) ?*DH;
pub extern fn i2d_DHparams(a: ?*const DH, out: [*c][*c]u8) c_int;
pub extern fn d2i_DHxparams(a: [*c]?*DH, in: [*c][*c]const u8, len: c_long) ?*DH;
pub extern fn i2d_DHxparams(a: ?*const DH, out: [*c][*c]u8) c_int;
pub extern fn DHparams_print_fp(fp: [*c]FILE, x: ?*const DH) c_int;
pub extern fn DHparams_print(bp: ?*BIO, x: ?*const DH) c_int;
pub extern fn DH_get_1024_160() ?*DH;
pub extern fn DH_get_2048_224() ?*DH;
pub extern fn DH_get_2048_256() ?*DH;
pub extern fn DH_new_by_nid(nid: c_int) ?*DH;
pub extern fn DH_get_nid(dh: ?*const DH) c_int;
pub extern fn DH_KDF_X9_42(out: [*c]u8, outlen: usize, Z: [*c]const u8, Zlen: usize, key_oid: ?*ASN1_OBJECT, ukm: [*c]const u8, ukmlen: usize, md: ?*const EVP_MD) c_int;
pub extern fn DH_get0_pqg(dh: ?*const DH, p: [*c]?*const BIGNUM, q: [*c]?*const BIGNUM, g: [*c]?*const BIGNUM) void;
pub extern fn DH_set0_pqg(dh: ?*DH, p: ?*BIGNUM, q: ?*BIGNUM, g: ?*BIGNUM) c_int;
pub extern fn DH_get0_key(dh: ?*const DH, pub_key: [*c]?*const BIGNUM, priv_key: [*c]?*const BIGNUM) void;
pub extern fn DH_set0_key(dh: ?*DH, pub_key: ?*BIGNUM, priv_key: ?*BIGNUM) c_int;
pub extern fn DH_get0_p(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_get0_q(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_get0_g(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_get0_priv_key(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_get0_pub_key(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_clear_flags(dh: ?*DH, flags: c_int) void;
pub extern fn DH_test_flags(dh: ?*const DH, flags: c_int) c_int;
pub extern fn DH_set_flags(dh: ?*DH, flags: c_int) void;
pub extern fn DH_get0_engine(d: ?*DH) ?*ENGINE;
pub extern fn DH_get_length(dh: ?*const DH) c_long;
pub extern fn DH_set_length(dh: ?*DH, length: c_long) c_int;
pub extern fn DH_meth_new(name: [*c]const u8, flags: c_int) ?*DH_METHOD;
pub extern fn DH_meth_free(dhm: ?*DH_METHOD) void;
pub extern fn DH_meth_dup(dhm: ?*const DH_METHOD) ?*DH_METHOD;
pub extern fn DH_meth_get0_name(dhm: ?*const DH_METHOD) [*c]const u8;
pub extern fn DH_meth_set1_name(dhm: ?*DH_METHOD, name: [*c]const u8) c_int;
pub extern fn DH_meth_get_flags(dhm: ?*const DH_METHOD) c_int;
pub extern fn DH_meth_set_flags(dhm: ?*DH_METHOD, flags: c_int) c_int;
pub extern fn DH_meth_get0_app_data(dhm: ?*const DH_METHOD) ?*anyopaque;
pub extern fn DH_meth_set0_app_data(dhm: ?*DH_METHOD, app_data: ?*anyopaque) c_int;
pub extern fn DH_meth_get_generate_key(dhm: ?*const DH_METHOD) ?*const fn (?*DH) callconv(.C) c_int;
pub extern fn DH_meth_set_generate_key(dhm: ?*DH_METHOD, generate_key: ?*const fn (?*DH) callconv(.C) c_int) c_int;
pub extern fn DH_meth_get_compute_key(dhm: ?*const DH_METHOD) ?*const fn ([*c]u8, ?*const BIGNUM, ?*DH) callconv(.C) c_int;
pub extern fn DH_meth_set_compute_key(dhm: ?*DH_METHOD, compute_key: ?*const fn ([*c]u8, ?*const BIGNUM, ?*DH) callconv(.C) c_int) c_int;
pub extern fn DH_meth_get_bn_mod_exp(dhm: ?*const DH_METHOD) ?*const fn (?*const DH, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.C) c_int;
pub extern fn DH_meth_set_bn_mod_exp(dhm: ?*DH_METHOD, bn_mod_exp: ?*const fn (?*const DH, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.C) c_int) c_int;
pub extern fn DH_meth_get_init(dhm: ?*const DH_METHOD) ?*const fn (?*DH) callconv(.C) c_int;
pub extern fn DH_meth_set_init(dhm: ?*DH_METHOD, init: ?*const fn (?*DH) callconv(.C) c_int) c_int;
pub extern fn DH_meth_get_finish(dhm: ?*const DH_METHOD) ?*const fn (?*DH) callconv(.C) c_int;
pub extern fn DH_meth_set_finish(dhm: ?*DH_METHOD, finish: ?*const fn (?*DH) callconv(.C) c_int) c_int;
pub extern fn DH_meth_get_generate_params(dhm: ?*const DH_METHOD) ?*const fn (?*DH, c_int, c_int, ?*BN_GENCB) callconv(.C) c_int;
pub extern fn DH_meth_set_generate_params(dhm: ?*DH_METHOD, generate_params: ?*const fn (?*DH, c_int, c_int, ?*BN_GENCB) callconv(.C) c_int) c_int;
pub extern fn DH_generate_parameters(prime_len: c_int, generator: c_int, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.C) void, cb_arg: ?*anyopaque) ?*DH;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx: ?*EVP_PKEY_CTX, nbits: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_q_bits(ctx: ?*EVP_PKEY_CTX, qbits: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_md_props(ctx: ?*EVP_PKEY_CTX, md_name: [*c]const u8, md_properties: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_gindex(ctx: ?*EVP_PKEY_CTX, gindex: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_type(ctx: ?*EVP_PKEY_CTX, name: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_seed(ctx: ?*EVP_PKEY_CTX, seed: [*c]const u8, seedlen: usize) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub const struct_DSA_SIG_st = opaque {};
pub const DSA_SIG = struct_DSA_SIG_st;
pub extern fn DSA_SIG_new() ?*DSA_SIG;
pub extern fn DSA_SIG_free(a: ?*DSA_SIG) void;
pub extern fn d2i_DSA_SIG(a: [*c]?*DSA_SIG, in: [*c][*c]const u8, len: c_long) ?*DSA_SIG;
pub extern fn i2d_DSA_SIG(a: ?*const DSA_SIG, out: [*c][*c]u8) c_int;
pub extern fn DSA_SIG_get0(sig: ?*const DSA_SIG, pr: [*c]?*const BIGNUM, ps: [*c]?*const BIGNUM) void;
pub extern fn DSA_SIG_set0(sig: ?*DSA_SIG, r: ?*BIGNUM, s: ?*BIGNUM) c_int;
pub extern fn DSAparams_dup(a: ?*const DSA) ?*DSA;
pub extern fn DSA_do_sign(dgst: [*c]const u8, dlen: c_int, dsa: ?*DSA) ?*DSA_SIG;
pub extern fn DSA_do_verify(dgst: [*c]const u8, dgst_len: c_int, sig: ?*DSA_SIG, dsa: ?*DSA) c_int;
pub extern fn DSA_OpenSSL() ?*const DSA_METHOD;
pub extern fn DSA_set_default_method(?*const DSA_METHOD) void;
pub extern fn DSA_get_default_method() ?*const DSA_METHOD;
pub extern fn DSA_set_method(dsa: ?*DSA, ?*const DSA_METHOD) c_int;
pub extern fn DSA_get_method(d: ?*DSA) ?*const DSA_METHOD;
pub extern fn DSA_new() ?*DSA;
pub extern fn DSA_new_method(engine: ?*ENGINE) ?*DSA;
pub extern fn DSA_free(r: ?*DSA) void;
pub extern fn DSA_up_ref(r: ?*DSA) c_int;
pub extern fn DSA_size(?*const DSA) c_int;
pub extern fn DSA_bits(d: ?*const DSA) c_int;
pub extern fn DSA_security_bits(d: ?*const DSA) c_int;
pub extern fn DSA_sign_setup(dsa: ?*DSA, ctx_in: ?*BN_CTX, kinvp: [*c]?*BIGNUM, rp: [*c]?*BIGNUM) c_int;
pub extern fn DSA_sign(@"type": c_int, dgst: [*c]const u8, dlen: c_int, sig: [*c]u8, siglen: [*c]c_uint, dsa: ?*DSA) c_int;
pub extern fn DSA_verify(@"type": c_int, dgst: [*c]const u8, dgst_len: c_int, sigbuf: [*c]const u8, siglen: c_int, dsa: ?*DSA) c_int;
pub extern fn DSA_set_ex_data(d: ?*DSA, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn DSA_get_ex_data(d: ?*const DSA, idx: c_int) ?*anyopaque;
pub extern fn d2i_DSAPublicKey(a: [*c]?*DSA, in: [*c][*c]const u8, len: c_long) ?*DSA;
pub extern fn i2d_DSAPublicKey(a: ?*const DSA, out: [*c][*c]u8) c_int;
pub extern fn d2i_DSAPrivateKey(a: [*c]?*DSA, in: [*c][*c]const u8, len: c_long) ?*DSA;
pub extern fn i2d_DSAPrivateKey(a: ?*const DSA, out: [*c][*c]u8) c_int;
pub extern fn d2i_DSAparams(a: [*c]?*DSA, in: [*c][*c]const u8, len: c_long) ?*DSA;
pub extern fn i2d_DSAparams(a: ?*const DSA, out: [*c][*c]u8) c_int;
pub extern fn DSA_generate_parameters(bits: c_int, seed: [*c]u8, seed_len: c_int, counter_ret: [*c]c_int, h_ret: [*c]c_ulong, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.C) void, cb_arg: ?*anyopaque) ?*DSA;
pub extern fn DSA_generate_parameters_ex(dsa: ?*DSA, bits: c_int, seed: [*c]const u8, seed_len: c_int, counter_ret: [*c]c_int, h_ret: [*c]c_ulong, cb: ?*BN_GENCB) c_int;
pub extern fn DSA_generate_key(a: ?*DSA) c_int;
pub extern fn DSAparams_print(bp: ?*BIO, x: ?*const DSA) c_int;
pub extern fn DSA_print(bp: ?*BIO, x: ?*const DSA, off: c_int) c_int;
pub extern fn DSAparams_print_fp(fp: [*c]FILE, x: ?*const DSA) c_int;
pub extern fn DSA_print_fp(bp: [*c]FILE, x: ?*const DSA, off: c_int) c_int;
pub extern fn DSA_dup_DH(r: ?*const DSA) ?*DH;
pub extern fn DSA_get0_pqg(d: ?*const DSA, p: [*c]?*const BIGNUM, q: [*c]?*const BIGNUM, g: [*c]?*const BIGNUM) void;
pub extern fn DSA_set0_pqg(d: ?*DSA, p: ?*BIGNUM, q: ?*BIGNUM, g: ?*BIGNUM) c_int;
pub extern fn DSA_get0_key(d: ?*const DSA, pub_key: [*c]?*const BIGNUM, priv_key: [*c]?*const BIGNUM) void;
pub extern fn DSA_set0_key(d: ?*DSA, pub_key: ?*BIGNUM, priv_key: ?*BIGNUM) c_int;
pub extern fn DSA_get0_p(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_get0_q(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_get0_g(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_get0_pub_key(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_get0_priv_key(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_clear_flags(d: ?*DSA, flags: c_int) void;
pub extern fn DSA_test_flags(d: ?*const DSA, flags: c_int) c_int;
pub extern fn DSA_set_flags(d: ?*DSA, flags: c_int) void;
pub extern fn DSA_get0_engine(d: ?*DSA) ?*ENGINE;
pub extern fn DSA_meth_new(name: [*c]const u8, flags: c_int) ?*DSA_METHOD;
pub extern fn DSA_meth_free(dsam: ?*DSA_METHOD) void;
pub extern fn DSA_meth_dup(dsam: ?*const DSA_METHOD) ?*DSA_METHOD;
pub extern fn DSA_meth_get0_name(dsam: ?*const DSA_METHOD) [*c]const u8;
pub extern fn DSA_meth_set1_name(dsam: ?*DSA_METHOD, name: [*c]const u8) c_int;
pub extern fn DSA_meth_get_flags(dsam: ?*const DSA_METHOD) c_int;
pub extern fn DSA_meth_set_flags(dsam: ?*DSA_METHOD, flags: c_int) c_int;
pub extern fn DSA_meth_get0_app_data(dsam: ?*const DSA_METHOD) ?*anyopaque;
pub extern fn DSA_meth_set0_app_data(dsam: ?*DSA_METHOD, app_data: ?*anyopaque) c_int;
pub extern fn DSA_meth_get_sign(dsam: ?*const DSA_METHOD) ?*const fn ([*c]const u8, c_int, ?*DSA) callconv(.C) ?*DSA_SIG;
pub extern fn DSA_meth_set_sign(dsam: ?*DSA_METHOD, sign: ?*const fn ([*c]const u8, c_int, ?*DSA) callconv(.C) ?*DSA_SIG) c_int;
pub extern fn DSA_meth_get_sign_setup(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA, ?*BN_CTX, [*c]?*BIGNUM, [*c]?*BIGNUM) callconv(.C) c_int;
pub extern fn DSA_meth_set_sign_setup(dsam: ?*DSA_METHOD, sign_setup: ?*const fn (?*DSA, ?*BN_CTX, [*c]?*BIGNUM, [*c]?*BIGNUM) callconv(.C) c_int) c_int;
pub extern fn DSA_meth_get_verify(dsam: ?*const DSA_METHOD) ?*const fn ([*c]const u8, c_int, ?*DSA_SIG, ?*DSA) callconv(.C) c_int;
pub extern fn DSA_meth_set_verify(dsam: ?*DSA_METHOD, verify: ?*const fn ([*c]const u8, c_int, ?*DSA_SIG, ?*DSA) callconv(.C) c_int) c_int;
pub extern fn DSA_meth_get_mod_exp(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.C) c_int;
pub extern fn DSA_meth_set_mod_exp(dsam: ?*DSA_METHOD, mod_exp: ?*const fn (?*DSA, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.C) c_int) c_int;
pub extern fn DSA_meth_get_bn_mod_exp(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.C) c_int;
pub extern fn DSA_meth_set_bn_mod_exp(dsam: ?*DSA_METHOD, bn_mod_exp: ?*const fn (?*DSA, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.C) c_int) c_int;
pub extern fn DSA_meth_get_init(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA) callconv(.C) c_int;
pub extern fn DSA_meth_set_init(dsam: ?*DSA_METHOD, init: ?*const fn (?*DSA) callconv(.C) c_int) c_int;
pub extern fn DSA_meth_get_finish(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA) callconv(.C) c_int;
pub extern fn DSA_meth_set_finish(dsam: ?*DSA_METHOD, finish: ?*const fn (?*DSA) callconv(.C) c_int) c_int;
pub extern fn DSA_meth_get_paramgen(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA, c_int, [*c]const u8, c_int, [*c]c_int, [*c]c_ulong, ?*BN_GENCB) callconv(.C) c_int;
pub extern fn DSA_meth_set_paramgen(dsam: ?*DSA_METHOD, paramgen: ?*const fn (?*DSA, c_int, [*c]const u8, c_int, [*c]c_int, [*c]c_ulong, ?*BN_GENCB) callconv(.C) c_int) c_int;
pub extern fn DSA_meth_get_keygen(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA) callconv(.C) c_int;
pub extern fn DSA_meth_set_keygen(dsam: ?*DSA_METHOD, keygen: ?*const fn (?*DSA) callconv(.C) c_int) c_int;
pub const struct_SHAstate_st = extern struct {
    h0: c_uint = @import("std").mem.zeroes(c_uint),
    h1: c_uint = @import("std").mem.zeroes(c_uint),
    h2: c_uint = @import("std").mem.zeroes(c_uint),
    h3: c_uint = @import("std").mem.zeroes(c_uint),
    h4: c_uint = @import("std").mem.zeroes(c_uint),
    Nl: c_uint = @import("std").mem.zeroes(c_uint),
    Nh: c_uint = @import("std").mem.zeroes(c_uint),
    data: [16]c_uint = @import("std").mem.zeroes([16]c_uint),
    num: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const SHA_CTX = struct_SHAstate_st;
pub extern fn SHA1_Init(c: [*c]SHA_CTX) c_int;
pub extern fn SHA1_Update(c: [*c]SHA_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA1_Final(md: [*c]u8, c: [*c]SHA_CTX) c_int;
pub extern fn SHA1_Transform(c: [*c]SHA_CTX, data: [*c]const u8) void;
pub extern fn SHA1(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
pub const struct_SHA256state_st = extern struct {
    h: [8]c_uint = @import("std").mem.zeroes([8]c_uint),
    Nl: c_uint = @import("std").mem.zeroes(c_uint),
    Nh: c_uint = @import("std").mem.zeroes(c_uint),
    data: [16]c_uint = @import("std").mem.zeroes([16]c_uint),
    num: c_uint = @import("std").mem.zeroes(c_uint),
    md_len: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const SHA256_CTX = struct_SHA256state_st;
pub extern fn SHA224_Init(c: [*c]SHA256_CTX) c_int;
pub extern fn SHA224_Update(c: [*c]SHA256_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA224_Final(md: [*c]u8, c: [*c]SHA256_CTX) c_int;
pub extern fn SHA256_Init(c: [*c]SHA256_CTX) c_int;
pub extern fn SHA256_Update(c: [*c]SHA256_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA256_Final(md: [*c]u8, c: [*c]SHA256_CTX) c_int;
pub extern fn SHA256_Transform(c: [*c]SHA256_CTX, data: [*c]const u8) void;
pub extern fn SHA224(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
pub extern fn SHA256(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
const union_unnamed_7 = extern union {
    d: [16]c_ulonglong,
    p: [128]u8,
};
pub const struct_SHA512state_st = extern struct {
    h: [8]c_ulonglong = @import("std").mem.zeroes([8]c_ulonglong),
    Nl: c_ulonglong = @import("std").mem.zeroes(c_ulonglong),
    Nh: c_ulonglong = @import("std").mem.zeroes(c_ulonglong),
    u: union_unnamed_7 = @import("std").mem.zeroes(union_unnamed_7),
    num: c_uint = @import("std").mem.zeroes(c_uint),
    md_len: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const SHA512_CTX = struct_SHA512state_st;
pub extern fn SHA384_Init(c: [*c]SHA512_CTX) c_int;
pub extern fn SHA384_Update(c: [*c]SHA512_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA384_Final(md: [*c]u8, c: [*c]SHA512_CTX) c_int;
pub extern fn SHA512_Init(c: [*c]SHA512_CTX) c_int;
pub extern fn SHA512_Update(c: [*c]SHA512_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA512_Final(md: [*c]u8, c: [*c]SHA512_CTX) c_int;
pub extern fn SHA512_Transform(c: [*c]SHA512_CTX, data: [*c]const u8) void;
pub extern fn SHA384(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
pub extern fn SHA512(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
pub const struct_stack_st_X509_NAME = opaque {};
pub const sk_X509_NAME_compfunc = ?*const fn ([*c]const ?*const X509_NAME, [*c]const ?*const X509_NAME) callconv(.C) c_int;
pub const sk_X509_NAME_freefunc = ?*const fn (?*X509_NAME) callconv(.C) void;
pub const sk_X509_NAME_copyfunc = ?*const fn (?*const X509_NAME) callconv(.C) ?*X509_NAME;
pub fn ossl_check_X509_NAME_type(arg_ptr: ?*X509_NAME) callconv(.C) ?*X509_NAME {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_NAME_sk_type(arg_sk: ?*const struct_stack_st_X509_NAME) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_NAME_sk_type(arg_sk: ?*struct_stack_st_X509_NAME) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_NAME_compfunc_type(arg_cmp: sk_X509_NAME_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_NAME_copyfunc_type(arg_cpy: sk_X509_NAME_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_NAME_freefunc_type(arg_fr: sk_X509_NAME_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509 = opaque {};
pub const sk_X509_compfunc = ?*const fn ([*c]const ?*const X509, [*c]const ?*const X509) callconv(.C) c_int;
pub const sk_X509_freefunc = ?*const fn (?*X509) callconv(.C) void;
pub const sk_X509_copyfunc = ?*const fn (?*const X509) callconv(.C) ?*X509;
pub fn ossl_check_X509_type(arg_ptr: ?*X509) callconv(.C) ?*X509 {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_sk_type(arg_sk: ?*const struct_stack_st_X509) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_sk_type(arg_sk: ?*struct_stack_st_X509) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_compfunc_type(arg_cmp: sk_X509_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_copyfunc_type(arg_cpy: sk_X509_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_freefunc_type(arg_fr: sk_X509_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509_REVOKED = opaque {};
pub const sk_X509_REVOKED_compfunc = ?*const fn ([*c]const ?*const X509_REVOKED, [*c]const ?*const X509_REVOKED) callconv(.C) c_int;
pub const sk_X509_REVOKED_freefunc = ?*const fn (?*X509_REVOKED) callconv(.C) void;
pub const sk_X509_REVOKED_copyfunc = ?*const fn (?*const X509_REVOKED) callconv(.C) ?*X509_REVOKED;
pub fn ossl_check_X509_REVOKED_type(arg_ptr: ?*X509_REVOKED) callconv(.C) ?*X509_REVOKED {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_REVOKED_sk_type(arg_sk: ?*const struct_stack_st_X509_REVOKED) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_REVOKED_sk_type(arg_sk: ?*struct_stack_st_X509_REVOKED) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_REVOKED_compfunc_type(arg_cmp: sk_X509_REVOKED_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_REVOKED_copyfunc_type(arg_cpy: sk_X509_REVOKED_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_REVOKED_freefunc_type(arg_fr: sk_X509_REVOKED_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509_CRL = opaque {};
pub const sk_X509_CRL_compfunc = ?*const fn ([*c]const ?*const X509_CRL, [*c]const ?*const X509_CRL) callconv(.C) c_int;
pub const sk_X509_CRL_freefunc = ?*const fn (?*X509_CRL) callconv(.C) void;
pub const sk_X509_CRL_copyfunc = ?*const fn (?*const X509_CRL) callconv(.C) ?*X509_CRL;
pub fn ossl_check_X509_CRL_type(arg_ptr: ?*X509_CRL) callconv(.C) ?*X509_CRL {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_CRL_sk_type(arg_sk: ?*const struct_stack_st_X509_CRL) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_CRL_sk_type(arg_sk: ?*struct_stack_st_X509_CRL) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_CRL_compfunc_type(arg_cmp: sk_X509_CRL_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_CRL_copyfunc_type(arg_cpy: sk_X509_CRL_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_CRL_freefunc_type(arg_fr: sk_X509_CRL_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const X509_ALGORS = struct_stack_st_X509_ALGOR;
pub const struct_X509_val_st = extern struct {
    notBefore: [*c]ASN1_TIME = @import("std").mem.zeroes([*c]ASN1_TIME),
    notAfter: [*c]ASN1_TIME = @import("std").mem.zeroes([*c]ASN1_TIME),
};
pub const X509_VAL = struct_X509_val_st;
pub const struct_X509_sig_st = opaque {};
pub const X509_SIG = struct_X509_sig_st;
pub const struct_X509_name_entry_st = opaque {};
pub const X509_NAME_ENTRY = struct_X509_name_entry_st;
pub const struct_stack_st_X509_NAME_ENTRY = opaque {};
pub const sk_X509_NAME_ENTRY_compfunc = ?*const fn ([*c]const ?*const X509_NAME_ENTRY, [*c]const ?*const X509_NAME_ENTRY) callconv(.C) c_int;
pub const sk_X509_NAME_ENTRY_freefunc = ?*const fn (?*X509_NAME_ENTRY) callconv(.C) void;
pub const sk_X509_NAME_ENTRY_copyfunc = ?*const fn (?*const X509_NAME_ENTRY) callconv(.C) ?*X509_NAME_ENTRY;
pub fn ossl_check_X509_NAME_ENTRY_type(arg_ptr: ?*X509_NAME_ENTRY) callconv(.C) ?*X509_NAME_ENTRY {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_NAME_ENTRY_sk_type(arg_sk: ?*const struct_stack_st_X509_NAME_ENTRY) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_NAME_ENTRY_sk_type(arg_sk: ?*struct_stack_st_X509_NAME_ENTRY) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_NAME_ENTRY_compfunc_type(arg_cmp: sk_X509_NAME_ENTRY_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_NAME_ENTRY_copyfunc_type(arg_cpy: sk_X509_NAME_ENTRY_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_NAME_ENTRY_freefunc_type(arg_fr: sk_X509_NAME_ENTRY_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_X509_extension_st = opaque {};
pub const X509_EXTENSION = struct_X509_extension_st;
pub const struct_stack_st_X509_EXTENSION = opaque {};
pub const sk_X509_EXTENSION_compfunc = ?*const fn ([*c]const ?*const X509_EXTENSION, [*c]const ?*const X509_EXTENSION) callconv(.C) c_int;
pub const sk_X509_EXTENSION_freefunc = ?*const fn (?*X509_EXTENSION) callconv(.C) void;
pub const sk_X509_EXTENSION_copyfunc = ?*const fn (?*const X509_EXTENSION) callconv(.C) ?*X509_EXTENSION;
pub fn ossl_check_X509_EXTENSION_type(arg_ptr: ?*X509_EXTENSION) callconv(.C) ?*X509_EXTENSION {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_EXTENSION_sk_type(arg_sk: ?*const struct_stack_st_X509_EXTENSION) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_EXTENSION_sk_type(arg_sk: ?*struct_stack_st_X509_EXTENSION) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_EXTENSION_compfunc_type(arg_cmp: sk_X509_EXTENSION_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_EXTENSION_copyfunc_type(arg_cpy: sk_X509_EXTENSION_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_EXTENSION_freefunc_type(arg_fr: sk_X509_EXTENSION_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const X509_EXTENSIONS = struct_stack_st_X509_EXTENSION;
pub const struct_x509_attributes_st = opaque {};
pub const X509_ATTRIBUTE = struct_x509_attributes_st;
pub const struct_stack_st_X509_ATTRIBUTE = opaque {};
pub const sk_X509_ATTRIBUTE_compfunc = ?*const fn ([*c]const ?*const X509_ATTRIBUTE, [*c]const ?*const X509_ATTRIBUTE) callconv(.C) c_int;
pub const sk_X509_ATTRIBUTE_freefunc = ?*const fn (?*X509_ATTRIBUTE) callconv(.C) void;
pub const sk_X509_ATTRIBUTE_copyfunc = ?*const fn (?*const X509_ATTRIBUTE) callconv(.C) ?*X509_ATTRIBUTE;
pub fn ossl_check_X509_ATTRIBUTE_type(arg_ptr: ?*X509_ATTRIBUTE) callconv(.C) ?*X509_ATTRIBUTE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_ATTRIBUTE_sk_type(arg_sk: ?*const struct_stack_st_X509_ATTRIBUTE) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_ATTRIBUTE_sk_type(arg_sk: ?*struct_stack_st_X509_ATTRIBUTE) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_ATTRIBUTE_compfunc_type(arg_cmp: sk_X509_ATTRIBUTE_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_ATTRIBUTE_copyfunc_type(arg_cpy: sk_X509_ATTRIBUTE_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_ATTRIBUTE_freefunc_type(arg_fr: sk_X509_ATTRIBUTE_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_X509_req_info_st = opaque {};
pub const X509_REQ_INFO = struct_X509_req_info_st;
pub const struct_X509_req_st = opaque {};
pub const X509_REQ = struct_X509_req_st;
pub const struct_x509_cert_aux_st = opaque {};
pub const X509_CERT_AUX = struct_x509_cert_aux_st;
pub const struct_x509_cinf_st = opaque {};
pub const X509_CINF = struct_x509_cinf_st;
pub const struct_X509_crl_info_st = opaque {};
pub const X509_CRL_INFO = struct_X509_crl_info_st;
pub const struct_private_key_st = extern struct {
    version: c_int = @import("std").mem.zeroes(c_int),
    enc_algor: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    enc_pkey: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    dec_pkey: ?*EVP_PKEY = @import("std").mem.zeroes(?*EVP_PKEY),
    key_length: c_int = @import("std").mem.zeroes(c_int),
    key_data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    key_free: c_int = @import("std").mem.zeroes(c_int),
    cipher: EVP_CIPHER_INFO = @import("std").mem.zeroes(EVP_CIPHER_INFO),
};
pub const X509_PKEY = struct_private_key_st;
pub const struct_X509_info_st = extern struct {
    x509: ?*X509 = @import("std").mem.zeroes(?*X509),
    crl: ?*X509_CRL = @import("std").mem.zeroes(?*X509_CRL),
    x_pkey: [*c]X509_PKEY = @import("std").mem.zeroes([*c]X509_PKEY),
    enc_cipher: EVP_CIPHER_INFO = @import("std").mem.zeroes(EVP_CIPHER_INFO),
    enc_len: c_int = @import("std").mem.zeroes(c_int),
    enc_data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const X509_INFO = struct_X509_info_st;
pub const struct_stack_st_X509_INFO = opaque {};
pub const sk_X509_INFO_compfunc = ?*const fn ([*c]const [*c]const X509_INFO, [*c]const [*c]const X509_INFO) callconv(.C) c_int;
pub const sk_X509_INFO_freefunc = ?*const fn ([*c]X509_INFO) callconv(.C) void;
pub const sk_X509_INFO_copyfunc = ?*const fn ([*c]const X509_INFO) callconv(.C) [*c]X509_INFO;
pub fn ossl_check_X509_INFO_type(arg_ptr: [*c]X509_INFO) callconv(.C) [*c]X509_INFO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_INFO_sk_type(arg_sk: ?*const struct_stack_st_X509_INFO) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_INFO_sk_type(arg_sk: ?*struct_stack_st_X509_INFO) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_INFO_compfunc_type(arg_cmp: sk_X509_INFO_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_INFO_copyfunc_type(arg_cpy: sk_X509_INFO_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_INFO_freefunc_type(arg_fr: sk_X509_INFO_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_Netscape_spkac_st = extern struct {
    pubkey: ?*X509_PUBKEY = @import("std").mem.zeroes(?*X509_PUBKEY),
    challenge: [*c]ASN1_IA5STRING = @import("std").mem.zeroes([*c]ASN1_IA5STRING),
};
pub const NETSCAPE_SPKAC = struct_Netscape_spkac_st;
pub const struct_Netscape_spki_st = extern struct {
    spkac: [*c]NETSCAPE_SPKAC = @import("std").mem.zeroes([*c]NETSCAPE_SPKAC),
    sig_algor: X509_ALGOR = @import("std").mem.zeroes(X509_ALGOR),
    signature: [*c]ASN1_BIT_STRING = @import("std").mem.zeroes([*c]ASN1_BIT_STRING),
};
pub const NETSCAPE_SPKI = struct_Netscape_spki_st;
pub const struct_Netscape_certificate_sequence = extern struct {
    type: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    certs: ?*struct_stack_st_X509 = @import("std").mem.zeroes(?*struct_stack_st_X509),
};
pub const NETSCAPE_CERT_SEQUENCE = struct_Netscape_certificate_sequence;
pub const struct_PBEPARAM_st = extern struct {
    salt: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    iter: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const PBEPARAM = struct_PBEPARAM_st;
pub const struct_PBE2PARAM_st = extern struct {
    keyfunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    encryption: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const PBE2PARAM = struct_PBE2PARAM_st;
pub const struct_PBKDF2PARAM_st = extern struct {
    salt: [*c]ASN1_TYPE = @import("std").mem.zeroes([*c]ASN1_TYPE),
    iter: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    keylength: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    prf: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const PBKDF2PARAM = struct_PBKDF2PARAM_st;
pub const PBMAC1PARAM = extern struct {
    keyDerivationFunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    messageAuthScheme: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const struct_SCRYPT_PARAMS_st = extern struct {
    salt: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    costParameter: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    blockSize: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    parallelizationParameter: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    keyLength: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const SCRYPT_PARAMS = struct_SCRYPT_PARAMS_st;
pub const struct_lhash_node_st = opaque {};
pub const OPENSSL_LH_NODE = struct_lhash_node_st;
pub const OPENSSL_LH_COMPFUNC = ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int;
pub const OPENSSL_LH_COMPFUNCTHUNK = ?*const fn (?*const anyopaque, ?*const anyopaque, OPENSSL_LH_COMPFUNC) callconv(.C) c_int;
pub const OPENSSL_LH_HASHFUNC = ?*const fn (?*const anyopaque) callconv(.C) c_ulong;
pub const OPENSSL_LH_HASHFUNCTHUNK = ?*const fn (?*const anyopaque, OPENSSL_LH_HASHFUNC) callconv(.C) c_ulong;
pub const OPENSSL_LH_DOALL_FUNC = ?*const fn (?*anyopaque) callconv(.C) void;
pub const OPENSSL_LH_DOALL_FUNC_THUNK = ?*const fn (?*anyopaque, OPENSSL_LH_DOALL_FUNC) callconv(.C) void;
pub const OPENSSL_LH_DOALL_FUNCARG = ?*const fn (?*anyopaque, ?*anyopaque) callconv(.C) void;
pub const OPENSSL_LH_DOALL_FUNCARG_THUNK = ?*const fn (?*anyopaque, ?*anyopaque, OPENSSL_LH_DOALL_FUNCARG) callconv(.C) void;
pub const struct_lhash_st = opaque {};
pub const OPENSSL_LHASH = struct_lhash_st;
pub extern fn OPENSSL_LH_error(lh: ?*OPENSSL_LHASH) c_int;
pub extern fn OPENSSL_LH_new(h: OPENSSL_LH_HASHFUNC, c: OPENSSL_LH_COMPFUNC) ?*OPENSSL_LHASH;
pub extern fn OPENSSL_LH_set_thunks(lh: ?*OPENSSL_LHASH, hw: OPENSSL_LH_HASHFUNCTHUNK, cw: OPENSSL_LH_COMPFUNCTHUNK, daw: OPENSSL_LH_DOALL_FUNC_THUNK, daaw: OPENSSL_LH_DOALL_FUNCARG_THUNK) ?*OPENSSL_LHASH;
pub extern fn OPENSSL_LH_free(lh: ?*OPENSSL_LHASH) void;
pub extern fn OPENSSL_LH_flush(lh: ?*OPENSSL_LHASH) void;
pub extern fn OPENSSL_LH_insert(lh: ?*OPENSSL_LHASH, data: ?*anyopaque) ?*anyopaque;
pub extern fn OPENSSL_LH_delete(lh: ?*OPENSSL_LHASH, data: ?*const anyopaque) ?*anyopaque;
pub extern fn OPENSSL_LH_retrieve(lh: ?*OPENSSL_LHASH, data: ?*const anyopaque) ?*anyopaque;
pub extern fn OPENSSL_LH_doall(lh: ?*OPENSSL_LHASH, func: OPENSSL_LH_DOALL_FUNC) void;
pub extern fn OPENSSL_LH_doall_arg(lh: ?*OPENSSL_LHASH, func: OPENSSL_LH_DOALL_FUNCARG, arg: ?*anyopaque) void;
pub extern fn OPENSSL_LH_doall_arg_thunk(lh: ?*OPENSSL_LHASH, daaw: OPENSSL_LH_DOALL_FUNCARG_THUNK, @"fn": OPENSSL_LH_DOALL_FUNCARG, arg: ?*anyopaque) void;
pub extern fn OPENSSL_LH_strhash(c: [*c]const u8) c_ulong;
pub extern fn OPENSSL_LH_num_items(lh: ?*const OPENSSL_LHASH) c_ulong;
pub extern fn OPENSSL_LH_get_down_load(lh: ?*const OPENSSL_LHASH) c_ulong;
pub extern fn OPENSSL_LH_set_down_load(lh: ?*OPENSSL_LHASH, down_load: c_ulong) void;
pub extern fn OPENSSL_LH_stats(lh: ?*const OPENSSL_LHASH, fp: [*c]FILE) void;
pub extern fn OPENSSL_LH_node_stats(lh: ?*const OPENSSL_LHASH, fp: [*c]FILE) void;
pub extern fn OPENSSL_LH_node_usage_stats(lh: ?*const OPENSSL_LHASH, fp: [*c]FILE) void;
pub extern fn OPENSSL_LH_stats_bio(lh: ?*const OPENSSL_LHASH, out: ?*BIO) void;
pub extern fn OPENSSL_LH_node_stats_bio(lh: ?*const OPENSSL_LHASH, out: ?*BIO) void;
pub extern fn OPENSSL_LH_node_usage_stats_bio(lh: ?*const OPENSSL_LHASH, out: ?*BIO) void;
pub const union_lh_OPENSSL_STRING_dummy_8 = extern union {
    d1: ?*anyopaque,
    d2: c_ulong,
    d3: c_int,
};
pub const struct_lhash_st_OPENSSL_STRING = extern struct {
    dummy: union_lh_OPENSSL_STRING_dummy_8 = @import("std").mem.zeroes(union_lh_OPENSSL_STRING_dummy_8),
};
pub const lh_OPENSSL_STRING_compfunc = ?*const fn ([*c]const OPENSSL_STRING, [*c]const OPENSSL_STRING) callconv(.C) c_int;
pub const lh_OPENSSL_STRING_hashfunc = ?*const fn ([*c]const OPENSSL_STRING) callconv(.C) c_ulong;
pub const lh_OPENSSL_STRING_doallfunc = ?*const fn ([*c]OPENSSL_STRING) callconv(.C) void;
pub fn lh_OPENSSL_STRING_hash_thunk(arg_data: ?*const anyopaque, arg_hfn: OPENSSL_LH_HASHFUNC) callconv(.C) c_ulong {
    var data = arg_data;
    _ = &data;
    var hfn = arg_hfn;
    _ = &hfn;
    var hfn_conv: ?*const fn ([*c]const OPENSSL_STRING) callconv(.C) c_ulong = @as(?*const fn ([*c]const OPENSSL_STRING) callconv(.C) c_ulong, @ptrCast(@alignCast(hfn)));
    _ = &hfn_conv;
    return hfn_conv.?(@as([*c]const OPENSSL_STRING, @ptrCast(@alignCast(data))));
}
pub fn lh_OPENSSL_STRING_comp_thunk(arg_da: ?*const anyopaque, arg_db: ?*const anyopaque, arg_cfn: OPENSSL_LH_COMPFUNC) callconv(.C) c_int {
    var da = arg_da;
    _ = &da;
    var db = arg_db;
    _ = &db;
    var cfn = arg_cfn;
    _ = &cfn;
    var cfn_conv: ?*const fn ([*c]const OPENSSL_STRING, [*c]const OPENSSL_STRING) callconv(.C) c_int = @as(?*const fn ([*c]const OPENSSL_STRING, [*c]const OPENSSL_STRING) callconv(.C) c_int, @ptrCast(@alignCast(cfn)));
    _ = &cfn_conv;
    return cfn_conv.?(@as([*c]const OPENSSL_STRING, @ptrCast(@alignCast(da))), @as([*c]const OPENSSL_STRING, @ptrCast(@alignCast(db))));
}
pub fn lh_OPENSSL_STRING_doall_thunk(arg_node: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNC) callconv(.C) void {
    var node = arg_node;
    _ = &node;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]OPENSSL_STRING) callconv(.C) void = @as(?*const fn ([*c]OPENSSL_STRING) callconv(.C) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]OPENSSL_STRING, @ptrCast(@alignCast(node))));
}
pub fn lh_OPENSSL_STRING_doall_arg_thunk(arg_node: ?*anyopaque, arg_arg: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNCARG) callconv(.C) void {
    var node = arg_node;
    _ = &node;
    var arg = arg_arg;
    _ = &arg;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]OPENSSL_STRING, ?*anyopaque) callconv(.C) void = @as(?*const fn ([*c]OPENSSL_STRING, ?*anyopaque) callconv(.C) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]OPENSSL_STRING, @ptrCast(@alignCast(node))), arg);
}
pub fn ossl_check_OPENSSL_STRING_lh_plain_type(arg_ptr: [*c]OPENSSL_STRING) callconv(.C) [*c]OPENSSL_STRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_STRING_lh_plain_type(arg_ptr: [*c]const OPENSSL_STRING) callconv(.C) [*c]const OPENSSL_STRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_STRING_lh_type(arg_lh: [*c]const struct_lhash_st_OPENSSL_STRING) callconv(.C) ?*const OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*const OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_OPENSSL_STRING_lh_type(arg_lh: [*c]struct_lhash_st_OPENSSL_STRING) callconv(.C) ?*OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_OPENSSL_STRING_lh_compfunc_type(arg_cmp: lh_OPENSSL_STRING_compfunc) callconv(.C) OPENSSL_LH_COMPFUNC {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_LH_COMPFUNC, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_STRING_lh_hashfunc_type(arg_hfn: lh_OPENSSL_STRING_hashfunc) callconv(.C) OPENSSL_LH_HASHFUNC {
    var hfn = arg_hfn;
    _ = &hfn;
    return @as(OPENSSL_LH_HASHFUNC, @ptrCast(@alignCast(hfn)));
}
pub fn ossl_check_OPENSSL_STRING_lh_doallfunc_type(arg_dfn: lh_OPENSSL_STRING_doallfunc) callconv(.C) OPENSSL_LH_DOALL_FUNC {
    var dfn = arg_dfn;
    _ = &dfn;
    return @as(OPENSSL_LH_DOALL_FUNC, @ptrCast(@alignCast(dfn)));
}
pub const union_lh_OPENSSL_CSTRING_dummy_9 = extern union {
    d1: ?*anyopaque,
    d2: c_ulong,
    d3: c_int,
};
pub const struct_lhash_st_OPENSSL_CSTRING = extern struct {
    dummy: union_lh_OPENSSL_CSTRING_dummy_9 = @import("std").mem.zeroes(union_lh_OPENSSL_CSTRING_dummy_9),
};
pub const lh_OPENSSL_CSTRING_compfunc = ?*const fn ([*c]const OPENSSL_CSTRING, [*c]const OPENSSL_CSTRING) callconv(.C) c_int;
pub const lh_OPENSSL_CSTRING_hashfunc = ?*const fn ([*c]const OPENSSL_CSTRING) callconv(.C) c_ulong;
pub const lh_OPENSSL_CSTRING_doallfunc = ?*const fn ([*c]OPENSSL_CSTRING) callconv(.C) void;
pub fn lh_OPENSSL_CSTRING_hash_thunk(arg_data: ?*const anyopaque, arg_hfn: OPENSSL_LH_HASHFUNC) callconv(.C) c_ulong {
    var data = arg_data;
    _ = &data;
    var hfn = arg_hfn;
    _ = &hfn;
    var hfn_conv: ?*const fn ([*c]const OPENSSL_CSTRING) callconv(.C) c_ulong = @as(?*const fn ([*c]const OPENSSL_CSTRING) callconv(.C) c_ulong, @ptrCast(@alignCast(hfn)));
    _ = &hfn_conv;
    return hfn_conv.?(@as([*c]const OPENSSL_CSTRING, @ptrCast(@alignCast(data))));
}
pub fn lh_OPENSSL_CSTRING_comp_thunk(arg_da: ?*const anyopaque, arg_db: ?*const anyopaque, arg_cfn: OPENSSL_LH_COMPFUNC) callconv(.C) c_int {
    var da = arg_da;
    _ = &da;
    var db = arg_db;
    _ = &db;
    var cfn = arg_cfn;
    _ = &cfn;
    var cfn_conv: ?*const fn ([*c]const OPENSSL_CSTRING, [*c]const OPENSSL_CSTRING) callconv(.C) c_int = @as(?*const fn ([*c]const OPENSSL_CSTRING, [*c]const OPENSSL_CSTRING) callconv(.C) c_int, @ptrCast(@alignCast(cfn)));
    _ = &cfn_conv;
    return cfn_conv.?(@as([*c]const OPENSSL_CSTRING, @ptrCast(@alignCast(da))), @as([*c]const OPENSSL_CSTRING, @ptrCast(@alignCast(db))));
}
pub fn lh_OPENSSL_CSTRING_doall_thunk(arg_node: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNC) callconv(.C) void {
    var node = arg_node;
    _ = &node;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]OPENSSL_CSTRING) callconv(.C) void = @as(?*const fn ([*c]OPENSSL_CSTRING) callconv(.C) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]OPENSSL_CSTRING, @ptrCast(@alignCast(node))));
}
pub fn lh_OPENSSL_CSTRING_doall_arg_thunk(arg_node: ?*anyopaque, arg_arg: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNCARG) callconv(.C) void {
    var node = arg_node;
    _ = &node;
    var arg = arg_arg;
    _ = &arg;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]OPENSSL_CSTRING, ?*anyopaque) callconv(.C) void = @as(?*const fn ([*c]OPENSSL_CSTRING, ?*anyopaque) callconv(.C) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]OPENSSL_CSTRING, @ptrCast(@alignCast(node))), arg);
}
pub fn ossl_check_OPENSSL_CSTRING_lh_plain_type(arg_ptr: [*c]OPENSSL_CSTRING) callconv(.C) [*c]OPENSSL_CSTRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_CSTRING_lh_plain_type(arg_ptr: [*c]const OPENSSL_CSTRING) callconv(.C) [*c]const OPENSSL_CSTRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_CSTRING_lh_type(arg_lh: [*c]const struct_lhash_st_OPENSSL_CSTRING) callconv(.C) ?*const OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*const OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_OPENSSL_CSTRING_lh_type(arg_lh: [*c]struct_lhash_st_OPENSSL_CSTRING) callconv(.C) ?*OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_OPENSSL_CSTRING_lh_compfunc_type(arg_cmp: lh_OPENSSL_CSTRING_compfunc) callconv(.C) OPENSSL_LH_COMPFUNC {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_LH_COMPFUNC, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_CSTRING_lh_hashfunc_type(arg_hfn: lh_OPENSSL_CSTRING_hashfunc) callconv(.C) OPENSSL_LH_HASHFUNC {
    var hfn = arg_hfn;
    _ = &hfn;
    return @as(OPENSSL_LH_HASHFUNC, @ptrCast(@alignCast(hfn)));
}
pub fn ossl_check_OPENSSL_CSTRING_lh_doallfunc_type(arg_dfn: lh_OPENSSL_CSTRING_doallfunc) callconv(.C) OPENSSL_LH_DOALL_FUNC {
    var dfn = arg_dfn;
    _ = &dfn;
    return @as(OPENSSL_LH_DOALL_FUNC, @ptrCast(@alignCast(dfn)));
}
pub const X509_LU_NONE: c_int = 0;
pub const X509_LU_X509: c_int = 1;
pub const X509_LU_CRL: c_int = 2;
pub const X509_LOOKUP_TYPE = c_uint;
pub const struct_stack_st_X509_LOOKUP = opaque {};
pub const sk_X509_LOOKUP_compfunc = ?*const fn ([*c]const ?*const X509_LOOKUP, [*c]const ?*const X509_LOOKUP) callconv(.C) c_int;
pub const sk_X509_LOOKUP_freefunc = ?*const fn (?*X509_LOOKUP) callconv(.C) void;
pub const sk_X509_LOOKUP_copyfunc = ?*const fn (?*const X509_LOOKUP) callconv(.C) ?*X509_LOOKUP;
pub fn ossl_check_X509_LOOKUP_type(arg_ptr: ?*X509_LOOKUP) callconv(.C) ?*X509_LOOKUP {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_LOOKUP_sk_type(arg_sk: ?*const struct_stack_st_X509_LOOKUP) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_LOOKUP_sk_type(arg_sk: ?*struct_stack_st_X509_LOOKUP) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_LOOKUP_compfunc_type(arg_cmp: sk_X509_LOOKUP_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_LOOKUP_copyfunc_type(arg_cpy: sk_X509_LOOKUP_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_LOOKUP_freefunc_type(arg_fr: sk_X509_LOOKUP_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509_OBJECT = opaque {};
pub const sk_X509_OBJECT_compfunc = ?*const fn ([*c]const ?*const X509_OBJECT, [*c]const ?*const X509_OBJECT) callconv(.C) c_int;
pub const sk_X509_OBJECT_freefunc = ?*const fn (?*X509_OBJECT) callconv(.C) void;
pub const sk_X509_OBJECT_copyfunc = ?*const fn (?*const X509_OBJECT) callconv(.C) ?*X509_OBJECT;
pub fn ossl_check_X509_OBJECT_type(arg_ptr: ?*X509_OBJECT) callconv(.C) ?*X509_OBJECT {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_OBJECT_sk_type(arg_sk: ?*const struct_stack_st_X509_OBJECT) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_OBJECT_sk_type(arg_sk: ?*struct_stack_st_X509_OBJECT) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_OBJECT_compfunc_type(arg_cmp: sk_X509_OBJECT_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_OBJECT_copyfunc_type(arg_cpy: sk_X509_OBJECT_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_OBJECT_freefunc_type(arg_fr: sk_X509_OBJECT_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509_VERIFY_PARAM = opaque {};
pub const sk_X509_VERIFY_PARAM_compfunc = ?*const fn ([*c]const ?*const X509_VERIFY_PARAM, [*c]const ?*const X509_VERIFY_PARAM) callconv(.C) c_int;
pub const sk_X509_VERIFY_PARAM_freefunc = ?*const fn (?*X509_VERIFY_PARAM) callconv(.C) void;
pub const sk_X509_VERIFY_PARAM_copyfunc = ?*const fn (?*const X509_VERIFY_PARAM) callconv(.C) ?*X509_VERIFY_PARAM;
pub fn ossl_check_X509_VERIFY_PARAM_type(arg_ptr: ?*X509_VERIFY_PARAM) callconv(.C) ?*X509_VERIFY_PARAM {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_VERIFY_PARAM_sk_type(arg_sk: ?*const struct_stack_st_X509_VERIFY_PARAM) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_VERIFY_PARAM_sk_type(arg_sk: ?*struct_stack_st_X509_VERIFY_PARAM) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_VERIFY_PARAM_compfunc_type(arg_cmp: sk_X509_VERIFY_PARAM_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_VERIFY_PARAM_copyfunc_type(arg_cpy: sk_X509_VERIFY_PARAM_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_VERIFY_PARAM_freefunc_type(arg_fr: sk_X509_VERIFY_PARAM_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_x509_trust_st = extern struct {
    trust: c_int = @import("std").mem.zeroes(c_int),
    flags: c_int = @import("std").mem.zeroes(c_int),
    check_trust: ?*const fn ([*c]struct_x509_trust_st, ?*X509, c_int) callconv(.C) c_int = @import("std").mem.zeroes(?*const fn ([*c]struct_x509_trust_st, ?*X509, c_int) callconv(.C) c_int),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    arg1: c_int = @import("std").mem.zeroes(c_int),
    arg2: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const X509_TRUST = struct_x509_trust_st;
pub const struct_stack_st_X509_TRUST = opaque {};
pub const sk_X509_TRUST_compfunc = ?*const fn ([*c]const [*c]const X509_TRUST, [*c]const [*c]const X509_TRUST) callconv(.C) c_int;
pub const sk_X509_TRUST_freefunc = ?*const fn ([*c]X509_TRUST) callconv(.C) void;
pub const sk_X509_TRUST_copyfunc = ?*const fn ([*c]const X509_TRUST) callconv(.C) [*c]X509_TRUST;
pub fn ossl_check_X509_TRUST_type(arg_ptr: [*c]X509_TRUST) callconv(.C) [*c]X509_TRUST {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_TRUST_sk_type(arg_sk: ?*const struct_stack_st_X509_TRUST) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_TRUST_sk_type(arg_sk: ?*struct_stack_st_X509_TRUST) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_TRUST_compfunc_type(arg_cmp: sk_X509_TRUST_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_TRUST_copyfunc_type(arg_cpy: sk_X509_TRUST_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_TRUST_freefunc_type(arg_fr: sk_X509_TRUST_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn X509_TRUST_set(t: [*c]c_int, trust: c_int) c_int;
pub extern fn X509_TRUST_get_count() c_int;
pub extern fn X509_TRUST_get0(idx: c_int) [*c]X509_TRUST;
pub extern fn X509_TRUST_get_by_id(id: c_int) c_int;
pub extern fn X509_TRUST_add(id: c_int, flags: c_int, ck: ?*const fn ([*c]X509_TRUST, ?*X509, c_int) callconv(.C) c_int, name: [*c]const u8, arg1: c_int, arg2: ?*anyopaque) c_int;
pub extern fn X509_TRUST_cleanup() void;
pub extern fn X509_TRUST_get_flags(xp: [*c]const X509_TRUST) c_int;
pub extern fn X509_TRUST_get0_name(xp: [*c]const X509_TRUST) [*c]u8;
pub extern fn X509_TRUST_get_trust(xp: [*c]const X509_TRUST) c_int;
pub extern fn X509_trusted(x: ?*const X509) c_int;
pub extern fn X509_add1_trust_object(x: ?*X509, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_add1_reject_object(x: ?*X509, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_trust_clear(x: ?*X509) void;
pub extern fn X509_reject_clear(x: ?*X509) void;
pub extern fn X509_get0_trust_objects(x: ?*X509) ?*struct_stack_st_ASN1_OBJECT;
pub extern fn X509_get0_reject_objects(x: ?*X509) ?*struct_stack_st_ASN1_OBJECT;
pub extern fn X509_TRUST_set_default(trust: ?*const fn (c_int, ?*X509, c_int) callconv(.C) c_int) ?*const fn (c_int, ?*X509, c_int) callconv(.C) c_int;
pub extern fn X509_check_trust(x: ?*X509, id: c_int, flags: c_int) c_int;
pub extern fn X509_verify_cert(ctx: ?*X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_verify(ctx: ?*X509_STORE_CTX) c_int;
pub extern fn X509_build_chain(target: ?*X509, certs: ?*struct_stack_st_X509, store: ?*X509_STORE, with_self_signed: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*struct_stack_st_X509;
pub extern fn X509_STORE_set_depth(store: ?*X509_STORE, depth: c_int) c_int;
pub const X509_STORE_CTX_verify_cb = ?*const fn (c_int, ?*X509_STORE_CTX) callconv(.C) c_int;
pub extern fn X509_STORE_CTX_print_verify_cb(ok: c_int, ctx: ?*X509_STORE_CTX) c_int;
pub const X509_STORE_CTX_verify_fn = ?*const fn (?*X509_STORE_CTX) callconv(.C) c_int;
pub const X509_STORE_CTX_get_issuer_fn = ?*const fn ([*c]?*X509, ?*X509_STORE_CTX, ?*X509) callconv(.C) c_int;
pub const X509_STORE_CTX_check_issued_fn = ?*const fn (?*X509_STORE_CTX, ?*X509, ?*X509) callconv(.C) c_int;
pub const X509_STORE_CTX_check_revocation_fn = ?*const fn (?*X509_STORE_CTX) callconv(.C) c_int;
pub const X509_STORE_CTX_get_crl_fn = ?*const fn (?*X509_STORE_CTX, [*c]?*X509_CRL, ?*X509) callconv(.C) c_int;
pub const X509_STORE_CTX_check_crl_fn = ?*const fn (?*X509_STORE_CTX, ?*X509_CRL) callconv(.C) c_int;
pub const X509_STORE_CTX_cert_crl_fn = ?*const fn (?*X509_STORE_CTX, ?*X509_CRL, ?*X509) callconv(.C) c_int;
pub const X509_STORE_CTX_check_policy_fn = ?*const fn (?*X509_STORE_CTX) callconv(.C) c_int;
pub const X509_STORE_CTX_lookup_certs_fn = ?*const fn (?*X509_STORE_CTX, ?*const X509_NAME) callconv(.C) ?*struct_stack_st_X509;
pub const X509_STORE_CTX_lookup_crls_fn = ?*const fn (?*const X509_STORE_CTX, ?*const X509_NAME) callconv(.C) ?*struct_stack_st_X509_CRL;
pub const X509_STORE_CTX_cleanup_fn = ?*const fn (?*X509_STORE_CTX) callconv(.C) c_int;
pub extern fn X509_STORE_CTX_set_depth(ctx: ?*X509_STORE_CTX, depth: c_int) void;
pub extern fn X509_OBJECT_idx_by_subject(h: ?*struct_stack_st_X509_OBJECT, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME) c_int;
pub extern fn X509_OBJECT_retrieve_by_subject(h: ?*struct_stack_st_X509_OBJECT, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME) ?*X509_OBJECT;
pub extern fn X509_OBJECT_retrieve_match(h: ?*struct_stack_st_X509_OBJECT, x: ?*X509_OBJECT) ?*X509_OBJECT;
pub extern fn X509_OBJECT_up_ref_count(a: ?*X509_OBJECT) c_int;
pub extern fn X509_OBJECT_new() ?*X509_OBJECT;
pub extern fn X509_OBJECT_free(a: ?*X509_OBJECT) void;
pub extern fn X509_OBJECT_get_type(a: ?*const X509_OBJECT) X509_LOOKUP_TYPE;
pub extern fn X509_OBJECT_get0_X509(a: ?*const X509_OBJECT) ?*X509;
pub extern fn X509_OBJECT_set1_X509(a: ?*X509_OBJECT, obj: ?*X509) c_int;
pub extern fn X509_OBJECT_get0_X509_CRL(a: ?*const X509_OBJECT) ?*X509_CRL;
pub extern fn X509_OBJECT_set1_X509_CRL(a: ?*X509_OBJECT, obj: ?*X509_CRL) c_int;
pub extern fn X509_STORE_new() ?*X509_STORE;
pub extern fn X509_STORE_free(xs: ?*X509_STORE) void;
pub extern fn X509_STORE_lock(xs: ?*X509_STORE) c_int;
pub extern fn X509_STORE_unlock(xs: ?*X509_STORE) c_int;
pub extern fn X509_STORE_up_ref(xs: ?*X509_STORE) c_int;
pub extern fn X509_STORE_get0_objects(xs: ?*const X509_STORE) ?*struct_stack_st_X509_OBJECT;
pub extern fn X509_STORE_get1_objects(xs: ?*X509_STORE) ?*struct_stack_st_X509_OBJECT;
pub extern fn X509_STORE_get1_all_certs(xs: ?*X509_STORE) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_get1_certs(xs: ?*X509_STORE_CTX, nm: ?*const X509_NAME) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_get1_crls(st: ?*const X509_STORE_CTX, nm: ?*const X509_NAME) ?*struct_stack_st_X509_CRL;
pub extern fn X509_STORE_set_flags(xs: ?*X509_STORE, flags: c_ulong) c_int;
pub extern fn X509_STORE_set_purpose(xs: ?*X509_STORE, purpose: c_int) c_int;
pub extern fn X509_STORE_set_trust(xs: ?*X509_STORE, trust: c_int) c_int;
pub extern fn X509_STORE_set1_param(xs: ?*X509_STORE, pm: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_STORE_get0_param(xs: ?*const X509_STORE) ?*X509_VERIFY_PARAM;
pub extern fn X509_STORE_set_verify(xs: ?*X509_STORE, verify: X509_STORE_CTX_verify_fn) void;
pub extern fn X509_STORE_CTX_set_verify(ctx: ?*X509_STORE_CTX, verify: X509_STORE_CTX_verify_fn) void;
pub extern fn X509_STORE_get_verify(xs: ?*const X509_STORE) X509_STORE_CTX_verify_fn;
pub extern fn X509_STORE_set_verify_cb(xs: ?*X509_STORE, verify_cb: X509_STORE_CTX_verify_cb) void;
pub extern fn X509_STORE_get_verify_cb(xs: ?*const X509_STORE) X509_STORE_CTX_verify_cb;
pub extern fn X509_STORE_set_get_issuer(xs: ?*X509_STORE, get_issuer: X509_STORE_CTX_get_issuer_fn) void;
pub extern fn X509_STORE_get_get_issuer(xs: ?*const X509_STORE) X509_STORE_CTX_get_issuer_fn;
pub extern fn X509_STORE_set_check_issued(xs: ?*X509_STORE, check_issued: X509_STORE_CTX_check_issued_fn) void;
pub extern fn X509_STORE_get_check_issued(s: ?*const X509_STORE) X509_STORE_CTX_check_issued_fn;
pub extern fn X509_STORE_set_check_revocation(xs: ?*X509_STORE, check_revocation: X509_STORE_CTX_check_revocation_fn) void;
pub extern fn X509_STORE_get_check_revocation(xs: ?*const X509_STORE) X509_STORE_CTX_check_revocation_fn;
pub extern fn X509_STORE_set_get_crl(xs: ?*X509_STORE, get_crl: X509_STORE_CTX_get_crl_fn) void;
pub extern fn X509_STORE_get_get_crl(xs: ?*const X509_STORE) X509_STORE_CTX_get_crl_fn;
pub extern fn X509_STORE_set_check_crl(xs: ?*X509_STORE, check_crl: X509_STORE_CTX_check_crl_fn) void;
pub extern fn X509_STORE_get_check_crl(xs: ?*const X509_STORE) X509_STORE_CTX_check_crl_fn;
pub extern fn X509_STORE_set_cert_crl(xs: ?*X509_STORE, cert_crl: X509_STORE_CTX_cert_crl_fn) void;
pub extern fn X509_STORE_get_cert_crl(xs: ?*const X509_STORE) X509_STORE_CTX_cert_crl_fn;
pub extern fn X509_STORE_set_check_policy(xs: ?*X509_STORE, check_policy: X509_STORE_CTX_check_policy_fn) void;
pub extern fn X509_STORE_get_check_policy(s: ?*const X509_STORE) X509_STORE_CTX_check_policy_fn;
pub extern fn X509_STORE_set_lookup_certs(xs: ?*X509_STORE, lookup_certs: X509_STORE_CTX_lookup_certs_fn) void;
pub extern fn X509_STORE_get_lookup_certs(s: ?*const X509_STORE) X509_STORE_CTX_lookup_certs_fn;
pub extern fn X509_STORE_set_lookup_crls(xs: ?*X509_STORE, lookup_crls: X509_STORE_CTX_lookup_crls_fn) void;
pub extern fn X509_STORE_get_lookup_crls(xs: ?*const X509_STORE) X509_STORE_CTX_lookup_crls_fn;
pub extern fn X509_STORE_set_cleanup(xs: ?*X509_STORE, cleanup: X509_STORE_CTX_cleanup_fn) void;
pub extern fn X509_STORE_get_cleanup(xs: ?*const X509_STORE) X509_STORE_CTX_cleanup_fn;
pub extern fn X509_STORE_set_ex_data(xs: ?*X509_STORE, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn X509_STORE_get_ex_data(xs: ?*const X509_STORE, idx: c_int) ?*anyopaque;
pub extern fn X509_STORE_CTX_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509_STORE_CTX;
pub extern fn X509_STORE_CTX_new() ?*X509_STORE_CTX;
pub extern fn X509_STORE_CTX_get1_issuer(issuer: [*c]?*X509, ctx: ?*X509_STORE_CTX, x: ?*X509) c_int;
pub extern fn X509_STORE_CTX_free(ctx: ?*X509_STORE_CTX) void;
pub extern fn X509_STORE_CTX_init(ctx: ?*X509_STORE_CTX, trust_store: ?*X509_STORE, target: ?*X509, untrusted: ?*struct_stack_st_X509) c_int;
pub extern fn X509_STORE_CTX_init_rpk(ctx: ?*X509_STORE_CTX, trust_store: ?*X509_STORE, rpk: ?*EVP_PKEY) c_int;
pub extern fn X509_STORE_CTX_set0_trusted_stack(ctx: ?*X509_STORE_CTX, sk: ?*struct_stack_st_X509) void;
pub extern fn X509_STORE_CTX_cleanup(ctx: ?*X509_STORE_CTX) void;
pub extern fn X509_STORE_CTX_get0_store(ctx: ?*const X509_STORE_CTX) ?*X509_STORE;
pub extern fn X509_STORE_CTX_get0_cert(ctx: ?*const X509_STORE_CTX) ?*X509;
pub extern fn X509_STORE_CTX_get0_rpk(ctx: ?*const X509_STORE_CTX) ?*EVP_PKEY;
pub extern fn X509_STORE_CTX_get0_untrusted(ctx: ?*const X509_STORE_CTX) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_set0_untrusted(ctx: ?*X509_STORE_CTX, sk: ?*struct_stack_st_X509) void;
pub extern fn X509_STORE_CTX_set_verify_cb(ctx: ?*X509_STORE_CTX, verify: X509_STORE_CTX_verify_cb) void;
pub extern fn X509_STORE_CTX_get_verify_cb(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_verify_cb;
pub extern fn X509_STORE_CTX_get_verify(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_verify_fn;
pub extern fn X509_STORE_CTX_get_get_issuer(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_get_issuer_fn;
pub extern fn X509_STORE_CTX_get_check_issued(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_check_issued_fn;
pub extern fn X509_STORE_CTX_get_check_revocation(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_check_revocation_fn;
pub extern fn X509_STORE_CTX_set_get_crl(ctx: ?*X509_STORE_CTX, get_crl: X509_STORE_CTX_get_crl_fn) void;
pub extern fn X509_STORE_CTX_get_get_crl(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_get_crl_fn;
pub extern fn X509_STORE_CTX_get_check_crl(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_check_crl_fn;
pub extern fn X509_STORE_CTX_get_cert_crl(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_cert_crl_fn;
pub extern fn X509_STORE_CTX_get_check_policy(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_check_policy_fn;
pub extern fn X509_STORE_CTX_get_lookup_certs(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_lookup_certs_fn;
pub extern fn X509_STORE_CTX_get_lookup_crls(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_lookup_crls_fn;
pub extern fn X509_STORE_CTX_get_cleanup(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_cleanup_fn;
pub extern fn X509_STORE_add_lookup(xs: ?*X509_STORE, m: ?*X509_LOOKUP_METHOD) ?*X509_LOOKUP;
pub extern fn X509_LOOKUP_hash_dir() ?*X509_LOOKUP_METHOD;
pub extern fn X509_LOOKUP_file() ?*X509_LOOKUP_METHOD;
pub extern fn X509_LOOKUP_store() ?*X509_LOOKUP_METHOD;
pub const X509_LOOKUP_ctrl_fn = ?*const fn (?*X509_LOOKUP, c_int, [*c]const u8, c_long, [*c][*c]u8) callconv(.C) c_int;
pub const X509_LOOKUP_ctrl_ex_fn = ?*const fn (?*X509_LOOKUP, c_int, [*c]const u8, c_long, [*c][*c]u8, ?*OSSL_LIB_CTX, [*c]const u8) callconv(.C) c_int;
pub const X509_LOOKUP_get_by_subject_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, ?*const X509_NAME, ?*X509_OBJECT) callconv(.C) c_int;
pub const X509_LOOKUP_get_by_subject_ex_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, ?*const X509_NAME, ?*X509_OBJECT, ?*OSSL_LIB_CTX, [*c]const u8) callconv(.C) c_int;
pub const X509_LOOKUP_get_by_issuer_serial_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, ?*const X509_NAME, [*c]const ASN1_INTEGER, ?*X509_OBJECT) callconv(.C) c_int;
pub const X509_LOOKUP_get_by_fingerprint_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, [*c]const u8, c_int, ?*X509_OBJECT) callconv(.C) c_int;
pub const X509_LOOKUP_get_by_alias_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, [*c]const u8, c_int, ?*X509_OBJECT) callconv(.C) c_int;
pub extern fn X509_LOOKUP_meth_new(name: [*c]const u8) ?*X509_LOOKUP_METHOD;
pub extern fn X509_LOOKUP_meth_free(method: ?*X509_LOOKUP_METHOD) void;
pub extern fn X509_LOOKUP_meth_set_new_item(method: ?*X509_LOOKUP_METHOD, new_item: ?*const fn (?*X509_LOOKUP) callconv(.C) c_int) c_int;
pub extern fn X509_LOOKUP_meth_get_new_item(method: ?*const X509_LOOKUP_METHOD) ?*const fn (?*X509_LOOKUP) callconv(.C) c_int;
pub extern fn X509_LOOKUP_meth_set_free(method: ?*X509_LOOKUP_METHOD, free_fn: ?*const fn (?*X509_LOOKUP) callconv(.C) void) c_int;
pub extern fn X509_LOOKUP_meth_get_free(method: ?*const X509_LOOKUP_METHOD) ?*const fn (?*X509_LOOKUP) callconv(.C) void;
pub extern fn X509_LOOKUP_meth_set_init(method: ?*X509_LOOKUP_METHOD, init: ?*const fn (?*X509_LOOKUP) callconv(.C) c_int) c_int;
pub extern fn X509_LOOKUP_meth_get_init(method: ?*const X509_LOOKUP_METHOD) ?*const fn (?*X509_LOOKUP) callconv(.C) c_int;
pub extern fn X509_LOOKUP_meth_set_shutdown(method: ?*X509_LOOKUP_METHOD, shutdown: ?*const fn (?*X509_LOOKUP) callconv(.C) c_int) c_int;
pub extern fn X509_LOOKUP_meth_get_shutdown(method: ?*const X509_LOOKUP_METHOD) ?*const fn (?*X509_LOOKUP) callconv(.C) c_int;
pub extern fn X509_LOOKUP_meth_set_ctrl(method: ?*X509_LOOKUP_METHOD, ctrl_fn: X509_LOOKUP_ctrl_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_ctrl(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_ctrl_fn;
pub extern fn X509_LOOKUP_meth_set_get_by_subject(method: ?*X509_LOOKUP_METHOD, @"fn": X509_LOOKUP_get_by_subject_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_get_by_subject(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_get_by_subject_fn;
pub extern fn X509_LOOKUP_meth_set_get_by_issuer_serial(method: ?*X509_LOOKUP_METHOD, @"fn": X509_LOOKUP_get_by_issuer_serial_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_get_by_issuer_serial(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_get_by_issuer_serial_fn;
pub extern fn X509_LOOKUP_meth_set_get_by_fingerprint(method: ?*X509_LOOKUP_METHOD, @"fn": X509_LOOKUP_get_by_fingerprint_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_get_by_fingerprint(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_get_by_fingerprint_fn;
pub extern fn X509_LOOKUP_meth_set_get_by_alias(method: ?*X509_LOOKUP_METHOD, @"fn": X509_LOOKUP_get_by_alias_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_get_by_alias(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_get_by_alias_fn;
pub extern fn X509_STORE_add_cert(xs: ?*X509_STORE, x: ?*X509) c_int;
pub extern fn X509_STORE_add_crl(xs: ?*X509_STORE, x: ?*X509_CRL) c_int;
pub extern fn X509_STORE_CTX_get_by_subject(vs: ?*const X509_STORE_CTX, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_STORE_CTX_get_obj_by_subject(vs: ?*X509_STORE_CTX, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME) ?*X509_OBJECT;
pub extern fn X509_LOOKUP_ctrl(ctx: ?*X509_LOOKUP, cmd: c_int, argc: [*c]const u8, argl: c_long, ret: [*c][*c]u8) c_int;
pub extern fn X509_LOOKUP_ctrl_ex(ctx: ?*X509_LOOKUP, cmd: c_int, argc: [*c]const u8, argl: c_long, ret: [*c][*c]u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_load_cert_file(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn X509_load_cert_file_ex(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_load_crl_file(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn X509_load_cert_crl_file(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn X509_load_cert_crl_file_ex(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_LOOKUP_new(method: ?*X509_LOOKUP_METHOD) ?*X509_LOOKUP;
pub extern fn X509_LOOKUP_free(ctx: ?*X509_LOOKUP) void;
pub extern fn X509_LOOKUP_init(ctx: ?*X509_LOOKUP) c_int;
pub extern fn X509_LOOKUP_by_subject(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_LOOKUP_by_subject_ex(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME, ret: ?*X509_OBJECT, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_LOOKUP_by_issuer_serial(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME, serial: [*c]const ASN1_INTEGER, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_LOOKUP_by_fingerprint(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, bytes: [*c]const u8, len: c_int, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_LOOKUP_by_alias(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, str: [*c]const u8, len: c_int, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_LOOKUP_set_method_data(ctx: ?*X509_LOOKUP, data: ?*anyopaque) c_int;
pub extern fn X509_LOOKUP_get_method_data(ctx: ?*const X509_LOOKUP) ?*anyopaque;
pub extern fn X509_LOOKUP_get_store(ctx: ?*const X509_LOOKUP) ?*X509_STORE;
pub extern fn X509_LOOKUP_shutdown(ctx: ?*X509_LOOKUP) c_int;
pub extern fn X509_STORE_load_file(xs: ?*X509_STORE, file: [*c]const u8) c_int;
pub extern fn X509_STORE_load_path(xs: ?*X509_STORE, path: [*c]const u8) c_int;
pub extern fn X509_STORE_load_store(xs: ?*X509_STORE, store: [*c]const u8) c_int;
pub extern fn X509_STORE_load_locations(s: ?*X509_STORE, file: [*c]const u8, dir: [*c]const u8) c_int;
pub extern fn X509_STORE_set_default_paths(xs: ?*X509_STORE) c_int;
pub extern fn X509_STORE_load_file_ex(xs: ?*X509_STORE, file: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_STORE_load_store_ex(xs: ?*X509_STORE, store: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_STORE_load_locations_ex(xs: ?*X509_STORE, file: [*c]const u8, dir: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_STORE_set_default_paths_ex(xs: ?*X509_STORE, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_STORE_CTX_set_ex_data(ctx: ?*X509_STORE_CTX, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn X509_STORE_CTX_get_ex_data(ctx: ?*const X509_STORE_CTX, idx: c_int) ?*anyopaque;
pub extern fn X509_STORE_CTX_get_error(ctx: ?*const X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_set_error(ctx: ?*X509_STORE_CTX, s: c_int) void;
pub extern fn X509_STORE_CTX_get_error_depth(ctx: ?*const X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_set_error_depth(ctx: ?*X509_STORE_CTX, depth: c_int) void;
pub extern fn X509_STORE_CTX_get_current_cert(ctx: ?*const X509_STORE_CTX) ?*X509;
pub extern fn X509_STORE_CTX_set_current_cert(ctx: ?*X509_STORE_CTX, x: ?*X509) void;
pub extern fn X509_STORE_CTX_get0_current_issuer(ctx: ?*const X509_STORE_CTX) ?*X509;
pub extern fn X509_STORE_CTX_get0_current_crl(ctx: ?*const X509_STORE_CTX) ?*X509_CRL;
pub extern fn X509_STORE_CTX_get0_parent_ctx(ctx: ?*const X509_STORE_CTX) ?*X509_STORE_CTX;
pub extern fn X509_STORE_CTX_get0_chain(ctx: ?*const X509_STORE_CTX) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_get1_chain(ctx: ?*const X509_STORE_CTX) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_set_cert(ctx: ?*X509_STORE_CTX, target: ?*X509) void;
pub extern fn X509_STORE_CTX_set0_rpk(ctx: ?*X509_STORE_CTX, target: ?*EVP_PKEY) void;
pub extern fn X509_STORE_CTX_set0_verified_chain(c: ?*X509_STORE_CTX, sk: ?*struct_stack_st_X509) void;
pub extern fn X509_STORE_CTX_set0_crls(ctx: ?*X509_STORE_CTX, sk: ?*struct_stack_st_X509_CRL) void;
pub extern fn X509_STORE_CTX_set_purpose(ctx: ?*X509_STORE_CTX, purpose: c_int) c_int;
pub extern fn X509_STORE_CTX_set_trust(ctx: ?*X509_STORE_CTX, trust: c_int) c_int;
pub extern fn X509_STORE_CTX_purpose_inherit(ctx: ?*X509_STORE_CTX, def_purpose: c_int, purpose: c_int, trust: c_int) c_int;
pub extern fn X509_STORE_CTX_set_flags(ctx: ?*X509_STORE_CTX, flags: c_ulong) void;
pub extern fn X509_STORE_CTX_set_time(ctx: ?*X509_STORE_CTX, flags: c_ulong, t: time_t) void;
pub extern fn X509_STORE_CTX_set_current_reasons(ctx: ?*X509_STORE_CTX, current_reasons: c_uint) void;
pub extern fn X509_STORE_CTX_get0_policy_tree(ctx: ?*const X509_STORE_CTX) ?*X509_POLICY_TREE;
pub extern fn X509_STORE_CTX_get_explicit_policy(ctx: ?*const X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_get_num_untrusted(ctx: ?*const X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_get0_param(ctx: ?*const X509_STORE_CTX) ?*X509_VERIFY_PARAM;
pub extern fn X509_STORE_CTX_set0_param(ctx: ?*X509_STORE_CTX, param: ?*X509_VERIFY_PARAM) void;
pub extern fn X509_STORE_CTX_set_default(ctx: ?*X509_STORE_CTX, name: [*c]const u8) c_int;
pub extern fn X509_STORE_CTX_set0_dane(ctx: ?*X509_STORE_CTX, dane: ?*SSL_DANE) void;
pub extern fn X509_VERIFY_PARAM_new() ?*X509_VERIFY_PARAM;
pub extern fn X509_VERIFY_PARAM_free(param: ?*X509_VERIFY_PARAM) void;
pub extern fn X509_VERIFY_PARAM_inherit(to: ?*X509_VERIFY_PARAM, from: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_set1(to: ?*X509_VERIFY_PARAM, from: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_set1_name(param: ?*X509_VERIFY_PARAM, name: [*c]const u8) c_int;
pub extern fn X509_VERIFY_PARAM_set_flags(param: ?*X509_VERIFY_PARAM, flags: c_ulong) c_int;
pub extern fn X509_VERIFY_PARAM_clear_flags(param: ?*X509_VERIFY_PARAM, flags: c_ulong) c_int;
pub extern fn X509_VERIFY_PARAM_get_flags(param: ?*const X509_VERIFY_PARAM) c_ulong;
pub extern fn X509_VERIFY_PARAM_set_purpose(param: ?*X509_VERIFY_PARAM, purpose: c_int) c_int;
pub extern fn X509_VERIFY_PARAM_set_trust(param: ?*X509_VERIFY_PARAM, trust: c_int) c_int;
pub extern fn X509_VERIFY_PARAM_set_depth(param: ?*X509_VERIFY_PARAM, depth: c_int) void;
pub extern fn X509_VERIFY_PARAM_set_auth_level(param: ?*X509_VERIFY_PARAM, auth_level: c_int) void;
pub extern fn X509_VERIFY_PARAM_get_time(param: ?*const X509_VERIFY_PARAM) time_t;
pub extern fn X509_VERIFY_PARAM_set_time(param: ?*X509_VERIFY_PARAM, t: time_t) void;
pub extern fn X509_VERIFY_PARAM_add0_policy(param: ?*X509_VERIFY_PARAM, policy: ?*ASN1_OBJECT) c_int;
pub extern fn X509_VERIFY_PARAM_set1_policies(param: ?*X509_VERIFY_PARAM, policies: ?*struct_stack_st_ASN1_OBJECT) c_int;
pub extern fn X509_VERIFY_PARAM_set_inh_flags(param: ?*X509_VERIFY_PARAM, flags: u32) c_int;
pub extern fn X509_VERIFY_PARAM_get_inh_flags(param: ?*const X509_VERIFY_PARAM) u32;
pub extern fn X509_VERIFY_PARAM_get0_host(param: ?*X509_VERIFY_PARAM, idx: c_int) [*c]u8;
pub extern fn X509_VERIFY_PARAM_set1_host(param: ?*X509_VERIFY_PARAM, name: [*c]const u8, namelen: usize) c_int;
pub extern fn X509_VERIFY_PARAM_add1_host(param: ?*X509_VERIFY_PARAM, name: [*c]const u8, namelen: usize) c_int;
pub extern fn X509_VERIFY_PARAM_set_hostflags(param: ?*X509_VERIFY_PARAM, flags: c_uint) void;
pub extern fn X509_VERIFY_PARAM_get_hostflags(param: ?*const X509_VERIFY_PARAM) c_uint;
pub extern fn X509_VERIFY_PARAM_get0_peername(param: ?*const X509_VERIFY_PARAM) [*c]u8;
pub extern fn X509_VERIFY_PARAM_move_peername(?*X509_VERIFY_PARAM, ?*X509_VERIFY_PARAM) void;
pub extern fn X509_VERIFY_PARAM_get0_email(param: ?*X509_VERIFY_PARAM) [*c]u8;
pub extern fn X509_VERIFY_PARAM_set1_email(param: ?*X509_VERIFY_PARAM, email: [*c]const u8, emaillen: usize) c_int;
pub extern fn X509_VERIFY_PARAM_get1_ip_asc(param: ?*X509_VERIFY_PARAM) [*c]u8;
pub extern fn X509_VERIFY_PARAM_set1_ip(param: ?*X509_VERIFY_PARAM, ip: [*c]const u8, iplen: usize) c_int;
pub extern fn X509_VERIFY_PARAM_set1_ip_asc(param: ?*X509_VERIFY_PARAM, ipasc: [*c]const u8) c_int;
pub extern fn X509_VERIFY_PARAM_get_depth(param: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_get_auth_level(param: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_get0_name(param: ?*const X509_VERIFY_PARAM) [*c]const u8;
pub extern fn X509_VERIFY_PARAM_add0_table(param: ?*X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_get_count() c_int;
pub extern fn X509_VERIFY_PARAM_get0(id: c_int) ?*const X509_VERIFY_PARAM;
pub extern fn X509_VERIFY_PARAM_lookup(name: [*c]const u8) ?*const X509_VERIFY_PARAM;
pub extern fn X509_VERIFY_PARAM_table_cleanup() void;
pub extern fn X509_policy_check(ptree: [*c]?*X509_POLICY_TREE, pexplicit_policy: [*c]c_int, certs: ?*struct_stack_st_X509, policy_oids: ?*struct_stack_st_ASN1_OBJECT, flags: c_uint) c_int;
pub extern fn X509_policy_tree_free(tree: ?*X509_POLICY_TREE) void;
pub extern fn X509_policy_tree_level_count(tree: ?*const X509_POLICY_TREE) c_int;
pub extern fn X509_policy_tree_get0_level(tree: ?*const X509_POLICY_TREE, i: c_int) ?*X509_POLICY_LEVEL;
pub const struct_stack_st_X509_POLICY_NODE = opaque {};
pub extern fn X509_policy_tree_get0_policies(tree: ?*const X509_POLICY_TREE) ?*struct_stack_st_X509_POLICY_NODE;
pub extern fn X509_policy_tree_get0_user_policies(tree: ?*const X509_POLICY_TREE) ?*struct_stack_st_X509_POLICY_NODE;
pub extern fn X509_policy_level_node_count(level: ?*X509_POLICY_LEVEL) c_int;
pub extern fn X509_policy_level_get0_node(level: ?*const X509_POLICY_LEVEL, i: c_int) ?*X509_POLICY_NODE;
pub extern fn X509_policy_node_get0_policy(node: ?*const X509_POLICY_NODE) ?*const ASN1_OBJECT;
pub const struct_stack_st_POLICYQUALINFO = opaque {};
pub extern fn X509_policy_node_get0_qualifiers(node: ?*const X509_POLICY_NODE) ?*struct_stack_st_POLICYQUALINFO;
pub extern fn X509_policy_node_get0_parent(node: ?*const X509_POLICY_NODE) ?*const X509_POLICY_NODE;
pub const struct_PKCS7_CTX_st = extern struct {
    libctx: ?*OSSL_LIB_CTX = @import("std").mem.zeroes(?*OSSL_LIB_CTX),
    propq: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const PKCS7_CTX = struct_PKCS7_CTX_st;
pub const struct_pkcs7_issuer_and_serial_st = extern struct {
    issuer: ?*X509_NAME = @import("std").mem.zeroes(?*X509_NAME),
    serial: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const PKCS7_ISSUER_AND_SERIAL = struct_pkcs7_issuer_and_serial_st;
pub const struct_pkcs7_signer_info_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    issuer_and_serial: [*c]PKCS7_ISSUER_AND_SERIAL = @import("std").mem.zeroes([*c]PKCS7_ISSUER_AND_SERIAL),
    digest_alg: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    auth_attr: ?*struct_stack_st_X509_ATTRIBUTE = @import("std").mem.zeroes(?*struct_stack_st_X509_ATTRIBUTE),
    digest_enc_alg: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    enc_digest: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    unauth_attr: ?*struct_stack_st_X509_ATTRIBUTE = @import("std").mem.zeroes(?*struct_stack_st_X509_ATTRIBUTE),
    pkey: ?*EVP_PKEY = @import("std").mem.zeroes(?*EVP_PKEY),
    ctx: [*c]const PKCS7_CTX = @import("std").mem.zeroes([*c]const PKCS7_CTX),
};
pub const PKCS7_SIGNER_INFO = struct_pkcs7_signer_info_st;
pub const struct_stack_st_PKCS7_SIGNER_INFO = opaque {};
pub const sk_PKCS7_SIGNER_INFO_compfunc = ?*const fn ([*c]const [*c]const PKCS7_SIGNER_INFO, [*c]const [*c]const PKCS7_SIGNER_INFO) callconv(.C) c_int;
pub const sk_PKCS7_SIGNER_INFO_freefunc = ?*const fn ([*c]PKCS7_SIGNER_INFO) callconv(.C) void;
pub const sk_PKCS7_SIGNER_INFO_copyfunc = ?*const fn ([*c]const PKCS7_SIGNER_INFO) callconv(.C) [*c]PKCS7_SIGNER_INFO;
pub fn ossl_check_PKCS7_SIGNER_INFO_type(arg_ptr: [*c]PKCS7_SIGNER_INFO) callconv(.C) [*c]PKCS7_SIGNER_INFO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_PKCS7_SIGNER_INFO_sk_type(arg_sk: ?*const struct_stack_st_PKCS7_SIGNER_INFO) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_SIGNER_INFO_sk_type(arg_sk: ?*struct_stack_st_PKCS7_SIGNER_INFO) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_SIGNER_INFO_compfunc_type(arg_cmp: sk_PKCS7_SIGNER_INFO_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_PKCS7_SIGNER_INFO_copyfunc_type(arg_cpy: sk_PKCS7_SIGNER_INFO_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_PKCS7_SIGNER_INFO_freefunc_type(arg_fr: sk_PKCS7_SIGNER_INFO_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_pkcs7_recip_info_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    issuer_and_serial: [*c]PKCS7_ISSUER_AND_SERIAL = @import("std").mem.zeroes([*c]PKCS7_ISSUER_AND_SERIAL),
    key_enc_algor: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    enc_key: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    cert: ?*X509 = @import("std").mem.zeroes(?*X509),
    ctx: [*c]const PKCS7_CTX = @import("std").mem.zeroes([*c]const PKCS7_CTX),
};
pub const PKCS7_RECIP_INFO = struct_pkcs7_recip_info_st;
pub const struct_stack_st_PKCS7_RECIP_INFO = opaque {};
pub const sk_PKCS7_RECIP_INFO_compfunc = ?*const fn ([*c]const [*c]const PKCS7_RECIP_INFO, [*c]const [*c]const PKCS7_RECIP_INFO) callconv(.C) c_int;
pub const sk_PKCS7_RECIP_INFO_freefunc = ?*const fn ([*c]PKCS7_RECIP_INFO) callconv(.C) void;
pub const sk_PKCS7_RECIP_INFO_copyfunc = ?*const fn ([*c]const PKCS7_RECIP_INFO) callconv(.C) [*c]PKCS7_RECIP_INFO;
pub fn ossl_check_PKCS7_RECIP_INFO_type(arg_ptr: [*c]PKCS7_RECIP_INFO) callconv(.C) [*c]PKCS7_RECIP_INFO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_PKCS7_RECIP_INFO_sk_type(arg_sk: ?*const struct_stack_st_PKCS7_RECIP_INFO) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_RECIP_INFO_sk_type(arg_sk: ?*struct_stack_st_PKCS7_RECIP_INFO) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_RECIP_INFO_compfunc_type(arg_cmp: sk_PKCS7_RECIP_INFO_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_PKCS7_RECIP_INFO_copyfunc_type(arg_cpy: sk_PKCS7_RECIP_INFO_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_PKCS7_RECIP_INFO_freefunc_type(arg_fr: sk_PKCS7_RECIP_INFO_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const PKCS7_SIGNED = struct_pkcs7_signed_st;
pub const struct_pkcs7_enc_content_st = extern struct {
    content_type: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    algorithm: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    enc_data: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    cipher: ?*const EVP_CIPHER = @import("std").mem.zeroes(?*const EVP_CIPHER),
    ctx: [*c]const PKCS7_CTX = @import("std").mem.zeroes([*c]const PKCS7_CTX),
};
pub const PKCS7_ENC_CONTENT = struct_pkcs7_enc_content_st;
pub const struct_pkcs7_enveloped_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    recipientinfo: ?*struct_stack_st_PKCS7_RECIP_INFO = @import("std").mem.zeroes(?*struct_stack_st_PKCS7_RECIP_INFO),
    enc_data: [*c]PKCS7_ENC_CONTENT = @import("std").mem.zeroes([*c]PKCS7_ENC_CONTENT),
};
pub const PKCS7_ENVELOPE = struct_pkcs7_enveloped_st;
pub const struct_pkcs7_signedandenveloped_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    md_algs: ?*struct_stack_st_X509_ALGOR = @import("std").mem.zeroes(?*struct_stack_st_X509_ALGOR),
    cert: ?*struct_stack_st_X509 = @import("std").mem.zeroes(?*struct_stack_st_X509),
    crl: ?*struct_stack_st_X509_CRL = @import("std").mem.zeroes(?*struct_stack_st_X509_CRL),
    signer_info: ?*struct_stack_st_PKCS7_SIGNER_INFO = @import("std").mem.zeroes(?*struct_stack_st_PKCS7_SIGNER_INFO),
    enc_data: [*c]PKCS7_ENC_CONTENT = @import("std").mem.zeroes([*c]PKCS7_ENC_CONTENT),
    recipientinfo: ?*struct_stack_st_PKCS7_RECIP_INFO = @import("std").mem.zeroes(?*struct_stack_st_PKCS7_RECIP_INFO),
};
pub const PKCS7_SIGN_ENVELOPE = struct_pkcs7_signedandenveloped_st;
pub const struct_pkcs7_digest_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    md: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    contents: [*c]struct_pkcs7_st = @import("std").mem.zeroes([*c]struct_pkcs7_st),
    digest: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
};
pub const PKCS7_DIGEST = struct_pkcs7_digest_st;
pub const struct_pkcs7_encrypted_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    enc_data: [*c]PKCS7_ENC_CONTENT = @import("std").mem.zeroes([*c]PKCS7_ENC_CONTENT),
};
pub const PKCS7_ENCRYPT = struct_pkcs7_encrypted_st;
const union_unnamed_10 = extern union {
    ptr: [*c]u8,
    data: [*c]ASN1_OCTET_STRING,
    sign: [*c]PKCS7_SIGNED,
    enveloped: [*c]PKCS7_ENVELOPE,
    signed_and_enveloped: [*c]PKCS7_SIGN_ENVELOPE,
    digest: [*c]PKCS7_DIGEST,
    encrypted: [*c]PKCS7_ENCRYPT,
    other: [*c]ASN1_TYPE,
};
pub const struct_pkcs7_st = extern struct {
    asn1: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    length: c_long = @import("std").mem.zeroes(c_long),
    state: c_int = @import("std").mem.zeroes(c_int),
    detached: c_int = @import("std").mem.zeroes(c_int),
    type: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    d: union_unnamed_10 = @import("std").mem.zeroes(union_unnamed_10),
    ctx: PKCS7_CTX = @import("std").mem.zeroes(PKCS7_CTX),
};
pub const struct_pkcs7_signed_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    md_algs: ?*struct_stack_st_X509_ALGOR = @import("std").mem.zeroes(?*struct_stack_st_X509_ALGOR),
    cert: ?*struct_stack_st_X509 = @import("std").mem.zeroes(?*struct_stack_st_X509),
    crl: ?*struct_stack_st_X509_CRL = @import("std").mem.zeroes(?*struct_stack_st_X509_CRL),
    signer_info: ?*struct_stack_st_PKCS7_SIGNER_INFO = @import("std").mem.zeroes(?*struct_stack_st_PKCS7_SIGNER_INFO),
    contents: [*c]struct_pkcs7_st = @import("std").mem.zeroes([*c]struct_pkcs7_st),
};
pub const PKCS7 = struct_pkcs7_st;
pub const struct_stack_st_PKCS7 = opaque {};
pub const sk_PKCS7_compfunc = ?*const fn ([*c]const [*c]const PKCS7, [*c]const [*c]const PKCS7) callconv(.C) c_int;
pub const sk_PKCS7_freefunc = ?*const fn ([*c]PKCS7) callconv(.C) void;
pub const sk_PKCS7_copyfunc = ?*const fn ([*c]const PKCS7) callconv(.C) [*c]PKCS7;
pub fn ossl_check_PKCS7_type(arg_ptr: [*c]PKCS7) callconv(.C) [*c]PKCS7 {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_PKCS7_sk_type(arg_sk: ?*const struct_stack_st_PKCS7) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_sk_type(arg_sk: ?*struct_stack_st_PKCS7) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_compfunc_type(arg_cmp: sk_PKCS7_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_PKCS7_copyfunc_type(arg_cpy: sk_PKCS7_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_PKCS7_freefunc_type(arg_fr: sk_PKCS7_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn PKCS7_ISSUER_AND_SERIAL_new() [*c]PKCS7_ISSUER_AND_SERIAL;
pub extern fn PKCS7_ISSUER_AND_SERIAL_free(a: [*c]PKCS7_ISSUER_AND_SERIAL) void;
pub extern fn d2i_PKCS7_ISSUER_AND_SERIAL(a: [*c][*c]PKCS7_ISSUER_AND_SERIAL, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_ISSUER_AND_SERIAL;
pub extern fn i2d_PKCS7_ISSUER_AND_SERIAL(a: [*c]const PKCS7_ISSUER_AND_SERIAL, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_ISSUER_AND_SERIAL_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ISSUER_AND_SERIAL_digest(data: [*c]PKCS7_ISSUER_AND_SERIAL, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn d2i_PKCS7_fp(fp: [*c]FILE, p7: [*c][*c]PKCS7) [*c]PKCS7;
pub extern fn i2d_PKCS7_fp(fp: [*c]FILE, p7: [*c]const PKCS7) c_int;
pub extern fn PKCS7_dup(a: [*c]const PKCS7) [*c]PKCS7;
pub extern fn d2i_PKCS7_bio(bp: ?*BIO, p7: [*c][*c]PKCS7) [*c]PKCS7;
pub extern fn i2d_PKCS7_bio(bp: ?*BIO, p7: [*c]const PKCS7) c_int;
pub extern fn i2d_PKCS7_bio_stream(out: ?*BIO, p7: [*c]PKCS7, in: ?*BIO, flags: c_int) c_int;
pub extern fn PEM_write_bio_PKCS7_stream(out: ?*BIO, p7: [*c]PKCS7, in: ?*BIO, flags: c_int) c_int;
pub extern fn PKCS7_SIGNER_INFO_new() [*c]PKCS7_SIGNER_INFO;
pub extern fn PKCS7_SIGNER_INFO_free(a: [*c]PKCS7_SIGNER_INFO) void;
pub extern fn d2i_PKCS7_SIGNER_INFO(a: [*c][*c]PKCS7_SIGNER_INFO, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_SIGNER_INFO;
pub extern fn i2d_PKCS7_SIGNER_INFO(a: [*c]const PKCS7_SIGNER_INFO, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_SIGNER_INFO_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_RECIP_INFO_new() [*c]PKCS7_RECIP_INFO;
pub extern fn PKCS7_RECIP_INFO_free(a: [*c]PKCS7_RECIP_INFO) void;
pub extern fn d2i_PKCS7_RECIP_INFO(a: [*c][*c]PKCS7_RECIP_INFO, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_RECIP_INFO;
pub extern fn i2d_PKCS7_RECIP_INFO(a: [*c]const PKCS7_RECIP_INFO, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_RECIP_INFO_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_SIGNED_new() [*c]PKCS7_SIGNED;
pub extern fn PKCS7_SIGNED_free(a: [*c]PKCS7_SIGNED) void;
pub extern fn d2i_PKCS7_SIGNED(a: [*c][*c]PKCS7_SIGNED, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_SIGNED;
pub extern fn i2d_PKCS7_SIGNED(a: [*c]const PKCS7_SIGNED, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_SIGNED_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ENC_CONTENT_new() [*c]PKCS7_ENC_CONTENT;
pub extern fn PKCS7_ENC_CONTENT_free(a: [*c]PKCS7_ENC_CONTENT) void;
pub extern fn d2i_PKCS7_ENC_CONTENT(a: [*c][*c]PKCS7_ENC_CONTENT, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_ENC_CONTENT;
pub extern fn i2d_PKCS7_ENC_CONTENT(a: [*c]const PKCS7_ENC_CONTENT, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_ENC_CONTENT_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ENVELOPE_new() [*c]PKCS7_ENVELOPE;
pub extern fn PKCS7_ENVELOPE_free(a: [*c]PKCS7_ENVELOPE) void;
pub extern fn d2i_PKCS7_ENVELOPE(a: [*c][*c]PKCS7_ENVELOPE, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_ENVELOPE;
pub extern fn i2d_PKCS7_ENVELOPE(a: [*c]const PKCS7_ENVELOPE, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_ENVELOPE_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_SIGN_ENVELOPE_new() [*c]PKCS7_SIGN_ENVELOPE;
pub extern fn PKCS7_SIGN_ENVELOPE_free(a: [*c]PKCS7_SIGN_ENVELOPE) void;
pub extern fn d2i_PKCS7_SIGN_ENVELOPE(a: [*c][*c]PKCS7_SIGN_ENVELOPE, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_SIGN_ENVELOPE;
pub extern fn i2d_PKCS7_SIGN_ENVELOPE(a: [*c]const PKCS7_SIGN_ENVELOPE, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_SIGN_ENVELOPE_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_DIGEST_new() [*c]PKCS7_DIGEST;
pub extern fn PKCS7_DIGEST_free(a: [*c]PKCS7_DIGEST) void;
pub extern fn d2i_PKCS7_DIGEST(a: [*c][*c]PKCS7_DIGEST, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_DIGEST;
pub extern fn i2d_PKCS7_DIGEST(a: [*c]const PKCS7_DIGEST, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_DIGEST_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ENCRYPT_new() [*c]PKCS7_ENCRYPT;
pub extern fn PKCS7_ENCRYPT_free(a: [*c]PKCS7_ENCRYPT) void;
pub extern fn d2i_PKCS7_ENCRYPT(a: [*c][*c]PKCS7_ENCRYPT, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_ENCRYPT;
pub extern fn i2d_PKCS7_ENCRYPT(a: [*c]const PKCS7_ENCRYPT, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_ENCRYPT_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_new() [*c]PKCS7;
pub extern fn PKCS7_free(a: [*c]PKCS7) void;
pub extern fn d2i_PKCS7(a: [*c][*c]PKCS7, in: [*c][*c]const u8, len: c_long) [*c]PKCS7;
pub extern fn i2d_PKCS7(a: [*c]const PKCS7, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) [*c]PKCS7;
pub extern fn PKCS7_ATTR_SIGN_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ATTR_VERIFY_it() ?*const ASN1_ITEM;
pub extern fn i2d_PKCS7_NDEF(a: [*c]const PKCS7, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_print_ctx(out: ?*BIO, x: [*c]const PKCS7, indent: c_int, pctx: ?*const ASN1_PCTX) c_int;
pub extern fn PKCS7_ctrl(p7: [*c]PKCS7, cmd: c_int, larg: c_long, parg: [*c]u8) c_long;
pub extern fn PKCS7_type_is_other(p7: [*c]PKCS7) c_int;
pub extern fn PKCS7_set_type(p7: [*c]PKCS7, @"type": c_int) c_int;
pub extern fn PKCS7_set0_type_other(p7: [*c]PKCS7, @"type": c_int, other: [*c]ASN1_TYPE) c_int;
pub extern fn PKCS7_set_content(p7: [*c]PKCS7, p7_data: [*c]PKCS7) c_int;
pub extern fn PKCS7_SIGNER_INFO_set(p7i: [*c]PKCS7_SIGNER_INFO, x509: ?*X509, pkey: ?*EVP_PKEY, dgst: ?*const EVP_MD) c_int;
pub extern fn PKCS7_SIGNER_INFO_sign(si: [*c]PKCS7_SIGNER_INFO) c_int;
pub extern fn PKCS7_add_signer(p7: [*c]PKCS7, p7i: [*c]PKCS7_SIGNER_INFO) c_int;
pub extern fn PKCS7_add_certificate(p7: [*c]PKCS7, cert: ?*X509) c_int;
pub extern fn PKCS7_add_crl(p7: [*c]PKCS7, crl: ?*X509_CRL) c_int;
pub extern fn PKCS7_content_new(p7: [*c]PKCS7, nid: c_int) c_int;
pub extern fn PKCS7_dataVerify(cert_store: ?*X509_STORE, ctx: ?*X509_STORE_CTX, bio: ?*BIO, p7: [*c]PKCS7, si: [*c]PKCS7_SIGNER_INFO) c_int;
pub extern fn PKCS7_signatureVerify(bio: ?*BIO, p7: [*c]PKCS7, si: [*c]PKCS7_SIGNER_INFO, signer: ?*X509) c_int;
pub extern fn PKCS7_dataInit(p7: [*c]PKCS7, bio: ?*BIO) ?*BIO;
pub extern fn PKCS7_dataFinal(p7: [*c]PKCS7, bio: ?*BIO) c_int;
pub extern fn PKCS7_dataDecode(p7: [*c]PKCS7, pkey: ?*EVP_PKEY, in_bio: ?*BIO, pcert: ?*X509) ?*BIO;
pub extern fn PKCS7_add_signature(p7: [*c]PKCS7, x509: ?*X509, pkey: ?*EVP_PKEY, dgst: ?*const EVP_MD) [*c]PKCS7_SIGNER_INFO;
pub extern fn PKCS7_cert_from_signer_info(p7: [*c]PKCS7, si: [*c]PKCS7_SIGNER_INFO) ?*X509;
pub extern fn PKCS7_set_digest(p7: [*c]PKCS7, md: ?*const EVP_MD) c_int;
pub extern fn PKCS7_get_signer_info(p7: [*c]PKCS7) ?*struct_stack_st_PKCS7_SIGNER_INFO;
pub extern fn PKCS7_add_recipient(p7: [*c]PKCS7, x509: ?*X509) [*c]PKCS7_RECIP_INFO;
pub extern fn PKCS7_SIGNER_INFO_get0_algs(si: [*c]PKCS7_SIGNER_INFO, pk: [*c]?*EVP_PKEY, pdig: [*c][*c]X509_ALGOR, psig: [*c][*c]X509_ALGOR) void;
pub extern fn PKCS7_RECIP_INFO_get0_alg(ri: [*c]PKCS7_RECIP_INFO, penc: [*c][*c]X509_ALGOR) void;
pub extern fn PKCS7_add_recipient_info(p7: [*c]PKCS7, ri: [*c]PKCS7_RECIP_INFO) c_int;
pub extern fn PKCS7_RECIP_INFO_set(p7i: [*c]PKCS7_RECIP_INFO, x509: ?*X509) c_int;
pub extern fn PKCS7_set_cipher(p7: [*c]PKCS7, cipher: ?*const EVP_CIPHER) c_int;
pub extern fn PKCS7_stream(boundary: [*c][*c][*c]u8, p7: [*c]PKCS7) c_int;
pub extern fn PKCS7_get_issuer_and_serial(p7: [*c]PKCS7, idx: c_int) [*c]PKCS7_ISSUER_AND_SERIAL;
pub extern fn PKCS7_get_octet_string(p7: [*c]PKCS7) [*c]ASN1_OCTET_STRING;
pub extern fn PKCS7_digest_from_attributes(sk: ?*struct_stack_st_X509_ATTRIBUTE) [*c]ASN1_OCTET_STRING;
pub extern fn PKCS7_add_signed_attribute(p7si: [*c]PKCS7_SIGNER_INFO, nid: c_int, @"type": c_int, data: ?*anyopaque) c_int;
pub extern fn PKCS7_add_attribute(p7si: [*c]PKCS7_SIGNER_INFO, nid: c_int, atrtype: c_int, value: ?*anyopaque) c_int;
pub extern fn PKCS7_get_attribute(si: [*c]const PKCS7_SIGNER_INFO, nid: c_int) [*c]ASN1_TYPE;
pub extern fn PKCS7_get_signed_attribute(si: [*c]const PKCS7_SIGNER_INFO, nid: c_int) [*c]ASN1_TYPE;
pub extern fn PKCS7_set_signed_attributes(p7si: [*c]PKCS7_SIGNER_INFO, sk: ?*struct_stack_st_X509_ATTRIBUTE) c_int;
pub extern fn PKCS7_set_attributes(p7si: [*c]PKCS7_SIGNER_INFO, sk: ?*struct_stack_st_X509_ATTRIBUTE) c_int;
pub extern fn PKCS7_sign(signcert: ?*X509, pkey: ?*EVP_PKEY, certs: ?*struct_stack_st_X509, data: ?*BIO, flags: c_int) [*c]PKCS7;
pub extern fn PKCS7_sign_ex(signcert: ?*X509, pkey: ?*EVP_PKEY, certs: ?*struct_stack_st_X509, data: ?*BIO, flags: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) [*c]PKCS7;
pub extern fn PKCS7_sign_add_signer(p7: [*c]PKCS7, signcert: ?*X509, pkey: ?*EVP_PKEY, md: ?*const EVP_MD, flags: c_int) [*c]PKCS7_SIGNER_INFO;
pub extern fn PKCS7_final(p7: [*c]PKCS7, data: ?*BIO, flags: c_int) c_int;
pub extern fn PKCS7_verify(p7: [*c]PKCS7, certs: ?*struct_stack_st_X509, store: ?*X509_STORE, indata: ?*BIO, out: ?*BIO, flags: c_int) c_int;
pub extern fn PKCS7_get0_signers(p7: [*c]PKCS7, certs: ?*struct_stack_st_X509, flags: c_int) ?*struct_stack_st_X509;
pub extern fn PKCS7_encrypt(certs: ?*struct_stack_st_X509, in: ?*BIO, cipher: ?*const EVP_CIPHER, flags: c_int) [*c]PKCS7;
pub extern fn PKCS7_encrypt_ex(certs: ?*struct_stack_st_X509, in: ?*BIO, cipher: ?*const EVP_CIPHER, flags: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) [*c]PKCS7;
pub extern fn PKCS7_decrypt(p7: [*c]PKCS7, pkey: ?*EVP_PKEY, cert: ?*X509, data: ?*BIO, flags: c_int) c_int;
pub extern fn PKCS7_add_attrib_smimecap(si: [*c]PKCS7_SIGNER_INFO, cap: ?*struct_stack_st_X509_ALGOR) c_int;
pub extern fn PKCS7_get_smimecap(si: [*c]PKCS7_SIGNER_INFO) ?*struct_stack_st_X509_ALGOR;
pub extern fn PKCS7_simple_smimecap(sk: ?*struct_stack_st_X509_ALGOR, nid: c_int, arg: c_int) c_int;
pub extern fn PKCS7_add_attrib_content_type(si: [*c]PKCS7_SIGNER_INFO, coid: ?*ASN1_OBJECT) c_int;
pub extern fn PKCS7_add0_attrib_signing_time(si: [*c]PKCS7_SIGNER_INFO, t: [*c]ASN1_TIME) c_int;
pub extern fn PKCS7_add1_attrib_digest(si: [*c]PKCS7_SIGNER_INFO, md: [*c]const u8, mdlen: c_int) c_int;
pub extern fn SMIME_write_PKCS7(bio: ?*BIO, p7: [*c]PKCS7, data: ?*BIO, flags: c_int) c_int;
pub extern fn SMIME_read_PKCS7_ex(bio: ?*BIO, bcont: [*c]?*BIO, p7: [*c][*c]PKCS7) [*c]PKCS7;
pub extern fn SMIME_read_PKCS7(bio: ?*BIO, bcont: [*c]?*BIO) [*c]PKCS7;
pub extern fn BIO_new_PKCS7(out: ?*BIO, p7: [*c]PKCS7) ?*BIO;
pub extern fn X509_CRL_set_default_method(meth: ?*const X509_CRL_METHOD) void;
pub extern fn X509_CRL_METHOD_new(crl_init: ?*const fn (?*X509_CRL) callconv(.C) c_int, crl_free: ?*const fn (?*X509_CRL) callconv(.C) c_int, crl_lookup: ?*const fn (?*X509_CRL, [*c]?*X509_REVOKED, [*c]const ASN1_INTEGER, ?*const X509_NAME) callconv(.C) c_int, crl_verify: ?*const fn (?*X509_CRL, ?*EVP_PKEY) callconv(.C) c_int) ?*X509_CRL_METHOD;
pub extern fn X509_CRL_METHOD_free(m: ?*X509_CRL_METHOD) void;
pub extern fn X509_CRL_set_meth_data(crl: ?*X509_CRL, dat: ?*anyopaque) void;
pub extern fn X509_CRL_get_meth_data(crl: ?*X509_CRL) ?*anyopaque;
pub extern fn X509_verify_cert_error_string(n: c_long) [*c]const u8;
pub extern fn X509_verify(a: ?*X509, r: ?*EVP_PKEY) c_int;
pub extern fn X509_self_signed(cert: ?*X509, verify_signature: c_int) c_int;
pub extern fn X509_REQ_verify_ex(a: ?*X509_REQ, r: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_REQ_verify(a: ?*X509_REQ, r: ?*EVP_PKEY) c_int;
pub extern fn X509_CRL_verify(a: ?*X509_CRL, r: ?*EVP_PKEY) c_int;
pub extern fn NETSCAPE_SPKI_verify(a: [*c]NETSCAPE_SPKI, r: ?*EVP_PKEY) c_int;
pub extern fn NETSCAPE_SPKI_b64_decode(str: [*c]const u8, len: c_int) [*c]NETSCAPE_SPKI;
pub extern fn NETSCAPE_SPKI_b64_encode(x: [*c]NETSCAPE_SPKI) [*c]u8;
pub extern fn NETSCAPE_SPKI_get_pubkey(x: [*c]NETSCAPE_SPKI) ?*EVP_PKEY;
pub extern fn NETSCAPE_SPKI_set_pubkey(x: [*c]NETSCAPE_SPKI, pkey: ?*EVP_PKEY) c_int;
pub extern fn NETSCAPE_SPKI_print(out: ?*BIO, spki: [*c]NETSCAPE_SPKI) c_int;
pub extern fn X509_signature_dump(bp: ?*BIO, sig: [*c]const ASN1_STRING, indent: c_int) c_int;
pub extern fn X509_signature_print(bp: ?*BIO, alg: [*c]const X509_ALGOR, sig: [*c]const ASN1_STRING) c_int;
pub extern fn X509_sign(x: ?*X509, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn X509_sign_ctx(x: ?*X509, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn X509_REQ_sign(x: ?*X509_REQ, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn X509_REQ_sign_ctx(x: ?*X509_REQ, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn X509_CRL_sign(x: ?*X509_CRL, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn X509_CRL_sign_ctx(x: ?*X509_CRL, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn NETSCAPE_SPKI_sign(x: [*c]NETSCAPE_SPKI, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn X509_pubkey_digest(data: ?*const X509, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_digest(data: ?*const X509, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_digest_sig(cert: ?*const X509, md_used: [*c]?*EVP_MD, md_is_fallback: [*c]c_int) [*c]ASN1_OCTET_STRING;
pub extern fn X509_CRL_digest(data: ?*const X509_CRL, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_REQ_digest(data: ?*const X509_REQ, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_NAME_digest(data: ?*const X509_NAME, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_load_http(url: [*c]const u8, bio: ?*BIO, rbio: ?*BIO, timeout: c_int) ?*X509;
pub extern fn X509_CRL_load_http(url: [*c]const u8, bio: ?*BIO, rbio: ?*BIO, timeout: c_int) ?*X509_CRL;
pub const CONF_VALUE = extern struct {
    section: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    value: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const struct_stack_st_CONF_VALUE = opaque {};
pub const sk_CONF_VALUE_compfunc = ?*const fn ([*c]const [*c]const CONF_VALUE, [*c]const [*c]const CONF_VALUE) callconv(.C) c_int;
pub const sk_CONF_VALUE_freefunc = ?*const fn ([*c]CONF_VALUE) callconv(.C) void;
pub const sk_CONF_VALUE_copyfunc = ?*const fn ([*c]const CONF_VALUE) callconv(.C) [*c]CONF_VALUE;
pub fn ossl_check_CONF_VALUE_type(arg_ptr: [*c]CONF_VALUE) callconv(.C) [*c]CONF_VALUE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_CONF_VALUE_sk_type(arg_sk: ?*const struct_stack_st_CONF_VALUE) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_CONF_VALUE_sk_type(arg_sk: ?*struct_stack_st_CONF_VALUE) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_CONF_VALUE_compfunc_type(arg_cmp: sk_CONF_VALUE_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_CONF_VALUE_copyfunc_type(arg_cpy: sk_CONF_VALUE_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_CONF_VALUE_freefunc_type(arg_fr: sk_CONF_VALUE_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const lh_CONF_VALUE_compfunc = ?*const fn ([*c]const CONF_VALUE, [*c]const CONF_VALUE) callconv(.C) c_int;
pub const lh_CONF_VALUE_hashfunc = ?*const fn ([*c]const CONF_VALUE) callconv(.C) c_ulong;
pub const lh_CONF_VALUE_doallfunc = ?*const fn ([*c]CONF_VALUE) callconv(.C) void;
pub fn lh_CONF_VALUE_hash_thunk(arg_data: ?*const anyopaque, arg_hfn: OPENSSL_LH_HASHFUNC) callconv(.C) c_ulong {
    var data = arg_data;
    _ = &data;
    var hfn = arg_hfn;
    _ = &hfn;
    var hfn_conv: ?*const fn ([*c]const CONF_VALUE) callconv(.C) c_ulong = @as(?*const fn ([*c]const CONF_VALUE) callconv(.C) c_ulong, @ptrCast(@alignCast(hfn)));
    _ = &hfn_conv;
    return hfn_conv.?(@as([*c]const CONF_VALUE, @ptrCast(@alignCast(data))));
}
pub fn lh_CONF_VALUE_comp_thunk(arg_da: ?*const anyopaque, arg_db: ?*const anyopaque, arg_cfn: OPENSSL_LH_COMPFUNC) callconv(.C) c_int {
    var da = arg_da;
    _ = &da;
    var db = arg_db;
    _ = &db;
    var cfn = arg_cfn;
    _ = &cfn;
    var cfn_conv: ?*const fn ([*c]const CONF_VALUE, [*c]const CONF_VALUE) callconv(.C) c_int = @as(?*const fn ([*c]const CONF_VALUE, [*c]const CONF_VALUE) callconv(.C) c_int, @ptrCast(@alignCast(cfn)));
    _ = &cfn_conv;
    return cfn_conv.?(@as([*c]const CONF_VALUE, @ptrCast(@alignCast(da))), @as([*c]const CONF_VALUE, @ptrCast(@alignCast(db))));
}
pub fn lh_CONF_VALUE_doall_thunk(arg_node: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNC) callconv(.C) void {
    var node = arg_node;
    _ = &node;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]CONF_VALUE) callconv(.C) void = @as(?*const fn ([*c]CONF_VALUE) callconv(.C) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]CONF_VALUE, @ptrCast(@alignCast(node))));
}
pub fn lh_CONF_VALUE_doall_arg_thunk(arg_node: ?*anyopaque, arg_arg: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNCARG) callconv(.C) void {
    var node = arg_node;
    _ = &node;
    var arg = arg_arg;
    _ = &arg;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]CONF_VALUE, ?*anyopaque) callconv(.C) void = @as(?*const fn ([*c]CONF_VALUE, ?*anyopaque) callconv(.C) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]CONF_VALUE, @ptrCast(@alignCast(node))), arg);
}
pub fn ossl_check_CONF_VALUE_lh_plain_type(arg_ptr: [*c]CONF_VALUE) callconv(.C) [*c]CONF_VALUE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_CONF_VALUE_lh_plain_type(arg_ptr: [*c]const CONF_VALUE) callconv(.C) [*c]const CONF_VALUE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_CONF_VALUE_lh_type(arg_lh: [*c]const struct_lhash_st_CONF_VALUE) callconv(.C) ?*const OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*const OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_CONF_VALUE_lh_type(arg_lh: [*c]struct_lhash_st_CONF_VALUE) callconv(.C) ?*OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_CONF_VALUE_lh_compfunc_type(arg_cmp: lh_CONF_VALUE_compfunc) callconv(.C) OPENSSL_LH_COMPFUNC {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_LH_COMPFUNC, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_CONF_VALUE_lh_hashfunc_type(arg_hfn: lh_CONF_VALUE_hashfunc) callconv(.C) OPENSSL_LH_HASHFUNC {
    var hfn = arg_hfn;
    _ = &hfn;
    return @as(OPENSSL_LH_HASHFUNC, @ptrCast(@alignCast(hfn)));
}
pub fn ossl_check_CONF_VALUE_lh_doallfunc_type(arg_dfn: lh_CONF_VALUE_doallfunc) callconv(.C) OPENSSL_LH_DOALL_FUNC {
    var dfn = arg_dfn;
    _ = &dfn;
    return @as(OPENSSL_LH_DOALL_FUNC, @ptrCast(@alignCast(dfn)));
}
pub const struct_conf_imodule_st = opaque {};
pub const CONF_IMODULE = struct_conf_imodule_st;
pub const struct_conf_module_st = opaque {};
pub const CONF_MODULE = struct_conf_module_st;
pub const struct_stack_st_CONF_MODULE = opaque {};
pub const struct_stack_st_CONF_IMODULE = opaque {};
pub const conf_init_func = fn (?*CONF_IMODULE, [*c]const CONF) callconv(.C) c_int;
pub const conf_finish_func = fn (?*CONF_IMODULE) callconv(.C) void;
pub extern fn CONF_set_default_method(meth: [*c]CONF_METHOD) c_int;
pub extern fn CONF_set_nconf(conf: [*c]CONF, hash: [*c]struct_lhash_st_CONF_VALUE) void;
pub extern fn CONF_load(conf: [*c]struct_lhash_st_CONF_VALUE, file: [*c]const u8, eline: [*c]c_long) [*c]struct_lhash_st_CONF_VALUE;
pub extern fn CONF_load_fp(conf: [*c]struct_lhash_st_CONF_VALUE, fp: [*c]FILE, eline: [*c]c_long) [*c]struct_lhash_st_CONF_VALUE;
pub extern fn CONF_load_bio(conf: [*c]struct_lhash_st_CONF_VALUE, bp: ?*BIO, eline: [*c]c_long) [*c]struct_lhash_st_CONF_VALUE;
pub extern fn CONF_get_section(conf: [*c]struct_lhash_st_CONF_VALUE, section: [*c]const u8) ?*struct_stack_st_CONF_VALUE;
pub extern fn CONF_get_string(conf: [*c]struct_lhash_st_CONF_VALUE, group: [*c]const u8, name: [*c]const u8) [*c]u8;
pub extern fn CONF_get_number(conf: [*c]struct_lhash_st_CONF_VALUE, group: [*c]const u8, name: [*c]const u8) c_long;
pub extern fn CONF_free(conf: [*c]struct_lhash_st_CONF_VALUE) void;
pub extern fn CONF_dump_fp(conf: [*c]struct_lhash_st_CONF_VALUE, out: [*c]FILE) c_int;
pub extern fn CONF_dump_bio(conf: [*c]struct_lhash_st_CONF_VALUE, out: ?*BIO) c_int;
pub extern fn OPENSSL_config(config_name: [*c]const u8) void;
pub extern fn NCONF_new_ex(libctx: ?*OSSL_LIB_CTX, meth: [*c]CONF_METHOD) [*c]CONF;
pub extern fn NCONF_get0_libctx(conf: [*c]const CONF) ?*OSSL_LIB_CTX;
pub extern fn NCONF_new(meth: [*c]CONF_METHOD) [*c]CONF;
pub extern fn NCONF_default() [*c]CONF_METHOD;
pub extern fn NCONF_WIN32() [*c]CONF_METHOD;
pub extern fn NCONF_free(conf: [*c]CONF) void;
pub extern fn NCONF_free_data(conf: [*c]CONF) void;
pub extern fn NCONF_load(conf: [*c]CONF, file: [*c]const u8, eline: [*c]c_long) c_int;
pub extern fn NCONF_load_fp(conf: [*c]CONF, fp: [*c]FILE, eline: [*c]c_long) c_int;
pub extern fn NCONF_load_bio(conf: [*c]CONF, bp: ?*BIO, eline: [*c]c_long) c_int;
pub extern fn NCONF_get_section_names(conf: [*c]const CONF) ?*struct_stack_st_OPENSSL_CSTRING;
pub extern fn NCONF_get_section(conf: [*c]const CONF, section: [*c]const u8) ?*struct_stack_st_CONF_VALUE;
pub extern fn NCONF_get_string(conf: [*c]const CONF, group: [*c]const u8, name: [*c]const u8) [*c]u8;
pub extern fn NCONF_get_number_e(conf: [*c]const CONF, group: [*c]const u8, name: [*c]const u8, result: [*c]c_long) c_int;
pub extern fn NCONF_dump_fp(conf: [*c]const CONF, out: [*c]FILE) c_int;
pub extern fn NCONF_dump_bio(conf: [*c]const CONF, out: ?*BIO) c_int;
pub extern fn CONF_modules_load(cnf: [*c]const CONF, appname: [*c]const u8, flags: c_ulong) c_int;
pub extern fn CONF_modules_load_file_ex(libctx: ?*OSSL_LIB_CTX, filename: [*c]const u8, appname: [*c]const u8, flags: c_ulong) c_int;
pub extern fn CONF_modules_load_file(filename: [*c]const u8, appname: [*c]const u8, flags: c_ulong) c_int;
pub extern fn CONF_modules_unload(all: c_int) void;
pub extern fn CONF_modules_finish() void;
pub extern fn CONF_module_add(name: [*c]const u8, ifunc: ?*const conf_init_func, ffunc: ?*const conf_finish_func) c_int;
pub extern fn CONF_imodule_get_name(md: ?*const CONF_IMODULE) [*c]const u8;
pub extern fn CONF_imodule_get_value(md: ?*const CONF_IMODULE) [*c]const u8;
pub extern fn CONF_imodule_get_usr_data(md: ?*const CONF_IMODULE) ?*anyopaque;
pub extern fn CONF_imodule_set_usr_data(md: ?*CONF_IMODULE, usr_data: ?*anyopaque) void;
pub extern fn CONF_imodule_get_module(md: ?*const CONF_IMODULE) ?*CONF_MODULE;
pub extern fn CONF_imodule_get_flags(md: ?*const CONF_IMODULE) c_ulong;
pub extern fn CONF_imodule_set_flags(md: ?*CONF_IMODULE, flags: c_ulong) void;
pub extern fn CONF_module_get_usr_data(pmod: ?*CONF_MODULE) ?*anyopaque;
pub extern fn CONF_module_set_usr_data(pmod: ?*CONF_MODULE, usr_data: ?*anyopaque) void;
pub extern fn CONF_get1_default_config_file() [*c]u8;
pub extern fn CONF_parse_list(list: [*c]const u8, sep: c_int, nospc: c_int, list_cb: ?*const fn ([*c]const u8, c_int, ?*anyopaque) callconv(.C) c_int, arg: ?*anyopaque) c_int;
pub extern fn OPENSSL_load_builtin_modules() void;
pub extern fn OSSL_HTTP_REQ_CTX_new(wbio: ?*BIO, rbio: ?*BIO, buf_size: c_int) ?*OSSL_HTTP_REQ_CTX;
pub extern fn OSSL_HTTP_REQ_CTX_free(rctx: ?*OSSL_HTTP_REQ_CTX) void;
pub extern fn OSSL_HTTP_REQ_CTX_set_request_line(rctx: ?*OSSL_HTTP_REQ_CTX, method_POST: c_int, server: [*c]const u8, port: [*c]const u8, path: [*c]const u8) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_add1_header(rctx: ?*OSSL_HTTP_REQ_CTX, name: [*c]const u8, value: [*c]const u8) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_set_expected(rctx: ?*OSSL_HTTP_REQ_CTX, content_type: [*c]const u8, asn1: c_int, timeout: c_int, keep_alive: c_int) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_set1_req(rctx: ?*OSSL_HTTP_REQ_CTX, content_type: [*c]const u8, it: ?*const ASN1_ITEM, req: ?*const ASN1_VALUE) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_nbio(rctx: ?*OSSL_HTTP_REQ_CTX) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_nbio_d2i(rctx: ?*OSSL_HTTP_REQ_CTX, pval: [*c]?*ASN1_VALUE, it: ?*const ASN1_ITEM) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_exchange(rctx: ?*OSSL_HTTP_REQ_CTX) ?*BIO;
pub extern fn OSSL_HTTP_REQ_CTX_get0_mem_bio(rctx: ?*const OSSL_HTTP_REQ_CTX) ?*BIO;
pub extern fn OSSL_HTTP_REQ_CTX_get_resp_len(rctx: ?*const OSSL_HTTP_REQ_CTX) usize;
pub extern fn OSSL_HTTP_REQ_CTX_set_max_response_length(rctx: ?*OSSL_HTTP_REQ_CTX, len: c_ulong) void;
pub extern fn OSSL_HTTP_is_alive(rctx: ?*const OSSL_HTTP_REQ_CTX) c_int;
pub const OSSL_HTTP_bio_cb_t = ?*const fn (?*BIO, ?*anyopaque, c_int, c_int) callconv(.C) ?*BIO;
pub extern fn OSSL_HTTP_open(server: [*c]const u8, port: [*c]const u8, proxy: [*c]const u8, no_proxy: [*c]const u8, use_ssl: c_int, bio: ?*BIO, rbio: ?*BIO, bio_update_fn: OSSL_HTTP_bio_cb_t, arg: ?*anyopaque, buf_size: c_int, overall_timeout: c_int) ?*OSSL_HTTP_REQ_CTX;
pub extern fn OSSL_HTTP_proxy_connect(bio: ?*BIO, server: [*c]const u8, port: [*c]const u8, proxyuser: [*c]const u8, proxypass: [*c]const u8, timeout: c_int, bio_err: ?*BIO, prog: [*c]const u8) c_int;
pub extern fn OSSL_HTTP_set1_request(rctx: ?*OSSL_HTTP_REQ_CTX, path: [*c]const u8, headers: ?*const struct_stack_st_CONF_VALUE, content_type: [*c]const u8, req: ?*BIO, expected_content_type: [*c]const u8, expect_asn1: c_int, max_resp_len: usize, timeout: c_int, keep_alive: c_int) c_int;
pub extern fn OSSL_HTTP_exchange(rctx: ?*OSSL_HTTP_REQ_CTX, redirection_url: [*c][*c]u8) ?*BIO;
pub extern fn OSSL_HTTP_get(url: [*c]const u8, proxy: [*c]const u8, no_proxy: [*c]const u8, bio: ?*BIO, rbio: ?*BIO, bio_update_fn: OSSL_HTTP_bio_cb_t, arg: ?*anyopaque, buf_size: c_int, headers: ?*const struct_stack_st_CONF_VALUE, expected_content_type: [*c]const u8, expect_asn1: c_int, max_resp_len: usize, timeout: c_int) ?*BIO;
pub extern fn OSSL_HTTP_transfer(prctx: [*c]?*OSSL_HTTP_REQ_CTX, server: [*c]const u8, port: [*c]const u8, path: [*c]const u8, use_ssl: c_int, proxy: [*c]const u8, no_proxy: [*c]const u8, bio: ?*BIO, rbio: ?*BIO, bio_update_fn: OSSL_HTTP_bio_cb_t, arg: ?*anyopaque, buf_size: c_int, headers: ?*const struct_stack_st_CONF_VALUE, content_type: [*c]const u8, req: ?*BIO, expected_content_type: [*c]const u8, expect_asn1: c_int, max_resp_len: usize, timeout: c_int, keep_alive: c_int) ?*BIO;
pub extern fn OSSL_HTTP_close(rctx: ?*OSSL_HTTP_REQ_CTX, ok: c_int) c_int;
pub extern fn OSSL_parse_url(url: [*c]const u8, pscheme: [*c][*c]u8, puser: [*c][*c]u8, phost: [*c][*c]u8, pport: [*c][*c]u8, pport_num: [*c]c_int, ppath: [*c][*c]u8, pquery: [*c][*c]u8, pfrag: [*c][*c]u8) c_int;
pub extern fn OSSL_HTTP_parse_url(url: [*c]const u8, pssl: [*c]c_int, puser: [*c][*c]u8, phost: [*c][*c]u8, pport: [*c][*c]u8, pport_num: [*c]c_int, ppath: [*c][*c]u8, pquery: [*c][*c]u8, pfrag: [*c][*c]u8) c_int;
pub extern fn OSSL_HTTP_adapt_proxy(proxy: [*c]const u8, no_proxy: [*c]const u8, server: [*c]const u8, use_ssl: c_int) [*c]const u8;
pub extern fn OSSL_HTTP_REQ_CTX_set_max_response_hdr_lines(rctx: ?*OSSL_HTTP_REQ_CTX, count: usize) void;
pub extern fn d2i_X509_fp(fp: [*c]FILE, x509: [*c]?*X509) ?*X509;
pub extern fn i2d_X509_fp(fp: [*c]FILE, x509: ?*const X509) c_int;
pub extern fn d2i_X509_CRL_fp(fp: [*c]FILE, crl: [*c]?*X509_CRL) ?*X509_CRL;
pub extern fn i2d_X509_CRL_fp(fp: [*c]FILE, crl: ?*const X509_CRL) c_int;
pub extern fn d2i_X509_REQ_fp(fp: [*c]FILE, req: [*c]?*X509_REQ) ?*X509_REQ;
pub extern fn i2d_X509_REQ_fp(fp: [*c]FILE, req: ?*const X509_REQ) c_int;
pub extern fn d2i_RSAPrivateKey_fp(fp: [*c]FILE, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSAPrivateKey_fp(fp: [*c]FILE, rsa: ?*const RSA) c_int;
pub extern fn d2i_RSAPublicKey_fp(fp: [*c]FILE, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSAPublicKey_fp(fp: [*c]FILE, rsa: ?*const RSA) c_int;
pub extern fn d2i_RSA_PUBKEY_fp(fp: [*c]FILE, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSA_PUBKEY_fp(fp: [*c]FILE, rsa: ?*const RSA) c_int;
pub extern fn d2i_DSA_PUBKEY_fp(fp: [*c]FILE, dsa: [*c]?*DSA) ?*DSA;
pub extern fn i2d_DSA_PUBKEY_fp(fp: [*c]FILE, dsa: ?*const DSA) c_int;
pub extern fn d2i_DSAPrivateKey_fp(fp: [*c]FILE, dsa: [*c]?*DSA) ?*DSA;
pub extern fn i2d_DSAPrivateKey_fp(fp: [*c]FILE, dsa: ?*const DSA) c_int;
pub extern fn d2i_EC_PUBKEY_fp(fp: [*c]FILE, eckey: [*c]?*EC_KEY) ?*EC_KEY;
pub extern fn i2d_EC_PUBKEY_fp(fp: [*c]FILE, eckey: ?*const EC_KEY) c_int;
pub extern fn d2i_ECPrivateKey_fp(fp: [*c]FILE, eckey: [*c]?*EC_KEY) ?*EC_KEY;
pub extern fn i2d_ECPrivateKey_fp(fp: [*c]FILE, eckey: ?*const EC_KEY) c_int;
pub extern fn d2i_PKCS8_fp(fp: [*c]FILE, p8: [*c]?*X509_SIG) ?*X509_SIG;
pub extern fn i2d_PKCS8_fp(fp: [*c]FILE, p8: ?*const X509_SIG) c_int;
pub extern fn d2i_X509_PUBKEY_fp(fp: [*c]FILE, xpk: [*c]?*X509_PUBKEY) ?*X509_PUBKEY;
pub extern fn i2d_X509_PUBKEY_fp(fp: [*c]FILE, xpk: ?*const X509_PUBKEY) c_int;
pub extern fn d2i_PKCS8_PRIV_KEY_INFO_fp(fp: [*c]FILE, p8inf: [*c]?*PKCS8_PRIV_KEY_INFO) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn i2d_PKCS8_PRIV_KEY_INFO_fp(fp: [*c]FILE, p8inf: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn i2d_PKCS8PrivateKeyInfo_fp(fp: [*c]FILE, key: ?*const EVP_PKEY) c_int;
pub extern fn i2d_PrivateKey_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_PrivateKey_ex_fp(fp: [*c]FILE, a: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PrivateKey_fp(fp: [*c]FILE, a: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn i2d_PUBKEY_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_PUBKEY_ex_fp(fp: [*c]FILE, a: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PUBKEY_fp(fp: [*c]FILE, a: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn d2i_X509_bio(bp: ?*BIO, x509: [*c]?*X509) ?*X509;
pub extern fn i2d_X509_bio(bp: ?*BIO, x509: ?*const X509) c_int;
pub extern fn d2i_X509_CRL_bio(bp: ?*BIO, crl: [*c]?*X509_CRL) ?*X509_CRL;
pub extern fn i2d_X509_CRL_bio(bp: ?*BIO, crl: ?*const X509_CRL) c_int;
pub extern fn d2i_X509_REQ_bio(bp: ?*BIO, req: [*c]?*X509_REQ) ?*X509_REQ;
pub extern fn i2d_X509_REQ_bio(bp: ?*BIO, req: ?*const X509_REQ) c_int;
pub extern fn d2i_RSAPrivateKey_bio(bp: ?*BIO, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSAPrivateKey_bio(bp: ?*BIO, rsa: ?*const RSA) c_int;
pub extern fn d2i_RSAPublicKey_bio(bp: ?*BIO, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSAPublicKey_bio(bp: ?*BIO, rsa: ?*const RSA) c_int;
pub extern fn d2i_RSA_PUBKEY_bio(bp: ?*BIO, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSA_PUBKEY_bio(bp: ?*BIO, rsa: ?*const RSA) c_int;
pub extern fn d2i_DSA_PUBKEY_bio(bp: ?*BIO, dsa: [*c]?*DSA) ?*DSA;
pub extern fn i2d_DSA_PUBKEY_bio(bp: ?*BIO, dsa: ?*const DSA) c_int;
pub extern fn d2i_DSAPrivateKey_bio(bp: ?*BIO, dsa: [*c]?*DSA) ?*DSA;
pub extern fn i2d_DSAPrivateKey_bio(bp: ?*BIO, dsa: ?*const DSA) c_int;
pub extern fn d2i_EC_PUBKEY_bio(bp: ?*BIO, eckey: [*c]?*EC_KEY) ?*EC_KEY;
pub extern fn i2d_EC_PUBKEY_bio(bp: ?*BIO, eckey: ?*const EC_KEY) c_int;
pub extern fn d2i_ECPrivateKey_bio(bp: ?*BIO, eckey: [*c]?*EC_KEY) ?*EC_KEY;
pub extern fn i2d_ECPrivateKey_bio(bp: ?*BIO, eckey: ?*const EC_KEY) c_int;
pub extern fn d2i_PKCS8_bio(bp: ?*BIO, p8: [*c]?*X509_SIG) ?*X509_SIG;
pub extern fn i2d_PKCS8_bio(bp: ?*BIO, p8: ?*const X509_SIG) c_int;
pub extern fn d2i_X509_PUBKEY_bio(bp: ?*BIO, xpk: [*c]?*X509_PUBKEY) ?*X509_PUBKEY;
pub extern fn i2d_X509_PUBKEY_bio(bp: ?*BIO, xpk: ?*const X509_PUBKEY) c_int;
pub extern fn d2i_PKCS8_PRIV_KEY_INFO_bio(bp: ?*BIO, p8inf: [*c]?*PKCS8_PRIV_KEY_INFO) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn i2d_PKCS8_PRIV_KEY_INFO_bio(bp: ?*BIO, p8inf: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn i2d_PKCS8PrivateKeyInfo_bio(bp: ?*BIO, key: ?*const EVP_PKEY) c_int;
pub extern fn i2d_PrivateKey_bio(bp: ?*BIO, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_PrivateKey_ex_bio(bp: ?*BIO, a: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PrivateKey_bio(bp: ?*BIO, a: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn i2d_PUBKEY_bio(bp: ?*BIO, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_PUBKEY_ex_bio(bp: ?*BIO, a: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PUBKEY_bio(bp: ?*BIO, a: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn X509_dup(a: ?*const X509) ?*X509;
pub extern fn X509_ALGOR_dup(a: [*c]const X509_ALGOR) [*c]X509_ALGOR;
pub extern fn X509_ATTRIBUTE_dup(a: ?*const X509_ATTRIBUTE) ?*X509_ATTRIBUTE;
pub extern fn X509_CRL_dup(a: ?*const X509_CRL) ?*X509_CRL;
pub extern fn X509_EXTENSION_dup(a: ?*const X509_EXTENSION) ?*X509_EXTENSION;
pub extern fn X509_PUBKEY_dup(a: ?*const X509_PUBKEY) ?*X509_PUBKEY;
pub extern fn X509_REQ_dup(a: ?*const X509_REQ) ?*X509_REQ;
pub extern fn X509_REVOKED_dup(a: ?*const X509_REVOKED) ?*X509_REVOKED;
pub extern fn X509_ALGOR_set0(alg: [*c]X509_ALGOR, aobj: ?*ASN1_OBJECT, ptype: c_int, pval: ?*anyopaque) c_int;
pub extern fn X509_ALGOR_get0(paobj: [*c]?*const ASN1_OBJECT, pptype: [*c]c_int, ppval: [*c]?*const anyopaque, algor: [*c]const X509_ALGOR) void;
pub extern fn X509_ALGOR_set_md(alg: [*c]X509_ALGOR, md: ?*const EVP_MD) void;
pub extern fn X509_ALGOR_cmp(a: [*c]const X509_ALGOR, b: [*c]const X509_ALGOR) c_int;
pub extern fn X509_ALGOR_copy(dest: [*c]X509_ALGOR, src: [*c]const X509_ALGOR) c_int;
pub extern fn X509_NAME_dup(a: ?*const X509_NAME) ?*X509_NAME;
pub extern fn X509_NAME_ENTRY_dup(a: ?*const X509_NAME_ENTRY) ?*X509_NAME_ENTRY;
pub extern fn X509_cmp_time(s: [*c]const ASN1_TIME, t: [*c]time_t) c_int;
pub extern fn X509_cmp_current_time(s: [*c]const ASN1_TIME) c_int;
pub extern fn X509_cmp_timeframe(vpm: ?*const X509_VERIFY_PARAM, start: [*c]const ASN1_TIME, end: [*c]const ASN1_TIME) c_int;
pub extern fn X509_time_adj(s: [*c]ASN1_TIME, adj: c_long, t: [*c]time_t) [*c]ASN1_TIME;
pub extern fn X509_time_adj_ex(s: [*c]ASN1_TIME, offset_day: c_int, offset_sec: c_long, t: [*c]time_t) [*c]ASN1_TIME;
pub extern fn X509_gmtime_adj(s: [*c]ASN1_TIME, adj: c_long) [*c]ASN1_TIME;
pub extern fn X509_get_default_cert_area() [*c]const u8;
pub extern fn X509_get_default_cert_dir() [*c]const u8;
pub extern fn X509_get_default_cert_file() [*c]const u8;
pub extern fn X509_get_default_cert_dir_env() [*c]const u8;
pub extern fn X509_get_default_cert_file_env() [*c]const u8;
pub extern fn X509_get_default_private_dir() [*c]const u8;
pub extern fn X509_to_X509_REQ(x: ?*X509, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) ?*X509_REQ;
pub extern fn X509_REQ_to_X509(r: ?*X509_REQ, days: c_int, pkey: ?*EVP_PKEY) ?*X509;
pub extern fn X509_ALGOR_new() [*c]X509_ALGOR;
pub extern fn X509_ALGOR_free(a: [*c]X509_ALGOR) void;
pub extern fn d2i_X509_ALGOR(a: [*c][*c]X509_ALGOR, in: [*c][*c]const u8, len: c_long) [*c]X509_ALGOR;
pub extern fn i2d_X509_ALGOR(a: [*c]const X509_ALGOR, out: [*c][*c]u8) c_int;
pub extern fn X509_ALGOR_it() ?*const ASN1_ITEM;
pub extern fn d2i_X509_ALGORS(a: [*c]?*X509_ALGORS, in: [*c][*c]const u8, len: c_long) ?*X509_ALGORS;
pub extern fn i2d_X509_ALGORS(a: ?*const X509_ALGORS, out: [*c][*c]u8) c_int;
pub extern fn X509_ALGORS_it() ?*const ASN1_ITEM;
pub extern fn X509_VAL_new() [*c]X509_VAL;
pub extern fn X509_VAL_free(a: [*c]X509_VAL) void;
pub extern fn d2i_X509_VAL(a: [*c][*c]X509_VAL, in: [*c][*c]const u8, len: c_long) [*c]X509_VAL;
pub extern fn i2d_X509_VAL(a: [*c]const X509_VAL, out: [*c][*c]u8) c_int;
pub extern fn X509_VAL_it() ?*const ASN1_ITEM;
pub extern fn X509_PUBKEY_new() ?*X509_PUBKEY;
pub extern fn X509_PUBKEY_free(a: ?*X509_PUBKEY) void;
pub extern fn d2i_X509_PUBKEY(a: [*c]?*X509_PUBKEY, in: [*c][*c]const u8, len: c_long) ?*X509_PUBKEY;
pub extern fn i2d_X509_PUBKEY(a: ?*const X509_PUBKEY, out: [*c][*c]u8) c_int;
pub extern fn X509_PUBKEY_it() ?*const ASN1_ITEM;
pub extern fn X509_PUBKEY_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509_PUBKEY;
pub extern fn X509_PUBKEY_set(x: [*c]?*X509_PUBKEY, pkey: ?*EVP_PKEY) c_int;
pub extern fn X509_PUBKEY_get0(key: ?*const X509_PUBKEY) ?*EVP_PKEY;
pub extern fn X509_PUBKEY_get(key: ?*const X509_PUBKEY) ?*EVP_PKEY;
pub extern fn X509_get_pubkey_parameters(pkey: ?*EVP_PKEY, chain: ?*struct_stack_st_X509) c_int;
pub extern fn X509_get_pathlen(x: ?*X509) c_long;
pub extern fn d2i_PUBKEY(a: [*c]?*EVP_PKEY, in: [*c][*c]const u8, len: c_long) ?*EVP_PKEY;
pub extern fn i2d_PUBKEY(a: ?*const EVP_PKEY, out: [*c][*c]u8) c_int;
pub extern fn d2i_PUBKEY_ex(a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_RSA_PUBKEY(a: [*c]?*RSA, in: [*c][*c]const u8, len: c_long) ?*RSA;
pub extern fn i2d_RSA_PUBKEY(a: ?*const RSA, out: [*c][*c]u8) c_int;
pub extern fn d2i_DSA_PUBKEY(a: [*c]?*DSA, in: [*c][*c]const u8, len: c_long) ?*DSA;
pub extern fn i2d_DSA_PUBKEY(a: ?*const DSA, out: [*c][*c]u8) c_int;
pub extern fn d2i_EC_PUBKEY(a: [*c]?*EC_KEY, in: [*c][*c]const u8, len: c_long) ?*EC_KEY;
pub extern fn i2d_EC_PUBKEY(a: ?*const EC_KEY, out: [*c][*c]u8) c_int;
pub extern fn X509_SIG_new() ?*X509_SIG;
pub extern fn X509_SIG_free(a: ?*X509_SIG) void;
pub extern fn d2i_X509_SIG(a: [*c]?*X509_SIG, in: [*c][*c]const u8, len: c_long) ?*X509_SIG;
pub extern fn i2d_X509_SIG(a: ?*const X509_SIG, out: [*c][*c]u8) c_int;
pub extern fn X509_SIG_it() ?*const ASN1_ITEM;
pub extern fn X509_SIG_get0(sig: ?*const X509_SIG, palg: [*c][*c]const X509_ALGOR, pdigest: [*c][*c]const ASN1_OCTET_STRING) void;
pub extern fn X509_SIG_getm(sig: ?*X509_SIG, palg: [*c][*c]X509_ALGOR, pdigest: [*c][*c]ASN1_OCTET_STRING) void;
pub extern fn X509_REQ_INFO_new() ?*X509_REQ_INFO;
pub extern fn X509_REQ_INFO_free(a: ?*X509_REQ_INFO) void;
pub extern fn d2i_X509_REQ_INFO(a: [*c]?*X509_REQ_INFO, in: [*c][*c]const u8, len: c_long) ?*X509_REQ_INFO;
pub extern fn i2d_X509_REQ_INFO(a: ?*const X509_REQ_INFO, out: [*c][*c]u8) c_int;
pub extern fn X509_REQ_INFO_it() ?*const ASN1_ITEM;
pub extern fn X509_REQ_new() ?*X509_REQ;
pub extern fn X509_REQ_free(a: ?*X509_REQ) void;
pub extern fn d2i_X509_REQ(a: [*c]?*X509_REQ, in: [*c][*c]const u8, len: c_long) ?*X509_REQ;
pub extern fn i2d_X509_REQ(a: ?*const X509_REQ, out: [*c][*c]u8) c_int;
pub extern fn X509_REQ_it() ?*const ASN1_ITEM;
pub extern fn X509_REQ_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509_REQ;
pub extern fn X509_ATTRIBUTE_new() ?*X509_ATTRIBUTE;
pub extern fn X509_ATTRIBUTE_free(a: ?*X509_ATTRIBUTE) void;
pub extern fn d2i_X509_ATTRIBUTE(a: [*c]?*X509_ATTRIBUTE, in: [*c][*c]const u8, len: c_long) ?*X509_ATTRIBUTE;
pub extern fn i2d_X509_ATTRIBUTE(a: ?*const X509_ATTRIBUTE, out: [*c][*c]u8) c_int;
pub extern fn X509_ATTRIBUTE_it() ?*const ASN1_ITEM;
pub extern fn X509_ATTRIBUTE_create(nid: c_int, atrtype: c_int, value: ?*anyopaque) ?*X509_ATTRIBUTE;
pub extern fn X509_EXTENSION_new() ?*X509_EXTENSION;
pub extern fn X509_EXTENSION_free(a: ?*X509_EXTENSION) void;
pub extern fn d2i_X509_EXTENSION(a: [*c]?*X509_EXTENSION, in: [*c][*c]const u8, len: c_long) ?*X509_EXTENSION;
pub extern fn i2d_X509_EXTENSION(a: ?*const X509_EXTENSION, out: [*c][*c]u8) c_int;
pub extern fn X509_EXTENSION_it() ?*const ASN1_ITEM;
pub extern fn d2i_X509_EXTENSIONS(a: [*c]?*X509_EXTENSIONS, in: [*c][*c]const u8, len: c_long) ?*X509_EXTENSIONS;
pub extern fn i2d_X509_EXTENSIONS(a: ?*const X509_EXTENSIONS, out: [*c][*c]u8) c_int;
pub extern fn X509_EXTENSIONS_it() ?*const ASN1_ITEM;
pub extern fn X509_NAME_ENTRY_new() ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_ENTRY_free(a: ?*X509_NAME_ENTRY) void;
pub extern fn d2i_X509_NAME_ENTRY(a: [*c]?*X509_NAME_ENTRY, in: [*c][*c]const u8, len: c_long) ?*X509_NAME_ENTRY;
pub extern fn i2d_X509_NAME_ENTRY(a: ?*const X509_NAME_ENTRY, out: [*c][*c]u8) c_int;
pub extern fn X509_NAME_ENTRY_it() ?*const ASN1_ITEM;
pub extern fn X509_NAME_new() ?*X509_NAME;
pub extern fn X509_NAME_free(a: ?*X509_NAME) void;
pub extern fn d2i_X509_NAME(a: [*c]?*X509_NAME, in: [*c][*c]const u8, len: c_long) ?*X509_NAME;
pub extern fn i2d_X509_NAME(a: ?*const X509_NAME, out: [*c][*c]u8) c_int;
pub extern fn X509_NAME_it() ?*const ASN1_ITEM;
pub extern fn X509_NAME_set(xn: [*c]?*X509_NAME, name: ?*const X509_NAME) c_int;
pub extern fn X509_CINF_new() ?*X509_CINF;
pub extern fn X509_CINF_free(a: ?*X509_CINF) void;
pub extern fn d2i_X509_CINF(a: [*c]?*X509_CINF, in: [*c][*c]const u8, len: c_long) ?*X509_CINF;
pub extern fn i2d_X509_CINF(a: ?*const X509_CINF, out: [*c][*c]u8) c_int;
pub extern fn X509_CINF_it() ?*const ASN1_ITEM;
pub extern fn X509_new() ?*X509;
pub extern fn X509_free(a: ?*X509) void;
pub extern fn d2i_X509(a: [*c]?*X509, in: [*c][*c]const u8, len: c_long) ?*X509;
pub extern fn i2d_X509(a: ?*const X509, out: [*c][*c]u8) c_int;
pub extern fn X509_it() ?*const ASN1_ITEM;
pub extern fn X509_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509;
pub extern fn X509_CERT_AUX_new() ?*X509_CERT_AUX;
pub extern fn X509_CERT_AUX_free(a: ?*X509_CERT_AUX) void;
pub extern fn d2i_X509_CERT_AUX(a: [*c]?*X509_CERT_AUX, in: [*c][*c]const u8, len: c_long) ?*X509_CERT_AUX;
pub extern fn i2d_X509_CERT_AUX(a: ?*const X509_CERT_AUX, out: [*c][*c]u8) c_int;
pub extern fn X509_CERT_AUX_it() ?*const ASN1_ITEM;
pub extern fn X509_set_ex_data(r: ?*X509, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn X509_get_ex_data(r: ?*const X509, idx: c_int) ?*anyopaque;
pub extern fn d2i_X509_AUX(a: [*c]?*X509, in: [*c][*c]const u8, len: c_long) ?*X509;
pub extern fn i2d_X509_AUX(a: ?*const X509, out: [*c][*c]u8) c_int;
pub extern fn i2d_re_X509_tbs(x: ?*X509, pp: [*c][*c]u8) c_int;
pub extern fn X509_SIG_INFO_get(siginf: ?*const X509_SIG_INFO, mdnid: [*c]c_int, pknid: [*c]c_int, secbits: [*c]c_int, flags: [*c]u32) c_int;
pub extern fn X509_SIG_INFO_set(siginf: ?*X509_SIG_INFO, mdnid: c_int, pknid: c_int, secbits: c_int, flags: u32) void;
pub extern fn X509_get_signature_info(x: ?*X509, mdnid: [*c]c_int, pknid: [*c]c_int, secbits: [*c]c_int, flags: [*c]u32) c_int;
pub extern fn X509_get0_signature(psig: [*c][*c]const ASN1_BIT_STRING, palg: [*c][*c]const X509_ALGOR, x: ?*const X509) void;
pub extern fn X509_get_signature_nid(x: ?*const X509) c_int;
pub extern fn X509_set0_distinguishing_id(x: ?*X509, d_id: [*c]ASN1_OCTET_STRING) void;
pub extern fn X509_get0_distinguishing_id(x: ?*X509) [*c]ASN1_OCTET_STRING;
pub extern fn X509_REQ_set0_distinguishing_id(x: ?*X509_REQ, d_id: [*c]ASN1_OCTET_STRING) void;
pub extern fn X509_REQ_get0_distinguishing_id(x: ?*X509_REQ) [*c]ASN1_OCTET_STRING;
pub extern fn X509_alias_set1(x: ?*X509, name: [*c]const u8, len: c_int) c_int;
pub extern fn X509_keyid_set1(x: ?*X509, id: [*c]const u8, len: c_int) c_int;
pub extern fn X509_alias_get0(x: ?*X509, len: [*c]c_int) [*c]u8;
pub extern fn X509_keyid_get0(x: ?*X509, len: [*c]c_int) [*c]u8;
pub extern fn X509_REVOKED_new() ?*X509_REVOKED;
pub extern fn X509_REVOKED_free(a: ?*X509_REVOKED) void;
pub extern fn d2i_X509_REVOKED(a: [*c]?*X509_REVOKED, in: [*c][*c]const u8, len: c_long) ?*X509_REVOKED;
pub extern fn i2d_X509_REVOKED(a: ?*const X509_REVOKED, out: [*c][*c]u8) c_int;
pub extern fn X509_REVOKED_it() ?*const ASN1_ITEM;
pub extern fn X509_CRL_INFO_new() ?*X509_CRL_INFO;
pub extern fn X509_CRL_INFO_free(a: ?*X509_CRL_INFO) void;
pub extern fn d2i_X509_CRL_INFO(a: [*c]?*X509_CRL_INFO, in: [*c][*c]const u8, len: c_long) ?*X509_CRL_INFO;
pub extern fn i2d_X509_CRL_INFO(a: ?*const X509_CRL_INFO, out: [*c][*c]u8) c_int;
pub extern fn X509_CRL_INFO_it() ?*const ASN1_ITEM;
pub extern fn X509_CRL_new() ?*X509_CRL;
pub extern fn X509_CRL_free(a: ?*X509_CRL) void;
pub extern fn d2i_X509_CRL(a: [*c]?*X509_CRL, in: [*c][*c]const u8, len: c_long) ?*X509_CRL;
pub extern fn i2d_X509_CRL(a: ?*const X509_CRL, out: [*c][*c]u8) c_int;
pub extern fn X509_CRL_it() ?*const ASN1_ITEM;
pub extern fn X509_CRL_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509_CRL;
pub extern fn X509_CRL_add0_revoked(crl: ?*X509_CRL, rev: ?*X509_REVOKED) c_int;
pub extern fn X509_CRL_get0_by_serial(crl: ?*X509_CRL, ret: [*c]?*X509_REVOKED, serial: [*c]const ASN1_INTEGER) c_int;
pub extern fn X509_CRL_get0_by_cert(crl: ?*X509_CRL, ret: [*c]?*X509_REVOKED, x: ?*X509) c_int;
pub extern fn X509_PKEY_new() [*c]X509_PKEY;
pub extern fn X509_PKEY_free(a: [*c]X509_PKEY) void;
pub extern fn NETSCAPE_SPKI_new() [*c]NETSCAPE_SPKI;
pub extern fn NETSCAPE_SPKI_free(a: [*c]NETSCAPE_SPKI) void;
pub extern fn d2i_NETSCAPE_SPKI(a: [*c][*c]NETSCAPE_SPKI, in: [*c][*c]const u8, len: c_long) [*c]NETSCAPE_SPKI;
pub extern fn i2d_NETSCAPE_SPKI(a: [*c]const NETSCAPE_SPKI, out: [*c][*c]u8) c_int;
pub extern fn NETSCAPE_SPKI_it() ?*const ASN1_ITEM;
pub extern fn NETSCAPE_SPKAC_new() [*c]NETSCAPE_SPKAC;
pub extern fn NETSCAPE_SPKAC_free(a: [*c]NETSCAPE_SPKAC) void;
pub extern fn d2i_NETSCAPE_SPKAC(a: [*c][*c]NETSCAPE_SPKAC, in: [*c][*c]const u8, len: c_long) [*c]NETSCAPE_SPKAC;
pub extern fn i2d_NETSCAPE_SPKAC(a: [*c]const NETSCAPE_SPKAC, out: [*c][*c]u8) c_int;
pub extern fn NETSCAPE_SPKAC_it() ?*const ASN1_ITEM;
pub extern fn NETSCAPE_CERT_SEQUENCE_new() [*c]NETSCAPE_CERT_SEQUENCE;
pub extern fn NETSCAPE_CERT_SEQUENCE_free(a: [*c]NETSCAPE_CERT_SEQUENCE) void;
pub extern fn d2i_NETSCAPE_CERT_SEQUENCE(a: [*c][*c]NETSCAPE_CERT_SEQUENCE, in: [*c][*c]const u8, len: c_long) [*c]NETSCAPE_CERT_SEQUENCE;
pub extern fn i2d_NETSCAPE_CERT_SEQUENCE(a: [*c]const NETSCAPE_CERT_SEQUENCE, out: [*c][*c]u8) c_int;
pub extern fn NETSCAPE_CERT_SEQUENCE_it() ?*const ASN1_ITEM;
pub extern fn X509_INFO_new() [*c]X509_INFO;
pub extern fn X509_INFO_free(a: [*c]X509_INFO) void;
pub extern fn X509_NAME_oneline(a: ?*const X509_NAME, buf: [*c]u8, size: c_int) [*c]u8;
pub extern fn ASN1_verify(i2d: ?*const i2d_of_void, algor1: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: [*c]u8, pkey: ?*EVP_PKEY) c_int;
pub extern fn ASN1_digest(i2d: ?*const i2d_of_void, @"type": ?*const EVP_MD, data: [*c]u8, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn ASN1_sign(i2d: ?*const i2d_of_void, algor1: [*c]X509_ALGOR, algor2: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: [*c]u8, pkey: ?*EVP_PKEY, @"type": ?*const EVP_MD) c_int;
pub extern fn ASN1_item_digest(it: ?*const ASN1_ITEM, @"type": ?*const EVP_MD, data: ?*anyopaque, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn ASN1_item_verify(it: ?*const ASN1_ITEM, alg: [*c]const X509_ALGOR, signature: [*c]const ASN1_BIT_STRING, data: ?*const anyopaque, pkey: ?*EVP_PKEY) c_int;
pub extern fn ASN1_item_verify_ctx(it: ?*const ASN1_ITEM, alg: [*c]const X509_ALGOR, signature: [*c]const ASN1_BIT_STRING, data: ?*const anyopaque, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn ASN1_item_sign(it: ?*const ASN1_ITEM, algor1: [*c]X509_ALGOR, algor2: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: ?*const anyopaque, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn ASN1_item_sign_ctx(it: ?*const ASN1_ITEM, algor1: [*c]X509_ALGOR, algor2: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: ?*const anyopaque, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn X509_get_version(x: ?*const X509) c_long;
pub extern fn X509_set_version(x: ?*X509, version: c_long) c_int;
pub extern fn X509_set_serialNumber(x: ?*X509, serial: [*c]ASN1_INTEGER) c_int;
pub extern fn X509_get_serialNumber(x: ?*X509) [*c]ASN1_INTEGER;
pub extern fn X509_get0_serialNumber(x: ?*const X509) [*c]const ASN1_INTEGER;
pub extern fn X509_set_issuer_name(x: ?*X509, name: ?*const X509_NAME) c_int;
pub extern fn X509_get_issuer_name(a: ?*const X509) ?*X509_NAME;
pub extern fn X509_set_subject_name(x: ?*X509, name: ?*const X509_NAME) c_int;
pub extern fn X509_get_subject_name(a: ?*const X509) ?*X509_NAME;
pub extern fn X509_get0_notBefore(x: ?*const X509) [*c]const ASN1_TIME;
pub extern fn X509_getm_notBefore(x: ?*const X509) [*c]ASN1_TIME;
pub extern fn X509_set1_notBefore(x: ?*X509, tm: [*c]const ASN1_TIME) c_int;
pub extern fn X509_get0_notAfter(x: ?*const X509) [*c]const ASN1_TIME;
pub extern fn X509_getm_notAfter(x: ?*const X509) [*c]ASN1_TIME;
pub extern fn X509_set1_notAfter(x: ?*X509, tm: [*c]const ASN1_TIME) c_int;
pub extern fn X509_set_pubkey(x: ?*X509, pkey: ?*EVP_PKEY) c_int;
pub extern fn X509_up_ref(x: ?*X509) c_int;
pub extern fn X509_get_signature_type(x: ?*const X509) c_int;
pub extern fn X509_get_X509_PUBKEY(x: ?*const X509) ?*X509_PUBKEY;
pub extern fn X509_get0_extensions(x: ?*const X509) ?*const struct_stack_st_X509_EXTENSION;
pub extern fn X509_get0_uids(x: ?*const X509, piuid: [*c][*c]const ASN1_BIT_STRING, psuid: [*c][*c]const ASN1_BIT_STRING) void;
pub extern fn X509_get0_tbs_sigalg(x: ?*const X509) [*c]const X509_ALGOR;
pub extern fn X509_get0_pubkey(x: ?*const X509) ?*EVP_PKEY;
pub extern fn X509_get_pubkey(x: ?*X509) ?*EVP_PKEY;
pub extern fn X509_get0_pubkey_bitstr(x: ?*const X509) [*c]ASN1_BIT_STRING;
pub extern fn X509_REQ_get_version(req: ?*const X509_REQ) c_long;
pub extern fn X509_REQ_set_version(x: ?*X509_REQ, version: c_long) c_int;
pub extern fn X509_REQ_get_subject_name(req: ?*const X509_REQ) ?*X509_NAME;
pub extern fn X509_REQ_set_subject_name(req: ?*X509_REQ, name: ?*const X509_NAME) c_int;
pub extern fn X509_REQ_get0_signature(req: ?*const X509_REQ, psig: [*c][*c]const ASN1_BIT_STRING, palg: [*c][*c]const X509_ALGOR) void;
pub extern fn X509_REQ_set0_signature(req: ?*X509_REQ, psig: [*c]ASN1_BIT_STRING) void;
pub extern fn X509_REQ_set1_signature_algo(req: ?*X509_REQ, palg: [*c]X509_ALGOR) c_int;
pub extern fn X509_REQ_get_signature_nid(req: ?*const X509_REQ) c_int;
pub extern fn i2d_re_X509_REQ_tbs(req: ?*X509_REQ, pp: [*c][*c]u8) c_int;
pub extern fn X509_REQ_set_pubkey(x: ?*X509_REQ, pkey: ?*EVP_PKEY) c_int;
pub extern fn X509_REQ_get_pubkey(req: ?*X509_REQ) ?*EVP_PKEY;
pub extern fn X509_REQ_get0_pubkey(req: ?*const X509_REQ) ?*EVP_PKEY;
pub extern fn X509_REQ_get_X509_PUBKEY(req: ?*X509_REQ) ?*X509_PUBKEY;
pub extern fn X509_REQ_extension_nid(nid: c_int) c_int;
pub extern fn X509_REQ_get_extension_nids() [*c]c_int;
pub extern fn X509_REQ_set_extension_nids(nids: [*c]c_int) void;
pub extern fn X509_REQ_get_extensions(req: ?*X509_REQ) ?*struct_stack_st_X509_EXTENSION;
pub extern fn X509_REQ_add_extensions_nid(req: ?*X509_REQ, exts: ?*const struct_stack_st_X509_EXTENSION, nid: c_int) c_int;
pub extern fn X509_REQ_add_extensions(req: ?*X509_REQ, ext: ?*const struct_stack_st_X509_EXTENSION) c_int;
pub extern fn X509_REQ_get_attr_count(req: ?*const X509_REQ) c_int;
pub extern fn X509_REQ_get_attr_by_NID(req: ?*const X509_REQ, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_REQ_get_attr_by_OBJ(req: ?*const X509_REQ, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_REQ_get_attr(req: ?*const X509_REQ, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_REQ_delete_attr(req: ?*X509_REQ, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_REQ_add1_attr(req: ?*X509_REQ, attr: ?*X509_ATTRIBUTE) c_int;
pub extern fn X509_REQ_add1_attr_by_OBJ(req: ?*X509_REQ, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_REQ_add1_attr_by_NID(req: ?*X509_REQ, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_REQ_add1_attr_by_txt(req: ?*X509_REQ, attrname: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_CRL_set_version(x: ?*X509_CRL, version: c_long) c_int;
pub extern fn X509_CRL_set_issuer_name(x: ?*X509_CRL, name: ?*const X509_NAME) c_int;
pub extern fn X509_CRL_set1_lastUpdate(x: ?*X509_CRL, tm: [*c]const ASN1_TIME) c_int;
pub extern fn X509_CRL_set1_nextUpdate(x: ?*X509_CRL, tm: [*c]const ASN1_TIME) c_int;
pub extern fn X509_CRL_sort(crl: ?*X509_CRL) c_int;
pub extern fn X509_CRL_up_ref(crl: ?*X509_CRL) c_int;
pub extern fn X509_CRL_get_version(crl: ?*const X509_CRL) c_long;
pub extern fn X509_CRL_get0_lastUpdate(crl: ?*const X509_CRL) [*c]const ASN1_TIME;
pub extern fn X509_CRL_get0_nextUpdate(crl: ?*const X509_CRL) [*c]const ASN1_TIME;
pub extern fn X509_CRL_get_lastUpdate(crl: ?*X509_CRL) [*c]ASN1_TIME;
pub extern fn X509_CRL_get_nextUpdate(crl: ?*X509_CRL) [*c]ASN1_TIME;
pub extern fn X509_CRL_get_issuer(crl: ?*const X509_CRL) ?*X509_NAME;
pub extern fn X509_CRL_get0_extensions(crl: ?*const X509_CRL) ?*const struct_stack_st_X509_EXTENSION;
pub extern fn X509_CRL_get_REVOKED(crl: ?*X509_CRL) ?*struct_stack_st_X509_REVOKED;
pub extern fn X509_CRL_get0_signature(crl: ?*const X509_CRL, psig: [*c][*c]const ASN1_BIT_STRING, palg: [*c][*c]const X509_ALGOR) void;
pub extern fn X509_CRL_get_signature_nid(crl: ?*const X509_CRL) c_int;
pub extern fn i2d_re_X509_CRL_tbs(req: ?*X509_CRL, pp: [*c][*c]u8) c_int;
pub extern fn X509_REVOKED_get0_serialNumber(x: ?*const X509_REVOKED) [*c]const ASN1_INTEGER;
pub extern fn X509_REVOKED_set_serialNumber(x: ?*X509_REVOKED, serial: [*c]ASN1_INTEGER) c_int;
pub extern fn X509_REVOKED_get0_revocationDate(x: ?*const X509_REVOKED) [*c]const ASN1_TIME;
pub extern fn X509_REVOKED_set_revocationDate(r: ?*X509_REVOKED, tm: [*c]ASN1_TIME) c_int;
pub extern fn X509_REVOKED_get0_extensions(r: ?*const X509_REVOKED) ?*const struct_stack_st_X509_EXTENSION;
pub extern fn X509_CRL_diff(base: ?*X509_CRL, newer: ?*X509_CRL, skey: ?*EVP_PKEY, md: ?*const EVP_MD, flags: c_uint) ?*X509_CRL;
pub extern fn X509_REQ_check_private_key(req: ?*const X509_REQ, pkey: ?*EVP_PKEY) c_int;
pub extern fn X509_check_private_key(cert: ?*const X509, pkey: ?*const EVP_PKEY) c_int;
pub extern fn X509_chain_check_suiteb(perror_depth: [*c]c_int, x: ?*X509, chain: ?*struct_stack_st_X509, flags: c_ulong) c_int;
pub extern fn X509_CRL_check_suiteb(crl: ?*X509_CRL, pk: ?*EVP_PKEY, flags: c_ulong) c_int;
pub extern fn OSSL_STACK_OF_X509_free(certs: ?*struct_stack_st_X509) void;
pub extern fn X509_chain_up_ref(chain: ?*struct_stack_st_X509) ?*struct_stack_st_X509;
pub extern fn X509_issuer_and_serial_cmp(a: ?*const X509, b: ?*const X509) c_int;
pub extern fn X509_issuer_and_serial_hash(a: ?*X509) c_ulong;
pub extern fn X509_issuer_name_cmp(a: ?*const X509, b: ?*const X509) c_int;
pub extern fn X509_issuer_name_hash(a: ?*X509) c_ulong;
pub extern fn X509_subject_name_cmp(a: ?*const X509, b: ?*const X509) c_int;
pub extern fn X509_subject_name_hash(x: ?*X509) c_ulong;
pub extern fn X509_issuer_name_hash_old(a: ?*X509) c_ulong;
pub extern fn X509_subject_name_hash_old(x: ?*X509) c_ulong;
pub extern fn X509_add_cert(sk: ?*struct_stack_st_X509, cert: ?*X509, flags: c_int) c_int;
pub extern fn X509_add_certs(sk: ?*struct_stack_st_X509, certs: ?*struct_stack_st_X509, flags: c_int) c_int;
pub extern fn X509_cmp(a: ?*const X509, b: ?*const X509) c_int;
pub extern fn X509_NAME_cmp(a: ?*const X509_NAME, b: ?*const X509_NAME) c_int;
pub extern fn X509_certificate_type(x: ?*const X509, pubkey: ?*const EVP_PKEY) c_int;
pub extern fn X509_NAME_hash_ex(x: ?*const X509_NAME, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, ok: [*c]c_int) c_ulong;
pub extern fn X509_NAME_hash_old(x: ?*const X509_NAME) c_ulong;
pub extern fn X509_CRL_cmp(a: ?*const X509_CRL, b: ?*const X509_CRL) c_int;
pub extern fn X509_CRL_match(a: ?*const X509_CRL, b: ?*const X509_CRL) c_int;
pub extern fn X509_aux_print(out: ?*BIO, x: ?*X509, indent: c_int) c_int;
pub extern fn X509_print_ex_fp(bp: [*c]FILE, x: ?*X509, nmflag: c_ulong, cflag: c_ulong) c_int;
pub extern fn X509_print_fp(bp: [*c]FILE, x: ?*X509) c_int;
pub extern fn X509_CRL_print_fp(bp: [*c]FILE, x: ?*X509_CRL) c_int;
pub extern fn X509_REQ_print_fp(bp: [*c]FILE, req: ?*X509_REQ) c_int;
pub extern fn X509_NAME_print_ex_fp(fp: [*c]FILE, nm: ?*const X509_NAME, indent: c_int, flags: c_ulong) c_int;
pub extern fn X509_NAME_print(bp: ?*BIO, name: ?*const X509_NAME, obase: c_int) c_int;
pub extern fn X509_NAME_print_ex(out: ?*BIO, nm: ?*const X509_NAME, indent: c_int, flags: c_ulong) c_int;
pub extern fn X509_print_ex(bp: ?*BIO, x: ?*X509, nmflag: c_ulong, cflag: c_ulong) c_int;
pub extern fn X509_print(bp: ?*BIO, x: ?*X509) c_int;
pub extern fn X509_ocspid_print(bp: ?*BIO, x: ?*X509) c_int;
pub extern fn X509_CRL_print_ex(out: ?*BIO, x: ?*X509_CRL, nmflag: c_ulong) c_int;
pub extern fn X509_CRL_print(bp: ?*BIO, x: ?*X509_CRL) c_int;
pub extern fn X509_REQ_print_ex(bp: ?*BIO, x: ?*X509_REQ, nmflag: c_ulong, cflag: c_ulong) c_int;
pub extern fn X509_REQ_print(bp: ?*BIO, req: ?*X509_REQ) c_int;
pub extern fn X509_NAME_entry_count(name: ?*const X509_NAME) c_int;
pub extern fn X509_NAME_get_text_by_NID(name: ?*const X509_NAME, nid: c_int, buf: [*c]u8, len: c_int) c_int;
pub extern fn X509_NAME_get_text_by_OBJ(name: ?*const X509_NAME, obj: ?*const ASN1_OBJECT, buf: [*c]u8, len: c_int) c_int;
pub extern fn X509_NAME_get_index_by_NID(name: ?*const X509_NAME, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_NAME_get_index_by_OBJ(name: ?*const X509_NAME, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_NAME_get_entry(name: ?*const X509_NAME, loc: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_delete_entry(name: ?*X509_NAME, loc: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_add_entry(name: ?*X509_NAME, ne: ?*const X509_NAME_ENTRY, loc: c_int, set: c_int) c_int;
pub extern fn X509_NAME_add_entry_by_OBJ(name: ?*X509_NAME, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int, loc: c_int, set: c_int) c_int;
pub extern fn X509_NAME_add_entry_by_NID(name: ?*X509_NAME, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int, loc: c_int, set: c_int) c_int;
pub extern fn X509_NAME_ENTRY_create_by_txt(ne: [*c]?*X509_NAME_ENTRY, field: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_ENTRY_create_by_NID(ne: [*c]?*X509_NAME_ENTRY, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_add_entry_by_txt(name: ?*X509_NAME, field: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int, loc: c_int, set: c_int) c_int;
pub extern fn X509_NAME_ENTRY_create_by_OBJ(ne: [*c]?*X509_NAME_ENTRY, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_ENTRY_set_object(ne: ?*X509_NAME_ENTRY, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_NAME_ENTRY_set_data(ne: ?*X509_NAME_ENTRY, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_NAME_ENTRY_get_object(ne: ?*const X509_NAME_ENTRY) ?*ASN1_OBJECT;
pub extern fn X509_NAME_ENTRY_get_data(ne: ?*const X509_NAME_ENTRY) [*c]ASN1_STRING;
pub extern fn X509_NAME_ENTRY_set(ne: ?*const X509_NAME_ENTRY) c_int;
pub extern fn X509_NAME_get0_der(nm: ?*const X509_NAME, pder: [*c][*c]const u8, pderlen: [*c]usize) c_int;
pub extern fn X509v3_get_ext_count(x: ?*const struct_stack_st_X509_EXTENSION) c_int;
pub extern fn X509v3_get_ext_by_NID(x: ?*const struct_stack_st_X509_EXTENSION, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509v3_get_ext_by_OBJ(x: ?*const struct_stack_st_X509_EXTENSION, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509v3_get_ext_by_critical(x: ?*const struct_stack_st_X509_EXTENSION, crit: c_int, lastpos: c_int) c_int;
pub extern fn X509v3_get_ext(x: ?*const struct_stack_st_X509_EXTENSION, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509v3_delete_ext(x: ?*struct_stack_st_X509_EXTENSION, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509v3_add_ext(x: [*c]?*struct_stack_st_X509_EXTENSION, ex: ?*X509_EXTENSION, loc: c_int) ?*struct_stack_st_X509_EXTENSION;
pub extern fn X509v3_add_extensions(target: [*c]?*struct_stack_st_X509_EXTENSION, exts: ?*const struct_stack_st_X509_EXTENSION) ?*struct_stack_st_X509_EXTENSION;
pub extern fn X509_get_ext_count(x: ?*const X509) c_int;
pub extern fn X509_get_ext_by_NID(x: ?*const X509, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_get_ext_by_OBJ(x: ?*const X509, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_get_ext_by_critical(x: ?*const X509, crit: c_int, lastpos: c_int) c_int;
pub extern fn X509_get_ext(x: ?*const X509, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_delete_ext(x: ?*X509, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_add_ext(x: ?*X509, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn X509_get_ext_d2i(x: ?*const X509, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn X509_add1_ext_i2d(x: ?*X509, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn X509_CRL_get_ext_count(x: ?*const X509_CRL) c_int;
pub extern fn X509_CRL_get_ext_by_NID(x: ?*const X509_CRL, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_CRL_get_ext_by_OBJ(x: ?*const X509_CRL, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_CRL_get_ext_by_critical(x: ?*const X509_CRL, crit: c_int, lastpos: c_int) c_int;
pub extern fn X509_CRL_get_ext(x: ?*const X509_CRL, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_CRL_delete_ext(x: ?*X509_CRL, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_CRL_add_ext(x: ?*X509_CRL, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn X509_CRL_get_ext_d2i(x: ?*const X509_CRL, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn X509_CRL_add1_ext_i2d(x: ?*X509_CRL, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn X509_REVOKED_get_ext_count(x: ?*const X509_REVOKED) c_int;
pub extern fn X509_REVOKED_get_ext_by_NID(x: ?*const X509_REVOKED, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_REVOKED_get_ext_by_OBJ(x: ?*const X509_REVOKED, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_REVOKED_get_ext_by_critical(x: ?*const X509_REVOKED, crit: c_int, lastpos: c_int) c_int;
pub extern fn X509_REVOKED_get_ext(x: ?*const X509_REVOKED, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_REVOKED_delete_ext(x: ?*X509_REVOKED, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_REVOKED_add_ext(x: ?*X509_REVOKED, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn X509_REVOKED_get_ext_d2i(x: ?*const X509_REVOKED, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn X509_REVOKED_add1_ext_i2d(x: ?*X509_REVOKED, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn X509_EXTENSION_create_by_NID(ex: [*c]?*X509_EXTENSION, nid: c_int, crit: c_int, data: [*c]ASN1_OCTET_STRING) ?*X509_EXTENSION;
pub extern fn X509_EXTENSION_create_by_OBJ(ex: [*c]?*X509_EXTENSION, obj: ?*const ASN1_OBJECT, crit: c_int, data: [*c]ASN1_OCTET_STRING) ?*X509_EXTENSION;
pub extern fn X509_EXTENSION_set_object(ex: ?*X509_EXTENSION, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_EXTENSION_set_critical(ex: ?*X509_EXTENSION, crit: c_int) c_int;
pub extern fn X509_EXTENSION_set_data(ex: ?*X509_EXTENSION, data: [*c]ASN1_OCTET_STRING) c_int;
pub extern fn X509_EXTENSION_get_object(ex: ?*X509_EXTENSION) ?*ASN1_OBJECT;
pub extern fn X509_EXTENSION_get_data(ne: ?*X509_EXTENSION) [*c]ASN1_OCTET_STRING;
pub extern fn X509_EXTENSION_get_critical(ex: ?*const X509_EXTENSION) c_int;
pub extern fn X509at_get_attr_count(x: ?*const struct_stack_st_X509_ATTRIBUTE) c_int;
pub extern fn X509at_get_attr_by_NID(x: ?*const struct_stack_st_X509_ATTRIBUTE, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509at_get_attr_by_OBJ(sk: ?*const struct_stack_st_X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509at_get_attr(x: ?*const struct_stack_st_X509_ATTRIBUTE, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509at_delete_attr(x: ?*struct_stack_st_X509_ATTRIBUTE, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509at_add1_attr(x: [*c]?*struct_stack_st_X509_ATTRIBUTE, attr: ?*X509_ATTRIBUTE) ?*struct_stack_st_X509_ATTRIBUTE;
pub extern fn X509at_add1_attr_by_OBJ(x: [*c]?*struct_stack_st_X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*struct_stack_st_X509_ATTRIBUTE;
pub extern fn X509at_add1_attr_by_NID(x: [*c]?*struct_stack_st_X509_ATTRIBUTE, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*struct_stack_st_X509_ATTRIBUTE;
pub extern fn X509at_add1_attr_by_txt(x: [*c]?*struct_stack_st_X509_ATTRIBUTE, attrname: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*struct_stack_st_X509_ATTRIBUTE;
pub extern fn X509at_get0_data_by_OBJ(x: ?*const struct_stack_st_X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT, lastpos: c_int, @"type": c_int) ?*anyopaque;
pub extern fn X509_ATTRIBUTE_create_by_NID(attr: [*c]?*X509_ATTRIBUTE, nid: c_int, atrtype: c_int, data: ?*const anyopaque, len: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_ATTRIBUTE_create_by_OBJ(attr: [*c]?*X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT, atrtype: c_int, data: ?*const anyopaque, len: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_ATTRIBUTE_create_by_txt(attr: [*c]?*X509_ATTRIBUTE, atrname: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_ATTRIBUTE_set1_object(attr: ?*X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_ATTRIBUTE_set1_data(attr: ?*X509_ATTRIBUTE, attrtype: c_int, data: ?*const anyopaque, len: c_int) c_int;
pub extern fn X509_ATTRIBUTE_get0_data(attr: ?*X509_ATTRIBUTE, idx: c_int, atrtype: c_int, data: ?*anyopaque) ?*anyopaque;
pub extern fn X509_ATTRIBUTE_count(attr: ?*const X509_ATTRIBUTE) c_int;
pub extern fn X509_ATTRIBUTE_get0_object(attr: ?*X509_ATTRIBUTE) ?*ASN1_OBJECT;
pub extern fn X509_ATTRIBUTE_get0_type(attr: ?*X509_ATTRIBUTE, idx: c_int) [*c]ASN1_TYPE;
pub extern fn EVP_PKEY_get_attr_count(key: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_attr_by_NID(key: ?*const EVP_PKEY, nid: c_int, lastpos: c_int) c_int;
pub extern fn EVP_PKEY_get_attr_by_OBJ(key: ?*const EVP_PKEY, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn EVP_PKEY_get_attr(key: ?*const EVP_PKEY, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn EVP_PKEY_delete_attr(key: ?*EVP_PKEY, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn EVP_PKEY_add1_attr(key: ?*EVP_PKEY, attr: ?*X509_ATTRIBUTE) c_int;
pub extern fn EVP_PKEY_add1_attr_by_OBJ(key: ?*EVP_PKEY, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn EVP_PKEY_add1_attr_by_NID(key: ?*EVP_PKEY, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn EVP_PKEY_add1_attr_by_txt(key: ?*EVP_PKEY, attrname: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_find_by_issuer_and_serial(sk: ?*struct_stack_st_X509, name: ?*const X509_NAME, serial: [*c]const ASN1_INTEGER) ?*X509;
pub extern fn X509_find_by_subject(sk: ?*struct_stack_st_X509, name: ?*const X509_NAME) ?*X509;
pub extern fn PBEPARAM_new() [*c]PBEPARAM;
pub extern fn PBEPARAM_free(a: [*c]PBEPARAM) void;
pub extern fn d2i_PBEPARAM(a: [*c][*c]PBEPARAM, in: [*c][*c]const u8, len: c_long) [*c]PBEPARAM;
pub extern fn i2d_PBEPARAM(a: [*c]const PBEPARAM, out: [*c][*c]u8) c_int;
pub extern fn PBEPARAM_it() ?*const ASN1_ITEM;
pub extern fn PBE2PARAM_new() [*c]PBE2PARAM;
pub extern fn PBE2PARAM_free(a: [*c]PBE2PARAM) void;
pub extern fn d2i_PBE2PARAM(a: [*c][*c]PBE2PARAM, in: [*c][*c]const u8, len: c_long) [*c]PBE2PARAM;
pub extern fn i2d_PBE2PARAM(a: [*c]const PBE2PARAM, out: [*c][*c]u8) c_int;
pub extern fn PBE2PARAM_it() ?*const ASN1_ITEM;
pub extern fn PBKDF2PARAM_new() [*c]PBKDF2PARAM;
pub extern fn PBKDF2PARAM_free(a: [*c]PBKDF2PARAM) void;
pub extern fn d2i_PBKDF2PARAM(a: [*c][*c]PBKDF2PARAM, in: [*c][*c]const u8, len: c_long) [*c]PBKDF2PARAM;
pub extern fn i2d_PBKDF2PARAM(a: [*c]const PBKDF2PARAM, out: [*c][*c]u8) c_int;
pub extern fn PBKDF2PARAM_it() ?*const ASN1_ITEM;
pub extern fn PBMAC1PARAM_new() [*c]PBMAC1PARAM;
pub extern fn PBMAC1PARAM_free(a: [*c]PBMAC1PARAM) void;
pub extern fn d2i_PBMAC1PARAM(a: [*c][*c]PBMAC1PARAM, in: [*c][*c]const u8, len: c_long) [*c]PBMAC1PARAM;
pub extern fn i2d_PBMAC1PARAM(a: [*c]const PBMAC1PARAM, out: [*c][*c]u8) c_int;
pub extern fn PBMAC1PARAM_it() ?*const ASN1_ITEM;
pub extern fn SCRYPT_PARAMS_new() [*c]SCRYPT_PARAMS;
pub extern fn SCRYPT_PARAMS_free(a: [*c]SCRYPT_PARAMS) void;
pub extern fn d2i_SCRYPT_PARAMS(a: [*c][*c]SCRYPT_PARAMS, in: [*c][*c]const u8, len: c_long) [*c]SCRYPT_PARAMS;
pub extern fn i2d_SCRYPT_PARAMS(a: [*c]const SCRYPT_PARAMS, out: [*c][*c]u8) c_int;
pub extern fn SCRYPT_PARAMS_it() ?*const ASN1_ITEM;
pub extern fn PKCS5_pbe_set0_algor(algor: [*c]X509_ALGOR, alg: c_int, iter: c_int, salt: [*c]const u8, saltlen: c_int) c_int;
pub extern fn PKCS5_pbe_set0_algor_ex(algor: [*c]X509_ALGOR, alg: c_int, iter: c_int, salt: [*c]const u8, saltlen: c_int, libctx: ?*OSSL_LIB_CTX) c_int;
pub extern fn PKCS5_pbe_set(alg: c_int, iter: c_int, salt: [*c]const u8, saltlen: c_int) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe_set_ex(alg: c_int, iter: c_int, salt: [*c]const u8, saltlen: c_int, libctx: ?*OSSL_LIB_CTX) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe2_set(cipher: ?*const EVP_CIPHER, iter: c_int, salt: [*c]u8, saltlen: c_int) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe2_set_iv(cipher: ?*const EVP_CIPHER, iter: c_int, salt: [*c]u8, saltlen: c_int, aiv: [*c]u8, prf_nid: c_int) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe2_set_iv_ex(cipher: ?*const EVP_CIPHER, iter: c_int, salt: [*c]u8, saltlen: c_int, aiv: [*c]u8, prf_nid: c_int, libctx: ?*OSSL_LIB_CTX) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe2_set_scrypt(cipher: ?*const EVP_CIPHER, salt: [*c]const u8, saltlen: c_int, aiv: [*c]u8, N: u64, r: u64, p: u64) [*c]X509_ALGOR;
pub extern fn PKCS5_pbkdf2_set(iter: c_int, salt: [*c]u8, saltlen: c_int, prf_nid: c_int, keylen: c_int) [*c]X509_ALGOR;
pub extern fn PKCS5_pbkdf2_set_ex(iter: c_int, salt: [*c]u8, saltlen: c_int, prf_nid: c_int, keylen: c_int, libctx: ?*OSSL_LIB_CTX) [*c]X509_ALGOR;
pub extern fn PBMAC1_get1_pbkdf2_param(macalg: [*c]const X509_ALGOR) [*c]PBKDF2PARAM;
pub extern fn PKCS8_PRIV_KEY_INFO_new() ?*PKCS8_PRIV_KEY_INFO;
pub extern fn PKCS8_PRIV_KEY_INFO_free(a: ?*PKCS8_PRIV_KEY_INFO) void;
pub extern fn d2i_PKCS8_PRIV_KEY_INFO(a: [*c]?*PKCS8_PRIV_KEY_INFO, in: [*c][*c]const u8, len: c_long) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn i2d_PKCS8_PRIV_KEY_INFO(a: ?*const PKCS8_PRIV_KEY_INFO, out: [*c][*c]u8) c_int;
pub extern fn PKCS8_PRIV_KEY_INFO_it() ?*const ASN1_ITEM;
pub extern fn EVP_PKCS82PKEY(p8: ?*const PKCS8_PRIV_KEY_INFO) ?*EVP_PKEY;
pub extern fn EVP_PKCS82PKEY_ex(p8: ?*const PKCS8_PRIV_KEY_INFO, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn EVP_PKEY2PKCS8(pkey: ?*const EVP_PKEY) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn PKCS8_pkey_set0(priv: ?*PKCS8_PRIV_KEY_INFO, aobj: ?*ASN1_OBJECT, version: c_int, ptype: c_int, pval: ?*anyopaque, penc: [*c]u8, penclen: c_int) c_int;
pub extern fn PKCS8_pkey_get0(ppkalg: [*c]?*const ASN1_OBJECT, pk: [*c][*c]const u8, ppklen: [*c]c_int, pa: [*c][*c]const X509_ALGOR, p8: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn PKCS8_pkey_get0_attrs(p8: ?*const PKCS8_PRIV_KEY_INFO) ?*const struct_stack_st_X509_ATTRIBUTE;
pub extern fn PKCS8_pkey_add1_attr(p8: ?*PKCS8_PRIV_KEY_INFO, attr: ?*X509_ATTRIBUTE) c_int;
pub extern fn PKCS8_pkey_add1_attr_by_NID(p8: ?*PKCS8_PRIV_KEY_INFO, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn PKCS8_pkey_add1_attr_by_OBJ(p8: ?*PKCS8_PRIV_KEY_INFO, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_PUBKEY_set0_public_key(@"pub": ?*X509_PUBKEY, penc: [*c]u8, penclen: c_int) void;
pub extern fn X509_PUBKEY_set0_param(@"pub": ?*X509_PUBKEY, aobj: ?*ASN1_OBJECT, ptype: c_int, pval: ?*anyopaque, penc: [*c]u8, penclen: c_int) c_int;
pub extern fn X509_PUBKEY_get0_param(ppkalg: [*c]?*ASN1_OBJECT, pk: [*c][*c]const u8, ppklen: [*c]c_int, pa: [*c][*c]X509_ALGOR, @"pub": ?*const X509_PUBKEY) c_int;
pub extern fn X509_PUBKEY_eq(a: ?*const X509_PUBKEY, b: ?*const X509_PUBKEY) c_int;
pub extern fn PEM_get_EVP_CIPHER_INFO(header: [*c]u8, cipher: [*c]EVP_CIPHER_INFO) c_int;
pub extern fn PEM_do_header(cipher: [*c]EVP_CIPHER_INFO, data: [*c]u8, len: [*c]c_long, callback: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio(bp: ?*BIO, name: [*c][*c]u8, header: [*c][*c]u8, data: [*c][*c]u8, len: [*c]c_long) c_int;
pub extern fn PEM_read_bio_ex(bp: ?*BIO, name: [*c][*c]u8, header: [*c][*c]u8, data: [*c][*c]u8, len: [*c]c_long, flags: c_uint) c_int;
pub extern fn PEM_bytes_read_bio_secmem(pdata: [*c][*c]u8, plen: [*c]c_long, pnm: [*c][*c]u8, name: [*c]const u8, bp: ?*BIO, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_bio(bp: ?*BIO, name: [*c]const u8, hdr: [*c]const u8, data: [*c]const u8, len: c_long) c_int;
pub extern fn PEM_bytes_read_bio(pdata: [*c][*c]u8, plen: [*c]c_long, pnm: [*c][*c]u8, name: [*c]const u8, bp: ?*BIO, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_ASN1_read_bio(d2i: ?*const d2i_of_void, name: [*c]const u8, bp: ?*BIO, x: [*c]?*anyopaque, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*anyopaque;
pub extern fn PEM_ASN1_write_bio(i2d: ?*const i2d_of_void, name: [*c]const u8, bp: ?*BIO, x: ?*const anyopaque, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_X509_INFO_read_bio(bp: ?*BIO, sk: ?*struct_stack_st_X509_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*struct_stack_st_X509_INFO;
pub extern fn PEM_X509_INFO_read_bio_ex(bp: ?*BIO, sk: ?*struct_stack_st_X509_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*struct_stack_st_X509_INFO;
pub extern fn PEM_X509_INFO_write_bio(bp: ?*BIO, xi: [*c]const X509_INFO, enc: ?*EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cd: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read(fp: [*c]FILE, name: [*c][*c]u8, header: [*c][*c]u8, data: [*c][*c]u8, len: [*c]c_long) c_int;
pub extern fn PEM_write(fp: [*c]FILE, name: [*c]const u8, hdr: [*c]const u8, data: [*c]const u8, len: c_long) c_int;
pub extern fn PEM_ASN1_read(d2i: ?*const d2i_of_void, name: [*c]const u8, fp: [*c]FILE, x: [*c]?*anyopaque, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*anyopaque;
pub extern fn PEM_ASN1_write(i2d: ?*const i2d_of_void, name: [*c]const u8, fp: [*c]FILE, x: ?*const anyopaque, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, callback: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_X509_INFO_read(fp: [*c]FILE, sk: ?*struct_stack_st_X509_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*struct_stack_st_X509_INFO;
pub extern fn PEM_X509_INFO_read_ex(fp: [*c]FILE, sk: ?*struct_stack_st_X509_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*struct_stack_st_X509_INFO;
pub extern fn PEM_SignInit(ctx: ?*EVP_MD_CTX, @"type": ?*EVP_MD) c_int;
pub extern fn PEM_SignUpdate(ctx: ?*EVP_MD_CTX, d: [*c]const u8, cnt: c_uint) c_int;
pub extern fn PEM_SignFinal(ctx: ?*EVP_MD_CTX, sigret: [*c]u8, siglen: [*c]c_uint, pkey: ?*EVP_PKEY) c_int;
pub extern fn PEM_def_callback(buf: [*c]u8, num: c_int, rwflag: c_int, userdata: ?*anyopaque) c_int;
pub extern fn PEM_proc_type(buf: [*c]u8, @"type": c_int) void;
pub extern fn PEM_dek_info(buf: [*c]u8, @"type": [*c]const u8, len: c_int, str: [*c]const u8) void;
pub extern fn PEM_read_bio_X509(out: ?*BIO, x: [*c]?*X509, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509;
pub extern fn PEM_read_X509(out: [*c]FILE, x: [*c]?*X509, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509;
pub extern fn PEM_write_bio_X509(out: ?*BIO, x: ?*const X509) c_int;
pub extern fn PEM_write_X509(out: [*c]FILE, x: ?*const X509) c_int;
pub extern fn PEM_read_bio_X509_AUX(out: ?*BIO, x: [*c]?*X509, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509;
pub extern fn PEM_read_X509_AUX(out: [*c]FILE, x: [*c]?*X509, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509;
pub extern fn PEM_write_bio_X509_AUX(out: ?*BIO, x: ?*const X509) c_int;
pub extern fn PEM_write_X509_AUX(out: [*c]FILE, x: ?*const X509) c_int;
pub extern fn PEM_read_bio_X509_REQ(out: ?*BIO, x: [*c]?*X509_REQ, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_REQ;
pub extern fn PEM_read_X509_REQ(out: [*c]FILE, x: [*c]?*X509_REQ, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_REQ;
pub extern fn PEM_write_bio_X509_REQ(out: ?*BIO, x: ?*const X509_REQ) c_int;
pub extern fn PEM_write_X509_REQ(out: [*c]FILE, x: ?*const X509_REQ) c_int;
pub extern fn PEM_write_bio_X509_REQ_NEW(out: ?*BIO, x: ?*const X509_REQ) c_int;
pub extern fn PEM_write_X509_REQ_NEW(out: [*c]FILE, x: ?*const X509_REQ) c_int;
pub extern fn PEM_read_bio_X509_CRL(out: ?*BIO, x: [*c]?*X509_CRL, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_CRL;
pub extern fn PEM_read_X509_CRL(out: [*c]FILE, x: [*c]?*X509_CRL, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_CRL;
pub extern fn PEM_write_bio_X509_CRL(out: ?*BIO, x: ?*const X509_CRL) c_int;
pub extern fn PEM_write_X509_CRL(out: [*c]FILE, x: ?*const X509_CRL) c_int;
pub extern fn PEM_read_bio_X509_PUBKEY(out: ?*BIO, x: [*c]?*X509_PUBKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_PUBKEY;
pub extern fn PEM_read_X509_PUBKEY(out: [*c]FILE, x: [*c]?*X509_PUBKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_PUBKEY;
pub extern fn PEM_write_bio_X509_PUBKEY(out: ?*BIO, x: ?*const X509_PUBKEY) c_int;
pub extern fn PEM_write_X509_PUBKEY(out: [*c]FILE, x: ?*const X509_PUBKEY) c_int;
pub extern fn PEM_read_bio_PKCS7(out: ?*BIO, x: [*c][*c]PKCS7, cb: ?*const pem_password_cb, u: ?*anyopaque) [*c]PKCS7;
pub extern fn PEM_read_PKCS7(out: [*c]FILE, x: [*c][*c]PKCS7, cb: ?*const pem_password_cb, u: ?*anyopaque) [*c]PKCS7;
pub extern fn PEM_write_bio_PKCS7(out: ?*BIO, x: [*c]const PKCS7) c_int;
pub extern fn PEM_write_PKCS7(out: [*c]FILE, x: [*c]const PKCS7) c_int;
pub extern fn PEM_read_bio_NETSCAPE_CERT_SEQUENCE(out: ?*BIO, x: [*c][*c]NETSCAPE_CERT_SEQUENCE, cb: ?*const pem_password_cb, u: ?*anyopaque) [*c]NETSCAPE_CERT_SEQUENCE;
pub extern fn PEM_read_NETSCAPE_CERT_SEQUENCE(out: [*c]FILE, x: [*c][*c]NETSCAPE_CERT_SEQUENCE, cb: ?*const pem_password_cb, u: ?*anyopaque) [*c]NETSCAPE_CERT_SEQUENCE;
pub extern fn PEM_write_bio_NETSCAPE_CERT_SEQUENCE(out: ?*BIO, x: [*c]const NETSCAPE_CERT_SEQUENCE) c_int;
pub extern fn PEM_write_NETSCAPE_CERT_SEQUENCE(out: [*c]FILE, x: [*c]const NETSCAPE_CERT_SEQUENCE) c_int;
pub extern fn PEM_read_bio_PKCS8(out: ?*BIO, x: [*c]?*X509_SIG, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_SIG;
pub extern fn PEM_read_PKCS8(out: [*c]FILE, x: [*c]?*X509_SIG, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_SIG;
pub extern fn PEM_write_bio_PKCS8(out: ?*BIO, x: ?*const X509_SIG) c_int;
pub extern fn PEM_write_PKCS8(out: [*c]FILE, x: ?*const X509_SIG) c_int;
pub extern fn PEM_read_bio_PKCS8_PRIV_KEY_INFO(out: ?*BIO, x: [*c]?*PKCS8_PRIV_KEY_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn PEM_read_PKCS8_PRIV_KEY_INFO(out: [*c]FILE, x: [*c]?*PKCS8_PRIV_KEY_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn PEM_write_bio_PKCS8_PRIV_KEY_INFO(out: ?*BIO, x: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn PEM_write_PKCS8_PRIV_KEY_INFO(out: [*c]FILE, x: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn PEM_read_bio_RSAPrivateKey(out: ?*BIO, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_read_RSAPrivateKey(out: [*c]FILE, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_write_bio_RSAPrivateKey(out: ?*BIO, x: ?*const RSA, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_RSAPrivateKey(out: [*c]FILE, x: ?*const RSA, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio_RSAPublicKey(out: ?*BIO, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_read_RSAPublicKey(out: [*c]FILE, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_write_bio_RSAPublicKey(out: ?*BIO, x: ?*const RSA) c_int;
pub extern fn PEM_write_RSAPublicKey(out: [*c]FILE, x: ?*const RSA) c_int;
pub extern fn PEM_read_bio_RSA_PUBKEY(out: ?*BIO, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_read_RSA_PUBKEY(out: [*c]FILE, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_write_bio_RSA_PUBKEY(out: ?*BIO, x: ?*const RSA) c_int;
pub extern fn PEM_write_RSA_PUBKEY(out: [*c]FILE, x: ?*const RSA) c_int;
pub extern fn PEM_read_bio_DSAPrivateKey(out: ?*BIO, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_read_DSAPrivateKey(out: [*c]FILE, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_write_bio_DSAPrivateKey(out: ?*BIO, x: ?*const DSA, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_DSAPrivateKey(out: [*c]FILE, x: ?*const DSA, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio_DSA_PUBKEY(out: ?*BIO, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_read_DSA_PUBKEY(out: [*c]FILE, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_write_bio_DSA_PUBKEY(out: ?*BIO, x: ?*const DSA) c_int;
pub extern fn PEM_write_DSA_PUBKEY(out: [*c]FILE, x: ?*const DSA) c_int;
pub extern fn PEM_read_bio_DSAparams(out: ?*BIO, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_read_DSAparams(out: [*c]FILE, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_write_bio_DSAparams(out: ?*BIO, x: ?*const DSA) c_int;
pub extern fn PEM_write_DSAparams(out: [*c]FILE, x: ?*const DSA) c_int;
pub extern fn PEM_read_bio_ECPKParameters(out: ?*BIO, x: [*c]?*EC_GROUP, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_GROUP;
pub extern fn PEM_read_ECPKParameters(out: [*c]FILE, x: [*c]?*EC_GROUP, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_GROUP;
pub extern fn PEM_write_bio_ECPKParameters(out: ?*BIO, x: ?*const EC_GROUP) c_int;
pub extern fn PEM_write_ECPKParameters(out: [*c]FILE, x: ?*const EC_GROUP) c_int;
pub extern fn PEM_read_bio_ECPrivateKey(out: ?*BIO, x: [*c]?*EC_KEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_KEY;
pub extern fn PEM_read_ECPrivateKey(out: [*c]FILE, x: [*c]?*EC_KEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_KEY;
pub extern fn PEM_write_bio_ECPrivateKey(out: ?*BIO, x: ?*const EC_KEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_ECPrivateKey(out: [*c]FILE, x: ?*const EC_KEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio_EC_PUBKEY(out: ?*BIO, x: [*c]?*EC_KEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_KEY;
pub extern fn PEM_read_EC_PUBKEY(out: [*c]FILE, x: [*c]?*EC_KEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_KEY;
pub extern fn PEM_write_bio_EC_PUBKEY(out: ?*BIO, x: ?*const EC_KEY) c_int;
pub extern fn PEM_write_EC_PUBKEY(out: [*c]FILE, x: ?*const EC_KEY) c_int;
pub extern fn PEM_read_bio_DHparams(out: ?*BIO, x: [*c]?*DH, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DH;
pub extern fn PEM_read_DHparams(out: [*c]FILE, x: [*c]?*DH, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DH;
pub extern fn PEM_write_bio_DHparams(out: ?*BIO, x: ?*const DH) c_int;
pub extern fn PEM_write_DHparams(out: [*c]FILE, x: ?*const DH) c_int;
pub extern fn PEM_write_bio_DHxparams(out: ?*BIO, x: ?*const DH) c_int;
pub extern fn PEM_write_DHxparams(out: [*c]FILE, x: ?*const DH) c_int;
pub extern fn PEM_read_bio_PrivateKey(out: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_read_bio_PrivateKey_ex(out: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_read_PrivateKey(out: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_read_PrivateKey_ex(out: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_write_bio_PrivateKey(out: ?*BIO, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_bio_PrivateKey_ex(out: ?*BIO, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PEM_write_PrivateKey(out: [*c]FILE, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_PrivateKey_ex(out: [*c]FILE, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PEM_read_bio_PUBKEY(out: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_read_bio_PUBKEY_ex(out: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_read_PUBKEY(out: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_read_PUBKEY_ex(out: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_write_bio_PUBKEY(out: ?*BIO, x: ?*const EVP_PKEY) c_int;
pub extern fn PEM_write_bio_PUBKEY_ex(out: ?*BIO, x: ?*const EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PEM_write_PUBKEY(out: [*c]FILE, x: ?*const EVP_PKEY) c_int;
pub extern fn PEM_write_PUBKEY_ex(out: [*c]FILE, x: ?*const EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PEM_write_bio_PrivateKey_traditional(bp: ?*BIO, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_bio_PKCS8PrivateKey_nid(bp: ?*BIO, x: ?*const EVP_PKEY, nid: c_int, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_bio_PKCS8PrivateKey(?*BIO, ?*const EVP_PKEY, ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn i2d_PKCS8PrivateKey_bio(bp: ?*BIO, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn i2d_PKCS8PrivateKey_nid_bio(bp: ?*BIO, x: ?*const EVP_PKEY, nid: c_int, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn d2i_PKCS8PrivateKey_bio(bp: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn i2d_PKCS8PrivateKey_fp(fp: [*c]FILE, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn i2d_PKCS8PrivateKey_nid_fp(fp: [*c]FILE, x: ?*const EVP_PKEY, nid: c_int, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_PKCS8PrivateKey_nid(fp: [*c]FILE, x: ?*const EVP_PKEY, nid: c_int, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn d2i_PKCS8PrivateKey_fp(fp: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_write_PKCS8PrivateKey(fp: [*c]FILE, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cd: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio_Parameters_ex(bp: ?*BIO, x: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_read_bio_Parameters(bp: ?*BIO, x: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn PEM_write_bio_Parameters(bp: ?*BIO, x: ?*const EVP_PKEY) c_int;
pub extern fn b2i_PrivateKey(in: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn b2i_PublicKey(in: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn b2i_PrivateKey_bio(in: ?*BIO) ?*EVP_PKEY;
pub extern fn b2i_PublicKey_bio(in: ?*BIO) ?*EVP_PKEY;
pub extern fn i2b_PrivateKey_bio(out: ?*BIO, pk: ?*const EVP_PKEY) c_int;
pub extern fn i2b_PublicKey_bio(out: ?*BIO, pk: ?*const EVP_PKEY) c_int;
pub extern fn b2i_PVK_bio(in: ?*BIO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn b2i_PVK_bio_ex(in: ?*BIO, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn i2b_PVK_bio(out: ?*BIO, pk: ?*const EVP_PKEY, enclevel: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn i2b_PVK_bio_ex(out: ?*BIO, pk: ?*const EVP_PKEY, enclevel: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn HMAC_size(e: ?*const HMAC_CTX) usize;
pub extern fn HMAC_CTX_new() ?*HMAC_CTX;
pub extern fn HMAC_CTX_reset(ctx: ?*HMAC_CTX) c_int;
pub extern fn HMAC_CTX_free(ctx: ?*HMAC_CTX) void;
pub extern fn HMAC_Init(ctx: ?*HMAC_CTX, key: ?*const anyopaque, len: c_int, md: ?*const EVP_MD) c_int;
pub extern fn HMAC_Init_ex(ctx: ?*HMAC_CTX, key: ?*const anyopaque, len: c_int, md: ?*const EVP_MD, impl: ?*ENGINE) c_int;
pub extern fn HMAC_Update(ctx: ?*HMAC_CTX, data: [*c]const u8, len: usize) c_int;
pub extern fn HMAC_Final(ctx: ?*HMAC_CTX, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn HMAC_CTX_copy(dctx: ?*HMAC_CTX, sctx: ?*HMAC_CTX) c_int;
pub extern fn HMAC_CTX_set_flags(ctx: ?*HMAC_CTX, flags: c_ulong) void;
pub extern fn HMAC_CTX_get_md(ctx: ?*const HMAC_CTX) ?*const EVP_MD;
pub extern fn HMAC(evp_md: ?*const EVP_MD, key: ?*const anyopaque, key_len: c_int, data: [*c]const u8, data_len: usize, md: [*c]u8, md_len: [*c]c_uint) [*c]u8;
pub const struct_async_job_st = opaque {};
pub const ASYNC_JOB = struct_async_job_st;
pub const struct_async_wait_ctx_st = opaque {};
pub const ASYNC_WAIT_CTX = struct_async_wait_ctx_st;
pub const ASYNC_callback_fn = ?*const fn (?*anyopaque) callconv(.C) c_int;
pub extern fn ASYNC_init_thread(max_size: usize, init_size: usize) c_int;
pub extern fn ASYNC_cleanup_thread() void;
pub extern fn ASYNC_WAIT_CTX_new() ?*ASYNC_WAIT_CTX;
pub extern fn ASYNC_WAIT_CTX_free(ctx: ?*ASYNC_WAIT_CTX) void;
pub extern fn ASYNC_WAIT_CTX_set_wait_fd(ctx: ?*ASYNC_WAIT_CTX, key: ?*const anyopaque, fd: c_int, custom_data: ?*anyopaque, cleanup: ?*const fn (?*ASYNC_WAIT_CTX, ?*const anyopaque, c_int, ?*anyopaque) callconv(.C) void) c_int;
pub extern fn ASYNC_WAIT_CTX_get_fd(ctx: ?*ASYNC_WAIT_CTX, key: ?*const anyopaque, fd: [*c]c_int, custom_data: [*c]?*anyopaque) c_int;
pub extern fn ASYNC_WAIT_CTX_get_all_fds(ctx: ?*ASYNC_WAIT_CTX, fd: [*c]c_int, numfds: [*c]usize) c_int;
pub extern fn ASYNC_WAIT_CTX_get_callback(ctx: ?*ASYNC_WAIT_CTX, callback: [*c]ASYNC_callback_fn, callback_arg: [*c]?*anyopaque) c_int;
pub extern fn ASYNC_WAIT_CTX_set_callback(ctx: ?*ASYNC_WAIT_CTX, callback: ASYNC_callback_fn, callback_arg: ?*anyopaque) c_int;
pub extern fn ASYNC_WAIT_CTX_set_status(ctx: ?*ASYNC_WAIT_CTX, status: c_int) c_int;
pub extern fn ASYNC_WAIT_CTX_get_status(ctx: ?*ASYNC_WAIT_CTX) c_int;
pub extern fn ASYNC_WAIT_CTX_get_changed_fds(ctx: ?*ASYNC_WAIT_CTX, addfd: [*c]c_int, numaddfds: [*c]usize, delfd: [*c]c_int, numdelfds: [*c]usize) c_int;
pub extern fn ASYNC_WAIT_CTX_clear_fd(ctx: ?*ASYNC_WAIT_CTX, key: ?*const anyopaque) c_int;
pub extern fn ASYNC_is_capable() c_int;
pub const ASYNC_stack_alloc_fn = ?*const fn ([*c]usize) callconv(.C) ?*anyopaque;
pub const ASYNC_stack_free_fn = ?*const fn (?*anyopaque) callconv(.C) void;
pub extern fn ASYNC_set_mem_functions(alloc_fn: ASYNC_stack_alloc_fn, free_fn: ASYNC_stack_free_fn) c_int;
pub extern fn ASYNC_get_mem_functions(alloc_fn: [*c]ASYNC_stack_alloc_fn, free_fn: [*c]ASYNC_stack_free_fn) void;
pub extern fn ASYNC_start_job(job: [*c]?*ASYNC_JOB, ctx: ?*ASYNC_WAIT_CTX, ret: [*c]c_int, func: ?*const fn (?*anyopaque) callconv(.C) c_int, args: ?*anyopaque, size: usize) c_int;
pub extern fn ASYNC_pause_job() c_int;
pub extern fn ASYNC_get_current_job() ?*ASYNC_JOB;
pub extern fn ASYNC_get_wait_ctx(job: ?*ASYNC_JOB) ?*ASYNC_WAIT_CTX;
pub extern fn ASYNC_block_pause() void;
pub extern fn ASYNC_unblock_pause() void;
pub const struct_stack_st_SCT = opaque {};
pub const sk_SCT_compfunc = ?*const fn ([*c]const ?*const SCT, [*c]const ?*const SCT) callconv(.C) c_int;
pub const sk_SCT_freefunc = ?*const fn (?*SCT) callconv(.C) void;
pub const sk_SCT_copyfunc = ?*const fn (?*const SCT) callconv(.C) ?*SCT;
pub fn ossl_check_SCT_type(arg_ptr: ?*SCT) callconv(.C) ?*SCT {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_SCT_sk_type(arg_sk: ?*const struct_stack_st_SCT) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SCT_sk_type(arg_sk: ?*struct_stack_st_SCT) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SCT_compfunc_type(arg_cmp: sk_SCT_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_SCT_copyfunc_type(arg_cpy: sk_SCT_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_SCT_freefunc_type(arg_fr: sk_SCT_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_CTLOG = opaque {};
pub const sk_CTLOG_compfunc = ?*const fn ([*c]const ?*const CTLOG, [*c]const ?*const CTLOG) callconv(.C) c_int;
pub const sk_CTLOG_freefunc = ?*const fn (?*CTLOG) callconv(.C) void;
pub const sk_CTLOG_copyfunc = ?*const fn (?*const CTLOG) callconv(.C) ?*CTLOG;
pub fn ossl_check_CTLOG_type(arg_ptr: ?*CTLOG) callconv(.C) ?*CTLOG {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_CTLOG_sk_type(arg_sk: ?*const struct_stack_st_CTLOG) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_CTLOG_sk_type(arg_sk: ?*struct_stack_st_CTLOG) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_CTLOG_compfunc_type(arg_cmp: sk_CTLOG_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_CTLOG_copyfunc_type(arg_cpy: sk_CTLOG_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_CTLOG_freefunc_type(arg_fr: sk_CTLOG_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const CT_LOG_ENTRY_TYPE_NOT_SET: c_int = -1;
pub const CT_LOG_ENTRY_TYPE_X509: c_int = 0;
pub const CT_LOG_ENTRY_TYPE_PRECERT: c_int = 1;
pub const ct_log_entry_type_t = c_int;
pub const SCT_VERSION_NOT_SET: c_int = -1;
pub const SCT_VERSION_V1: c_int = 0;
pub const sct_version_t = c_int;
pub const SCT_SOURCE_UNKNOWN: c_int = 0;
pub const SCT_SOURCE_TLS_EXTENSION: c_int = 1;
pub const SCT_SOURCE_X509V3_EXTENSION: c_int = 2;
pub const SCT_SOURCE_OCSP_STAPLED_RESPONSE: c_int = 3;
pub const sct_source_t = c_uint;
pub const SCT_VALIDATION_STATUS_NOT_SET: c_int = 0;
pub const SCT_VALIDATION_STATUS_UNKNOWN_LOG: c_int = 1;
pub const SCT_VALIDATION_STATUS_VALID: c_int = 2;
pub const SCT_VALIDATION_STATUS_INVALID: c_int = 3;
pub const SCT_VALIDATION_STATUS_UNVERIFIED: c_int = 4;
pub const SCT_VALIDATION_STATUS_UNKNOWN_VERSION: c_int = 5;
pub const sct_validation_status_t = c_uint;
pub extern fn CT_POLICY_EVAL_CTX_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*CT_POLICY_EVAL_CTX;
pub extern fn CT_POLICY_EVAL_CTX_new() ?*CT_POLICY_EVAL_CTX;
pub extern fn CT_POLICY_EVAL_CTX_free(ctx: ?*CT_POLICY_EVAL_CTX) void;
pub extern fn CT_POLICY_EVAL_CTX_get0_cert(ctx: ?*const CT_POLICY_EVAL_CTX) ?*X509;
pub extern fn CT_POLICY_EVAL_CTX_set1_cert(ctx: ?*CT_POLICY_EVAL_CTX, cert: ?*X509) c_int;
pub extern fn CT_POLICY_EVAL_CTX_get0_issuer(ctx: ?*const CT_POLICY_EVAL_CTX) ?*X509;
pub extern fn CT_POLICY_EVAL_CTX_set1_issuer(ctx: ?*CT_POLICY_EVAL_CTX, issuer: ?*X509) c_int;
pub extern fn CT_POLICY_EVAL_CTX_get0_log_store(ctx: ?*const CT_POLICY_EVAL_CTX) ?*const CTLOG_STORE;
pub extern fn CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(ctx: ?*CT_POLICY_EVAL_CTX, log_store: ?*CTLOG_STORE) void;
pub extern fn CT_POLICY_EVAL_CTX_get_time(ctx: ?*const CT_POLICY_EVAL_CTX) u64;
pub extern fn CT_POLICY_EVAL_CTX_set_time(ctx: ?*CT_POLICY_EVAL_CTX, time_in_ms: u64) void;
pub extern fn SCT_new() ?*SCT;
pub extern fn SCT_new_from_base64(version: u8, logid_base64: [*c]const u8, entry_type: ct_log_entry_type_t, timestamp: u64, extensions_base64: [*c]const u8, signature_base64: [*c]const u8) ?*SCT;
pub extern fn SCT_free(sct: ?*SCT) void;
pub extern fn SCT_LIST_free(a: ?*struct_stack_st_SCT) void;
pub extern fn SCT_get_version(sct: ?*const SCT) sct_version_t;
pub extern fn SCT_set_version(sct: ?*SCT, version: sct_version_t) c_int;
pub extern fn SCT_get_log_entry_type(sct: ?*const SCT) ct_log_entry_type_t;
pub extern fn SCT_set_log_entry_type(sct: ?*SCT, entry_type: ct_log_entry_type_t) c_int;
pub extern fn SCT_get0_log_id(sct: ?*const SCT, log_id: [*c][*c]u8) usize;
pub extern fn SCT_set0_log_id(sct: ?*SCT, log_id: [*c]u8, log_id_len: usize) c_int;
pub extern fn SCT_set1_log_id(sct: ?*SCT, log_id: [*c]const u8, log_id_len: usize) c_int;
pub extern fn SCT_get_timestamp(sct: ?*const SCT) u64;
pub extern fn SCT_set_timestamp(sct: ?*SCT, timestamp: u64) void;
pub extern fn SCT_get_signature_nid(sct: ?*const SCT) c_int;
pub extern fn SCT_set_signature_nid(sct: ?*SCT, nid: c_int) c_int;
pub extern fn SCT_get0_extensions(sct: ?*const SCT, ext: [*c][*c]u8) usize;
pub extern fn SCT_set0_extensions(sct: ?*SCT, ext: [*c]u8, ext_len: usize) void;
pub extern fn SCT_set1_extensions(sct: ?*SCT, ext: [*c]const u8, ext_len: usize) c_int;
pub extern fn SCT_get0_signature(sct: ?*const SCT, sig: [*c][*c]u8) usize;
pub extern fn SCT_set0_signature(sct: ?*SCT, sig: [*c]u8, sig_len: usize) void;
pub extern fn SCT_set1_signature(sct: ?*SCT, sig: [*c]const u8, sig_len: usize) c_int;
pub extern fn SCT_get_source(sct: ?*const SCT) sct_source_t;
pub extern fn SCT_set_source(sct: ?*SCT, source: sct_source_t) c_int;
pub extern fn SCT_validation_status_string(sct: ?*const SCT) [*c]const u8;
pub extern fn SCT_print(sct: ?*const SCT, out: ?*BIO, indent: c_int, logs: ?*const CTLOG_STORE) void;
pub extern fn SCT_LIST_print(sct_list: ?*const struct_stack_st_SCT, out: ?*BIO, indent: c_int, separator: [*c]const u8, logs: ?*const CTLOG_STORE) void;
pub extern fn SCT_get_validation_status(sct: ?*const SCT) sct_validation_status_t;
pub extern fn SCT_validate(sct: ?*SCT, ctx: ?*const CT_POLICY_EVAL_CTX) c_int;
pub extern fn SCT_LIST_validate(scts: ?*const struct_stack_st_SCT, ctx: ?*CT_POLICY_EVAL_CTX) c_int;
pub extern fn i2o_SCT_LIST(a: ?*const struct_stack_st_SCT, pp: [*c][*c]u8) c_int;
pub extern fn o2i_SCT_LIST(a: [*c]?*struct_stack_st_SCT, pp: [*c][*c]const u8, len: usize) ?*struct_stack_st_SCT;
pub extern fn i2d_SCT_LIST(a: ?*const struct_stack_st_SCT, pp: [*c][*c]u8) c_int;
pub extern fn d2i_SCT_LIST(a: [*c]?*struct_stack_st_SCT, pp: [*c][*c]const u8, len: c_long) ?*struct_stack_st_SCT;
pub extern fn i2o_SCT(sct: ?*const SCT, out: [*c][*c]u8) c_int;
pub extern fn o2i_SCT(psct: [*c]?*SCT, in: [*c][*c]const u8, len: usize) ?*SCT;
pub extern fn CTLOG_new_ex(public_key: ?*EVP_PKEY, name: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*CTLOG;
pub extern fn CTLOG_new(public_key: ?*EVP_PKEY, name: [*c]const u8) ?*CTLOG;
pub extern fn CTLOG_new_from_base64_ex(ct_log: [*c]?*CTLOG, pkey_base64: [*c]const u8, name: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn CTLOG_new_from_base64(ct_log: [*c]?*CTLOG, pkey_base64: [*c]const u8, name: [*c]const u8) c_int;
pub extern fn CTLOG_free(log: ?*CTLOG) void;
pub extern fn CTLOG_get0_name(log: ?*const CTLOG) [*c]const u8;
pub extern fn CTLOG_get0_log_id(log: ?*const CTLOG, log_id: [*c][*c]const u8, log_id_len: [*c]usize) void;
pub extern fn CTLOG_get0_public_key(log: ?*const CTLOG) ?*EVP_PKEY;
pub extern fn CTLOG_STORE_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*CTLOG_STORE;
pub extern fn CTLOG_STORE_new() ?*CTLOG_STORE;
pub extern fn CTLOG_STORE_free(store: ?*CTLOG_STORE) void;
pub extern fn CTLOG_STORE_get0_log_by_id(store: ?*const CTLOG_STORE, log_id: [*c]const u8, log_id_len: usize) ?*const CTLOG;
pub extern fn CTLOG_STORE_load_file(store: ?*CTLOG_STORE, file: [*c]const u8) c_int;
pub extern fn CTLOG_STORE_load_default_file(store: ?*CTLOG_STORE) c_int;
pub extern fn ERR_load_SSL_strings() c_int;
pub const ssl_crock_st = ?*struct_ssl_st;
pub const struct_tls_session_ticket_ext_st = extern struct {
    length: c_ushort = @import("std").mem.zeroes(c_ushort),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const TLS_SESSION_TICKET_EXT = struct_tls_session_ticket_ext_st;
pub const struct_ssl_method_st = opaque {};
pub const SSL_METHOD = struct_ssl_method_st;
pub const struct_ssl_cipher_st = opaque {};
pub const SSL_CIPHER = struct_ssl_cipher_st;
pub const struct_ssl_session_st = opaque {};
pub const SSL_SESSION = struct_ssl_session_st;
pub const struct_tls_sigalgs_st = opaque {};
pub const TLS_SIGALGS = struct_tls_sigalgs_st;
pub const struct_ssl_conf_ctx_st = opaque {};
pub const SSL_CONF_CTX = struct_ssl_conf_ctx_st;
pub const struct_stack_st_SSL_CIPHER = opaque {};
pub const struct_srtp_protection_profile_st = extern struct {
    name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    id: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub const SRTP_PROTECTION_PROFILE = struct_srtp_protection_profile_st;
pub const struct_stack_st_SRTP_PROTECTION_PROFILE = opaque {};
pub const sk_SRTP_PROTECTION_PROFILE_compfunc = ?*const fn ([*c]const [*c]const SRTP_PROTECTION_PROFILE, [*c]const [*c]const SRTP_PROTECTION_PROFILE) callconv(.C) c_int;
pub const sk_SRTP_PROTECTION_PROFILE_freefunc = ?*const fn ([*c]SRTP_PROTECTION_PROFILE) callconv(.C) void;
pub const sk_SRTP_PROTECTION_PROFILE_copyfunc = ?*const fn ([*c]const SRTP_PROTECTION_PROFILE) callconv(.C) [*c]SRTP_PROTECTION_PROFILE;
pub fn ossl_check_SRTP_PROTECTION_PROFILE_type(arg_ptr: [*c]SRTP_PROTECTION_PROFILE) callconv(.C) [*c]SRTP_PROTECTION_PROFILE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(arg_sk: ?*const struct_stack_st_SRTP_PROTECTION_PROFILE) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SRTP_PROTECTION_PROFILE_sk_type(arg_sk: ?*struct_stack_st_SRTP_PROTECTION_PROFILE) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SRTP_PROTECTION_PROFILE_compfunc_type(arg_cmp: sk_SRTP_PROTECTION_PROFILE_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_SRTP_PROTECTION_PROFILE_copyfunc_type(arg_cpy: sk_SRTP_PROTECTION_PROFILE_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_SRTP_PROTECTION_PROFILE_freefunc_type(arg_fr: sk_SRTP_PROTECTION_PROFILE_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const tls_session_ticket_ext_cb_fn = ?*const fn (?*SSL, [*c]const u8, c_int, ?*anyopaque) callconv(.C) c_int;
pub const tls_session_secret_cb_fn = ?*const fn (?*SSL, ?*anyopaque, [*c]c_int, ?*struct_stack_st_SSL_CIPHER, [*c]?*const SSL_CIPHER, ?*anyopaque) callconv(.C) c_int;
pub const custom_ext_add_cb = ?*const fn (?*SSL, c_uint, [*c][*c]const u8, [*c]usize, [*c]c_int, ?*anyopaque) callconv(.C) c_int;
pub const custom_ext_free_cb = ?*const fn (?*SSL, c_uint, [*c]const u8, ?*anyopaque) callconv(.C) void;
pub const custom_ext_parse_cb = ?*const fn (?*SSL, c_uint, [*c]const u8, usize, [*c]c_int, ?*anyopaque) callconv(.C) c_int;
pub const SSL_custom_ext_add_cb_ex = ?*const fn (?*SSL, c_uint, c_uint, [*c][*c]const u8, [*c]usize, ?*X509, usize, [*c]c_int, ?*anyopaque) callconv(.C) c_int;
pub const SSL_custom_ext_free_cb_ex = ?*const fn (?*SSL, c_uint, c_uint, [*c]const u8, ?*anyopaque) callconv(.C) void;
pub const SSL_custom_ext_parse_cb_ex = ?*const fn (?*SSL, c_uint, c_uint, [*c]const u8, usize, ?*X509, usize, [*c]c_int, ?*anyopaque) callconv(.C) c_int;
pub const SSL_verify_cb = ?*const fn (c_int, ?*X509_STORE_CTX) callconv(.C) c_int;
pub const SSL_async_callback_fn = ?*const fn (?*SSL, ?*anyopaque) callconv(.C) c_int;
pub extern fn SSL_CTX_get_options(ctx: ?*const SSL_CTX) u64;
pub extern fn SSL_get_options(s: ?*const SSL) u64;
pub extern fn SSL_CTX_clear_options(ctx: ?*SSL_CTX, op: u64) u64;
pub extern fn SSL_clear_options(s: ?*SSL, op: u64) u64;
pub extern fn SSL_CTX_set_options(ctx: ?*SSL_CTX, op: u64) u64;
pub extern fn SSL_set_options(s: ?*SSL, op: u64) u64;
pub extern fn SSL_CTX_set_msg_callback(ctx: ?*SSL_CTX, cb: ?*const fn (c_int, c_int, c_int, ?*const anyopaque, usize, ?*SSL, ?*anyopaque) callconv(.C) void) void;
pub extern fn SSL_set_msg_callback(ssl: ?*SSL, cb: ?*const fn (c_int, c_int, c_int, ?*const anyopaque, usize, ?*SSL, ?*anyopaque) callconv(.C) void) void;
pub extern fn SSL_SRP_CTX_init(s: ?*SSL) c_int;
pub extern fn SSL_CTX_SRP_CTX_init(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_SRP_CTX_free(ctx: ?*SSL) c_int;
pub extern fn SSL_CTX_SRP_CTX_free(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_srp_server_param_with_username(s: ?*SSL, ad: [*c]c_int) c_int;
pub extern fn SRP_Calc_A_param(s: ?*SSL) c_int;
pub const GEN_SESSION_CB = ?*const fn (?*SSL, [*c]u8, [*c]c_uint) callconv(.C) c_int;
pub const struct_lhash_st_SSL_SESSION = opaque {};
pub extern fn SSL_CTX_sessions(ctx: ?*SSL_CTX) ?*struct_lhash_st_SSL_SESSION;
pub extern fn SSL_CTX_sess_set_new_cb(ctx: ?*SSL_CTX, new_session_cb: ?*const fn (?*struct_ssl_st, ?*SSL_SESSION) callconv(.C) c_int) void;
pub extern fn SSL_CTX_sess_get_new_cb(ctx: ?*SSL_CTX) ?*const fn (?*struct_ssl_st, ?*SSL_SESSION) callconv(.C) c_int;
pub extern fn SSL_CTX_sess_set_remove_cb(ctx: ?*SSL_CTX, remove_session_cb: ?*const fn (?*struct_ssl_ctx_st, ?*SSL_SESSION) callconv(.C) void) void;
pub extern fn SSL_CTX_sess_get_remove_cb(ctx: ?*SSL_CTX) ?*const fn (?*struct_ssl_ctx_st, ?*SSL_SESSION) callconv(.C) void;
pub extern fn SSL_CTX_sess_set_get_cb(ctx: ?*SSL_CTX, get_session_cb: ?*const fn (?*struct_ssl_st, [*c]const u8, c_int, [*c]c_int) callconv(.C) ?*SSL_SESSION) void;
pub extern fn SSL_CTX_sess_get_get_cb(ctx: ?*SSL_CTX) ?*const fn (?*struct_ssl_st, [*c]const u8, c_int, [*c]c_int) callconv(.C) ?*SSL_SESSION;
pub extern fn SSL_CTX_set_info_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*const SSL, c_int, c_int) callconv(.C) void) void;
pub extern fn SSL_CTX_get_info_callback(ctx: ?*SSL_CTX) ?*const fn (?*const SSL, c_int, c_int) callconv(.C) void;
pub extern fn SSL_CTX_set_client_cert_cb(ctx: ?*SSL_CTX, client_cert_cb: ?*const fn (?*SSL, [*c]?*X509, [*c]?*EVP_PKEY) callconv(.C) c_int) void;
pub extern fn SSL_CTX_get_client_cert_cb(ctx: ?*SSL_CTX) ?*const fn (?*SSL, [*c]?*X509, [*c]?*EVP_PKEY) callconv(.C) c_int;
pub extern fn SSL_CTX_set_client_cert_engine(ctx: ?*SSL_CTX, e: ?*ENGINE) c_int;
pub extern fn SSL_CTX_set_cookie_generate_cb(ctx: ?*SSL_CTX, app_gen_cookie_cb: ?*const fn (?*SSL, [*c]u8, [*c]c_uint) callconv(.C) c_int) void;
pub extern fn SSL_CTX_set_cookie_verify_cb(ctx: ?*SSL_CTX, app_verify_cookie_cb: ?*const fn (?*SSL, [*c]const u8, c_uint) callconv(.C) c_int) void;
pub extern fn SSL_CTX_set_stateless_cookie_generate_cb(ctx: ?*SSL_CTX, gen_stateless_cookie_cb: ?*const fn (?*SSL, [*c]u8, [*c]usize) callconv(.C) c_int) void;
pub extern fn SSL_CTX_set_stateless_cookie_verify_cb(ctx: ?*SSL_CTX, verify_stateless_cookie_cb: ?*const fn (?*SSL, [*c]const u8, usize) callconv(.C) c_int) void;
pub const SSL_CTX_npn_advertised_cb_func = ?*const fn (?*SSL, [*c][*c]const u8, [*c]c_uint, ?*anyopaque) callconv(.C) c_int;
pub extern fn SSL_CTX_set_next_protos_advertised_cb(s: ?*SSL_CTX, cb: SSL_CTX_npn_advertised_cb_func, arg: ?*anyopaque) void;
pub const SSL_CTX_npn_select_cb_func = ?*const fn (?*SSL, [*c][*c]u8, [*c]u8, [*c]const u8, c_uint, ?*anyopaque) callconv(.C) c_int;
pub extern fn SSL_CTX_set_next_proto_select_cb(s: ?*SSL_CTX, cb: SSL_CTX_npn_select_cb_func, arg: ?*anyopaque) void;
pub extern fn SSL_get0_next_proto_negotiated(s: ?*const SSL, data: [*c][*c]const u8, len: [*c]c_uint) void;
pub extern fn SSL_select_next_proto(out: [*c][*c]u8, outlen: [*c]u8, in: [*c]const u8, inlen: c_uint, client: [*c]const u8, client_len: c_uint) c_int;
pub extern fn SSL_CTX_set_alpn_protos(ctx: ?*SSL_CTX, protos: [*c]const u8, protos_len: c_uint) c_int;
pub extern fn SSL_set_alpn_protos(ssl: ?*SSL, protos: [*c]const u8, protos_len: c_uint) c_int;
pub const SSL_CTX_alpn_select_cb_func = ?*const fn (?*SSL, [*c][*c]const u8, [*c]u8, [*c]const u8, c_uint, ?*anyopaque) callconv(.C) c_int;
pub extern fn SSL_CTX_set_alpn_select_cb(ctx: ?*SSL_CTX, cb: SSL_CTX_alpn_select_cb_func, arg: ?*anyopaque) void;
pub extern fn SSL_get0_alpn_selected(ssl: ?*const SSL, data: [*c][*c]const u8, len: [*c]c_uint) void;
pub const SSL_psk_client_cb_func = ?*const fn (?*SSL, [*c]const u8, [*c]u8, c_uint, [*c]u8, c_uint) callconv(.C) c_uint;
pub extern fn SSL_CTX_set_psk_client_callback(ctx: ?*SSL_CTX, cb: SSL_psk_client_cb_func) void;
pub extern fn SSL_set_psk_client_callback(ssl: ?*SSL, cb: SSL_psk_client_cb_func) void;
pub const SSL_psk_server_cb_func = ?*const fn (?*SSL, [*c]const u8, [*c]u8, c_uint) callconv(.C) c_uint;
pub extern fn SSL_CTX_set_psk_server_callback(ctx: ?*SSL_CTX, cb: SSL_psk_server_cb_func) void;
pub extern fn SSL_set_psk_server_callback(ssl: ?*SSL, cb: SSL_psk_server_cb_func) void;
pub extern fn SSL_CTX_use_psk_identity_hint(ctx: ?*SSL_CTX, identity_hint: [*c]const u8) c_int;
pub extern fn SSL_use_psk_identity_hint(s: ?*SSL, identity_hint: [*c]const u8) c_int;
pub extern fn SSL_get_psk_identity_hint(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_get_psk_identity(s: ?*const SSL) [*c]const u8;
pub const SSL_psk_find_session_cb_func = ?*const fn (?*SSL, [*c]const u8, usize, [*c]?*SSL_SESSION) callconv(.C) c_int;
pub const SSL_psk_use_session_cb_func = ?*const fn (?*SSL, ?*const EVP_MD, [*c][*c]const u8, [*c]usize, [*c]?*SSL_SESSION) callconv(.C) c_int;
pub extern fn SSL_set_psk_find_session_callback(s: ?*SSL, cb: SSL_psk_find_session_cb_func) void;
pub extern fn SSL_CTX_set_psk_find_session_callback(ctx: ?*SSL_CTX, cb: SSL_psk_find_session_cb_func) void;
pub extern fn SSL_set_psk_use_session_callback(s: ?*SSL, cb: SSL_psk_use_session_cb_func) void;
pub extern fn SSL_CTX_set_psk_use_session_callback(ctx: ?*SSL_CTX, cb: SSL_psk_use_session_cb_func) void;
pub extern fn SSL_CTX_has_client_custom_ext(ctx: ?*const SSL_CTX, ext_type: c_uint) c_int;
pub extern fn SSL_CTX_add_client_custom_ext(ctx: ?*SSL_CTX, ext_type: c_uint, add_cb: custom_ext_add_cb, free_cb: custom_ext_free_cb, add_arg: ?*anyopaque, parse_cb: custom_ext_parse_cb, parse_arg: ?*anyopaque) c_int;
pub extern fn SSL_CTX_add_server_custom_ext(ctx: ?*SSL_CTX, ext_type: c_uint, add_cb: custom_ext_add_cb, free_cb: custom_ext_free_cb, add_arg: ?*anyopaque, parse_cb: custom_ext_parse_cb, parse_arg: ?*anyopaque) c_int;
pub extern fn SSL_CTX_add_custom_ext(ctx: ?*SSL_CTX, ext_type: c_uint, context: c_uint, add_cb: SSL_custom_ext_add_cb_ex, free_cb: SSL_custom_ext_free_cb_ex, add_arg: ?*anyopaque, parse_cb: SSL_custom_ext_parse_cb_ex, parse_arg: ?*anyopaque) c_int;
pub extern fn SSL_extension_supported(ext_type: c_uint) c_int;
pub const SSL_CTX_keylog_cb_func = ?*const fn (?*const SSL, [*c]const u8) callconv(.C) void;
pub extern fn SSL_CTX_set_keylog_callback(ctx: ?*SSL_CTX, cb: SSL_CTX_keylog_cb_func) void;
pub extern fn SSL_CTX_get_keylog_callback(ctx: ?*const SSL_CTX) SSL_CTX_keylog_cb_func;
pub extern fn SSL_CTX_set_max_early_data(ctx: ?*SSL_CTX, max_early_data: u32) c_int;
pub extern fn SSL_CTX_get_max_early_data(ctx: ?*const SSL_CTX) u32;
pub extern fn SSL_set_max_early_data(s: ?*SSL, max_early_data: u32) c_int;
pub extern fn SSL_get_max_early_data(s: ?*const SSL) u32;
pub extern fn SSL_CTX_set_recv_max_early_data(ctx: ?*SSL_CTX, recv_max_early_data: u32) c_int;
pub extern fn SSL_CTX_get_recv_max_early_data(ctx: ?*const SSL_CTX) u32;
pub extern fn SSL_set_recv_max_early_data(s: ?*SSL, recv_max_early_data: u32) c_int;
pub extern fn SSL_get_recv_max_early_data(s: ?*const SSL) u32;
pub extern fn SSL_CTX_set_tlsext_max_fragment_length(ctx: ?*SSL_CTX, mode: u8) c_int;
pub extern fn SSL_set_tlsext_max_fragment_length(ssl: ?*SSL, mode: u8) c_int;
pub extern fn SSL_get_servername(s: ?*const SSL, @"type": c_int) [*c]const u8;
pub extern fn SSL_get_servername_type(s: ?*const SSL) c_int;
pub extern fn SSL_export_keying_material(s: ?*SSL, out: [*c]u8, olen: usize, label: [*c]const u8, llen: usize, context: [*c]const u8, contextlen: usize, use_context: c_int) c_int;
pub extern fn SSL_export_keying_material_early(s: ?*SSL, out: [*c]u8, olen: usize, label: [*c]const u8, llen: usize, context: [*c]const u8, contextlen: usize) c_int;
pub extern fn SSL_get_peer_signature_type_nid(s: ?*const SSL, pnid: [*c]c_int) c_int;
pub extern fn SSL_get_signature_type_nid(s: ?*const SSL, pnid: [*c]c_int) c_int;
pub extern fn SSL_get_sigalgs(s: ?*SSL, idx: c_int, psign: [*c]c_int, phash: [*c]c_int, psignandhash: [*c]c_int, rsig: [*c]u8, rhash: [*c]u8) c_int;
pub extern fn SSL_get1_builtin_sigalgs(libctx: ?*OSSL_LIB_CTX) [*c]u8;
pub extern fn SSL_get_shared_sigalgs(s: ?*SSL, idx: c_int, psign: [*c]c_int, phash: [*c]c_int, psignandhash: [*c]c_int, rsig: [*c]u8, rhash: [*c]u8) c_int;
pub extern fn SSL_check_chain(s: ?*SSL, x: ?*X509, pk: ?*EVP_PKEY, chain: ?*struct_stack_st_X509) c_int;
pub extern fn SSL_CTX_set_tlsext_ticket_key_evp_cb(ctx: ?*SSL_CTX, fp: ?*const fn (?*SSL, [*c]u8, [*c]u8, ?*EVP_CIPHER_CTX, ?*EVP_MAC_CTX, c_int) callconv(.C) c_int) c_int;
pub extern fn SSL_CTX_set_tlsext_use_srtp(ctx: ?*SSL_CTX, profiles: [*c]const u8) c_int;
pub extern fn SSL_set_tlsext_use_srtp(ssl: ?*SSL, profiles: [*c]const u8) c_int;
pub extern fn SSL_get_srtp_profiles(ssl: ?*SSL) ?*struct_stack_st_SRTP_PROTECTION_PROFILE;
pub extern fn SSL_get_selected_srtp_profile(s: ?*SSL) [*c]SRTP_PROTECTION_PROFILE;
pub extern fn OSSL_QUIC_client_method() ?*const SSL_METHOD;
pub extern fn OSSL_QUIC_client_thread_method() ?*const SSL_METHOD;
pub const sk_SSL_CIPHER_compfunc = ?*const fn ([*c]const ?*const SSL_CIPHER, [*c]const ?*const SSL_CIPHER) callconv(.C) c_int;
pub const sk_SSL_CIPHER_freefunc = ?*const fn (?*SSL_CIPHER) callconv(.C) void;
pub const sk_SSL_CIPHER_copyfunc = ?*const fn (?*const SSL_CIPHER) callconv(.C) ?*SSL_CIPHER;
pub fn ossl_check_SSL_CIPHER_type(arg_ptr: ?*const SSL_CIPHER) callconv(.C) ?*const SSL_CIPHER {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_SSL_CIPHER_sk_type(arg_sk: ?*const struct_stack_st_SSL_CIPHER) callconv(.C) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SSL_CIPHER_sk_type(arg_sk: ?*struct_stack_st_SSL_CIPHER) callconv(.C) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SSL_CIPHER_compfunc_type(arg_cmp: sk_SSL_CIPHER_compfunc) callconv(.C) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_SSL_CIPHER_copyfunc_type(arg_cpy: sk_SSL_CIPHER_copyfunc) callconv(.C) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_SSL_CIPHER_freefunc_type(arg_fr: sk_SSL_CIPHER_freefunc) callconv(.C) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn SSL_set_debug(s: ?*SSL, debug: c_int) void;
pub const TLS_ST_BEFORE: c_int = 0;
pub const TLS_ST_OK: c_int = 1;
pub const DTLS_ST_CR_HELLO_VERIFY_REQUEST: c_int = 2;
pub const TLS_ST_CR_SRVR_HELLO: c_int = 3;
pub const TLS_ST_CR_CERT: c_int = 4;
pub const TLS_ST_CR_COMP_CERT: c_int = 5;
pub const TLS_ST_CR_CERT_STATUS: c_int = 6;
pub const TLS_ST_CR_KEY_EXCH: c_int = 7;
pub const TLS_ST_CR_CERT_REQ: c_int = 8;
pub const TLS_ST_CR_SRVR_DONE: c_int = 9;
pub const TLS_ST_CR_SESSION_TICKET: c_int = 10;
pub const TLS_ST_CR_CHANGE: c_int = 11;
pub const TLS_ST_CR_FINISHED: c_int = 12;
pub const TLS_ST_CW_CLNT_HELLO: c_int = 13;
pub const TLS_ST_CW_CERT: c_int = 14;
pub const TLS_ST_CW_COMP_CERT: c_int = 15;
pub const TLS_ST_CW_KEY_EXCH: c_int = 16;
pub const TLS_ST_CW_CERT_VRFY: c_int = 17;
pub const TLS_ST_CW_CHANGE: c_int = 18;
pub const TLS_ST_CW_NEXT_PROTO: c_int = 19;
pub const TLS_ST_CW_FINISHED: c_int = 20;
pub const TLS_ST_SW_HELLO_REQ: c_int = 21;
pub const TLS_ST_SR_CLNT_HELLO: c_int = 22;
pub const DTLS_ST_SW_HELLO_VERIFY_REQUEST: c_int = 23;
pub const TLS_ST_SW_SRVR_HELLO: c_int = 24;
pub const TLS_ST_SW_CERT: c_int = 25;
pub const TLS_ST_SW_COMP_CERT: c_int = 26;
pub const TLS_ST_SW_KEY_EXCH: c_int = 27;
pub const TLS_ST_SW_CERT_REQ: c_int = 28;
pub const TLS_ST_SW_SRVR_DONE: c_int = 29;
pub const TLS_ST_SR_CERT: c_int = 30;
pub const TLS_ST_SR_COMP_CERT: c_int = 31;
pub const TLS_ST_SR_KEY_EXCH: c_int = 32;
pub const TLS_ST_SR_CERT_VRFY: c_int = 33;
pub const TLS_ST_SR_NEXT_PROTO: c_int = 34;
pub const TLS_ST_SR_CHANGE: c_int = 35;
pub const TLS_ST_SR_FINISHED: c_int = 36;
pub const TLS_ST_SW_SESSION_TICKET: c_int = 37;
pub const TLS_ST_SW_CERT_STATUS: c_int = 38;
pub const TLS_ST_SW_CHANGE: c_int = 39;
pub const TLS_ST_SW_FINISHED: c_int = 40;
pub const TLS_ST_SW_ENCRYPTED_EXTENSIONS: c_int = 41;
pub const TLS_ST_CR_ENCRYPTED_EXTENSIONS: c_int = 42;
pub const TLS_ST_CR_CERT_VRFY: c_int = 43;
pub const TLS_ST_SW_CERT_VRFY: c_int = 44;
pub const TLS_ST_CR_HELLO_REQ: c_int = 45;
pub const TLS_ST_SW_KEY_UPDATE: c_int = 46;
pub const TLS_ST_CW_KEY_UPDATE: c_int = 47;
pub const TLS_ST_SR_KEY_UPDATE: c_int = 48;
pub const TLS_ST_CR_KEY_UPDATE: c_int = 49;
pub const TLS_ST_EARLY_DATA: c_int = 50;
pub const TLS_ST_PENDING_EARLY_DATA_END: c_int = 51;
pub const TLS_ST_CW_END_OF_EARLY_DATA: c_int = 52;
pub const TLS_ST_SR_END_OF_EARLY_DATA: c_int = 53;
pub const OSSL_HANDSHAKE_STATE = c_uint;
pub extern fn SSL_in_init(s: ?*const SSL) c_int;
pub extern fn SSL_in_before(s: ?*const SSL) c_int;
pub extern fn SSL_is_init_finished(s: ?*const SSL) c_int;
pub extern fn SSL_get_finished(s: ?*const SSL, buf: ?*anyopaque, count: usize) usize;
pub extern fn SSL_get_peer_finished(s: ?*const SSL, buf: ?*anyopaque, count: usize) usize;
pub extern fn PEM_read_bio_SSL_SESSION(out: ?*BIO, x: [*c]?*SSL_SESSION, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*SSL_SESSION;
pub extern fn PEM_read_SSL_SESSION(out: [*c]FILE, x: [*c]?*SSL_SESSION, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*SSL_SESSION;
pub extern fn PEM_write_bio_SSL_SESSION(out: ?*BIO, x: ?*const SSL_SESSION) c_int;
pub extern fn PEM_write_SSL_SESSION(out: [*c]FILE, x: ?*const SSL_SESSION) c_int;
pub extern fn SSL_get0_group_name(s: ?*SSL) [*c]const u8;
pub extern fn SSL_group_to_name(s: ?*SSL, id: c_int) [*c]const u8;
pub extern fn SSL_set0_tmp_dh_pkey(s: ?*SSL, dhpkey: ?*EVP_PKEY) c_int;
pub extern fn SSL_CTX_set0_tmp_dh_pkey(ctx: ?*SSL_CTX, dhpkey: ?*EVP_PKEY) c_int;
pub extern fn BIO_f_ssl() ?*const BIO_METHOD;
pub extern fn BIO_new_ssl(ctx: ?*SSL_CTX, client: c_int) ?*BIO;
pub extern fn BIO_new_ssl_connect(ctx: ?*SSL_CTX) ?*BIO;
pub extern fn BIO_new_buffer_ssl_connect(ctx: ?*SSL_CTX) ?*BIO;
pub extern fn BIO_ssl_copy_session_id(to: ?*BIO, from: ?*BIO) c_int;
pub extern fn BIO_ssl_shutdown(ssl_bio: ?*BIO) void;
pub extern fn SSL_CTX_set_cipher_list(?*SSL_CTX, str: [*c]const u8) c_int;
pub extern fn SSL_CTX_new(meth: ?*const SSL_METHOD) ?*SSL_CTX;
pub extern fn SSL_CTX_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, meth: ?*const SSL_METHOD) ?*SSL_CTX;
pub extern fn SSL_CTX_up_ref(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_free(?*SSL_CTX) void;
pub extern fn SSL_CTX_set_timeout(ctx: ?*SSL_CTX, t: c_long) c_long;
pub extern fn SSL_CTX_get_timeout(ctx: ?*const SSL_CTX) c_long;
pub extern fn SSL_CTX_get_cert_store(?*const SSL_CTX) ?*X509_STORE;
pub extern fn SSL_CTX_set_cert_store(?*SSL_CTX, ?*X509_STORE) void;
pub extern fn SSL_CTX_set1_cert_store(?*SSL_CTX, ?*X509_STORE) void;
pub extern fn SSL_want(s: ?*const SSL) c_int;
pub extern fn SSL_clear(s: ?*SSL) c_int;
pub extern fn SSL_CTX_flush_sessions(ctx: ?*SSL_CTX, tm: c_long) void;
pub extern fn SSL_CTX_flush_sessions_ex(ctx: ?*SSL_CTX, tm: time_t) void;
pub extern fn SSL_get_current_cipher(s: ?*const SSL) ?*const SSL_CIPHER;
pub extern fn SSL_get_pending_cipher(s: ?*const SSL) ?*const SSL_CIPHER;
pub extern fn SSL_CIPHER_get_bits(c: ?*const SSL_CIPHER, alg_bits: [*c]c_int) c_int;
pub extern fn SSL_CIPHER_get_version(c: ?*const SSL_CIPHER) [*c]const u8;
pub extern fn SSL_CIPHER_get_name(c: ?*const SSL_CIPHER) [*c]const u8;
pub extern fn SSL_CIPHER_standard_name(c: ?*const SSL_CIPHER) [*c]const u8;
pub extern fn OPENSSL_cipher_name(rfc_name: [*c]const u8) [*c]const u8;
pub extern fn SSL_CIPHER_get_id(c: ?*const SSL_CIPHER) u32;
pub extern fn SSL_CIPHER_get_protocol_id(c: ?*const SSL_CIPHER) u16;
pub extern fn SSL_CIPHER_get_kx_nid(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_CIPHER_get_auth_nid(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_CIPHER_get_handshake_digest(c: ?*const SSL_CIPHER) ?*const EVP_MD;
pub extern fn SSL_CIPHER_is_aead(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_get_fd(s: ?*const SSL) c_int;
pub extern fn SSL_get_rfd(s: ?*const SSL) c_int;
pub extern fn SSL_get_wfd(s: ?*const SSL) c_int;
pub extern fn SSL_get_cipher_list(s: ?*const SSL, n: c_int) [*c]const u8;
pub extern fn SSL_get_shared_ciphers(s: ?*const SSL, buf: [*c]u8, size: c_int) [*c]u8;
pub extern fn SSL_get_read_ahead(s: ?*const SSL) c_int;
pub extern fn SSL_pending(s: ?*const SSL) c_int;
pub extern fn SSL_has_pending(s: ?*const SSL) c_int;
pub extern fn SSL_set_fd(s: ?*SSL, fd: c_int) c_int;
pub extern fn SSL_set_rfd(s: ?*SSL, fd: c_int) c_int;
pub extern fn SSL_set_wfd(s: ?*SSL, fd: c_int) c_int;
pub extern fn SSL_set0_rbio(s: ?*SSL, rbio: ?*BIO) void;
pub extern fn SSL_set0_wbio(s: ?*SSL, wbio: ?*BIO) void;
pub extern fn SSL_set_bio(s: ?*SSL, rbio: ?*BIO, wbio: ?*BIO) void;
pub extern fn SSL_get_rbio(s: ?*const SSL) ?*BIO;
pub extern fn SSL_get_wbio(s: ?*const SSL) ?*BIO;
pub extern fn SSL_set_cipher_list(s: ?*SSL, str: [*c]const u8) c_int;
pub extern fn SSL_CTX_set_ciphersuites(ctx: ?*SSL_CTX, str: [*c]const u8) c_int;
pub extern fn SSL_set_ciphersuites(s: ?*SSL, str: [*c]const u8) c_int;
pub extern fn SSL_set_read_ahead(s: ?*SSL, yes: c_int) void;
pub extern fn SSL_get_verify_mode(s: ?*const SSL) c_int;
pub extern fn SSL_get_verify_depth(s: ?*const SSL) c_int;
pub extern fn SSL_get_verify_callback(s: ?*const SSL) SSL_verify_cb;
pub extern fn SSL_set_verify(s: ?*SSL, mode: c_int, callback: SSL_verify_cb) void;
pub extern fn SSL_set_verify_depth(s: ?*SSL, depth: c_int) void;
pub extern fn SSL_set_cert_cb(s: ?*SSL, cb: ?*const fn (?*SSL, ?*anyopaque) callconv(.C) c_int, arg: ?*anyopaque) void;
pub extern fn SSL_use_RSAPrivateKey(ssl: ?*SSL, rsa: ?*RSA) c_int;
pub extern fn SSL_use_RSAPrivateKey_ASN1(ssl: ?*SSL, d: [*c]const u8, len: c_long) c_int;
pub extern fn SSL_use_PrivateKey(ssl: ?*SSL, pkey: ?*EVP_PKEY) c_int;
pub extern fn SSL_use_PrivateKey_ASN1(pk: c_int, ssl: ?*SSL, d: [*c]const u8, len: c_long) c_int;
pub extern fn SSL_use_certificate(ssl: ?*SSL, x: ?*X509) c_int;
pub extern fn SSL_use_certificate_ASN1(ssl: ?*SSL, d: [*c]const u8, len: c_int) c_int;
pub extern fn SSL_use_cert_and_key(ssl: ?*SSL, x509: ?*X509, privatekey: ?*EVP_PKEY, chain: ?*struct_stack_st_X509, override: c_int) c_int;
pub extern fn SSL_CTX_use_serverinfo(ctx: ?*SSL_CTX, serverinfo: [*c]const u8, serverinfo_length: usize) c_int;
pub extern fn SSL_CTX_use_serverinfo_ex(ctx: ?*SSL_CTX, version: c_uint, serverinfo: [*c]const u8, serverinfo_length: usize) c_int;
pub extern fn SSL_CTX_use_serverinfo_file(ctx: ?*SSL_CTX, file: [*c]const u8) c_int;
pub extern fn SSL_use_RSAPrivateKey_file(ssl: ?*SSL, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_use_PrivateKey_file(ssl: ?*SSL, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_use_certificate_file(ssl: ?*SSL, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_CTX_use_RSAPrivateKey_file(ctx: ?*SSL_CTX, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_CTX_use_PrivateKey_file(ctx: ?*SSL_CTX, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_CTX_use_certificate_file(ctx: ?*SSL_CTX, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_CTX_use_certificate_chain_file(ctx: ?*SSL_CTX, file: [*c]const u8) c_int;
pub extern fn SSL_use_certificate_chain_file(ssl: ?*SSL, file: [*c]const u8) c_int;
pub extern fn SSL_load_client_CA_file(file: [*c]const u8) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_load_client_CA_file_ex(file: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_add_file_cert_subjects_to_stack(stackCAs: ?*struct_stack_st_X509_NAME, file: [*c]const u8) c_int;
pub extern fn SSL_add_dir_cert_subjects_to_stack(stackCAs: ?*struct_stack_st_X509_NAME, dir: [*c]const u8) c_int;
pub extern fn SSL_add_store_cert_subjects_to_stack(stackCAs: ?*struct_stack_st_X509_NAME, uri: [*c]const u8) c_int;
pub extern fn SSL_state_string(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_rstate_string(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_state_string_long(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_rstate_string_long(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_SESSION_get_time(s: ?*const SSL_SESSION) c_long;
pub extern fn SSL_SESSION_set_time(s: ?*SSL_SESSION, t: c_long) c_long;
pub extern fn SSL_SESSION_get_timeout(s: ?*const SSL_SESSION) c_long;
pub extern fn SSL_SESSION_set_timeout(s: ?*SSL_SESSION, t: c_long) c_long;
pub extern fn SSL_SESSION_get_protocol_version(s: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_set_protocol_version(s: ?*SSL_SESSION, version: c_int) c_int;
pub extern fn SSL_SESSION_get_time_ex(s: ?*const SSL_SESSION) time_t;
pub extern fn SSL_SESSION_set_time_ex(s: ?*SSL_SESSION, t: time_t) time_t;
pub extern fn SSL_SESSION_get0_hostname(s: ?*const SSL_SESSION) [*c]const u8;
pub extern fn SSL_SESSION_set1_hostname(s: ?*SSL_SESSION, hostname: [*c]const u8) c_int;
pub extern fn SSL_SESSION_get0_alpn_selected(s: ?*const SSL_SESSION, alpn: [*c][*c]const u8, len: [*c]usize) void;
pub extern fn SSL_SESSION_set1_alpn_selected(s: ?*SSL_SESSION, alpn: [*c]const u8, len: usize) c_int;
pub extern fn SSL_SESSION_get0_cipher(s: ?*const SSL_SESSION) ?*const SSL_CIPHER;
pub extern fn SSL_SESSION_set_cipher(s: ?*SSL_SESSION, cipher: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_SESSION_has_ticket(s: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_get_ticket_lifetime_hint(s: ?*const SSL_SESSION) c_ulong;
pub extern fn SSL_SESSION_get0_ticket(s: ?*const SSL_SESSION, tick: [*c][*c]const u8, len: [*c]usize) void;
pub extern fn SSL_SESSION_get_max_early_data(s: ?*const SSL_SESSION) u32;
pub extern fn SSL_SESSION_set_max_early_data(s: ?*SSL_SESSION, max_early_data: u32) c_int;
pub extern fn SSL_copy_session_id(to: ?*SSL, from: ?*const SSL) c_int;
pub extern fn SSL_SESSION_get0_peer(s: ?*SSL_SESSION) ?*X509;
pub extern fn SSL_SESSION_set1_id_context(s: ?*SSL_SESSION, sid_ctx: [*c]const u8, sid_ctx_len: c_uint) c_int;
pub extern fn SSL_SESSION_set1_id(s: ?*SSL_SESSION, sid: [*c]const u8, sid_len: c_uint) c_int;
pub extern fn SSL_SESSION_is_resumable(s: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_new() ?*SSL_SESSION;
pub extern fn SSL_SESSION_dup(src: ?*const SSL_SESSION) ?*SSL_SESSION;
pub extern fn SSL_SESSION_get_id(s: ?*const SSL_SESSION, len: [*c]c_uint) [*c]const u8;
pub extern fn SSL_SESSION_get0_id_context(s: ?*const SSL_SESSION, len: [*c]c_uint) [*c]const u8;
pub extern fn SSL_SESSION_get_compress_id(s: ?*const SSL_SESSION) c_uint;
pub extern fn SSL_SESSION_print_fp(fp: [*c]FILE, ses: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_print(fp: ?*BIO, ses: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_print_keylog(bp: ?*BIO, x: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_up_ref(ses: ?*SSL_SESSION) c_int;
pub extern fn SSL_SESSION_free(ses: ?*SSL_SESSION) void;
pub extern fn i2d_SSL_SESSION(in: ?*const SSL_SESSION, pp: [*c][*c]u8) c_int;
pub extern fn SSL_set_session(to: ?*SSL, session: ?*SSL_SESSION) c_int;
pub extern fn SSL_CTX_add_session(ctx: ?*SSL_CTX, session: ?*SSL_SESSION) c_int;
pub extern fn SSL_CTX_remove_session(ctx: ?*SSL_CTX, session: ?*SSL_SESSION) c_int;
pub extern fn SSL_CTX_set_generate_session_id(ctx: ?*SSL_CTX, cb: GEN_SESSION_CB) c_int;
pub extern fn SSL_set_generate_session_id(s: ?*SSL, cb: GEN_SESSION_CB) c_int;
pub extern fn SSL_has_matching_session_id(s: ?*const SSL, id: [*c]const u8, id_len: c_uint) c_int;
pub extern fn d2i_SSL_SESSION(a: [*c]?*SSL_SESSION, pp: [*c][*c]const u8, length: c_long) ?*SSL_SESSION;
pub extern fn d2i_SSL_SESSION_ex(a: [*c]?*SSL_SESSION, pp: [*c][*c]const u8, length: c_long, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*SSL_SESSION;
pub extern fn SSL_get0_peer_certificate(s: ?*const SSL) ?*X509;
pub extern fn SSL_get1_peer_certificate(s: ?*const SSL) ?*X509;
pub extern fn SSL_get_peer_cert_chain(s: ?*const SSL) ?*struct_stack_st_X509;
pub extern fn SSL_CTX_get_verify_mode(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_CTX_get_verify_depth(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_CTX_get_verify_callback(ctx: ?*const SSL_CTX) SSL_verify_cb;
pub extern fn SSL_CTX_set_verify(ctx: ?*SSL_CTX, mode: c_int, callback: SSL_verify_cb) void;
pub extern fn SSL_CTX_set_verify_depth(ctx: ?*SSL_CTX, depth: c_int) void;
pub extern fn SSL_CTX_set_cert_verify_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*X509_STORE_CTX, ?*anyopaque) callconv(.C) c_int, arg: ?*anyopaque) void;
pub extern fn SSL_CTX_set_cert_cb(c: ?*SSL_CTX, cb: ?*const fn (?*SSL, ?*anyopaque) callconv(.C) c_int, arg: ?*anyopaque) void;
pub extern fn SSL_CTX_use_RSAPrivateKey(ctx: ?*SSL_CTX, rsa: ?*RSA) c_int;
pub extern fn SSL_CTX_use_RSAPrivateKey_ASN1(ctx: ?*SSL_CTX, d: [*c]const u8, len: c_long) c_int;
pub extern fn SSL_CTX_use_PrivateKey(ctx: ?*SSL_CTX, pkey: ?*EVP_PKEY) c_int;
pub extern fn SSL_CTX_use_PrivateKey_ASN1(pk: c_int, ctx: ?*SSL_CTX, d: [*c]const u8, len: c_long) c_int;
pub extern fn SSL_CTX_use_certificate(ctx: ?*SSL_CTX, x: ?*X509) c_int;
pub extern fn SSL_CTX_use_certificate_ASN1(ctx: ?*SSL_CTX, len: c_int, d: [*c]const u8) c_int;
pub extern fn SSL_CTX_use_cert_and_key(ctx: ?*SSL_CTX, x509: ?*X509, privatekey: ?*EVP_PKEY, chain: ?*struct_stack_st_X509, override: c_int) c_int;
pub extern fn SSL_CTX_set_default_passwd_cb(ctx: ?*SSL_CTX, cb: ?*const pem_password_cb) void;
pub extern fn SSL_CTX_set_default_passwd_cb_userdata(ctx: ?*SSL_CTX, u: ?*anyopaque) void;
pub extern fn SSL_CTX_get_default_passwd_cb(ctx: ?*SSL_CTX) ?*const pem_password_cb;
pub extern fn SSL_CTX_get_default_passwd_cb_userdata(ctx: ?*SSL_CTX) ?*anyopaque;
pub extern fn SSL_set_default_passwd_cb(s: ?*SSL, cb: ?*const pem_password_cb) void;
pub extern fn SSL_set_default_passwd_cb_userdata(s: ?*SSL, u: ?*anyopaque) void;
pub extern fn SSL_get_default_passwd_cb(s: ?*SSL) ?*const pem_password_cb;
pub extern fn SSL_get_default_passwd_cb_userdata(s: ?*SSL) ?*anyopaque;
pub extern fn SSL_CTX_check_private_key(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_check_private_key(ctx: ?*const SSL) c_int;
pub extern fn SSL_CTX_set_session_id_context(ctx: ?*SSL_CTX, sid_ctx: [*c]const u8, sid_ctx_len: c_uint) c_int;
pub extern fn SSL_new(ctx: ?*SSL_CTX) ?*SSL;
pub extern fn SSL_up_ref(s: ?*SSL) c_int;
pub extern fn SSL_is_dtls(s: ?*const SSL) c_int;
pub extern fn SSL_is_tls(s: ?*const SSL) c_int;
pub extern fn SSL_is_quic(s: ?*const SSL) c_int;
pub extern fn SSL_set_session_id_context(ssl: ?*SSL, sid_ctx: [*c]const u8, sid_ctx_len: c_uint) c_int;
pub extern fn SSL_CTX_set_purpose(ctx: ?*SSL_CTX, purpose: c_int) c_int;
pub extern fn SSL_set_purpose(ssl: ?*SSL, purpose: c_int) c_int;
pub extern fn SSL_CTX_set_trust(ctx: ?*SSL_CTX, trust: c_int) c_int;
pub extern fn SSL_set_trust(ssl: ?*SSL, trust: c_int) c_int;
pub extern fn SSL_set1_host(s: ?*SSL, hostname: [*c]const u8) c_int;
pub extern fn SSL_add1_host(s: ?*SSL, hostname: [*c]const u8) c_int;
pub extern fn SSL_get0_peername(s: ?*SSL) [*c]const u8;
pub extern fn SSL_set_hostflags(s: ?*SSL, flags: c_uint) void;
pub extern fn SSL_CTX_dane_enable(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_dane_mtype_set(ctx: ?*SSL_CTX, md: ?*const EVP_MD, mtype: u8, ord: u8) c_int;
pub extern fn SSL_dane_enable(s: ?*SSL, basedomain: [*c]const u8) c_int;
pub extern fn SSL_dane_tlsa_add(s: ?*SSL, usage: u8, selector: u8, mtype: u8, data: [*c]const u8, dlen: usize) c_int;
pub extern fn SSL_get0_dane_authority(s: ?*SSL, mcert: [*c]?*X509, mspki: [*c]?*EVP_PKEY) c_int;
pub extern fn SSL_get0_dane_tlsa(s: ?*SSL, usage: [*c]u8, selector: [*c]u8, mtype: [*c]u8, data: [*c][*c]const u8, dlen: [*c]usize) c_int;
pub extern fn SSL_get0_dane(ssl: ?*SSL) ?*SSL_DANE;
pub extern fn SSL_CTX_dane_set_flags(ctx: ?*SSL_CTX, flags: c_ulong) c_ulong;
pub extern fn SSL_CTX_dane_clear_flags(ctx: ?*SSL_CTX, flags: c_ulong) c_ulong;
pub extern fn SSL_dane_set_flags(ssl: ?*SSL, flags: c_ulong) c_ulong;
pub extern fn SSL_dane_clear_flags(ssl: ?*SSL, flags: c_ulong) c_ulong;
pub extern fn SSL_CTX_set1_param(ctx: ?*SSL_CTX, vpm: ?*X509_VERIFY_PARAM) c_int;
pub extern fn SSL_set1_param(ssl: ?*SSL, vpm: ?*X509_VERIFY_PARAM) c_int;
pub extern fn SSL_CTX_get0_param(ctx: ?*SSL_CTX) ?*X509_VERIFY_PARAM;
pub extern fn SSL_get0_param(ssl: ?*SSL) ?*X509_VERIFY_PARAM;
pub extern fn SSL_CTX_set_srp_username(ctx: ?*SSL_CTX, name: [*c]u8) c_int;
pub extern fn SSL_CTX_set_srp_password(ctx: ?*SSL_CTX, password: [*c]u8) c_int;
pub extern fn SSL_CTX_set_srp_strength(ctx: ?*SSL_CTX, strength: c_int) c_int;
pub extern fn SSL_CTX_set_srp_client_pwd_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, ?*anyopaque) callconv(.C) [*c]u8) c_int;
pub extern fn SSL_CTX_set_srp_verify_param_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, ?*anyopaque) callconv(.C) c_int) c_int;
pub extern fn SSL_CTX_set_srp_username_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, [*c]c_int, ?*anyopaque) callconv(.C) c_int) c_int;
pub extern fn SSL_CTX_set_srp_cb_arg(ctx: ?*SSL_CTX, arg: ?*anyopaque) c_int;
pub extern fn SSL_set_srp_server_param(s: ?*SSL, N: ?*const BIGNUM, g: ?*const BIGNUM, sa: ?*BIGNUM, v: ?*BIGNUM, info: [*c]u8) c_int;
pub extern fn SSL_set_srp_server_param_pw(s: ?*SSL, user: [*c]const u8, pass: [*c]const u8, grp: [*c]const u8) c_int;
pub extern fn SSL_get_srp_g(s: ?*SSL) ?*BIGNUM;
pub extern fn SSL_get_srp_N(s: ?*SSL) ?*BIGNUM;
pub extern fn SSL_get_srp_username(s: ?*SSL) [*c]u8;
pub extern fn SSL_get_srp_userinfo(s: ?*SSL) [*c]u8;
pub const SSL_client_hello_cb_fn = ?*const fn (?*SSL, [*c]c_int, ?*anyopaque) callconv(.C) c_int;
pub extern fn SSL_CTX_set_client_hello_cb(c: ?*SSL_CTX, cb: SSL_client_hello_cb_fn, arg: ?*anyopaque) void;
pub extern fn SSL_client_hello_isv2(s: ?*SSL) c_int;
pub extern fn SSL_client_hello_get0_legacy_version(s: ?*SSL) c_uint;
pub extern fn SSL_client_hello_get0_random(s: ?*SSL, out: [*c][*c]const u8) usize;
pub extern fn SSL_client_hello_get0_session_id(s: ?*SSL, out: [*c][*c]const u8) usize;
pub extern fn SSL_client_hello_get0_ciphers(s: ?*SSL, out: [*c][*c]const u8) usize;
pub extern fn SSL_client_hello_get0_compression_methods(s: ?*SSL, out: [*c][*c]const u8) usize;
pub extern fn SSL_client_hello_get1_extensions_present(s: ?*SSL, out: [*c][*c]c_int, outlen: [*c]usize) c_int;
pub extern fn SSL_client_hello_get_extension_order(s: ?*SSL, exts: [*c]u16, num_exts: [*c]usize) c_int;
pub extern fn SSL_client_hello_get0_ext(s: ?*SSL, @"type": c_uint, out: [*c][*c]const u8, outlen: [*c]usize) c_int;
pub extern fn SSL_certs_clear(s: ?*SSL) void;
pub extern fn SSL_free(ssl: ?*SSL) void;
pub extern fn SSL_waiting_for_async(s: ?*SSL) c_int;
pub extern fn SSL_get_all_async_fds(s: ?*SSL, fds: [*c]c_int, numfds: [*c]usize) c_int;
pub extern fn SSL_get_changed_async_fds(s: ?*SSL, addfd: [*c]c_int, numaddfds: [*c]usize, delfd: [*c]c_int, numdelfds: [*c]usize) c_int;
pub extern fn SSL_CTX_set_async_callback(ctx: ?*SSL_CTX, callback: SSL_async_callback_fn) c_int;
pub extern fn SSL_CTX_set_async_callback_arg(ctx: ?*SSL_CTX, arg: ?*anyopaque) c_int;
pub extern fn SSL_set_async_callback(s: ?*SSL, callback: SSL_async_callback_fn) c_int;
pub extern fn SSL_set_async_callback_arg(s: ?*SSL, arg: ?*anyopaque) c_int;
pub extern fn SSL_get_async_status(s: ?*SSL, status: [*c]c_int) c_int;
pub extern fn SSL_accept(ssl: ?*SSL) c_int;
pub extern fn SSL_stateless(s: ?*SSL) c_int;
pub extern fn SSL_connect(ssl: ?*SSL) c_int;
pub extern fn SSL_read(ssl: ?*SSL, buf: ?*anyopaque, num: c_int) c_int;
pub extern fn SSL_read_ex(ssl: ?*SSL, buf: ?*anyopaque, num: usize, readbytes: [*c]usize) c_int;
pub extern fn SSL_read_early_data(s: ?*SSL, buf: ?*anyopaque, num: usize, readbytes: [*c]usize) c_int;
pub extern fn SSL_peek(ssl: ?*SSL, buf: ?*anyopaque, num: c_int) c_int;
pub extern fn SSL_peek_ex(ssl: ?*SSL, buf: ?*anyopaque, num: usize, readbytes: [*c]usize) c_int;
pub extern fn SSL_sendfile(s: ?*SSL, fd: c_int, offset: off_t, size: usize, flags: c_int) isize;
pub extern fn SSL_write(ssl: ?*SSL, buf: ?*const anyopaque, num: c_int) c_int;
pub extern fn SSL_write_ex(s: ?*SSL, buf: ?*const anyopaque, num: usize, written: [*c]usize) c_int;
pub extern fn SSL_write_early_data(s: ?*SSL, buf: ?*const anyopaque, num: usize, written: [*c]usize) c_int;
pub extern fn SSL_ctrl(ssl: ?*SSL, cmd: c_int, larg: c_long, parg: ?*anyopaque) c_long;
pub extern fn SSL_callback_ctrl(?*SSL, c_int, ?*const fn () callconv(.C) void) c_long;
pub extern fn SSL_CTX_ctrl(ctx: ?*SSL_CTX, cmd: c_int, larg: c_long, parg: ?*anyopaque) c_long;
pub extern fn SSL_CTX_callback_ctrl(?*SSL_CTX, c_int, ?*const fn () callconv(.C) void) c_long;
pub extern fn SSL_write_ex2(s: ?*SSL, buf: ?*const anyopaque, num: usize, flags: u64, written: [*c]usize) c_int;
pub extern fn SSL_get_early_data_status(s: ?*const SSL) c_int;
pub extern fn SSL_get_error(s: ?*const SSL, ret_code: c_int) c_int;
pub extern fn SSL_get_version(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_get_handshake_rtt(s: ?*const SSL, rtt: [*c]u64) c_int;
pub extern fn SSL_CTX_set_ssl_version(ctx: ?*SSL_CTX, meth: ?*const SSL_METHOD) c_int;
pub extern fn TLS_method() ?*const SSL_METHOD;
pub extern fn TLS_server_method() ?*const SSL_METHOD;
pub extern fn TLS_client_method() ?*const SSL_METHOD;
pub extern fn TLSv1_method() ?*const SSL_METHOD;
pub extern fn TLSv1_server_method() ?*const SSL_METHOD;
pub extern fn TLSv1_client_method() ?*const SSL_METHOD;
pub extern fn TLSv1_1_method() ?*const SSL_METHOD;
pub extern fn TLSv1_1_server_method() ?*const SSL_METHOD;
pub extern fn TLSv1_1_client_method() ?*const SSL_METHOD;
pub extern fn TLSv1_2_method() ?*const SSL_METHOD;
pub extern fn TLSv1_2_server_method() ?*const SSL_METHOD;
pub extern fn TLSv1_2_client_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_server_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_client_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_2_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_2_server_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_2_client_method() ?*const SSL_METHOD;
pub extern fn DTLS_method() ?*const SSL_METHOD;
pub extern fn DTLS_server_method() ?*const SSL_METHOD;
pub extern fn DTLS_client_method() ?*const SSL_METHOD;
pub extern fn DTLS_get_data_mtu(s: ?*const SSL) usize;
pub extern fn SSL_get_ciphers(s: ?*const SSL) ?*struct_stack_st_SSL_CIPHER;
pub extern fn SSL_CTX_get_ciphers(ctx: ?*const SSL_CTX) ?*struct_stack_st_SSL_CIPHER;
pub extern fn SSL_get_client_ciphers(s: ?*const SSL) ?*struct_stack_st_SSL_CIPHER;
pub extern fn SSL_get1_supported_ciphers(s: ?*SSL) ?*struct_stack_st_SSL_CIPHER;
pub extern fn SSL_do_handshake(s: ?*SSL) c_int;
pub extern fn SSL_key_update(s: ?*SSL, updatetype: c_int) c_int;
pub extern fn SSL_get_key_update_type(s: ?*const SSL) c_int;
pub extern fn SSL_renegotiate(s: ?*SSL) c_int;
pub extern fn SSL_renegotiate_abbreviated(s: ?*SSL) c_int;
pub extern fn SSL_renegotiate_pending(s: ?*const SSL) c_int;
pub extern fn SSL_new_session_ticket(s: ?*SSL) c_int;
pub extern fn SSL_shutdown(s: ?*SSL) c_int;
pub extern fn SSL_verify_client_post_handshake(s: ?*SSL) c_int;
pub extern fn SSL_CTX_set_post_handshake_auth(ctx: ?*SSL_CTX, val: c_int) void;
pub extern fn SSL_set_post_handshake_auth(s: ?*SSL, val: c_int) void;
pub extern fn SSL_CTX_get_ssl_method(ctx: ?*const SSL_CTX) ?*const SSL_METHOD;
pub extern fn SSL_get_ssl_method(s: ?*const SSL) ?*const SSL_METHOD;
pub extern fn SSL_set_ssl_method(s: ?*SSL, method: ?*const SSL_METHOD) c_int;
pub extern fn SSL_alert_type_string_long(value: c_int) [*c]const u8;
pub extern fn SSL_alert_type_string(value: c_int) [*c]const u8;
pub extern fn SSL_alert_desc_string_long(value: c_int) [*c]const u8;
pub extern fn SSL_alert_desc_string(value: c_int) [*c]const u8;
pub extern fn SSL_set0_CA_list(s: ?*SSL, name_list: ?*struct_stack_st_X509_NAME) void;
pub extern fn SSL_CTX_set0_CA_list(ctx: ?*SSL_CTX, name_list: ?*struct_stack_st_X509_NAME) void;
pub extern fn SSL_get0_CA_list(s: ?*const SSL) ?*const struct_stack_st_X509_NAME;
pub extern fn SSL_CTX_get0_CA_list(ctx: ?*const SSL_CTX) ?*const struct_stack_st_X509_NAME;
pub extern fn SSL_add1_to_CA_list(ssl: ?*SSL, x: ?*const X509) c_int;
pub extern fn SSL_CTX_add1_to_CA_list(ctx: ?*SSL_CTX, x: ?*const X509) c_int;
pub extern fn SSL_get0_peer_CA_list(s: ?*const SSL) ?*const struct_stack_st_X509_NAME;
pub extern fn SSL_set_client_CA_list(s: ?*SSL, name_list: ?*struct_stack_st_X509_NAME) void;
pub extern fn SSL_CTX_set_client_CA_list(ctx: ?*SSL_CTX, name_list: ?*struct_stack_st_X509_NAME) void;
pub extern fn SSL_get_client_CA_list(s: ?*const SSL) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_CTX_get_client_CA_list(s: ?*const SSL_CTX) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_add_client_CA(ssl: ?*SSL, x: ?*X509) c_int;
pub extern fn SSL_CTX_add_client_CA(ctx: ?*SSL_CTX, x: ?*X509) c_int;
pub extern fn SSL_set_connect_state(s: ?*SSL) void;
pub extern fn SSL_set_accept_state(s: ?*SSL) void;
pub extern fn SSL_get_default_timeout(s: ?*const SSL) c_long;
pub extern fn SSL_CIPHER_description(?*const SSL_CIPHER, buf: [*c]u8, size: c_int) [*c]u8;
pub extern fn SSL_dup_CA_list(sk: ?*const struct_stack_st_X509_NAME) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_dup(ssl: ?*SSL) ?*SSL;
pub extern fn SSL_get_certificate(ssl: ?*const SSL) ?*X509;
pub extern fn SSL_get_privatekey(ssl: ?*const SSL) ?*struct_evp_pkey_st;
pub extern fn SSL_CTX_get0_certificate(ctx: ?*const SSL_CTX) ?*X509;
pub extern fn SSL_CTX_get0_privatekey(ctx: ?*const SSL_CTX) ?*EVP_PKEY;
pub extern fn SSL_CTX_set_quiet_shutdown(ctx: ?*SSL_CTX, mode: c_int) void;
pub extern fn SSL_CTX_get_quiet_shutdown(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_set_quiet_shutdown(ssl: ?*SSL, mode: c_int) void;
pub extern fn SSL_get_quiet_shutdown(ssl: ?*const SSL) c_int;
pub extern fn SSL_set_shutdown(ssl: ?*SSL, mode: c_int) void;
pub extern fn SSL_get_shutdown(ssl: ?*const SSL) c_int;
pub extern fn SSL_version(ssl: ?*const SSL) c_int;
pub extern fn SSL_client_version(s: ?*const SSL) c_int;
pub extern fn SSL_CTX_set_default_verify_paths(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_set_default_verify_dir(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_set_default_verify_file(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_set_default_verify_store(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_load_verify_file(ctx: ?*SSL_CTX, CAfile: [*c]const u8) c_int;
pub extern fn SSL_CTX_load_verify_dir(ctx: ?*SSL_CTX, CApath: [*c]const u8) c_int;
pub extern fn SSL_CTX_load_verify_store(ctx: ?*SSL_CTX, CAstore: [*c]const u8) c_int;
pub extern fn SSL_CTX_load_verify_locations(ctx: ?*SSL_CTX, CAfile: [*c]const u8, CApath: [*c]const u8) c_int;
pub extern fn SSL_get_session(ssl: ?*const SSL) ?*SSL_SESSION;
pub extern fn SSL_get1_session(ssl: ?*SSL) ?*SSL_SESSION;
pub extern fn SSL_get_SSL_CTX(ssl: ?*const SSL) ?*SSL_CTX;
pub extern fn SSL_set_SSL_CTX(ssl: ?*SSL, ctx: ?*SSL_CTX) ?*SSL_CTX;
pub extern fn SSL_set_info_callback(ssl: ?*SSL, cb: ?*const fn (?*const SSL, c_int, c_int) callconv(.C) void) void;
pub extern fn SSL_get_info_callback(ssl: ?*const SSL) ?*const fn (?*const SSL, c_int, c_int) callconv(.C) void;
pub extern fn SSL_get_state(ssl: ?*const SSL) OSSL_HANDSHAKE_STATE;
pub extern fn SSL_set_verify_result(ssl: ?*SSL, v: c_long) void;
pub extern fn SSL_get_verify_result(ssl: ?*const SSL) c_long;
pub extern fn SSL_get0_verified_chain(s: ?*const SSL) ?*struct_stack_st_X509;
pub extern fn SSL_get_client_random(ssl: ?*const SSL, out: [*c]u8, outlen: usize) usize;
pub extern fn SSL_get_server_random(ssl: ?*const SSL, out: [*c]u8, outlen: usize) usize;
pub extern fn SSL_SESSION_get_master_key(sess: ?*const SSL_SESSION, out: [*c]u8, outlen: usize) usize;
pub extern fn SSL_SESSION_set1_master_key(sess: ?*SSL_SESSION, in: [*c]const u8, len: usize) c_int;
pub extern fn SSL_SESSION_get_max_fragment_length(sess: ?*const SSL_SESSION) u8;
pub extern fn SSL_set_ex_data(ssl: ?*SSL, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn SSL_get_ex_data(ssl: ?*const SSL, idx: c_int) ?*anyopaque;
pub extern fn SSL_SESSION_set_ex_data(ss: ?*SSL_SESSION, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn SSL_SESSION_get_ex_data(ss: ?*const SSL_SESSION, idx: c_int) ?*anyopaque;
pub extern fn SSL_CTX_set_ex_data(ssl: ?*SSL_CTX, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn SSL_CTX_get_ex_data(ssl: ?*const SSL_CTX, idx: c_int) ?*anyopaque;
pub extern fn SSL_get_ex_data_X509_STORE_CTX_idx() c_int;
pub extern fn SSL_CTX_set_default_read_buffer_len(ctx: ?*SSL_CTX, len: usize) void;
pub extern fn SSL_set_default_read_buffer_len(s: ?*SSL, len: usize) void;
pub extern fn SSL_CTX_set_tmp_dh_callback(ctx: ?*SSL_CTX, dh: ?*const fn (?*SSL, c_int, c_int) callconv(.C) ?*DH) void;
pub extern fn SSL_set_tmp_dh_callback(ssl: ?*SSL, dh: ?*const fn (?*SSL, c_int, c_int) callconv(.C) ?*DH) void;
pub extern fn SSL_get_current_compression(s: ?*const SSL) ?*const COMP_METHOD;
pub extern fn SSL_get_current_expansion(s: ?*const SSL) ?*const COMP_METHOD;
pub extern fn SSL_COMP_get_name(comp: ?*const COMP_METHOD) [*c]const u8;
pub extern fn SSL_COMP_get0_name(comp: ?*const SSL_COMP) [*c]const u8;
pub extern fn SSL_COMP_get_id(comp: ?*const SSL_COMP) c_int;
pub extern fn SSL_COMP_get_compression_methods() ?*struct_stack_st_SSL_COMP;
pub extern fn SSL_COMP_set0_compression_methods(meths: ?*struct_stack_st_SSL_COMP) ?*struct_stack_st_SSL_COMP;
pub extern fn SSL_COMP_add_compression_method(id: c_int, cm: ?*COMP_METHOD) c_int;
pub extern fn SSL_CIPHER_find(ssl: ?*SSL, ptr: [*c]const u8) ?*const SSL_CIPHER;
pub extern fn SSL_CIPHER_get_cipher_nid(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_CIPHER_get_digest_nid(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_bytes_to_cipher_list(s: ?*SSL, bytes: [*c]const u8, len: usize, isv2format: c_int, sk: [*c]?*struct_stack_st_SSL_CIPHER, scsvs: [*c]?*struct_stack_st_SSL_CIPHER) c_int;
pub extern fn SSL_set_session_ticket_ext(s: ?*SSL, ext_data: ?*anyopaque, ext_len: c_int) c_int;
pub extern fn SSL_set_session_ticket_ext_cb(s: ?*SSL, cb: tls_session_ticket_ext_cb_fn, arg: ?*anyopaque) c_int;
pub extern fn SSL_set_session_secret_cb(s: ?*SSL, session_secret_cb: tls_session_secret_cb_fn, arg: ?*anyopaque) c_int;
pub extern fn SSL_CTX_set_not_resumable_session_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, c_int) callconv(.C) c_int) void;
pub extern fn SSL_set_not_resumable_session_callback(ssl: ?*SSL, cb: ?*const fn (?*SSL, c_int) callconv(.C) c_int) void;
pub extern fn SSL_CTX_set_record_padding_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, c_int, usize, ?*anyopaque) callconv(.C) usize) void;
pub extern fn SSL_CTX_set_record_padding_callback_arg(ctx: ?*SSL_CTX, arg: ?*anyopaque) void;
pub extern fn SSL_CTX_get_record_padding_callback_arg(ctx: ?*const SSL_CTX) ?*anyopaque;
pub extern fn SSL_CTX_set_block_padding(ctx: ?*SSL_CTX, block_size: usize) c_int;
pub extern fn SSL_CTX_set_block_padding_ex(ctx: ?*SSL_CTX, app_block_size: usize, hs_block_size: usize) c_int;
pub extern fn SSL_set_record_padding_callback(ssl: ?*SSL, cb: ?*const fn (?*SSL, c_int, usize, ?*anyopaque) callconv(.C) usize) c_int;
pub extern fn SSL_set_record_padding_callback_arg(ssl: ?*SSL, arg: ?*anyopaque) void;
pub extern fn SSL_get_record_padding_callback_arg(ssl: ?*const SSL) ?*anyopaque;
pub extern fn SSL_set_block_padding(ssl: ?*SSL, block_size: usize) c_int;
pub extern fn SSL_set_block_padding_ex(ssl: ?*SSL, app_block_size: usize, hs_block_size: usize) c_int;
pub extern fn SSL_set_num_tickets(s: ?*SSL, num_tickets: usize) c_int;
pub extern fn SSL_get_num_tickets(s: ?*const SSL) usize;
pub extern fn SSL_CTX_set_num_tickets(ctx: ?*SSL_CTX, num_tickets: usize) c_int;
pub extern fn SSL_CTX_get_num_tickets(ctx: ?*const SSL_CTX) usize;
pub extern fn SSL_handle_events(s: ?*SSL) c_int;
pub extern fn SSL_get_event_timeout(s: ?*SSL, tv: [*c]struct_timeval, is_infinite: [*c]c_int) c_int;
pub extern fn SSL_get_rpoll_descriptor(s: ?*SSL, desc: [*c]BIO_POLL_DESCRIPTOR) c_int;
pub extern fn SSL_get_wpoll_descriptor(s: ?*SSL, desc: [*c]BIO_POLL_DESCRIPTOR) c_int;
pub extern fn SSL_net_read_desired(s: ?*SSL) c_int;
pub extern fn SSL_net_write_desired(s: ?*SSL) c_int;
pub extern fn SSL_set_blocking_mode(s: ?*SSL, blocking: c_int) c_int;
pub extern fn SSL_get_blocking_mode(s: ?*SSL) c_int;
pub extern fn SSL_set1_initial_peer_addr(s: ?*SSL, peer_addr: ?*const BIO_ADDR) c_int;
pub extern fn SSL_get0_connection(s: ?*SSL) ?*SSL;
pub extern fn SSL_is_connection(s: ?*SSL) c_int;
pub extern fn SSL_get_stream_type(s: ?*SSL) c_int;
pub extern fn SSL_get_stream_id(s: ?*SSL) u64;
pub extern fn SSL_is_stream_local(s: ?*SSL) c_int;
pub extern fn SSL_set_default_stream_mode(s: ?*SSL, mode: u32) c_int;
pub extern fn SSL_new_stream(s: ?*SSL, flags: u64) ?*SSL;
pub extern fn SSL_set_incoming_stream_policy(s: ?*SSL, policy: c_int, aec: u64) c_int;
pub extern fn SSL_accept_stream(s: ?*SSL, flags: u64) ?*SSL;
pub extern fn SSL_get_accept_stream_queue_len(s: ?*SSL) usize;
pub extern fn SSL_inject_net_dgram(s: ?*SSL, buf: [*c]const u8, buf_len: usize, peer: ?*const BIO_ADDR, local: ?*const BIO_ADDR) c_int;
pub const struct_ssl_shutdown_ex_args_st = extern struct {
    quic_error_code: u64 = @import("std").mem.zeroes(u64),
    quic_reason: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const SSL_SHUTDOWN_EX_ARGS = struct_ssl_shutdown_ex_args_st;
pub extern fn SSL_shutdown_ex(ssl: ?*SSL, flags: u64, args: [*c]const SSL_SHUTDOWN_EX_ARGS, args_len: usize) c_int;
pub extern fn SSL_stream_conclude(ssl: ?*SSL, flags: u64) c_int;
pub const struct_ssl_stream_reset_args_st = extern struct {
    quic_error_code: u64 = @import("std").mem.zeroes(u64),
};
pub const SSL_STREAM_RESET_ARGS = struct_ssl_stream_reset_args_st;
pub extern fn SSL_stream_reset(ssl: ?*SSL, args: [*c]const SSL_STREAM_RESET_ARGS, args_len: usize) c_int;
pub extern fn SSL_get_stream_read_state(ssl: ?*SSL) c_int;
pub extern fn SSL_get_stream_write_state(ssl: ?*SSL) c_int;
pub extern fn SSL_get_stream_read_error_code(ssl: ?*SSL, app_error_code: [*c]u64) c_int;
pub extern fn SSL_get_stream_write_error_code(ssl: ?*SSL, app_error_code: [*c]u64) c_int;
pub const struct_ssl_conn_close_info_st = extern struct {
    error_code: u64 = @import("std").mem.zeroes(u64),
    frame_type: u64 = @import("std").mem.zeroes(u64),
    reason: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    reason_len: usize = @import("std").mem.zeroes(usize),
    flags: u32 = @import("std").mem.zeroes(u32),
};
pub const SSL_CONN_CLOSE_INFO = struct_ssl_conn_close_info_st;
pub extern fn SSL_get_conn_close_info(ssl: ?*SSL, info: [*c]SSL_CONN_CLOSE_INFO, info_len: usize) c_int;
pub extern fn SSL_get_value_uint(s: ?*SSL, class_: u32, id: u32, v: [*c]u64) c_int;
pub extern fn SSL_set_value_uint(s: ?*SSL, class_: u32, id: u32, v: u64) c_int;
pub const struct_ssl_poll_item_st = extern struct {
    desc: BIO_POLL_DESCRIPTOR = @import("std").mem.zeroes(BIO_POLL_DESCRIPTOR),
    events: u64 = @import("std").mem.zeroes(u64),
    revents: u64 = @import("std").mem.zeroes(u64),
};
pub const SSL_POLL_ITEM = struct_ssl_poll_item_st;
pub extern fn SSL_poll(items: [*c]SSL_POLL_ITEM, num_items: usize, stride: usize, timeout: [*c]const struct_timeval, flags: u64, result_count: [*c]usize) c_int;
pub fn SSL_as_poll_descriptor(arg_s: ?*SSL) callconv(.C) BIO_POLL_DESCRIPTOR {
    var s = arg_s;
    _ = &s;
    var d: BIO_POLL_DESCRIPTOR = undefined;
    _ = &d;
    d.type = 2;
    d.value.ssl = s;
    return d;
}
pub extern fn SSL_session_reused(s: ?*const SSL) c_int;
pub extern fn SSL_is_server(s: ?*const SSL) c_int;
pub extern fn SSL_CONF_CTX_new() ?*SSL_CONF_CTX;
pub extern fn SSL_CONF_CTX_finish(cctx: ?*SSL_CONF_CTX) c_int;
pub extern fn SSL_CONF_CTX_free(cctx: ?*SSL_CONF_CTX) void;
pub extern fn SSL_CONF_CTX_set_flags(cctx: ?*SSL_CONF_CTX, flags: c_uint) c_uint;
pub extern fn SSL_CONF_CTX_clear_flags(cctx: ?*SSL_CONF_CTX, flags: c_uint) c_uint;
pub extern fn SSL_CONF_CTX_set1_prefix(cctx: ?*SSL_CONF_CTX, pre: [*c]const u8) c_int;
pub extern fn SSL_CONF_CTX_set_ssl(cctx: ?*SSL_CONF_CTX, ssl: ?*SSL) void;
pub extern fn SSL_CONF_CTX_set_ssl_ctx(cctx: ?*SSL_CONF_CTX, ctx: ?*SSL_CTX) void;
pub extern fn SSL_CONF_cmd(cctx: ?*SSL_CONF_CTX, cmd: [*c]const u8, value: [*c]const u8) c_int;
pub extern fn SSL_CONF_cmd_argv(cctx: ?*SSL_CONF_CTX, pargc: [*c]c_int, pargv: [*c][*c][*c]u8) c_int;
pub extern fn SSL_CONF_cmd_value_type(cctx: ?*SSL_CONF_CTX, cmd: [*c]const u8) c_int;
pub extern fn SSL_add_ssl_module() void;
pub extern fn SSL_config(s: ?*SSL, name: [*c]const u8) c_int;
pub extern fn SSL_CTX_config(ctx: ?*SSL_CTX, name: [*c]const u8) c_int;
pub extern fn SSL_trace(write_p: c_int, version: c_int, content_type: c_int, buf: ?*const anyopaque, len: usize, ssl: ?*SSL, arg: ?*anyopaque) void;
pub extern fn DTLSv1_listen(s: ?*SSL, client: ?*BIO_ADDR) c_int;
pub const ssl_ct_validation_cb = ?*const fn (?*const CT_POLICY_EVAL_CTX, ?*const struct_stack_st_SCT, ?*anyopaque) callconv(.C) c_int;
pub extern fn SSL_set_ct_validation_callback(s: ?*SSL, callback: ssl_ct_validation_cb, arg: ?*anyopaque) c_int;
pub extern fn SSL_CTX_set_ct_validation_callback(ctx: ?*SSL_CTX, callback: ssl_ct_validation_cb, arg: ?*anyopaque) c_int;
pub const SSL_CT_VALIDATION_PERMISSIVE: c_int = 0;
pub const SSL_CT_VALIDATION_STRICT: c_int = 1;
const enum_unnamed_11 = c_uint;
pub extern fn SSL_enable_ct(s: ?*SSL, validation_mode: c_int) c_int;
pub extern fn SSL_CTX_enable_ct(ctx: ?*SSL_CTX, validation_mode: c_int) c_int;
pub extern fn SSL_ct_is_enabled(s: ?*const SSL) c_int;
pub extern fn SSL_CTX_ct_is_enabled(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_get0_peer_scts(s: ?*SSL) ?*const struct_stack_st_SCT;
pub extern fn SSL_CTX_set_default_ctlog_list_file(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_set_ctlog_list_file(ctx: ?*SSL_CTX, path: [*c]const u8) c_int;
pub extern fn SSL_CTX_set0_ctlog_store(ctx: ?*SSL_CTX, logs: ?*CTLOG_STORE) void;
pub extern fn SSL_CTX_get0_ctlog_store(ctx: ?*const SSL_CTX) ?*const CTLOG_STORE;
pub extern fn SSL_set_security_level(s: ?*SSL, level: c_int) void;
pub extern fn SSL_get_security_level(s: ?*const SSL) c_int;
pub extern fn SSL_set_security_callback(s: ?*SSL, cb: ?*const fn (?*const SSL, ?*const SSL_CTX, c_int, c_int, c_int, ?*anyopaque, ?*anyopaque) callconv(.C) c_int) void;
pub extern fn SSL_get_security_callback(s: ?*const SSL) ?*const fn (?*const SSL, ?*const SSL_CTX, c_int, c_int, c_int, ?*anyopaque, ?*anyopaque) callconv(.C) c_int;
pub extern fn SSL_set0_security_ex_data(s: ?*SSL, ex: ?*anyopaque) void;
pub extern fn SSL_get0_security_ex_data(s: ?*const SSL) ?*anyopaque;
pub extern fn SSL_CTX_set_security_level(ctx: ?*SSL_CTX, level: c_int) void;
pub extern fn SSL_CTX_get_security_level(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_CTX_set_security_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*const SSL, ?*const SSL_CTX, c_int, c_int, c_int, ?*anyopaque, ?*anyopaque) callconv(.C) c_int) void;
pub extern fn SSL_CTX_get_security_callback(ctx: ?*const SSL_CTX) ?*const fn (?*const SSL, ?*const SSL_CTX, c_int, c_int, c_int, ?*anyopaque, ?*anyopaque) callconv(.C) c_int;
pub extern fn SSL_CTX_set0_security_ex_data(ctx: ?*SSL_CTX, ex: ?*anyopaque) void;
pub extern fn SSL_CTX_get0_security_ex_data(ctx: ?*const SSL_CTX) ?*anyopaque;
pub extern fn OPENSSL_init_ssl(opts: u64, settings: ?*const OPENSSL_INIT_SETTINGS) c_int;
pub extern fn SSL_free_buffers(ssl: ?*SSL) c_int;
pub extern fn SSL_alloc_buffers(ssl: ?*SSL) c_int;
pub const SSL_TICKET_STATUS = c_int;
pub const SSL_TICKET_RETURN = c_int;
pub const SSL_CTX_generate_session_ticket_fn = ?*const fn (?*SSL, ?*anyopaque) callconv(.C) c_int;
pub const SSL_CTX_decrypt_session_ticket_fn = ?*const fn (?*SSL, ?*SSL_SESSION, [*c]const u8, usize, SSL_TICKET_STATUS, ?*anyopaque) callconv(.C) SSL_TICKET_RETURN;
pub extern fn SSL_CTX_set_session_ticket_cb(ctx: ?*SSL_CTX, gen_cb: SSL_CTX_generate_session_ticket_fn, dec_cb: SSL_CTX_decrypt_session_ticket_fn, arg: ?*anyopaque) c_int;
pub extern fn SSL_SESSION_set1_ticket_appdata(ss: ?*SSL_SESSION, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SSL_SESSION_get0_ticket_appdata(ss: ?*SSL_SESSION, data: [*c]?*anyopaque, len: [*c]usize) c_int;
pub const DTLS_timer_cb = ?*const fn (?*SSL, c_uint) callconv(.C) c_uint;
pub extern fn DTLS_set_timer_cb(s: ?*SSL, cb: DTLS_timer_cb) void;
pub const SSL_allow_early_data_cb_fn = ?*const fn (?*SSL, ?*anyopaque) callconv(.C) c_int;
pub extern fn SSL_CTX_set_allow_early_data_cb(ctx: ?*SSL_CTX, cb: SSL_allow_early_data_cb_fn, arg: ?*anyopaque) void;
pub extern fn SSL_set_allow_early_data_cb(s: ?*SSL, cb: SSL_allow_early_data_cb_fn, arg: ?*anyopaque) void;
pub extern fn OSSL_default_cipher_list() [*c]const u8;
pub extern fn OSSL_default_ciphersuites() [*c]const u8;
pub extern fn SSL_CTX_compress_certs(ctx: ?*SSL_CTX, alg: c_int) c_int;
pub extern fn SSL_compress_certs(ssl: ?*SSL, alg: c_int) c_int;
pub extern fn SSL_CTX_set1_cert_comp_preference(ctx: ?*SSL_CTX, algs: [*c]c_int, len: usize) c_int;
pub extern fn SSL_set1_cert_comp_preference(ssl: ?*SSL, algs: [*c]c_int, len: usize) c_int;
pub extern fn SSL_CTX_set1_compressed_cert(ctx: ?*SSL_CTX, algorithm: c_int, comp_data: [*c]u8, comp_length: usize, orig_length: usize) c_int;
pub extern fn SSL_set1_compressed_cert(ssl: ?*SSL, algorithm: c_int, comp_data: [*c]u8, comp_length: usize, orig_length: usize) c_int;
pub extern fn SSL_CTX_get1_compressed_cert(ctx: ?*SSL_CTX, alg: c_int, data: [*c][*c]u8, orig_len: [*c]usize) usize;
pub extern fn SSL_get1_compressed_cert(ssl: ?*SSL, alg: c_int, data: [*c][*c]u8, orig_len: [*c]usize) usize;
pub extern fn SSL_add_expected_rpk(s: ?*SSL, rpk: ?*EVP_PKEY) c_int;
pub extern fn SSL_get0_peer_rpk(s: ?*const SSL) ?*EVP_PKEY;
pub extern fn SSL_SESSION_get0_peer_rpk(s: ?*SSL_SESSION) ?*EVP_PKEY;
pub extern fn SSL_get_negotiated_client_cert_type(s: ?*const SSL) c_int;
pub extern fn SSL_get_negotiated_server_cert_type(s: ?*const SSL) c_int;
pub extern fn SSL_set1_client_cert_type(s: ?*SSL, val: [*c]const u8, len: usize) c_int;
pub extern fn SSL_set1_server_cert_type(s: ?*SSL, val: [*c]const u8, len: usize) c_int;
pub extern fn SSL_CTX_set1_client_cert_type(ctx: ?*SSL_CTX, val: [*c]const u8, len: usize) c_int;
pub extern fn SSL_CTX_set1_server_cert_type(ctx: ?*SSL_CTX, val: [*c]const u8, len: usize) c_int;
pub extern fn SSL_get0_client_cert_type(s: ?*const SSL, t: [*c][*c]u8, len: [*c]usize) c_int;
pub extern fn SSL_get0_server_cert_type(s: ?*const SSL, t: [*c][*c]u8, len: [*c]usize) c_int;
pub extern fn SSL_CTX_get0_client_cert_type(ctx: ?*const SSL_CTX, t: [*c][*c]u8, len: [*c]usize) c_int;
pub extern fn SSL_CTX_get0_server_cert_type(s: ?*const SSL_CTX, t: [*c][*c]u8, len: [*c]usize) c_int;
pub extern fn __error() [*c]c_int;
pub fn ERR_GET_LIB(arg_errcode: c_ulong) callconv(.C) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    if ((errcode & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, @bitCast(@as(c_int, 2147483647))) +% @as(c_uint, @bitCast(@as(c_int, 1))))))) != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) return 2;
    return @as(c_int, @bitCast(@as(c_uint, @truncate((errcode >> @intCast(23)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
}
pub fn ERR_GET_RFLAGS(arg_errcode: c_ulong) callconv(.C) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    if ((errcode & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, @bitCast(@as(c_int, 2147483647))) +% @as(c_uint, @bitCast(@as(c_int, 1))))))) != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) return 0;
    return @as(c_int, @bitCast(@as(c_uint, @truncate(errcode & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 31) << @intCast(18))))))));
}
pub fn ERR_GET_REASON(arg_errcode: c_ulong) callconv(.C) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    if ((errcode & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, @bitCast(@as(c_int, 2147483647))) +% @as(c_uint, @bitCast(@as(c_int, 1))))))) != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) return @as(c_int, @bitCast(@as(c_uint, @truncate(errcode & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, @bitCast(@as(c_int, 2147483647))))))))));
    return @as(c_int, @bitCast(@as(c_uint, @truncate(errcode & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8388607))))))));
}
pub fn ERR_FATAL_ERROR(arg_errcode: c_ulong) callconv(.C) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    return @intFromBool((ERR_GET_RFLAGS(errcode) & (@as(c_int, 1) << @intCast(18))) != @as(c_int, 0));
}
pub fn ERR_COMMON_ERROR(arg_errcode: c_ulong) callconv(.C) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    return @intFromBool((ERR_GET_RFLAGS(errcode) & (@as(c_int, 2) << @intCast(18))) != @as(c_int, 0));
}
pub const struct_ERR_string_data_st = extern struct {
    @"error": c_ulong = @import("std").mem.zeroes(c_ulong),
    string: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const ERR_STRING_DATA = struct_ERR_string_data_st;
pub const union_lh_ERR_STRING_DATA_dummy_12 = extern union {
    d1: ?*anyopaque,
    d2: c_ulong,
    d3: c_int,
};
pub const struct_lhash_st_ERR_STRING_DATA = extern struct {
    dummy: union_lh_ERR_STRING_DATA_dummy_12 = @import("std").mem.zeroes(union_lh_ERR_STRING_DATA_dummy_12),
};
pub const lh_ERR_STRING_DATA_compfunc = ?*const fn ([*c]const ERR_STRING_DATA, [*c]const ERR_STRING_DATA) callconv(.C) c_int;
pub const lh_ERR_STRING_DATA_hashfunc = ?*const fn ([*c]const ERR_STRING_DATA) callconv(.C) c_ulong;
pub const lh_ERR_STRING_DATA_doallfunc = ?*const fn ([*c]ERR_STRING_DATA) callconv(.C) void;
pub fn lh_ERR_STRING_DATA_hash_thunk(arg_data: ?*const anyopaque, arg_hfn: OPENSSL_LH_HASHFUNC) callconv(.C) c_ulong {
    var data = arg_data;
    _ = &data;
    var hfn = arg_hfn;
    _ = &hfn;
    var hfn_conv: ?*const fn ([*c]const ERR_STRING_DATA) callconv(.C) c_ulong = @as(?*const fn ([*c]const ERR_STRING_DATA) callconv(.C) c_ulong, @ptrCast(@alignCast(hfn)));
    _ = &hfn_conv;
    return hfn_conv.?(@as([*c]const ERR_STRING_DATA, @ptrCast(@alignCast(data))));
}
pub fn lh_ERR_STRING_DATA_comp_thunk(arg_da: ?*const anyopaque, arg_db: ?*const anyopaque, arg_cfn: OPENSSL_LH_COMPFUNC) callconv(.C) c_int {
    var da = arg_da;
    _ = &da;
    var db = arg_db;
    _ = &db;
    var cfn = arg_cfn;
    _ = &cfn;
    var cfn_conv: ?*const fn ([*c]const ERR_STRING_DATA, [*c]const ERR_STRING_DATA) callconv(.C) c_int = @as(?*const fn ([*c]const ERR_STRING_DATA, [*c]const ERR_STRING_DATA) callconv(.C) c_int, @ptrCast(@alignCast(cfn)));
    _ = &cfn_conv;
    return cfn_conv.?(@as([*c]const ERR_STRING_DATA, @ptrCast(@alignCast(da))), @as([*c]const ERR_STRING_DATA, @ptrCast(@alignCast(db))));
}
pub fn lh_ERR_STRING_DATA_doall_thunk(arg_node: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNC) callconv(.C) void {
    var node = arg_node;
    _ = &node;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]ERR_STRING_DATA) callconv(.C) void = @as(?*const fn ([*c]ERR_STRING_DATA) callconv(.C) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]ERR_STRING_DATA, @ptrCast(@alignCast(node))));
}
pub fn lh_ERR_STRING_DATA_doall_arg_thunk(arg_node: ?*anyopaque, arg_arg: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNCARG) callconv(.C) void {
    var node = arg_node;
    _ = &node;
    var arg = arg_arg;
    _ = &arg;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]ERR_STRING_DATA, ?*anyopaque) callconv(.C) void = @as(?*const fn ([*c]ERR_STRING_DATA, ?*anyopaque) callconv(.C) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]ERR_STRING_DATA, @ptrCast(@alignCast(node))), arg);
}
pub fn ossl_check_ERR_STRING_DATA_lh_plain_type(arg_ptr: [*c]ERR_STRING_DATA) callconv(.C) [*c]ERR_STRING_DATA {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ERR_STRING_DATA_lh_plain_type(arg_ptr: [*c]const ERR_STRING_DATA) callconv(.C) [*c]const ERR_STRING_DATA {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ERR_STRING_DATA_lh_type(arg_lh: [*c]const struct_lhash_st_ERR_STRING_DATA) callconv(.C) ?*const OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*const OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_ERR_STRING_DATA_lh_type(arg_lh: [*c]struct_lhash_st_ERR_STRING_DATA) callconv(.C) ?*OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_ERR_STRING_DATA_lh_compfunc_type(arg_cmp: lh_ERR_STRING_DATA_compfunc) callconv(.C) OPENSSL_LH_COMPFUNC {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_LH_COMPFUNC, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ERR_STRING_DATA_lh_hashfunc_type(arg_hfn: lh_ERR_STRING_DATA_hashfunc) callconv(.C) OPENSSL_LH_HASHFUNC {
    var hfn = arg_hfn;
    _ = &hfn;
    return @as(OPENSSL_LH_HASHFUNC, @ptrCast(@alignCast(hfn)));
}
pub fn ossl_check_ERR_STRING_DATA_lh_doallfunc_type(arg_dfn: lh_ERR_STRING_DATA_doallfunc) callconv(.C) OPENSSL_LH_DOALL_FUNC {
    var dfn = arg_dfn;
    _ = &dfn;
    return @as(OPENSSL_LH_DOALL_FUNC, @ptrCast(@alignCast(dfn)));
}
pub extern fn ERR_new() void;
pub extern fn ERR_set_debug(file: [*c]const u8, line: c_int, func: [*c]const u8) void;
pub extern fn ERR_set_error(lib: c_int, reason: c_int, fmt: [*c]const u8, ...) void;
pub extern fn ERR_vset_error(lib: c_int, reason: c_int, fmt: [*c]const u8, args: va_list) void;
pub extern fn ERR_set_error_data(data: [*c]u8, flags: c_int) void;
pub extern fn ERR_get_error() c_ulong;
pub extern fn ERR_get_error_all(file: [*c][*c]const u8, line: [*c]c_int, func: [*c][*c]const u8, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_get_error_line(file: [*c][*c]const u8, line: [*c]c_int) c_ulong;
pub extern fn ERR_get_error_line_data(file: [*c][*c]const u8, line: [*c]c_int, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_error() c_ulong;
pub extern fn ERR_peek_error_line(file: [*c][*c]const u8, line: [*c]c_int) c_ulong;
pub extern fn ERR_peek_error_func(func: [*c][*c]const u8) c_ulong;
pub extern fn ERR_peek_error_data(data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_error_all(file: [*c][*c]const u8, line: [*c]c_int, func: [*c][*c]const u8, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_error_line_data(file: [*c][*c]const u8, line: [*c]c_int, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_last_error() c_ulong;
pub extern fn ERR_peek_last_error_line(file: [*c][*c]const u8, line: [*c]c_int) c_ulong;
pub extern fn ERR_peek_last_error_func(func: [*c][*c]const u8) c_ulong;
pub extern fn ERR_peek_last_error_data(data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_last_error_all(file: [*c][*c]const u8, line: [*c]c_int, func: [*c][*c]const u8, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_last_error_line_data(file: [*c][*c]const u8, line: [*c]c_int, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_clear_error() void;
pub extern fn ERR_error_string(e: c_ulong, buf: [*c]u8) [*c]u8;
pub extern fn ERR_error_string_n(e: c_ulong, buf: [*c]u8, len: usize) void;
pub extern fn ERR_lib_error_string(e: c_ulong) [*c]const u8;
pub extern fn ERR_func_error_string(e: c_ulong) [*c]const u8;
pub extern fn ERR_reason_error_string(e: c_ulong) [*c]const u8;
pub extern fn ERR_print_errors_cb(cb: ?*const fn ([*c]const u8, usize, ?*anyopaque) callconv(.C) c_int, u: ?*anyopaque) void;
pub extern fn ERR_print_errors_fp(fp: [*c]FILE) void;
pub extern fn ERR_print_errors(bp: ?*BIO) void;
pub extern fn ERR_add_error_data(num: c_int, ...) void;
pub extern fn ERR_add_error_vdata(num: c_int, args: va_list) void;
pub extern fn ERR_add_error_txt(sepr: [*c]const u8, txt: [*c]const u8) void;
pub extern fn ERR_add_error_mem_bio(sep: [*c]const u8, bio: ?*BIO) void;
pub extern fn ERR_load_strings(lib: c_int, str: [*c]ERR_STRING_DATA) c_int;
pub extern fn ERR_load_strings_const(str: [*c]const ERR_STRING_DATA) c_int;
pub extern fn ERR_unload_strings(lib: c_int, str: [*c]ERR_STRING_DATA) c_int;
pub extern fn ERR_remove_thread_state(?*anyopaque) void;
pub extern fn ERR_remove_state(pid: c_ulong) void;
pub extern fn ERR_get_state() [*c]ERR_STATE;
pub extern fn ERR_get_next_error_library() c_int;
pub extern fn ERR_set_mark() c_int;
pub extern fn ERR_pop_to_mark() c_int;
pub extern fn ERR_clear_last_mark() c_int;
pub extern fn ERR_count_to_mark() c_int;
pub extern fn ERR_pop() c_int;
pub extern fn OSSL_ERR_STATE_new() [*c]ERR_STATE;
pub extern fn OSSL_ERR_STATE_save(es: [*c]ERR_STATE) void;
pub extern fn OSSL_ERR_STATE_save_to_mark(es: [*c]ERR_STATE) void;
pub extern fn OSSL_ERR_STATE_restore(es: [*c]const ERR_STATE) void;
pub extern fn OSSL_ERR_STATE_free(es: [*c]ERR_STATE) void;
pub extern fn start_tls_server(c_int) c_int;
pub extern fn accept_connection() ?*SSL;
pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 18);
pub const __clang_minor__ = @as(c_int, 1);
pub const __clang_patchlevel__ = @as(c_int, 6);
pub const __clang_version__ = "18.1.6 (https://github.com/ziglang/zig-bootstrap 98bc6bf4fc4009888d33941daf6b600d20a42a56)";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __MEMORY_SCOPE_SYSTEM = @as(c_int, 0);
pub const __MEMORY_SCOPE_DEVICE = @as(c_int, 1);
pub const __MEMORY_SCOPE_WRKGRP = @as(c_int, 2);
pub const __MEMORY_SCOPE_WVFRNT = @as(c_int, 3);
pub const __MEMORY_SCOPE_SINGLE = @as(c_int, 4);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __FPCLASS_SNAN = @as(c_int, 0x0001);
pub const __FPCLASS_QNAN = @as(c_int, 0x0002);
pub const __FPCLASS_NEGINF = @as(c_int, 0x0004);
pub const __FPCLASS_NEGNORMAL = @as(c_int, 0x0008);
pub const __FPCLASS_NEGSUBNORMAL = @as(c_int, 0x0010);
pub const __FPCLASS_NEGZERO = @as(c_int, 0x0020);
pub const __FPCLASS_POSZERO = @as(c_int, 0x0040);
pub const __FPCLASS_POSSUBNORMAL = @as(c_int, 0x0080);
pub const __FPCLASS_POSNORMAL = @as(c_int, 0x0100);
pub const __FPCLASS_POSINF = @as(c_int, 0x0200);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 18.1.6 (https://github.com/ziglang/zig-bootstrap 98bc6bf4fc4009888d33941daf6b600d20a42a56)";
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 1);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __block = @compileError("unable to translate macro: undefined identifier `__blocks__`");
// (no file):42:9
pub const __BLOCKS__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-32";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const _LP64 = @as(c_int, 1);
pub const __LP64__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 8);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 64);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @as(c_int, 128);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 32);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 32);
pub const __INTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 8);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 4);
pub const __SIZEOF_WINT_T__ = @as(c_int, 4);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_long;
pub const __INTMAX_FMTd__ = "ld";
pub const __INTMAX_FMTi__ = "li";
pub const __INTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `L`");
// (no file):97:9
pub const __UINTMAX_TYPE__ = c_ulong;
pub const __UINTMAX_FMTo__ = "lo";
pub const __UINTMAX_FMTu__ = "lu";
pub const __UINTMAX_FMTx__ = "lx";
pub const __UINTMAX_FMTX__ = "lX";
pub const __UINTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`");
// (no file):103:9
pub const __PTRDIFF_TYPE__ = c_long;
pub const __PTRDIFF_FMTd__ = "ld";
pub const __PTRDIFF_FMTi__ = "li";
pub const __INTPTR_TYPE__ = c_long;
pub const __INTPTR_FMTd__ = "ld";
pub const __INTPTR_FMTi__ = "li";
pub const __SIZE_TYPE__ = c_ulong;
pub const __SIZE_FMTo__ = "lo";
pub const __SIZE_FMTu__ = "lu";
pub const __SIZE_FMTx__ = "lx";
pub const __SIZE_FMTX__ = "lX";
pub const __WCHAR_TYPE__ = c_int;
pub const __WINT_TYPE__ = c_int;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulong;
pub const __UINTPTR_FMTo__ = "lo";
pub const __UINTPTR_FMTu__ = "lu";
pub const __UINTPTR_FMTx__ = "lx";
pub const __UINTPTR_FMTX__ = "lX";
pub const __FLT16_DENORM_MIN__ = @as(f16, 5.9604644775390625e-8);
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_EPSILON__ = @as(f16, 9.765625e-4);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT16_MIN__ = @as(f16, 6.103515625e-5);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = @as(f64, 4.9406564584124654e-324);
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = @as(f64, 2.2204460492503131e-16);
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = @as(f64, 2.2250738585072014e-308);
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 4.9406564584124654e-324);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 15);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 2.2204460492503131e-16);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 53);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __LDBL_MAX_EXP__ = @as(c_int, 1024);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.7976931348623157e+308);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __LDBL_MIN__ = @as(c_longdouble, 2.2250738585072014e-308);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 8);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub const __INT64_TYPE__ = c_longlong;
pub const __INT64_FMTd__ = "lld";
pub const __INT64_FMTi__ = "lli";
pub const __INT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `LL`");
// (no file):199:9
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `U`");
// (no file):221:9
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulonglong;
pub const __UINT64_FMTo__ = "llo";
pub const __UINT64_FMTu__ = "llu";
pub const __UINT64_FMTx__ = "llx";
pub const __UINT64_FMTX__ = "llX";
pub const __UINT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `ULL`");
// (no file):229:9
pub const __UINT64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __INT64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_longlong;
pub const __INT_LEAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "lld";
pub const __INT_LEAST64_FMTi__ = "lli";
pub const __UINT_LEAST64_TYPE__ = c_ulonglong;
pub const __UINT_LEAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINT_LEAST64_FMTo__ = "llo";
pub const __UINT_LEAST64_FMTu__ = "llu";
pub const __UINT_LEAST64_FMTx__ = "llx";
pub const __UINT_LEAST64_FMTX__ = "llX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_longlong;
pub const __INT_FAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "lld";
pub const __INT_FAST64_FMTi__ = "lli";
pub const __UINT_FAST64_TYPE__ = c_ulonglong;
pub const __UINT_FAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINT_FAST64_FMTo__ = "llo";
pub const __UINT_FAST64_FMTu__ = "llu";
pub const __UINT_FAST64_FMTx__ = "llx";
pub const __UINT_FAST64_FMTX__ = "llX";
pub const __USER_LABEL_PREFIX__ = @compileError("unable to translate macro: undefined identifier `_`");
// (no file):320:9
pub const __NO_MATH_ERRNO__ = @as(c_int, 1);
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __SSP_STRONG__ = @as(c_int, 2);
pub const __nonnull = @compileError("unable to translate macro: undefined identifier `_Nonnull`");
// (no file):351:9
pub const __null_unspecified = @compileError("unable to translate macro: undefined identifier `_Null_unspecified`");
// (no file):352:9
pub const __nullable = @compileError("unable to translate macro: undefined identifier `_Nullable`");
// (no file):353:9
pub const TARGET_OS_WIN32 = @as(c_int, 0);
pub const TARGET_OS_WINDOWS = @as(c_int, 0);
pub const TARGET_OS_LINUX = @as(c_int, 0);
pub const TARGET_OS_UNIX = @as(c_int, 0);
pub const TARGET_OS_MAC = @as(c_int, 1);
pub const TARGET_OS_OSX = @as(c_int, 1);
pub const TARGET_OS_IPHONE = @as(c_int, 0);
pub const TARGET_OS_IOS = @as(c_int, 0);
pub const TARGET_OS_TV = @as(c_int, 0);
pub const TARGET_OS_WATCH = @as(c_int, 0);
pub const TARGET_OS_DRIVERKIT = @as(c_int, 0);
pub const TARGET_OS_MACCATALYST = @as(c_int, 0);
pub const TARGET_OS_SIMULATOR = @as(c_int, 0);
pub const TARGET_OS_EMBEDDED = @as(c_int, 0);
pub const TARGET_OS_NANO = @as(c_int, 0);
pub const TARGET_IPHONE_SIMULATOR = @as(c_int, 0);
pub const TARGET_OS_UIKITFORMAC = @as(c_int, 0);
pub const __AARCH64EL__ = @as(c_int, 1);
pub const __aarch64__ = @as(c_int, 1);
pub const __GCC_ASM_FLAG_OUTPUTS__ = @as(c_int, 1);
pub const __AARCH64_CMODEL_SMALL__ = @as(c_int, 1);
pub const __ARM_ACLE = @as(c_int, 200);
pub const __ARM_ARCH = @as(c_int, 8);
pub const __ARM_ARCH_PROFILE = 'A';
pub const __ARM_64BIT_STATE = @as(c_int, 1);
pub const __ARM_PCS_AAPCS64 = @as(c_int, 1);
pub const __ARM_ARCH_ISA_A64 = @as(c_int, 1);
pub const __ARM_FEATURE_CLZ = @as(c_int, 1);
pub const __ARM_FEATURE_FMA = @as(c_int, 1);
pub const __ARM_FEATURE_LDREX = @as(c_int, 0xF);
pub const __ARM_FEATURE_IDIV = @as(c_int, 1);
pub const __ARM_FEATURE_DIV = @as(c_int, 1);
pub const __ARM_FEATURE_NUMERIC_MAXMIN = @as(c_int, 1);
pub const __ARM_FEATURE_DIRECTED_ROUNDING = @as(c_int, 1);
pub const __ARM_ALIGN_MAX_STACK_PWR = @as(c_int, 4);
pub const __ARM_STATE_ZA = @as(c_int, 1);
pub const __ARM_STATE_ZT0 = @as(c_int, 1);
pub const __ARM_FP = @as(c_int, 0xE);
pub const __ARM_FP16_FORMAT_IEEE = @as(c_int, 1);
pub const __ARM_FP16_ARGS = @as(c_int, 1);
pub const __ARM_SIZEOF_WCHAR_T = @as(c_int, 4);
pub const __ARM_SIZEOF_MINIMAL_ENUM = @as(c_int, 4);
pub const __ARM_NEON = @as(c_int, 1);
pub const __ARM_NEON_FP = @as(c_int, 0xE);
pub const __ARM_FEATURE_CRC32 = @as(c_int, 1);
pub const __ARM_FEATURE_RCPC = @as(c_int, 1);
pub const __ARM_FEATURE_CRYPTO = @as(c_int, 1);
pub const __ARM_FEATURE_AES = @as(c_int, 1);
pub const __ARM_FEATURE_SHA2 = @as(c_int, 1);
pub const __ARM_FEATURE_SHA3 = @as(c_int, 1);
pub const __ARM_FEATURE_SHA512 = @as(c_int, 1);
pub const __ARM_FEATURE_PAUTH = @as(c_int, 1);
pub const __ARM_FEATURE_UNALIGNED = @as(c_int, 1);
pub const __ARM_FEATURE_FP16_VECTOR_ARITHMETIC = @as(c_int, 1);
pub const __ARM_FEATURE_FP16_SCALAR_ARITHMETIC = @as(c_int, 1);
pub const __ARM_FEATURE_DOTPROD = @as(c_int, 1);
pub const __ARM_FEATURE_ATOMICS = @as(c_int, 1);
pub const __ARM_FEATURE_FP16_FML = @as(c_int, 1);
pub const __ARM_FEATURE_COMPLEX = @as(c_int, 1);
pub const __ARM_FEATURE_JCVT = @as(c_int, 1);
pub const __ARM_FEATURE_QRDMX = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = @as(c_int, 1);
pub const __FP_FAST_FMA = @as(c_int, 1);
pub const __FP_FAST_FMAF = @as(c_int, 1);
pub const __AARCH64_SIMD__ = @as(c_int, 1);
pub const __ARM64_ARCH_8__ = @as(c_int, 1);
pub const __ARM_NEON__ = @as(c_int, 1);
pub const __REGISTER_PREFIX__ = "";
pub const __arm64 = @as(c_int, 1);
pub const __arm64__ = @as(c_int, 1);
pub const __APPLE_CC__ = @as(c_int, 6000);
pub const __APPLE__ = @as(c_int, 1);
pub const __STDC_NO_THREADS__ = @as(c_int, 1);
pub const __weak = @compileError("unable to translate macro: undefined identifier `objc_gc`");
// (no file):431:9
pub const __strong = "";
pub const __unsafe_unretained = "";
pub const __DYNAMIC__ = @as(c_int, 1);
pub const __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140201, .decimal);
pub const __ENVIRONMENT_OS_VERSION_MIN_REQUIRED__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140201, .decimal);
pub const __MACH__ = @as(c_int, 1);
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const _DEBUG = @as(c_int, 1);
pub const __GCC_HAVE_DWARF2_CFI_ASM = @as(c_int, 1);
pub const OPENSSL_SSL_H = "";
pub const OPENSSL_MACROS_H = "";
pub const OPENSSL_OPENSSLCONF_H = "";
pub const OPENSSL_CONFIGURATION_H = "";
pub const OPENSSL_SYS_MACOSX = @as(c_int, 1);
pub const OPENSSL_CONFIGURED_API = @as(c_int, 30400);
pub const OPENSSL_RAND_SEED_OS = "";
pub const OPENSSL_THREADS = "";
pub const OPENSSL_NO_ACVP_TESTS = "";
pub const OPENSSL_NO_AFALGENG = "";
pub const OPENSSL_NO_ASAN = "";
pub const OPENSSL_NO_BROTLI = "";
pub const OPENSSL_NO_BROTLI_DYNAMIC = "";
pub const OPENSSL_NO_CRYPTO_MDEBUG = "";
pub const OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE = "";
pub const OPENSSL_NO_DEMOS = "";
pub const OPENSSL_NO_DEVCRYPTOENG = "";
pub const OPENSSL_NO_EGD = "";
pub const OPENSSL_NO_EXTERNAL_TESTS = "";
pub const OPENSSL_NO_FIPS_POST = "";
pub const OPENSSL_NO_FIPS_SECURITYCHECKS = "";
pub const OPENSSL_NO_FUZZ_AFL = "";
pub const OPENSSL_NO_FUZZ_LIBFUZZER = "";
pub const OPENSSL_NO_H3DEMO = "";
pub const OPENSSL_NO_JITTER = "";
pub const OPENSSL_NO_KTLS = "";
pub const OPENSSL_NO_MD2 = "";
pub const OPENSSL_NO_MSAN = "";
pub const OPENSSL_NO_PIE = "";
pub const OPENSSL_NO_RC5 = "";
pub const OPENSSL_NO_SCTP = "";
pub const OPENSSL_NO_SSL3 = "";
pub const OPENSSL_NO_SSL3_METHOD = "";
pub const OPENSSL_NO_TFO = "";
pub const OPENSSL_NO_TRACE = "";
pub const OPENSSL_NO_UBSAN = "";
pub const OPENSSL_NO_UNIT_TEST = "";
pub const OPENSSL_NO_UPLINK = "";
pub const OPENSSL_NO_WEAK_SSL_CIPHERS = "";
pub const OPENSSL_NO_WINSTORE = "";
pub const OPENSSL_NO_ZLIB = "";
pub const OPENSSL_NO_ZLIB_DYNAMIC = "";
pub const OPENSSL_NO_ZSTD = "";
pub const OPENSSL_NO_ZSTD_DYNAMIC = "";
pub const OPENSSL_NO_STATIC_ENGINE = "";
pub const SIXTY_FOUR_BIT_LONG = "";
pub const RC4_INT = c_uint;
pub const OPENSSL_NO_COMP_ALG = "";
pub const OPENSSL_OPENSSLV_H = "";
pub const OPENSSL_VERSION_MAJOR = @as(c_int, 3);
pub const OPENSSL_VERSION_MINOR = @as(c_int, 4);
pub const OPENSSL_VERSION_PATCH = @as(c_int, 0);
pub const OPENSSL_VERSION_PRE_RELEASE = "";
pub const OPENSSL_VERSION_BUILD_METADATA = "";
pub const OPENSSL_SHLIB_VERSION = @as(c_int, 3);
pub inline fn OPENSSL_VERSION_PREREQ(maj: anytype, min: anytype) @TypeOf(((OPENSSL_VERSION_MAJOR << @as(c_int, 16)) + OPENSSL_VERSION_MINOR) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((OPENSSL_VERSION_MAJOR << @as(c_int, 16)) + OPENSSL_VERSION_MINOR) >= ((maj << @as(c_int, 16)) + min);
}
pub const OPENSSL_VERSION_STR = "3.4.0";
pub const OPENSSL_FULL_VERSION_STR = "3.4.0";
pub const OPENSSL_RELEASE_DATE = "22 Oct 2024";
pub const OPENSSL_VERSION_TEXT = "OpenSSL 3.4.0 22 Oct 2024";
pub const _OPENSSL_VERSION_PRE_RELEASE = @as(c_long, 0x0);
pub const OPENSSL_VERSION_NUMBER = (((OPENSSL_VERSION_MAJOR << @as(c_int, 28)) | (OPENSSL_VERSION_MINOR << @as(c_int, 20))) | (OPENSSL_VERSION_PATCH << @as(c_int, 4))) | _OPENSSL_VERSION_PRE_RELEASE;
pub const HEADER_OPENSSLV_H = "";
pub const OPENSSL_MSTR_HELPER = @compileError("unable to translate C expr: unexpected token '#'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:19:10
pub inline fn OPENSSL_MSTR(x: anytype) @TypeOf(OPENSSL_MSTR_HELPER(x)) {
    _ = &x;
    return OPENSSL_MSTR_HELPER(x);
}
pub const NON_EMPTY_TRANSLATION_UNIT = @compileError("unable to translate macro: undefined identifier `dummy`");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:26:10
pub const OSSL_DEPRECATED = @compileError("unable to translate macro: undefined identifier `deprecated`");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:62:14
pub const OSSL_DEPRECATED_FOR = @compileError("unable to translate macro: undefined identifier `deprecated`");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:63:14
pub const OPENSSL_API_LEVEL = OPENSSL_CONFIGURED_API;
pub const OSSL_DEPRECATEDIN_3_4 = OSSL_DEPRECATED(@as(f64, 3.4));
pub inline fn OSSL_DEPRECATEDIN_3_4_FOR(msg: anytype) @TypeOf(OSSL_DEPRECATED_FOR(@as(f64, 3.4), msg)) {
    _ = &msg;
    return OSSL_DEPRECATED_FOR(@as(f64, 3.4), msg);
}
pub const OSSL_DEPRECATEDIN_3_1 = OSSL_DEPRECATED(@as(f64, 3.1));
pub inline fn OSSL_DEPRECATEDIN_3_1_FOR(msg: anytype) @TypeOf(OSSL_DEPRECATED_FOR(@as(f64, 3.1), msg)) {
    _ = &msg;
    return OSSL_DEPRECATED_FOR(@as(f64, 3.1), msg);
}
pub const OSSL_DEPRECATEDIN_3_0 = OSSL_DEPRECATED(@as(f64, 3.0));
pub inline fn OSSL_DEPRECATEDIN_3_0_FOR(msg: anytype) @TypeOf(OSSL_DEPRECATED_FOR(@as(f64, 3.0), msg)) {
    _ = &msg;
    return OSSL_DEPRECATED_FOR(@as(f64, 3.0), msg);
}
pub const OSSL_DEPRECATEDIN_1_1_1 = @compileError("invalid number suffix: '.1'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:217:12
pub const OSSL_DEPRECATEDIN_1_1_1_FOR = @compileError("invalid number suffix: '.1'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:218:12
pub const OSSL_DEPRECATEDIN_1_1_0 = @compileError("invalid number suffix: '.0'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:228:12
pub const OSSL_DEPRECATEDIN_1_1_0_FOR = @compileError("invalid number suffix: '.0'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:229:12
pub const OSSL_DEPRECATEDIN_1_0_2 = @compileError("invalid number suffix: '.2'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:239:12
pub const OSSL_DEPRECATEDIN_1_0_2_FOR = @compileError("invalid number suffix: '.2'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:240:12
pub const OSSL_DEPRECATEDIN_1_0_1 = @compileError("invalid number suffix: '.1'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:250:12
pub const OSSL_DEPRECATEDIN_1_0_1_FOR = @compileError("invalid number suffix: '.1'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:251:12
pub const OSSL_DEPRECATEDIN_1_0_0 = @compileError("invalid number suffix: '.0'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:261:12
pub const OSSL_DEPRECATEDIN_1_0_0_FOR = @compileError("invalid number suffix: '.0'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:262:12
pub const OSSL_DEPRECATEDIN_0_9_8 = @compileError("invalid number suffix: '.8'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:272:12
pub const OSSL_DEPRECATEDIN_0_9_8_FOR = @compileError("invalid number suffix: '.8'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:273:12
pub const OPENSSL_FILE = @compileError("unable to translate macro: undefined identifier `__FILE__`");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:291:12
pub const OPENSSL_LINE = @compileError("unable to translate macro: undefined identifier `__LINE__`");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:292:12
pub const OPENSSL_FUNC = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:312:13
pub const OSSL_CRYPTO_ALLOC = @compileError("unable to translate macro: undefined identifier `__malloc__`");
// /opt/homebrew/opt/openssl@3/include/openssl/macros.h:330:12
pub const HEADER_SSL_H = "";
pub const OPENSSL_E_OS2_H = "";
pub const HEADER_E_OS2_H = "";
pub const OPENSSL_SYS_UNIX = "";
pub const OPENSSL_EXPORT = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/e_os2.h:183:11
pub const OPENSSL_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/e_os2.h:184:11
pub const _SYS_TYPES_H_ = "";
pub const __SYS_APPLEAPIOPTS_H__ = "";
pub const __APPLE_API_STANDARD = "";
pub const __APPLE_API_STABLE = "";
pub const __APPLE_API_EVOLVING = "";
pub const __APPLE_API_UNSTABLE = "";
pub const __APPLE_API_PRIVATE = "";
pub const __APPLE_API_OBSOLETE = "";
pub const _CDEFS_H_ = "";
pub const __BEGIN_DECLS = "";
pub const __END_DECLS = "";
pub inline fn __has_cpp_attribute(x: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &x;
    return @as(c_int, 0);
}
pub inline fn __P(protos: anytype) @TypeOf(protos) {
    _ = &protos;
    return protos;
}
pub const __CONCAT = @compileError("unable to translate C expr: unexpected token '##'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:116:9
pub const __STRING = @compileError("unable to translate C expr: unexpected token '#'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:117:9
pub const __const = @compileError("unable to translate C expr: unexpected token 'const'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:119:9
pub const __signed = c_int;
pub const __volatile = @compileError("unable to translate C expr: unexpected token 'volatile'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:121:9
pub const __dead2 = @compileError("unable to translate macro: undefined identifier `__noreturn__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:165:9
pub const __pure2 = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:166:9
pub const __stateful_pure = @compileError("unable to translate macro: undefined identifier `__pure__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:167:9
pub const __unused = @compileError("unable to translate macro: undefined identifier `__unused__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:172:9
pub const __used = @compileError("unable to translate macro: undefined identifier `__used__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:177:9
pub const __cold = @compileError("unable to translate macro: undefined identifier `__cold__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:183:9
pub const __returns_nonnull = @compileError("unable to translate macro: undefined identifier `returns_nonnull`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:190:9
pub const __exported = @compileError("unable to translate macro: undefined identifier `__visibility__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:200:9
pub const __exported_push = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:201:9
pub const __exported_pop = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:202:9
pub const __deprecated = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:214:9
pub const __deprecated_msg = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:218:10
pub inline fn __deprecated_enum_msg(_msg: anytype) @TypeOf(__deprecated_msg(_msg)) {
    _ = &_msg;
    return __deprecated_msg(_msg);
}
pub const __kpi_deprecated = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:229:9
pub const __unavailable = @compileError("unable to translate macro: undefined identifier `__unavailable__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:235:9
pub const __kpi_unavailable = "";
pub const __kpi_deprecated_arm64_macos_unavailable = "";
pub const __dead = "";
pub const __pure = "";
pub const __restrict = @compileError("unable to translate C expr: unexpected token 'restrict'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:257:9
pub const __disable_tail_calls = @compileError("unable to translate macro: undefined identifier `__disable_tail_calls__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:290:9
pub const __not_tail_called = @compileError("unable to translate macro: undefined identifier `__not_tail_called__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:302:9
pub const __result_use_check = @compileError("unable to translate macro: undefined identifier `__warn_unused_result__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:313:9
pub const __swift_unavailable = @compileError("unable to translate macro: undefined identifier `__availability__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:323:9
pub const __abortlike = __dead2 ++ __cold ++ __not_tail_called;
pub const __header_inline = @compileError("unable to translate C expr: unexpected token 'inline'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:357:10
pub const __header_always_inline = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:370:10
pub const __unreachable_ok_push = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:383:10
pub const __unreachable_ok_pop = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:386:10
pub const __printflike = @compileError("unable to translate macro: undefined identifier `__format__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:407:9
pub const __printf0like = @compileError("unable to translate macro: undefined identifier `__format__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:409:9
pub const __scanflike = @compileError("unable to translate macro: undefined identifier `__format__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:411:9
pub const __osloglike = @compileError("unable to translate macro: undefined identifier `__format__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:413:9
pub const __IDSTRING = @compileError("unable to translate C expr: unexpected token 'static'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:416:9
pub const __COPYRIGHT = @compileError("unable to translate macro: undefined identifier `copyright`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:419:9
pub const __RCSID = @compileError("unable to translate macro: undefined identifier `rcsid`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:423:9
pub const __SCCSID = @compileError("unable to translate macro: undefined identifier `sccsid`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:427:9
pub const __PROJECT_VERSION = @compileError("unable to translate macro: undefined identifier `project_version`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:431:9
pub const __FBSDID = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:436:9
pub const __DECONST = @compileError("unable to translate C expr: unexpected token 'const'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:440:9
pub const __DEVOLATILE = @compileError("unable to translate C expr: unexpected token 'volatile'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:444:9
pub const __DEQUALIFY = @compileError("unable to translate C expr: unexpected token 'const'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:448:9
pub const __alloc_align = @compileError("unable to translate macro: undefined identifier `alloc_align`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:457:9
pub const __alloc_size = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:478:9
pub const __has_safe_buffers = @as(c_int, 1);
pub const __unsafe_buffer_usage = @compileError("unable to translate macro: undefined identifier `__unsafe_buffer_usage__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:559:9
pub const __unsafe_buffer_usage_begin = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:565:9
pub const __unsafe_buffer_usage_end = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:566:9
pub const __DARWIN_ONLY_64_BIT_INO_T = @as(c_int, 1);
pub const __DARWIN_ONLY_UNIX_CONFORMANCE = @as(c_int, 1);
pub const __DARWIN_ONLY_VERS_1050 = @as(c_int, 1);
pub const __DARWIN_UNIX03 = @as(c_int, 1);
pub const __DARWIN_64_BIT_INO_T = @as(c_int, 1);
pub const __DARWIN_VERS_1050 = @as(c_int, 1);
pub const __DARWIN_NON_CANCELABLE = @as(c_int, 0);
pub const __DARWIN_SUF_UNIX03 = "";
pub const __DARWIN_SUF_64_BIT_INO_T = "";
pub const __DARWIN_SUF_1050 = "";
pub const __DARWIN_SUF_NON_CANCELABLE = "";
pub const __DARWIN_SUF_EXTSN = "$DARWIN_EXTSN";
pub const __DARWIN_ALIAS = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:751:9
pub const __DARWIN_ALIAS_C = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:752:9
pub const __DARWIN_ALIAS_I = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:753:9
pub const __DARWIN_NOCANCEL = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:754:9
pub const __DARWIN_INODE64 = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:755:9
pub const __DARWIN_1050 = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:757:9
pub const __DARWIN_1050ALIAS = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:758:9
pub const __DARWIN_1050ALIAS_C = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:759:9
pub const __DARWIN_1050ALIAS_I = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:760:9
pub const __DARWIN_1050INODE64 = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:761:9
pub const __DARWIN_EXTSN = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:763:9
pub const __DARWIN_EXTSN_C = @compileError("unable to translate C expr: unexpected token '__asm'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:764:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_2_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:35:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_2_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:41:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_2_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:47:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_3_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:53:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_3_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:59:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_3_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:65:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:71:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:77:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:83:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:89:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_5_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:95:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_5_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:101:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_6_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:107:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_6_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:113:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_7_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:119:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_7_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:125:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:131:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:137:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:143:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:149:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_4 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:155:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:161:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:167:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:173:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:179:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:185:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:191:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:197:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:203:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:209:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:215:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:221:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:227:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_4 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:233:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:239:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:245:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:251:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:257:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_4 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:263:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:269:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:275:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:281:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:287:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_4 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:293:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_5 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:299:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_6 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:305:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_7 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:311:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:317:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:323:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:329:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:335:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_5 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:341:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_4 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:347:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_6 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:359:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_7 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:365:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_8 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:371:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:377:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:383:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:389:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:395:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_4 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:401:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_5 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:407:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_6 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:413:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_7 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:419:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_8 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:425:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_16_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:431:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_16_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:437:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_16_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:443:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_16_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:449:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_16_4 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:455:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_16_5 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:461:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_16_6 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:467:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_16_7 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:473:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_17_0 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:479:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_17_1 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:485:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_17_2 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:491:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_17_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:497:9
pub const __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_17_4 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:503:9
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_0(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_1(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_2(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_3(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_4(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_5(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_6(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_7(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_8(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_9(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_10(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_10_2(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_10_3(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_11(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_11_2(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_11_3(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_11_4(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_12(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_12_1(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_12_2(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_12_4(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_13(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_13_1(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_13_2(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_13_4(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_14(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_1(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_4(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_5(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_6(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_15(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_15_1(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_15_4(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_10_16(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_11_0(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_11_1(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_11_3(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_11_4(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_11_5(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_11_6(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_12_0(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_12_1(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_12_2(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_12_3(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_12_4(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_12_5(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_12_6(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_12_7(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_13_0(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_13_1(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_13_2(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_13_3(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_13_4(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_13_5(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_13_6(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_14_0(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_14_1(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __DARWIN_ALIAS_STARTING_MAC___MAC_14_2(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub const __DARWIN_ALIAS_STARTING_MAC___MAC_14_3 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:863:9
pub const __DARWIN_ALIAS_STARTING_MAC___MAC_14_4 = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_symbol_aliasing.h:869:9
pub const __DARWIN_ALIAS_STARTING = @compileError("unable to translate macro: undefined identifier `__DARWIN_ALIAS_STARTING_MAC_`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:774:9
pub const ___POSIX_C_DEPRECATED_STARTING_198808L = "";
pub const ___POSIX_C_DEPRECATED_STARTING_199009L = "";
pub const ___POSIX_C_DEPRECATED_STARTING_199209L = "";
pub const ___POSIX_C_DEPRECATED_STARTING_199309L = "";
pub const ___POSIX_C_DEPRECATED_STARTING_199506L = "";
pub const ___POSIX_C_DEPRECATED_STARTING_200112L = "";
pub const ___POSIX_C_DEPRECATED_STARTING_200809L = "";
pub const __POSIX_C_DEPRECATED = @compileError("unable to translate macro: undefined identifier `___POSIX_C_DEPRECATED_STARTING_`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:837:9
pub const __DARWIN_C_ANSI = @as(c_long, 0o10000);
pub const __DARWIN_C_FULL = @as(c_long, 900000);
pub const __DARWIN_C_LEVEL = __DARWIN_C_FULL;
pub const __STDC_WANT_LIB_EXT1__ = @as(c_int, 1);
pub const __DARWIN_NO_LONG_LONG = @as(c_int, 0);
pub const _DARWIN_FEATURE_64_BIT_INODE = @as(c_int, 1);
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE = @as(c_int, 1);
pub const _DARWIN_FEATURE_ONLY_VERS_1050 = @as(c_int, 1);
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = @as(c_int, 1);
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE = @as(c_int, 3);
pub const __CAST_AWAY_QUALIFIER = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:935:9
pub const __XNU_PRIVATE_EXTERN = @compileError("unable to translate macro: undefined identifier `visibility`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:949:9
pub const __has_ptrcheck = @as(c_int, 0);
pub const __single = "";
pub const __unsafe_indexable = "";
pub const __counted_by = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:963:9
pub const __sized_by = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:964:9
pub const __ended_by = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:965:9
pub const __terminated_by = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:966:9
pub const __null_terminated = "";
pub const __ptrcheck_abi_assume_single = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:976:9
pub const __ptrcheck_abi_assume_unsafe_indexable = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:977:9
pub inline fn __unsafe_forge_bidi_indexable(T: anytype, P: anytype, S: anytype) @TypeOf(T(P)) {
    _ = &T;
    _ = &P;
    _ = &S;
    return T(P);
}
pub const __unsafe_forge_single = @import("std").zig.c_translation.Macros.CAST_OR_CALL;
pub inline fn __unsafe_forge_terminated_by(T: anytype, P: anytype, E: anytype) @TypeOf(T(P)) {
    _ = &T;
    _ = &P;
    _ = &E;
    return T(P);
}
pub const __unsafe_forge_null_terminated = @import("std").zig.c_translation.Macros.CAST_OR_CALL;
pub inline fn __terminated_by_to_indexable(P: anytype) @TypeOf(P) {
    _ = &P;
    return P;
}
pub inline fn __unsafe_terminated_by_to_indexable(P: anytype) @TypeOf(P) {
    _ = &P;
    return P;
}
pub inline fn __null_terminated_to_indexable(P: anytype) @TypeOf(P) {
    _ = &P;
    return P;
}
pub inline fn __unsafe_null_terminated_to_indexable(P: anytype) @TypeOf(P) {
    _ = &P;
    return P;
}
pub const __unsafe_terminated_by_from_indexable = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:988:9
pub const __unsafe_null_terminated_from_indexable = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:989:9
pub const __array_decay_dicards_count_in_parameters = "";
pub const __unsafe_late_const = "";
pub const __ptrcheck_unavailable = "";
pub const __ptrcheck_unavailable_r = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:998:9
pub const __ASSUME_PTR_ABI_SINGLE_BEGIN = __ptrcheck_abi_assume_single();
pub const __ASSUME_PTR_ABI_SINGLE_END = __ptrcheck_abi_assume_unsafe_indexable();
pub const __header_indexable = "";
pub const __header_bidi_indexable = "";
pub const __compiler_barrier = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:1027:9
pub const __enum_open = @compileError("unable to translate macro: undefined identifier `__enum_extensibility__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:1030:9
pub const __enum_closed = @compileError("unable to translate macro: undefined identifier `__enum_extensibility__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:1031:9
pub const __enum_options = @compileError("unable to translate macro: undefined identifier `__flag_enum__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:1038:9
pub const __enum_decl = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:1051:9
pub const __enum_closed_decl = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:1053:9
pub const __options_decl = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:1055:9
pub const __options_closed_decl = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/cdefs.h:1057:9
pub const __kernel_ptr_semantics = "";
pub const __kernel_data_semantics = "";
pub const __kernel_dual_semantics = "";
pub const _BSD_MACHINE_TYPES_H_ = "";
pub const _ARM_MACHTYPES_H_ = "";
pub const _MACHTYPES_H_ = "";
pub const _BSD_ARM__TYPES_H_ = "";
pub const _INT8_T = "";
pub const _INT16_T = "";
pub const _INT32_T = "";
pub const _INT64_T = "";
pub const _U_INT8_T = "";
pub const _U_INT16_T = "";
pub const _U_INT32_T = "";
pub const _U_INT64_T = "";
pub const _INTPTR_T = "";
pub const _UINTPTR_T = "";
pub const USER_ADDR_NULL = @import("std").zig.c_translation.cast(user_addr_t, @as(c_int, 0));
pub inline fn CAST_USER_ADDR_T(a_ptr: anytype) user_addr_t {
    _ = &a_ptr;
    return @import("std").zig.c_translation.cast(user_addr_t, @import("std").zig.c_translation.cast(usize, a_ptr));
}
pub const _SYS__TYPES_H_ = "";
pub const _BSD_MACHINE__TYPES_H_ = "";
pub const __DARWIN_NULL = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const _SYS__PTHREAD_TYPES_H_ = "";
pub const __PTHREAD_SIZE__ = @as(c_int, 8176);
pub const __PTHREAD_ATTR_SIZE__ = @as(c_int, 56);
pub const __PTHREAD_MUTEXATTR_SIZE__ = @as(c_int, 8);
pub const __PTHREAD_MUTEX_SIZE__ = @as(c_int, 56);
pub const __PTHREAD_CONDATTR_SIZE__ = @as(c_int, 8);
pub const __PTHREAD_COND_SIZE__ = @as(c_int, 40);
pub const __PTHREAD_ONCE_SIZE__ = @as(c_int, 8);
pub const __PTHREAD_RWLOCK_SIZE__ = @as(c_int, 192);
pub const __PTHREAD_RWLOCKATTR_SIZE__ = @as(c_int, 16);
pub const __offsetof = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_types.h:83:9
pub const _BSD_MACHINE_ENDIAN_H_ = "";
pub const _ARM__ENDIAN_H_ = "";
pub const _QUAD_HIGHWORD = @as(c_int, 1);
pub const _QUAD_LOWWORD = @as(c_int, 0);
pub const __DARWIN_LITTLE_ENDIAN = @as(c_int, 1234);
pub const __DARWIN_BIG_ENDIAN = @as(c_int, 4321);
pub const __DARWIN_PDP_ENDIAN = @as(c_int, 3412);
pub const __DARWIN_BYTE_ORDER = __DARWIN_LITTLE_ENDIAN;
pub const LITTLE_ENDIAN = __DARWIN_LITTLE_ENDIAN;
pub const BIG_ENDIAN = __DARWIN_BIG_ENDIAN;
pub const PDP_ENDIAN = __DARWIN_PDP_ENDIAN;
pub const BYTE_ORDER = __DARWIN_BYTE_ORDER;
pub const _SYS__ENDIAN_H_ = "";
pub const _OS__OSBYTEORDER_H = "";
pub inline fn __DARWIN_OSSwapConstInt16(x: anytype) __uint16_t {
    _ = &x;
    return @import("std").zig.c_translation.cast(__uint16_t, ((@import("std").zig.c_translation.cast(__uint16_t, x) & @as(c_uint, 0xff00)) >> @as(c_int, 8)) | ((@import("std").zig.c_translation.cast(__uint16_t, x) & @as(c_uint, 0x00ff)) << @as(c_int, 8)));
}
pub inline fn __DARWIN_OSSwapConstInt32(x: anytype) __uint32_t {
    _ = &x;
    return @import("std").zig.c_translation.cast(__uint32_t, ((((@import("std").zig.c_translation.cast(__uint32_t, x) & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hex)) >> @as(c_int, 24)) | ((@import("std").zig.c_translation.cast(__uint32_t, x) & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hex)) >> @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(__uint32_t, x) & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(__uint32_t, x) & @as(c_uint, 0x000000ff)) << @as(c_int, 24)));
}
pub inline fn __DARWIN_OSSwapConstInt64(x: anytype) __uint64_t {
    _ = &x;
    return @import("std").zig.c_translation.cast(__uint64_t, ((((((((@import("std").zig.c_translation.cast(__uint64_t, x) & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((@import("std").zig.c_translation.cast(__uint64_t, x) & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((@import("std").zig.c_translation.cast(__uint64_t, x) & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((@import("std").zig.c_translation.cast(__uint64_t, x) & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(__uint64_t, x) & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(__uint64_t, x) & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((@import("std").zig.c_translation.cast(__uint64_t, x) & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((@import("std").zig.c_translation.cast(__uint64_t, x) & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56)));
}
pub const __DARWIN_OS_INLINE = @compileError("unable to translate C expr: unexpected token 'static'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/libkern/_OSByteOrder.h:67:17
pub const _OS_OSBYTEORDERARM_H = "";
pub const __CLANG_STDINT_H = "";
pub const _STDINT_H_ = "";
pub const __WORDSIZE = @as(c_int, 64);
pub const _UINT8_T = "";
pub const _UINT16_T = "";
pub const _UINT32_T = "";
pub const _UINT64_T = "";
pub const _INTMAX_T = "";
pub const _UINTMAX_T = "";
pub inline fn INT8_C(v: anytype) @TypeOf(v) {
    _ = &v;
    return v;
}
pub inline fn INT16_C(v: anytype) @TypeOf(v) {
    _ = &v;
    return v;
}
pub inline fn INT32_C(v: anytype) @TypeOf(v) {
    _ = &v;
    return v;
}
pub const INT64_C = @import("std").zig.c_translation.Macros.LL_SUFFIX;
pub inline fn UINT8_C(v: anytype) @TypeOf(v) {
    _ = &v;
    return v;
}
pub inline fn UINT16_C(v: anytype) @TypeOf(v) {
    _ = &v;
    return v;
}
pub const UINT32_C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const UINT64_C = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const INTMAX_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const UINTMAX_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INT8_MAX = @as(c_int, 127);
pub const INT16_MAX = @as(c_int, 32767);
pub const INT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT64_MAX = @as(c_longlong, 9223372036854775807);
pub const INT8_MIN = -@as(c_int, 128);
pub const INT16_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const INT32_MIN = -INT32_MAX - @as(c_int, 1);
pub const INT64_MIN = -INT64_MAX - @as(c_int, 1);
pub const UINT8_MAX = @as(c_int, 255);
pub const UINT16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const UINT64_MAX = @as(c_ulonglong, 18446744073709551615);
pub const INT_LEAST8_MIN = INT8_MIN;
pub const INT_LEAST16_MIN = INT16_MIN;
pub const INT_LEAST32_MIN = INT32_MIN;
pub const INT_LEAST64_MIN = INT64_MIN;
pub const INT_LEAST8_MAX = INT8_MAX;
pub const INT_LEAST16_MAX = INT16_MAX;
pub const INT_LEAST32_MAX = INT32_MAX;
pub const INT_LEAST64_MAX = INT64_MAX;
pub const UINT_LEAST8_MAX = UINT8_MAX;
pub const UINT_LEAST16_MAX = UINT16_MAX;
pub const UINT_LEAST32_MAX = UINT32_MAX;
pub const UINT_LEAST64_MAX = UINT64_MAX;
pub const INT_FAST8_MIN = INT8_MIN;
pub const INT_FAST16_MIN = INT16_MIN;
pub const INT_FAST32_MIN = INT32_MIN;
pub const INT_FAST64_MIN = INT64_MIN;
pub const INT_FAST8_MAX = INT8_MAX;
pub const INT_FAST16_MAX = INT16_MAX;
pub const INT_FAST32_MAX = INT32_MAX;
pub const INT_FAST64_MAX = INT64_MAX;
pub const UINT_FAST8_MAX = UINT8_MAX;
pub const UINT_FAST16_MAX = UINT16_MAX;
pub const UINT_FAST32_MAX = UINT32_MAX;
pub const UINT_FAST64_MAX = UINT64_MAX;
pub const INTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const INTPTR_MIN = -INTPTR_MAX - @as(c_int, 1);
pub const UINTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const INTMAX_MAX = INTMAX_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINTMAX_MAX = UINTMAX_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INTMAX_MIN = -INTMAX_MAX - @as(c_int, 1);
pub const PTRDIFF_MIN = INTMAX_MIN;
pub const PTRDIFF_MAX = INTMAX_MAX;
pub const SIZE_MAX = UINTPTR_MAX;
pub const RSIZE_MAX = SIZE_MAX >> @as(c_int, 1);
pub const WCHAR_MAX = __WCHAR_MAX__;
pub const WCHAR_MIN = -WCHAR_MAX - @as(c_int, 1);
pub const WINT_MIN = INT32_MIN;
pub const WINT_MAX = INT32_MAX;
pub const SIG_ATOMIC_MIN = INT32_MIN;
pub const SIG_ATOMIC_MAX = INT32_MAX;
pub const _ARM_ARCH_H = "";
pub inline fn __DARWIN_OSSwapInt16(x: anytype) __uint16_t {
    _ = &x;
    return @import("std").zig.c_translation.cast(__uint16_t, if (__builtin_constant_p(x)) __DARWIN_OSSwapConstInt16(x) else _OSSwapInt16(x));
}
pub inline fn __DARWIN_OSSwapInt32(x: anytype) @TypeOf(if (__builtin_constant_p(x)) __DARWIN_OSSwapConstInt32(x) else _OSSwapInt32(x)) {
    _ = &x;
    return if (__builtin_constant_p(x)) __DARWIN_OSSwapConstInt32(x) else _OSSwapInt32(x);
}
pub inline fn __DARWIN_OSSwapInt64(x: anytype) @TypeOf(if (__builtin_constant_p(x)) __DARWIN_OSSwapConstInt64(x) else _OSSwapInt64(x)) {
    _ = &x;
    return if (__builtin_constant_p(x)) __DARWIN_OSSwapConstInt64(x) else _OSSwapInt64(x);
}
pub inline fn ntohs(x: anytype) @TypeOf(__DARWIN_OSSwapInt16(x)) {
    _ = &x;
    return __DARWIN_OSSwapInt16(x);
}
pub inline fn htons(x: anytype) @TypeOf(__DARWIN_OSSwapInt16(x)) {
    _ = &x;
    return __DARWIN_OSSwapInt16(x);
}
pub inline fn ntohl(x: anytype) @TypeOf(__DARWIN_OSSwapInt32(x)) {
    _ = &x;
    return __DARWIN_OSSwapInt32(x);
}
pub inline fn htonl(x: anytype) @TypeOf(__DARWIN_OSSwapInt32(x)) {
    _ = &x;
    return __DARWIN_OSSwapInt32(x);
}
pub inline fn ntohll(x: anytype) @TypeOf(__DARWIN_OSSwapInt64(x)) {
    _ = &x;
    return __DARWIN_OSSwapInt64(x);
}
pub inline fn htonll(x: anytype) @TypeOf(__DARWIN_OSSwapInt64(x)) {
    _ = &x;
    return __DARWIN_OSSwapInt64(x);
}
pub const NTOHL = @compileError("unable to translate C expr: unexpected token '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_endian.h:144:9
pub const NTOHS = @compileError("unable to translate C expr: unexpected token '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_endian.h:145:9
pub const NTOHLL = @compileError("unable to translate C expr: unexpected token '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_endian.h:146:9
pub const HTONL = @compileError("unable to translate C expr: unexpected token '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_endian.h:147:9
pub const HTONS = @compileError("unable to translate C expr: unexpected token '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_endian.h:148:9
pub const HTONLL = @compileError("unable to translate C expr: unexpected token '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_endian.h:149:9
pub const _U_CHAR = "";
pub const _U_SHORT = "";
pub const _U_INT = "";
pub const _U_LONG = "";
pub const __DARWIN_UINT = "";
pub const _CADDR_T = "";
pub const _DEV_T = "";
pub const _BLKCNT_T = "";
pub const _BLKSIZE_T = "";
pub const _GID_T = "";
pub const _IN_ADDR_T = "";
pub const _IN_PORT_T = "";
pub const _INO_T = "";
pub const _INO64_T = "";
pub const _KEY_T = "";
pub const _MODE_T = "";
pub const _NLINK_T = "";
pub const _ID_T = "";
pub const _PID_T = "";
pub const _OFF_T = "";
pub const _UID_T = "";
pub inline fn major(x: anytype) i32 {
    _ = &x;
    return @import("std").zig.c_translation.cast(i32, (@import("std").zig.c_translation.cast(u_int32_t, x) >> @as(c_int, 24)) & @as(c_int, 0xff));
}
pub inline fn minor(x: anytype) i32 {
    _ = &x;
    return @import("std").zig.c_translation.cast(i32, x & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffff, .hex));
}
pub inline fn makedev(x: anytype, y: anytype) dev_t {
    _ = &x;
    _ = &y;
    return @import("std").zig.c_translation.cast(dev_t, (x << @as(c_int, 24)) | y);
}
pub const _CLOCK_T = "";
pub const _SIZE_T = "";
pub const _SSIZE_T = "";
pub const _TIME_T = "";
pub const _USECONDS_T = "";
pub const _SUSECONDS_T = "";
pub const _RSIZE_T = "";
pub const _ERRNO_T = "";
pub const _FD_SET = "";
pub const __AVAILABILITY__ = "";
pub const __API_TO_BE_DEPRECATED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __API_TO_BE_DEPRECATED_MACOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __API_TO_BE_DEPRECATED_IOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __API_TO_BE_DEPRECATED_MACCATALYST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __API_TO_BE_DEPRECATED_WATCHOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __API_TO_BE_DEPRECATED_TVOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __API_TO_BE_DEPRECATED_DRIVERKIT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __API_TO_BE_DEPRECATED_VISIONOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __AVAILABILITY_VERSIONS__ = "";
pub const __MAC_10_0 = @as(c_int, 1000);
pub const __MAC_10_1 = @as(c_int, 1010);
pub const __MAC_10_2 = @as(c_int, 1020);
pub const __MAC_10_3 = @as(c_int, 1030);
pub const __MAC_10_4 = @as(c_int, 1040);
pub const __MAC_10_5 = @as(c_int, 1050);
pub const __MAC_10_6 = @as(c_int, 1060);
pub const __MAC_10_7 = @as(c_int, 1070);
pub const __MAC_10_8 = @as(c_int, 1080);
pub const __MAC_10_9 = @as(c_int, 1090);
pub const __MAC_10_10 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101000, .decimal);
pub const __MAC_10_10_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101002, .decimal);
pub const __MAC_10_10_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101003, .decimal);
pub const __MAC_10_11 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101100, .decimal);
pub const __MAC_10_11_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101102, .decimal);
pub const __MAC_10_11_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101103, .decimal);
pub const __MAC_10_11_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101104, .decimal);
pub const __MAC_10_12 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101200, .decimal);
pub const __MAC_10_12_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101201, .decimal);
pub const __MAC_10_12_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101202, .decimal);
pub const __MAC_10_12_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101204, .decimal);
pub const __MAC_10_13 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101300, .decimal);
pub const __MAC_10_13_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101301, .decimal);
pub const __MAC_10_13_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101302, .decimal);
pub const __MAC_10_13_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101304, .decimal);
pub const __MAC_10_14 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101400, .decimal);
pub const __MAC_10_14_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101401, .decimal);
pub const __MAC_10_14_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101404, .decimal);
pub const __MAC_10_14_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101405, .decimal);
pub const __MAC_10_14_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101406, .decimal);
pub const __MAC_10_15 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101500, .decimal);
pub const __MAC_10_15_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101501, .decimal);
pub const __MAC_10_15_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101504, .decimal);
pub const __MAC_10_16 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 101600, .decimal);
pub const __MAC_11_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110000, .decimal);
pub const __MAC_11_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110100, .decimal);
pub const __MAC_11_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110300, .decimal);
pub const __MAC_11_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110400, .decimal);
pub const __MAC_11_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110500, .decimal);
pub const __MAC_11_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110600, .decimal);
pub const __MAC_12_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120000, .decimal);
pub const __MAC_12_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120100, .decimal);
pub const __MAC_12_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120200, .decimal);
pub const __MAC_12_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120300, .decimal);
pub const __MAC_12_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120400, .decimal);
pub const __MAC_12_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120500, .decimal);
pub const __MAC_12_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120600, .decimal);
pub const __MAC_12_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120700, .decimal);
pub const __MAC_13_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130000, .decimal);
pub const __MAC_13_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130100, .decimal);
pub const __MAC_13_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130200, .decimal);
pub const __MAC_13_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130300, .decimal);
pub const __MAC_13_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130400, .decimal);
pub const __MAC_13_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130500, .decimal);
pub const __MAC_13_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130600, .decimal);
pub const __MAC_14_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140000, .decimal);
pub const __MAC_14_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140100, .decimal);
pub const __MAC_14_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140200, .decimal);
pub const __MAC_14_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140300, .decimal);
pub const __MAC_14_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140400, .decimal);
pub const __IPHONE_2_0 = @as(c_int, 20000);
pub const __IPHONE_2_1 = @as(c_int, 20100);
pub const __IPHONE_2_2 = @as(c_int, 20200);
pub const __IPHONE_3_0 = @as(c_int, 30000);
pub const __IPHONE_3_1 = @as(c_int, 30100);
pub const __IPHONE_3_2 = @as(c_int, 30200);
pub const __IPHONE_4_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40000, .decimal);
pub const __IPHONE_4_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40100, .decimal);
pub const __IPHONE_4_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40200, .decimal);
pub const __IPHONE_4_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40300, .decimal);
pub const __IPHONE_5_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 50000, .decimal);
pub const __IPHONE_5_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 50100, .decimal);
pub const __IPHONE_6_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60000, .decimal);
pub const __IPHONE_6_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60100, .decimal);
pub const __IPHONE_7_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70000, .decimal);
pub const __IPHONE_7_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70100, .decimal);
pub const __IPHONE_8_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80000, .decimal);
pub const __IPHONE_8_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80100, .decimal);
pub const __IPHONE_8_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80200, .decimal);
pub const __IPHONE_8_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80300, .decimal);
pub const __IPHONE_8_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80400, .decimal);
pub const __IPHONE_9_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90000, .decimal);
pub const __IPHONE_9_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90100, .decimal);
pub const __IPHONE_9_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90200, .decimal);
pub const __IPHONE_9_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90300, .decimal);
pub const __IPHONE_10_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __IPHONE_10_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100100, .decimal);
pub const __IPHONE_10_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100200, .decimal);
pub const __IPHONE_10_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100300, .decimal);
pub const __IPHONE_11_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110000, .decimal);
pub const __IPHONE_11_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110100, .decimal);
pub const __IPHONE_11_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110200, .decimal);
pub const __IPHONE_11_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110300, .decimal);
pub const __IPHONE_11_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110400, .decimal);
pub const __IPHONE_12_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120000, .decimal);
pub const __IPHONE_12_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120100, .decimal);
pub const __IPHONE_12_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120200, .decimal);
pub const __IPHONE_12_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120300, .decimal);
pub const __IPHONE_12_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120400, .decimal);
pub const __IPHONE_13_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130000, .decimal);
pub const __IPHONE_13_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130100, .decimal);
pub const __IPHONE_13_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130200, .decimal);
pub const __IPHONE_13_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130300, .decimal);
pub const __IPHONE_13_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130400, .decimal);
pub const __IPHONE_13_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130500, .decimal);
pub const __IPHONE_13_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130600, .decimal);
pub const __IPHONE_13_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130700, .decimal);
pub const __IPHONE_14_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140000, .decimal);
pub const __IPHONE_14_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140100, .decimal);
pub const __IPHONE_14_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140200, .decimal);
pub const __IPHONE_14_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140300, .decimal);
pub const __IPHONE_14_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140500, .decimal);
pub const __IPHONE_14_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140400, .decimal);
pub const __IPHONE_14_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140600, .decimal);
pub const __IPHONE_14_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140700, .decimal);
pub const __IPHONE_14_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140800, .decimal);
pub const __IPHONE_15_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150000, .decimal);
pub const __IPHONE_15_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150100, .decimal);
pub const __IPHONE_15_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150200, .decimal);
pub const __IPHONE_15_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150300, .decimal);
pub const __IPHONE_15_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150400, .decimal);
pub const __IPHONE_15_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150500, .decimal);
pub const __IPHONE_15_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150600, .decimal);
pub const __IPHONE_15_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150700, .decimal);
pub const __IPHONE_15_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150800, .decimal);
pub const __IPHONE_16_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160000, .decimal);
pub const __IPHONE_16_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160100, .decimal);
pub const __IPHONE_16_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160200, .decimal);
pub const __IPHONE_16_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160300, .decimal);
pub const __IPHONE_16_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160400, .decimal);
pub const __IPHONE_16_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160500, .decimal);
pub const __IPHONE_16_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160600, .decimal);
pub const __IPHONE_16_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160700, .decimal);
pub const __IPHONE_17_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170000, .decimal);
pub const __IPHONE_17_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170100, .decimal);
pub const __IPHONE_17_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170200, .decimal);
pub const __IPHONE_17_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170300, .decimal);
pub const __IPHONE_17_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170400, .decimal);
pub const __WATCHOS_1_0 = @as(c_int, 10000);
pub const __WATCHOS_2_0 = @as(c_int, 20000);
pub const __WATCHOS_2_1 = @as(c_int, 20100);
pub const __WATCHOS_2_2 = @as(c_int, 20200);
pub const __WATCHOS_3_0 = @as(c_int, 30000);
pub const __WATCHOS_3_1 = @as(c_int, 30100);
pub const __WATCHOS_3_1_1 = @as(c_int, 30101);
pub const __WATCHOS_3_2 = @as(c_int, 30200);
pub const __WATCHOS_4_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40000, .decimal);
pub const __WATCHOS_4_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40100, .decimal);
pub const __WATCHOS_4_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40200, .decimal);
pub const __WATCHOS_4_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40300, .decimal);
pub const __WATCHOS_5_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 50000, .decimal);
pub const __WATCHOS_5_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 50100, .decimal);
pub const __WATCHOS_5_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 50200, .decimal);
pub const __WATCHOS_5_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 50300, .decimal);
pub const __WATCHOS_6_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60000, .decimal);
pub const __WATCHOS_6_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60100, .decimal);
pub const __WATCHOS_6_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60200, .decimal);
pub const __WATCHOS_7_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70000, .decimal);
pub const __WATCHOS_7_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70100, .decimal);
pub const __WATCHOS_7_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70200, .decimal);
pub const __WATCHOS_7_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70300, .decimal);
pub const __WATCHOS_7_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70400, .decimal);
pub const __WATCHOS_7_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70500, .decimal);
pub const __WATCHOS_7_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70600, .decimal);
pub const __WATCHOS_8_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80000, .decimal);
pub const __WATCHOS_8_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80100, .decimal);
pub const __WATCHOS_8_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80300, .decimal);
pub const __WATCHOS_8_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80400, .decimal);
pub const __WATCHOS_8_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80500, .decimal);
pub const __WATCHOS_8_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80600, .decimal);
pub const __WATCHOS_8_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80700, .decimal);
pub const __WATCHOS_8_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80800, .decimal);
pub const __WATCHOS_9_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90000, .decimal);
pub const __WATCHOS_9_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90100, .decimal);
pub const __WATCHOS_9_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90200, .decimal);
pub const __WATCHOS_9_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90300, .decimal);
pub const __WATCHOS_9_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90400, .decimal);
pub const __WATCHOS_9_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90500, .decimal);
pub const __WATCHOS_9_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90600, .decimal);
pub const __WATCHOS_10_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __WATCHOS_10_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100100, .decimal);
pub const __WATCHOS_10_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100200, .decimal);
pub const __WATCHOS_10_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100300, .decimal);
pub const __WATCHOS_10_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100400, .decimal);
pub const __TVOS_9_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90000, .decimal);
pub const __TVOS_9_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90100, .decimal);
pub const __TVOS_9_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 90200, .decimal);
pub const __TVOS_10_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100000, .decimal);
pub const __TVOS_10_0_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100001, .decimal);
pub const __TVOS_10_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100100, .decimal);
pub const __TVOS_10_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 100200, .decimal);
pub const __TVOS_11_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110000, .decimal);
pub const __TVOS_11_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110100, .decimal);
pub const __TVOS_11_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110200, .decimal);
pub const __TVOS_11_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110300, .decimal);
pub const __TVOS_11_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 110400, .decimal);
pub const __TVOS_12_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120000, .decimal);
pub const __TVOS_12_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120100, .decimal);
pub const __TVOS_12_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120200, .decimal);
pub const __TVOS_12_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120300, .decimal);
pub const __TVOS_12_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 120400, .decimal);
pub const __TVOS_13_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130000, .decimal);
pub const __TVOS_13_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130200, .decimal);
pub const __TVOS_13_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130300, .decimal);
pub const __TVOS_13_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 130400, .decimal);
pub const __TVOS_14_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140000, .decimal);
pub const __TVOS_14_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140100, .decimal);
pub const __TVOS_14_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140200, .decimal);
pub const __TVOS_14_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140300, .decimal);
pub const __TVOS_14_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140500, .decimal);
pub const __TVOS_14_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140600, .decimal);
pub const __TVOS_14_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 140700, .decimal);
pub const __TVOS_15_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150000, .decimal);
pub const __TVOS_15_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150100, .decimal);
pub const __TVOS_15_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150200, .decimal);
pub const __TVOS_15_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150300, .decimal);
pub const __TVOS_15_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150400, .decimal);
pub const __TVOS_15_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150500, .decimal);
pub const __TVOS_15_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 150600, .decimal);
pub const __TVOS_16_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160000, .decimal);
pub const __TVOS_16_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160100, .decimal);
pub const __TVOS_16_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160200, .decimal);
pub const __TVOS_16_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160300, .decimal);
pub const __TVOS_16_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160400, .decimal);
pub const __TVOS_16_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160500, .decimal);
pub const __TVOS_16_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160600, .decimal);
pub const __TVOS_17_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170000, .decimal);
pub const __TVOS_17_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170100, .decimal);
pub const __TVOS_17_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170200, .decimal);
pub const __TVOS_17_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170300, .decimal);
pub const __TVOS_17_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 170400, .decimal);
pub const __BRIDGEOS_2_0 = @as(c_int, 20000);
pub const __BRIDGEOS_3_0 = @as(c_int, 30000);
pub const __BRIDGEOS_3_1 = @as(c_int, 30100);
pub const __BRIDGEOS_3_4 = @as(c_int, 30400);
pub const __BRIDGEOS_4_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40000, .decimal);
pub const __BRIDGEOS_4_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 40100, .decimal);
pub const __BRIDGEOS_5_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 50000, .decimal);
pub const __BRIDGEOS_5_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 50100, .decimal);
pub const __BRIDGEOS_5_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 50300, .decimal);
pub const __BRIDGEOS_6_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60000, .decimal);
pub const __BRIDGEOS_6_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60200, .decimal);
pub const __BRIDGEOS_6_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60400, .decimal);
pub const __BRIDGEOS_6_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60500, .decimal);
pub const __BRIDGEOS_6_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60600, .decimal);
pub const __BRIDGEOS_7_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70000, .decimal);
pub const __BRIDGEOS_7_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70100, .decimal);
pub const __BRIDGEOS_7_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70200, .decimal);
pub const __BRIDGEOS_7_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70300, .decimal);
pub const __BRIDGEOS_7_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70400, .decimal);
pub const __BRIDGEOS_7_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 70600, .decimal);
pub const __BRIDGEOS_8_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80000, .decimal);
pub const __BRIDGEOS_8_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80100, .decimal);
pub const __BRIDGEOS_8_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80200, .decimal);
pub const __BRIDGEOS_8_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80300, .decimal);
pub const __BRIDGEOS_8_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 80400, .decimal);
pub const __DRIVERKIT_19_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 190000, .decimal);
pub const __DRIVERKIT_20_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 200000, .decimal);
pub const __DRIVERKIT_21_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 210000, .decimal);
pub const __DRIVERKIT_22_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 220000, .decimal);
pub const __DRIVERKIT_22_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 220400, .decimal);
pub const __DRIVERKIT_22_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 220500, .decimal);
pub const __DRIVERKIT_22_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 220600, .decimal);
pub const __DRIVERKIT_23_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 230000, .decimal);
pub const __DRIVERKIT_23_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 230100, .decimal);
pub const __DRIVERKIT_23_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 230200, .decimal);
pub const __DRIVERKIT_23_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 230300, .decimal);
pub const __DRIVERKIT_23_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 230400, .decimal);
pub const __VISIONOS_1_0 = @as(c_int, 10000);
pub const __VISIONOS_1_1 = @as(c_int, 10100);
pub const MAC_OS_X_VERSION_10_0 = __MAC_10_0;
pub const MAC_OS_X_VERSION_10_1 = __MAC_10_1;
pub const MAC_OS_X_VERSION_10_2 = __MAC_10_2;
pub const MAC_OS_X_VERSION_10_3 = __MAC_10_3;
pub const MAC_OS_X_VERSION_10_4 = __MAC_10_4;
pub const MAC_OS_X_VERSION_10_5 = __MAC_10_5;
pub const MAC_OS_X_VERSION_10_6 = __MAC_10_6;
pub const MAC_OS_X_VERSION_10_7 = __MAC_10_7;
pub const MAC_OS_X_VERSION_10_8 = __MAC_10_8;
pub const MAC_OS_X_VERSION_10_9 = __MAC_10_9;
pub const MAC_OS_X_VERSION_10_10 = __MAC_10_10;
pub const MAC_OS_X_VERSION_10_10_2 = __MAC_10_10_2;
pub const MAC_OS_X_VERSION_10_10_3 = __MAC_10_10_3;
pub const MAC_OS_X_VERSION_10_11 = __MAC_10_11;
pub const MAC_OS_X_VERSION_10_11_2 = __MAC_10_11_2;
pub const MAC_OS_X_VERSION_10_11_3 = __MAC_10_11_3;
pub const MAC_OS_X_VERSION_10_11_4 = __MAC_10_11_4;
pub const MAC_OS_X_VERSION_10_12 = __MAC_10_12;
pub const MAC_OS_X_VERSION_10_12_1 = __MAC_10_12_1;
pub const MAC_OS_X_VERSION_10_12_2 = __MAC_10_12_2;
pub const MAC_OS_X_VERSION_10_12_4 = __MAC_10_12_4;
pub const MAC_OS_X_VERSION_10_13 = __MAC_10_13;
pub const MAC_OS_X_VERSION_10_13_1 = __MAC_10_13_1;
pub const MAC_OS_X_VERSION_10_13_2 = __MAC_10_13_2;
pub const MAC_OS_X_VERSION_10_13_4 = __MAC_10_13_4;
pub const MAC_OS_X_VERSION_10_14 = __MAC_10_14;
pub const MAC_OS_X_VERSION_10_14_1 = __MAC_10_14_1;
pub const MAC_OS_X_VERSION_10_14_4 = __MAC_10_14_4;
pub const MAC_OS_X_VERSION_10_14_5 = __MAC_10_14_5;
pub const MAC_OS_X_VERSION_10_14_6 = __MAC_10_14_6;
pub const MAC_OS_X_VERSION_10_15 = __MAC_10_15;
pub const MAC_OS_X_VERSION_10_15_1 = __MAC_10_15_1;
pub const MAC_OS_X_VERSION_10_15_4 = __MAC_10_15_4;
pub const MAC_OS_X_VERSION_10_16 = __MAC_10_16;
pub const MAC_OS_VERSION_11_0 = __MAC_11_0;
pub const MAC_OS_VERSION_11_1 = __MAC_11_1;
pub const MAC_OS_VERSION_11_3 = __MAC_11_3;
pub const MAC_OS_VERSION_11_4 = __MAC_11_4;
pub const MAC_OS_VERSION_11_5 = __MAC_11_5;
pub const MAC_OS_VERSION_11_6 = __MAC_11_6;
pub const MAC_OS_VERSION_12_0 = __MAC_12_0;
pub const MAC_OS_VERSION_12_1 = __MAC_12_1;
pub const MAC_OS_VERSION_12_2 = __MAC_12_2;
pub const MAC_OS_VERSION_12_3 = __MAC_12_3;
pub const MAC_OS_VERSION_12_4 = __MAC_12_4;
pub const MAC_OS_VERSION_12_5 = __MAC_12_5;
pub const MAC_OS_VERSION_12_6 = __MAC_12_6;
pub const MAC_OS_VERSION_12_7 = __MAC_12_7;
pub const MAC_OS_VERSION_13_0 = __MAC_13_0;
pub const MAC_OS_VERSION_13_1 = __MAC_13_1;
pub const MAC_OS_VERSION_13_2 = __MAC_13_2;
pub const MAC_OS_VERSION_13_3 = __MAC_13_3;
pub const MAC_OS_VERSION_13_4 = __MAC_13_4;
pub const MAC_OS_VERSION_13_5 = __MAC_13_5;
pub const MAC_OS_VERSION_13_6 = __MAC_13_6;
pub const MAC_OS_VERSION_14_0 = __MAC_14_0;
pub const MAC_OS_VERSION_14_1 = __MAC_14_1;
pub const MAC_OS_VERSION_14_2 = __MAC_14_2;
pub const MAC_OS_VERSION_14_3 = __MAC_14_3;
pub const MAC_OS_VERSION_14_4 = __MAC_14_4;
pub const __AVAILABILITY_INTERNAL__ = "";
pub const __MAC_OS_X_VERSION_MIN_REQUIRED = __ENVIRONMENT_OS_VERSION_MIN_REQUIRED__;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED = __MAC_14_4;
pub const __AVAILABILITY_INTERNAL_DEPRECATED = @compileError("unable to translate macro: undefined identifier `deprecated`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:160:9
pub const __AVAILABILITY_INTERNAL_DEPRECATED_MSG = @compileError("unable to translate macro: undefined identifier `deprecated`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:163:17
pub const __AVAILABILITY_INTERNAL_UNAVAILABLE = @compileError("unable to translate macro: undefined identifier `unavailable`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:172:9
pub const __AVAILABILITY_INTERNAL_WEAK_IMPORT = @compileError("unable to translate macro: undefined identifier `weak_import`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:173:9
pub const __AVAILABILITY_INTERNAL_REGULAR = "";
pub const __AVAILABILITY_INTERNAL_LEGACY__ = "";
pub const __ENABLE_LEGACY_MAC_AVAILABILITY = @as(c_int, 1);
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2831:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2832:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2833:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2835:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2839:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2841:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2846:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2850:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2851:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2853:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2857:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2859:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2863:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2865:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2870:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2874:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2875:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2877:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2881:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2883:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2887:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2889:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2894:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2899:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2903:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2905:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2909:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2911:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2915:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2917:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2921:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2923:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2927:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2929:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2933:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2935:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2939:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2941:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2945:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2947:25
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2951:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2952:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2953:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2954:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2955:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2956:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2958:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2962:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2964:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2969:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2973:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2974:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2976:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2980:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2982:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2986:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2988:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2993:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2997:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:2998:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3000:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3004:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3006:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3010:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3012:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3017:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3021:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3022:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3024:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3028:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3030:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3034:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3036:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3040:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3042:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3046:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3048:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3052:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3054:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3058:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3060:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3064:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3066:25
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3070:21
pub const __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3071:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3072:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3073:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3074:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3075:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3077:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3081:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3083:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3088:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3092:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3093:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3095:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3099:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3101:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3105:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3107:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3112:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3116:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3117:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3119:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3123:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3125:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3129:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3131:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3136:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3140:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3141:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3143:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3147:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3149:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3153:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3155:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3159:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3161:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3165:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3167:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3171:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3173:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3177:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3179:25
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3183:21
pub const __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3184:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3185:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3186:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3187:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3188:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3190:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3194:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3196:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3201:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3205:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3206:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3208:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3212:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3214:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3218:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3220:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3225:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3229:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3230:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3232:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3236:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3238:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3242:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3244:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3249:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3253:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3254:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3256:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3260:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3262:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3266:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3268:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3272:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3274:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3278:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3280:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3284:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3286:25
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3290:21
pub const __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3291:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3292:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEPRECATED__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3293:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3294:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3295:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3296:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3298:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3302:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3304:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3309:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3313:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3314:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3316:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3320:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3322:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3326:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3328:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3333:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3337:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3338:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3340:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3344:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3346:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3350:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3352:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3357:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3361:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3363:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3367:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3369:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3373:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3375:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3379:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3381:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3385:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3387:25
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3391:21
pub const __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3392:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3393:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3394:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3395:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3396:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3398:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3402:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3404:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3409:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3413:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3414:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3416:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3420:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3422:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3426:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3428:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3433:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3437:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3438:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3440:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3444:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3446:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3450:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3452:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3457:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3461:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3462:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3464:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3468:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3470:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3474:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3476:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3480:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3482:25
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3486:21
pub const __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3487:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3488:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3489:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3490:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3491:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3493:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3497:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3499:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3504:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3508:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3509:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3511:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3515:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3517:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3521:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3523:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3528:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3532:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3533:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3535:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3539:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3541:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3545:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3547:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3552:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_13_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3556:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3557:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3559:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3563:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3565:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3569:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3571:25
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3575:21
pub const __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3576:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3577:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3578:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3579:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3580:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3582:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3586:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3588:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3593:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3597:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3598:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3600:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3604:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3606:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3610:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3612:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3617:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3621:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3622:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3624:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3628:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3630:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3634:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3636:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3641:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3645:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3646:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3648:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3652:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3654:25
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3658:21
pub const __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3659:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3660:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3661:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3662:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3663:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3665:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3669:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3671:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3676:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3680:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3681:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3683:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3687:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3689:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3693:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3695:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3700:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3704:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3705:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3707:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3711:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3713:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3717:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3719:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3724:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3728:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_14 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3729:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3730:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3732:25
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3736:21
pub const __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3737:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3738:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_0 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3739:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_0_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3741:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3745:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3746:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3747:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3749:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3753:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3755:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3760:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3764:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3765:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3767:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3771:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3773:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3777:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3779:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3784:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3788:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3789:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3791:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3795:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3797:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3801:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3803:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3808:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3812:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3814:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3818:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3820:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3824:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3826:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3830:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3832:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3836:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3838:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3842:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3844:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3848:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3850:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3854:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3856:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3860:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3862:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_13_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3867:25
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3871:21
pub const __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3872:21
pub const __AVAILABILITY_INTERNAL__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3873:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3874:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3875:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3876:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3878:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3882:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3884:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3888:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3889:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3891:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3895:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3897:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3901:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3903:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3908:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3912:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3913:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3915:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3919:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3921:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3925:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3927:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3932:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3936:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_2_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3937:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3938:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3939:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3941:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3945:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3946:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3948:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3952:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3954:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3958:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3960:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3965:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3969:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3970:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3972:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3976:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3978:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3982:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3984:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3989:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3993:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_3_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3994:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3995:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_10 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3996:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_10_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3997:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_10_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:3999:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_10_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4003:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_10_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4005:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_10_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4010:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4014:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4015:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4017:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4021:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4023:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4027:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4029:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4034:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4038:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4039:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4041:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4045:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4047:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4051:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4053:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4058:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4062:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_13_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4064:25
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_13_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4068:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4069:21
pub const __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4070:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4071:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4072:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4073:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4075:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4079:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4081:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4085:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4087:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4091:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4092:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4094:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4098:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4100:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4104:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4106:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4111:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4115:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_2_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4116:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4117:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4118:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4120:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4124:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4126:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4130:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4131:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4133:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4137:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4139:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4143:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4145:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4150:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4154:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_3_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4155:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4156:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4157:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4159:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4163:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4164:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4166:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4170:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4172:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4176:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4178:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4183:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4187:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_4_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4188:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4189:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4190:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4191:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4193:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11_3 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4197:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11_3_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4199:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4203:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4205:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4210:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4214:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4215:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4217:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4221:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4223:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4227:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4229:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4234:25
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4238:21
pub const __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4239:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4240:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4241:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_1_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4242:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_1_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4244:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_1_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4248:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_1_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4250:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_1_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4254:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_1_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4256:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_1_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4260:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_1_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4261:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4262:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_2_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4263:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_2_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4265:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_2_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4269:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_2_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4271:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_2_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4275:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_2_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4276:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4277:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_4_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4278:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_4_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4280:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_4_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4284:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_4_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4285:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_12 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4286:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_12_1 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4287:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_12_1_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4289:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_12_2 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4293:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_12_2_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4295:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_12_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4299:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_12_4_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4301:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_12_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4306:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4310:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_13_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4312:25
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_13_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4316:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_10_14 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4317:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4318:21
pub const __AVAILABILITY_INTERNAL__MAC_10_12_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4319:21
pub const __AVAILABILITY_INTERNAL__MAC_10_13 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4320:21
pub const __AVAILABILITY_INTERNAL__MAC_10_13_4 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4321:21
pub const __AVAILABILITY_INTERNAL__MAC_10_14 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4322:21
pub const __AVAILABILITY_INTERNAL__MAC_10_14_DEP__MAC_10_14 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4323:21
pub const __AVAILABILITY_INTERNAL__MAC_10_15 = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4324:21
pub const __AVAILABILITY_INTERNAL__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4326:21
pub const __AVAILABILITY_INTERNAL__MAC_NA_DEP__MAC_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4327:21
pub const __AVAILABILITY_INTERNAL__MAC_NA_DEP__MAC_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4328:21
pub const __AVAILABILITY_INTERNAL__IPHONE_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4330:21
pub const __AVAILABILITY_INTERNAL__IPHONE_NA__IPHONE_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4331:21
pub const __AVAILABILITY_INTERNAL__IPHONE_NA_DEP__IPHONE_NA = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4332:21
pub const __AVAILABILITY_INTERNAL__IPHONE_NA_DEP__IPHONE_NA_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4333:21
pub const __AVAILABILITY_INTERNAL__IPHONE_COMPAT_VERSION = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4336:22
pub const __AVAILABILITY_INTERNAL__IPHONE_COMPAT_VERSION_DEP__IPHONE_COMPAT_VERSION = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4337:22
pub const __AVAILABILITY_INTERNAL__IPHONE_COMPAT_VERSION_DEP__IPHONE_COMPAT_VERSION_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternalLegacy.h:4338:22
pub const __API_AVAILABLE_PLATFORM_macos = @compileError("unable to translate macro: undefined identifier `macos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:180:12
pub const __API_DEPRECATED_PLATFORM_macos = @compileError("unable to translate macro: undefined identifier `macos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:181:12
pub const __API_UNAVAILABLE_PLATFORM_macos = @compileError("unable to translate macro: undefined identifier `macos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:182:12
pub const __API_AVAILABLE_PLATFORM_macosx = @compileError("unable to translate macro: undefined identifier `macos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:183:12
pub const __API_DEPRECATED_PLATFORM_macosx = @compileError("unable to translate macro: undefined identifier `macos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:184:12
pub const __API_UNAVAILABLE_PLATFORM_macosx = @compileError("unable to translate macro: undefined identifier `macos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:185:12
pub const __API_AVAILABLE_PLATFORM_ios = @compileError("unable to translate macro: undefined identifier `ios`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:186:12
pub const __API_DEPRECATED_PLATFORM_ios = @compileError("unable to translate macro: undefined identifier `ios`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:187:12
pub const __API_UNAVAILABLE_PLATFORM_ios = @compileError("unable to translate macro: undefined identifier `ios`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:188:12
pub const __API_AVAILABLE_PLATFORM_macCatalyst = @compileError("unable to translate macro: undefined identifier `macCatalyst`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:189:12
pub const __API_DEPRECATED_PLATFORM_macCatalyst = @compileError("unable to translate macro: undefined identifier `macCatalyst`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:190:12
pub const __API_UNAVAILABLE_PLATFORM_macCatalyst = @compileError("unable to translate macro: undefined identifier `macCatalyst`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:191:12
pub const __API_AVAILABLE_PLATFORM_watchos = @compileError("unable to translate macro: undefined identifier `watchos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:195:12
pub const __API_DEPRECATED_PLATFORM_watchos = @compileError("unable to translate macro: undefined identifier `watchos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:196:12
pub const __API_UNAVAILABLE_PLATFORM_watchos = @compileError("unable to translate macro: undefined identifier `watchos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:197:12
pub const __API_AVAILABLE_PLATFORM_tvos = @compileError("unable to translate macro: undefined identifier `tvos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:198:12
pub const __API_DEPRECATED_PLATFORM_tvos = @compileError("unable to translate macro: undefined identifier `tvos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:199:12
pub const __API_UNAVAILABLE_PLATFORM_tvos = @compileError("unable to translate macro: undefined identifier `tvos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:200:12
pub const __API_AVAILABLE_PLATFORM_driverkit = @compileError("unable to translate macro: undefined identifier `driverkit`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:204:12
pub const __API_DEPRECATED_PLATFORM_driverkit = @compileError("unable to translate macro: undefined identifier `driverkit`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:205:12
pub const __API_UNAVAILABLE_PLATFORM_driverkit = @compileError("unable to translate macro: undefined identifier `driverkit`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:206:12
pub const __API_AVAILABLE_PLATFORM_visionos = @compileError("unable to translate macro: undefined identifier `visionos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:207:12
pub const __API_DEPRECATED_PLATFORM_visionos = @compileError("unable to translate macro: undefined identifier `visionos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:208:12
pub const __API_UNAVAILABLE_PLATFORM_visionos = @compileError("unable to translate macro: undefined identifier `visionos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:209:12
pub const __API_AVAILABLE_PLATFORM_xros = @compileError("unable to translate macro: undefined identifier `visionos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:210:12
pub const __API_DEPRECATED_PLATFORM_xros = @compileError("unable to translate macro: undefined identifier `visionos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:211:12
pub const __API_UNAVAILABLE_PLATFORM_xros = @compileError("unable to translate macro: undefined identifier `visionos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:212:12
pub const __API_APPLY_TO = @compileError("unable to translate macro: undefined identifier `any`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:219:11
pub inline fn __API_RANGE_STRINGIFY(x: anytype) @TypeOf(__API_RANGE_STRINGIFY2(x)) {
    _ = &x;
    return __API_RANGE_STRINGIFY2(x);
}
pub const __API_RANGE_STRINGIFY2 = @compileError("unable to translate C expr: unexpected token '#'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:221:11
pub const __API_A = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:235:13
pub inline fn __API_AVAILABLE0(arg0: anytype) @TypeOf(__API_A(arg0)) {
    _ = &arg0;
    return __API_A(arg0);
}
pub inline fn __API_AVAILABLE1(arg0: anytype, arg1: anytype) @TypeOf(__API_A(arg0) ++ __API_A(arg1)) {
    _ = &arg0;
    _ = &arg1;
    return __API_A(arg0) ++ __API_A(arg1);
}
pub inline fn __API_AVAILABLE2(arg0: anytype, arg1: anytype, arg2: anytype) @TypeOf(__API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    return __API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2);
}
pub inline fn __API_AVAILABLE3(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(__API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    return __API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3);
}
pub inline fn __API_AVAILABLE4(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(__API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    return __API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4);
}
pub inline fn __API_AVAILABLE5(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(__API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4) ++ __API_A(arg5)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    return __API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4) ++ __API_A(arg5);
}
pub inline fn __API_AVAILABLE6(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(__API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4) ++ __API_A(arg5) ++ __API_A(arg6)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    return __API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4) ++ __API_A(arg5) ++ __API_A(arg6);
}
pub inline fn __API_AVAILABLE7(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(__API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4) ++ __API_A(arg5) ++ __API_A(arg6) ++ __API_A(arg7)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    return __API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4) ++ __API_A(arg5) ++ __API_A(arg6) ++ __API_A(arg7);
}
pub inline fn __API_AVAILABLE8(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(__API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4) ++ __API_A(arg5) ++ __API_A(arg6) ++ __API_A(arg7) ++ __API_A(arg8)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    _ = &arg8;
    return __API_A(arg0) ++ __API_A(arg1) ++ __API_A(arg2) ++ __API_A(arg3) ++ __API_A(arg4) ++ __API_A(arg5) ++ __API_A(arg6) ++ __API_A(arg7) ++ __API_A(arg8);
}
pub const __API_AVAILABLE_GET_MACRO = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:246:13
pub const __API_A_BEGIN = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:248:13
pub inline fn __API_AVAILABLE_BEGIN0(arg0: anytype) @TypeOf(__API_A_BEGIN(arg0)) {
    _ = &arg0;
    return __API_A_BEGIN(arg0);
}
pub inline fn __API_AVAILABLE_BEGIN1(arg0: anytype, arg1: anytype) @TypeOf(__API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1)) {
    _ = &arg0;
    _ = &arg1;
    return __API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1);
}
pub inline fn __API_AVAILABLE_BEGIN2(arg0: anytype, arg1: anytype, arg2: anytype) @TypeOf(__API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    return __API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2);
}
pub inline fn __API_AVAILABLE_BEGIN3(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(__API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    return __API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3);
}
pub inline fn __API_AVAILABLE_BEGIN4(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(__API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    return __API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4);
}
pub inline fn __API_AVAILABLE_BEGIN5(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(__API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4) ++ __API_A_BEGIN(arg5)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    return __API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4) ++ __API_A_BEGIN(arg5);
}
pub inline fn __API_AVAILABLE_BEGIN6(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(__API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4) ++ __API_A_BEGIN(arg5) ++ __API_A_BEGIN(arg6)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    return __API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4) ++ __API_A_BEGIN(arg5) ++ __API_A_BEGIN(arg6);
}
pub inline fn __API_AVAILABLE_BEGIN7(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(__API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4) ++ __API_A_BEGIN(arg5) ++ __API_A_BEGIN(arg6) ++ __API_A_BEGIN(arg7)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    return __API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4) ++ __API_A_BEGIN(arg5) ++ __API_A_BEGIN(arg6) ++ __API_A_BEGIN(arg7);
}
pub inline fn __API_AVAILABLE_BEGIN8(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(__API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4) ++ __API_A_BEGIN(arg5) ++ __API_A_BEGIN(arg6) ++ __API_A_BEGIN(arg7) ++ __API_A_BEGIN(arg8)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    _ = &arg8;
    return __API_A_BEGIN(arg0) ++ __API_A_BEGIN(arg1) ++ __API_A_BEGIN(arg2) ++ __API_A_BEGIN(arg3) ++ __API_A_BEGIN(arg4) ++ __API_A_BEGIN(arg5) ++ __API_A_BEGIN(arg6) ++ __API_A_BEGIN(arg7) ++ __API_A_BEGIN(arg8);
}
pub const __API_AVAILABLE_BEGIN_GET_MACRO = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:259:13
pub const __API_D = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:263:13
pub inline fn __API_DEPRECATED_MSG0(msg: anytype, arg0: anytype) @TypeOf(__API_D(msg, arg0)) {
    _ = &msg;
    _ = &arg0;
    return __API_D(msg, arg0);
}
pub inline fn __API_DEPRECATED_MSG1(msg: anytype, arg0: anytype, arg1: anytype) @TypeOf(__API_D(msg, arg0) ++ __API_D(msg, arg1)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    return __API_D(msg, arg0) ++ __API_D(msg, arg1);
}
pub inline fn __API_DEPRECATED_MSG2(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype) @TypeOf(__API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    return __API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2);
}
pub inline fn __API_DEPRECATED_MSG3(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(__API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    return __API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3);
}
pub inline fn __API_DEPRECATED_MSG4(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(__API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    return __API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4);
}
pub inline fn __API_DEPRECATED_MSG5(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(__API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4) ++ __API_D(msg, arg5)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    return __API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4) ++ __API_D(msg, arg5);
}
pub inline fn __API_DEPRECATED_MSG6(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(__API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4) ++ __API_D(msg, arg5) ++ __API_D(msg, arg6)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    return __API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4) ++ __API_D(msg, arg5) ++ __API_D(msg, arg6);
}
pub inline fn __API_DEPRECATED_MSG7(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(__API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4) ++ __API_D(msg, arg5) ++ __API_D(msg, arg6) ++ __API_D(msg, arg7)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    return __API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4) ++ __API_D(msg, arg5) ++ __API_D(msg, arg6) ++ __API_D(msg, arg7);
}
pub inline fn __API_DEPRECATED_MSG8(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(__API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4) ++ __API_D(msg, arg5) ++ __API_D(msg, arg6) ++ __API_D(msg, arg7) ++ __API_D(msg, arg8)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    _ = &arg8;
    return __API_D(msg, arg0) ++ __API_D(msg, arg1) ++ __API_D(msg, arg2) ++ __API_D(msg, arg3) ++ __API_D(msg, arg4) ++ __API_D(msg, arg5) ++ __API_D(msg, arg6) ++ __API_D(msg, arg7) ++ __API_D(msg, arg8);
}
pub const __API_DEPRECATED_MSG_GET_MACRO = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:274:13
pub const __API_D_BEGIN = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:276:13
pub inline fn __API_DEPRECATED_BEGIN0(msg: anytype, arg0: anytype) @TypeOf(__API_D_BEGIN(msg, arg0)) {
    _ = &msg;
    _ = &arg0;
    return __API_D_BEGIN(msg, arg0);
}
pub inline fn __API_DEPRECATED_BEGIN1(msg: anytype, arg0: anytype, arg1: anytype) @TypeOf(__API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    return __API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1);
}
pub inline fn __API_DEPRECATED_BEGIN2(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype) @TypeOf(__API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    return __API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2);
}
pub inline fn __API_DEPRECATED_BEGIN3(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(__API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    return __API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3);
}
pub inline fn __API_DEPRECATED_BEGIN4(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(__API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    return __API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4);
}
pub inline fn __API_DEPRECATED_BEGIN5(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(__API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4) ++ __API_D_BEGIN(msg, arg5)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    return __API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4) ++ __API_D_BEGIN(msg, arg5);
}
pub inline fn __API_DEPRECATED_BEGIN6(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(__API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4) ++ __API_D_BEGIN(msg, arg5) ++ __API_D_BEGIN(msg, arg6)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    return __API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4) ++ __API_D_BEGIN(msg, arg5) ++ __API_D_BEGIN(msg, arg6);
}
pub inline fn __API_DEPRECATED_BEGIN7(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(__API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4) ++ __API_D_BEGIN(msg, arg5) ++ __API_D_BEGIN(msg, arg6) ++ __API_D_BEGIN(msg, arg7)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    return __API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4) ++ __API_D_BEGIN(msg, arg5) ++ __API_D_BEGIN(msg, arg6) ++ __API_D_BEGIN(msg, arg7);
}
pub inline fn __API_DEPRECATED_BEGIN8(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(__API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4) ++ __API_D_BEGIN(msg, arg5) ++ __API_D_BEGIN(msg, arg6) ++ __API_D_BEGIN(msg, arg7) ++ __API_D_BEGIN(msg, arg8)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    _ = &arg8;
    return __API_D_BEGIN(msg, arg0) ++ __API_D_BEGIN(msg, arg1) ++ __API_D_BEGIN(msg, arg2) ++ __API_D_BEGIN(msg, arg3) ++ __API_D_BEGIN(msg, arg4) ++ __API_D_BEGIN(msg, arg5) ++ __API_D_BEGIN(msg, arg6) ++ __API_D_BEGIN(msg, arg7) ++ __API_D_BEGIN(msg, arg8);
}
pub const __API_DEPRECATED_BEGIN_GET_MACRO = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:287:13
pub const __API_R = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:290:17
pub inline fn __API_DEPRECATED_REP0(msg: anytype, arg0: anytype) @TypeOf(__API_R(msg, arg0)) {
    _ = &msg;
    _ = &arg0;
    return __API_R(msg, arg0);
}
pub inline fn __API_DEPRECATED_REP1(msg: anytype, arg0: anytype, arg1: anytype) @TypeOf(__API_R(msg, arg0) ++ __API_R(msg, arg1)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    return __API_R(msg, arg0) ++ __API_R(msg, arg1);
}
pub inline fn __API_DEPRECATED_REP2(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype) @TypeOf(__API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    return __API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2);
}
pub inline fn __API_DEPRECATED_REP3(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(__API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    return __API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3);
}
pub inline fn __API_DEPRECATED_REP4(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(__API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    return __API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4);
}
pub inline fn __API_DEPRECATED_REP5(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(__API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4) ++ __API_R(msg, arg5)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    return __API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4) ++ __API_R(msg, arg5);
}
pub inline fn __API_DEPRECATED_REP6(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(__API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4) ++ __API_R(msg, arg5) ++ __API_R(msg, arg6)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    return __API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4) ++ __API_R(msg, arg5) ++ __API_R(msg, arg6);
}
pub inline fn __API_DEPRECATED_REP7(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(__API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4) ++ __API_R(msg, arg5) ++ __API_R(msg, arg6) ++ __API_R(msg, arg7)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    return __API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4) ++ __API_R(msg, arg5) ++ __API_R(msg, arg6) ++ __API_R(msg, arg7);
}
pub inline fn __API_DEPRECATED_REP8(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(__API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4) ++ __API_R(msg, arg5) ++ __API_R(msg, arg6) ++ __API_R(msg, arg7) ++ __API_R(msg, arg8)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    _ = &arg8;
    return __API_R(msg, arg0) ++ __API_R(msg, arg1) ++ __API_R(msg, arg2) ++ __API_R(msg, arg3) ++ __API_R(msg, arg4) ++ __API_R(msg, arg5) ++ __API_R(msg, arg6) ++ __API_R(msg, arg7) ++ __API_R(msg, arg8);
}
pub const __API_DEPRECATED_REP_GET_MACRO = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:304:13
pub const __API_R_BEGIN = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:307:17
pub inline fn __API_DEPRECATED_BEGIN_REP0(msg: anytype, arg0: anytype) @TypeOf(__API_R_BEGIN(msg, arg0)) {
    _ = &msg;
    _ = &arg0;
    return __API_R_BEGIN(msg, arg0);
}
pub inline fn __API_DEPRECATED_BEGIN_REP1(msg: anytype, arg0: anytype, arg1: anytype) @TypeOf(__API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    return __API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1);
}
pub inline fn __API_DEPRECATED_BEGIN_REP2(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype) @TypeOf(__API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    return __API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2);
}
pub inline fn __API_DEPRECATED_BEGIN_REP3(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(__API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    return __API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3);
}
pub inline fn __API_DEPRECATED_BEGIN_REP4(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(__API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    return __API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4);
}
pub inline fn __API_DEPRECATED_BEGIN_REP5(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(__API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4) ++ __API_R_BEGIN(msg, arg5)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    return __API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4) ++ __API_R_BEGIN(msg, arg5);
}
pub inline fn __API_DEPRECATED_BEGIN_REP6(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(__API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4) ++ __API_R_BEGIN(msg, arg5) ++ __API_R_BEGIN(msg, arg6)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    return __API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4) ++ __API_R_BEGIN(msg, arg5) ++ __API_R_BEGIN(msg, arg6);
}
pub inline fn __API_DEPRECATED_BEGIN_REP7(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(__API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4) ++ __API_R_BEGIN(msg, arg5) ++ __API_R_BEGIN(msg, arg6) ++ __API_R_BEGIN(msg, arg7)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    return __API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4) ++ __API_R_BEGIN(msg, arg5) ++ __API_R_BEGIN(msg, arg6) ++ __API_R_BEGIN(msg, arg7);
}
pub inline fn __API_DEPRECATED_BEGIN_REP8(msg: anytype, arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(__API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4) ++ __API_R_BEGIN(msg, arg5) ++ __API_R_BEGIN(msg, arg6) ++ __API_R_BEGIN(msg, arg7) ++ __API_R_BEGIN(msg, arg8)) {
    _ = &msg;
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    _ = &arg8;
    return __API_R_BEGIN(msg, arg0) ++ __API_R_BEGIN(msg, arg1) ++ __API_R_BEGIN(msg, arg2) ++ __API_R_BEGIN(msg, arg3) ++ __API_R_BEGIN(msg, arg4) ++ __API_R_BEGIN(msg, arg5) ++ __API_R_BEGIN(msg, arg6) ++ __API_R_BEGIN(msg, arg7) ++ __API_R_BEGIN(msg, arg8);
}
pub const __API_DEPRECATED_BEGIN_REP_GET_MACRO = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:321:13
pub const __API_U = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:332:13
pub inline fn __API_UNAVAILABLE0(arg0: anytype) @TypeOf(__API_U(arg0)) {
    _ = &arg0;
    return __API_U(arg0);
}
pub inline fn __API_UNAVAILABLE1(arg0: anytype, arg1: anytype) @TypeOf(__API_U(arg0) ++ __API_U(arg1)) {
    _ = &arg0;
    _ = &arg1;
    return __API_U(arg0) ++ __API_U(arg1);
}
pub inline fn __API_UNAVAILABLE2(arg0: anytype, arg1: anytype, arg2: anytype) @TypeOf(__API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    return __API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2);
}
pub inline fn __API_UNAVAILABLE3(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(__API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    return __API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3);
}
pub inline fn __API_UNAVAILABLE4(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(__API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    return __API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4);
}
pub inline fn __API_UNAVAILABLE5(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(__API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4) ++ __API_U(arg5)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    return __API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4) ++ __API_U(arg5);
}
pub inline fn __API_UNAVAILABLE6(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(__API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4) ++ __API_U(arg5) ++ __API_U(arg6)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    return __API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4) ++ __API_U(arg5) ++ __API_U(arg6);
}
pub inline fn __API_UNAVAILABLE7(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(__API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4) ++ __API_U(arg5) ++ __API_U(arg6) ++ __API_U(arg7)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    return __API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4) ++ __API_U(arg5) ++ __API_U(arg6) ++ __API_U(arg7);
}
pub inline fn __API_UNAVAILABLE8(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(__API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4) ++ __API_U(arg5) ++ __API_U(arg6) ++ __API_U(arg7) ++ __API_U(arg8)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    _ = &arg8;
    return __API_U(arg0) ++ __API_U(arg1) ++ __API_U(arg2) ++ __API_U(arg3) ++ __API_U(arg4) ++ __API_U(arg5) ++ __API_U(arg6) ++ __API_U(arg7) ++ __API_U(arg8);
}
pub const __API_UNAVAILABLE_GET_MACRO = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:343:13
pub const __API_U_BEGIN = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:345:13
pub inline fn __API_UNAVAILABLE_BEGIN0(arg0: anytype) @TypeOf(__API_U_BEGIN(arg0)) {
    _ = &arg0;
    return __API_U_BEGIN(arg0);
}
pub inline fn __API_UNAVAILABLE_BEGIN1(arg0: anytype, arg1: anytype) @TypeOf(__API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1)) {
    _ = &arg0;
    _ = &arg1;
    return __API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1);
}
pub inline fn __API_UNAVAILABLE_BEGIN2(arg0: anytype, arg1: anytype, arg2: anytype) @TypeOf(__API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    return __API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2);
}
pub inline fn __API_UNAVAILABLE_BEGIN3(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(__API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    return __API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3);
}
pub inline fn __API_UNAVAILABLE_BEGIN4(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(__API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    return __API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4);
}
pub inline fn __API_UNAVAILABLE_BEGIN5(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(__API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4) ++ __API_U_BEGIN(arg5)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    return __API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4) ++ __API_U_BEGIN(arg5);
}
pub inline fn __API_UNAVAILABLE_BEGIN6(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(__API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4) ++ __API_U_BEGIN(arg5) ++ __API_U_BEGIN(arg6)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    return __API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4) ++ __API_U_BEGIN(arg5) ++ __API_U_BEGIN(arg6);
}
pub inline fn __API_UNAVAILABLE_BEGIN7(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(__API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4) ++ __API_U_BEGIN(arg5) ++ __API_U_BEGIN(arg6) ++ __API_U_BEGIN(arg7)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    return __API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4) ++ __API_U_BEGIN(arg5) ++ __API_U_BEGIN(arg6) ++ __API_U_BEGIN(arg7);
}
pub inline fn __API_UNAVAILABLE_BEGIN8(arg0: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(__API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4) ++ __API_U_BEGIN(arg5) ++ __API_U_BEGIN(arg6) ++ __API_U_BEGIN(arg7) ++ __API_U_BEGIN(arg8)) {
    _ = &arg0;
    _ = &arg1;
    _ = &arg2;
    _ = &arg3;
    _ = &arg4;
    _ = &arg5;
    _ = &arg6;
    _ = &arg7;
    _ = &arg8;
    return __API_U_BEGIN(arg0) ++ __API_U_BEGIN(arg1) ++ __API_U_BEGIN(arg2) ++ __API_U_BEGIN(arg3) ++ __API_U_BEGIN(arg4) ++ __API_U_BEGIN(arg5) ++ __API_U_BEGIN(arg6) ++ __API_U_BEGIN(arg7) ++ __API_U_BEGIN(arg8);
}
pub const __API_UNAVAILABLE_BEGIN_GET_MACRO = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:356:13
pub const __swift_compiler_version_at_least = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:378:13
pub const __SPI_AVAILABLE = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:386:11
pub const __SPI_AVAILABLE_BEGIN = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:390:11
pub const __SPI_AVAILABLE_END = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/AvailabilityInternal.h:394:11
pub const __OSX_AVAILABLE_STARTING = @compileError("unable to translate macro: undefined identifier `__AVAILABILITY_INTERNAL`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:213:17
pub const __OSX_AVAILABLE_BUT_DEPRECATED = @compileError("unable to translate macro: undefined identifier `__AVAILABILITY_INTERNAL`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:214:17
pub const __OSX_AVAILABLE_BUT_DEPRECATED_MSG = @compileError("unable to translate macro: undefined identifier `__AVAILABILITY_INTERNAL`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:216:17
pub const __OS_AVAILABILITY = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:239:13
pub const __OS_AVAILABILITY_MSG = @compileError("unable to translate macro: undefined identifier `availability`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:240:13
pub const __OSX_EXTENSION_UNAVAILABLE = @compileError("unable to translate macro: undefined identifier `macosx_app_extension`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:257:13
pub const __IOS_EXTENSION_UNAVAILABLE = @compileError("unable to translate macro: undefined identifier `ios_app_extension`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:258:13
pub inline fn __OS_EXTENSION_UNAVAILABLE(_msg: anytype) @TypeOf(__OSX_EXTENSION_UNAVAILABLE(_msg) ++ __IOS_EXTENSION_UNAVAILABLE(_msg)) {
    _ = &_msg;
    return __OSX_EXTENSION_UNAVAILABLE(_msg) ++ __IOS_EXTENSION_UNAVAILABLE(_msg);
}
pub const __OSX_UNAVAILABLE = @compileError("unable to translate macro: undefined identifier `macosx`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:275:13
pub const __OSX_AVAILABLE = @compileError("unable to translate macro: undefined identifier `macosx`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:276:13
pub const __OSX_DEPRECATED = @compileError("unable to translate macro: undefined identifier `macosx`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:277:13
pub const __IOS_UNAVAILABLE = @compileError("unable to translate macro: undefined identifier `ios`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:301:13
pub const __IOS_PROHIBITED = @compileError("unable to translate macro: undefined identifier `ios`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:303:15
pub const __IOS_AVAILABLE = @compileError("unable to translate macro: undefined identifier `ios`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:305:13
pub const __IOS_DEPRECATED = @compileError("unable to translate macro: undefined identifier `ios`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:306:13
pub const __TVOS_UNAVAILABLE = @compileError("unable to translate macro: undefined identifier `tvos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:330:13
pub const __TVOS_PROHIBITED = @compileError("unable to translate macro: undefined identifier `tvos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:332:15
pub const __TVOS_AVAILABLE = @compileError("unable to translate macro: undefined identifier `tvos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:334:13
pub const __TVOS_DEPRECATED = @compileError("unable to translate macro: undefined identifier `tvos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:335:13
pub const __WATCHOS_UNAVAILABLE = @compileError("unable to translate macro: undefined identifier `watchos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:359:13
pub const __WATCHOS_PROHIBITED = @compileError("unable to translate macro: undefined identifier `watchos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:361:15
pub const __WATCHOS_AVAILABLE = @compileError("unable to translate macro: undefined identifier `watchos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:363:13
pub const __WATCHOS_DEPRECATED = @compileError("unable to translate macro: undefined identifier `watchos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:364:13
pub const __SWIFT_UNAVAILABLE = @compileError("unable to translate macro: undefined identifier `swift`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:387:13
pub const __SWIFT_UNAVAILABLE_MSG = @compileError("unable to translate macro: undefined identifier `swift`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:388:13
pub const __API_AVAILABLE = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:431:13
pub const __API_AVAILABLE_BEGIN = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:433:13
pub const __API_AVAILABLE_END = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:434:13
pub const __API_DEPRECATED = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:452:13
pub const __API_DEPRECATED_WITH_REPLACEMENT = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:453:13
pub const __API_DEPRECATED_BEGIN = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:455:13
pub const __API_DEPRECATED_END = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:456:13
pub const __API_DEPRECATED_WITH_REPLACEMENT_BEGIN = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:458:13
pub const __API_DEPRECATED_WITH_REPLACEMENT_END = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:459:13
pub const __API_UNAVAILABLE = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:469:13
pub const __API_UNAVAILABLE_BEGIN = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:471:13
pub const __API_UNAVAILABLE_END = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:472:13
pub const __SPI_DEPRECATED = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:545:11
pub const __SPI_DEPRECATED_WITH_REPLACEMENT = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/Availability.h:549:11
pub const __DARWIN_FD_SETSIZE = @as(c_int, 1024);
pub const __DARWIN_NBBY = @as(c_int, 8);
pub const __DARWIN_NFDBITS = @import("std").zig.c_translation.sizeof(__int32_t) * __DARWIN_NBBY;
pub inline fn __DARWIN_howmany(x: anytype, y: anytype) @TypeOf(if (@import("std").zig.c_translation.MacroArithmetic.rem(x, y) == @as(c_int, 0)) @import("std").zig.c_translation.MacroArithmetic.div(x, y) else @import("std").zig.c_translation.MacroArithmetic.div(x, y) + @as(c_int, 1)) {
    _ = &x;
    _ = &y;
    return if (@import("std").zig.c_translation.MacroArithmetic.rem(x, y) == @as(c_int, 0)) @import("std").zig.c_translation.MacroArithmetic.div(x, y) else @import("std").zig.c_translation.MacroArithmetic.div(x, y) + @as(c_int, 1);
}
pub inline fn __DARWIN_FD_SET(n: anytype, p: anytype) @TypeOf(__darwin_fd_set(n, p)) {
    _ = &n;
    _ = &p;
    return __darwin_fd_set(n, p);
}
pub inline fn __DARWIN_FD_CLR(n: anytype, p: anytype) @TypeOf(__darwin_fd_clr(n, p)) {
    _ = &n;
    _ = &p;
    return __darwin_fd_clr(n, p);
}
pub inline fn __DARWIN_FD_ISSET(n: anytype, p: anytype) @TypeOf(__darwin_fd_isset(n, p)) {
    _ = &n;
    _ = &p;
    return __darwin_fd_isset(n, p);
}
pub const __DARWIN_FD_ZERO = @compileError("unable to translate macro: undefined identifier `__builtin_bzero`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_types/_fd_def.h:115:9
pub const __DARWIN_FD_COPY = @compileError("unable to translate C expr: unexpected token '*'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/_types/_fd_def.h:120:9
pub const NBBY = __DARWIN_NBBY;
pub const NFDBITS = __DARWIN_NFDBITS;
pub inline fn howmany(x: anytype, y: anytype) @TypeOf(__DARWIN_howmany(x, y)) {
    _ = &x;
    _ = &y;
    return __DARWIN_howmany(x, y);
}
pub const FD_SETSIZE = __DARWIN_FD_SETSIZE;
pub inline fn FD_SET(n: anytype, p: anytype) @TypeOf(__DARWIN_FD_SET(n, p)) {
    _ = &n;
    _ = &p;
    return __DARWIN_FD_SET(n, p);
}
pub inline fn FD_CLR(n: anytype, p: anytype) @TypeOf(__DARWIN_FD_CLR(n, p)) {
    _ = &n;
    _ = &p;
    return __DARWIN_FD_CLR(n, p);
}
pub inline fn FD_ZERO(p: anytype) @TypeOf(__DARWIN_FD_ZERO(p)) {
    _ = &p;
    return __DARWIN_FD_ZERO(p);
}
pub inline fn FD_ISSET(n: anytype, p: anytype) @TypeOf(__DARWIN_FD_ISSET(n, p)) {
    _ = &n;
    _ = &p;
    return __DARWIN_FD_ISSET(n, p);
}
pub inline fn FD_COPY(f: anytype, t: anytype) @TypeOf(__DARWIN_FD_COPY(f, t)) {
    _ = &f;
    _ = &t;
    return __DARWIN_FD_COPY(f, t);
}
pub const _PTHREAD_ATTR_T = "";
pub const _PTHREAD_COND_T = "";
pub const _PTHREAD_CONDATTR_T = "";
pub const _PTHREAD_MUTEX_T = "";
pub const _PTHREAD_MUTEXATTR_T = "";
pub const _PTHREAD_ONCE_T = "";
pub const _PTHREAD_RWLOCK_T = "";
pub const _PTHREAD_RWLOCKATTR_T = "";
pub const _PTHREAD_T = "";
pub const _PTHREAD_KEY_T = "";
pub const _FSBLKCNT_T = "";
pub const _FSFILCNT_T = "";
pub const ossl_ssize_t = isize;
pub const OSSL_SSIZE_MAX = @import("std").zig.c_translation.cast(isize, SIZE_MAX >> @as(c_int, 1));
pub const __owur = "";
pub const OPENSSL_NO_INTTYPES_H = "";
pub const OPENSSL_NO_STDINT_H = "";
pub const __CLANG_INTTYPES_H = "";
pub const _INTTYPES_H_ = "";
pub const __PRI_8_LENGTH_MODIFIER__ = "hh";
pub const __PRI_64_LENGTH_MODIFIER__ = "ll";
pub const __SCN_64_LENGTH_MODIFIER__ = "ll";
pub const __PRI_MAX_LENGTH_MODIFIER__ = "j";
pub const __SCN_MAX_LENGTH_MODIFIER__ = "j";
pub const PRId8 = __PRI_8_LENGTH_MODIFIER__ ++ "d";
pub const PRIi8 = __PRI_8_LENGTH_MODIFIER__ ++ "i";
pub const PRIo8 = __PRI_8_LENGTH_MODIFIER__ ++ "o";
pub const PRIu8 = __PRI_8_LENGTH_MODIFIER__ ++ "u";
pub const PRIx8 = __PRI_8_LENGTH_MODIFIER__ ++ "x";
pub const PRIX8 = __PRI_8_LENGTH_MODIFIER__ ++ "X";
pub const PRId16 = "hd";
pub const PRIi16 = "hi";
pub const PRIo16 = "ho";
pub const PRIu16 = "hu";
pub const PRIx16 = "hx";
pub const PRIX16 = "hX";
pub const PRId32 = "d";
pub const PRIi32 = "i";
pub const PRIo32 = "o";
pub const PRIu32 = "u";
pub const PRIx32 = "x";
pub const PRIX32 = "X";
pub const PRId64 = __PRI_64_LENGTH_MODIFIER__ ++ "d";
pub const PRIi64 = __PRI_64_LENGTH_MODIFIER__ ++ "i";
pub const PRIo64 = __PRI_64_LENGTH_MODIFIER__ ++ "o";
pub const PRIu64 = __PRI_64_LENGTH_MODIFIER__ ++ "u";
pub const PRIx64 = __PRI_64_LENGTH_MODIFIER__ ++ "x";
pub const PRIX64 = __PRI_64_LENGTH_MODIFIER__ ++ "X";
pub const PRIdLEAST8 = PRId8;
pub const PRIiLEAST8 = PRIi8;
pub const PRIoLEAST8 = PRIo8;
pub const PRIuLEAST8 = PRIu8;
pub const PRIxLEAST8 = PRIx8;
pub const PRIXLEAST8 = PRIX8;
pub const PRIdLEAST16 = PRId16;
pub const PRIiLEAST16 = PRIi16;
pub const PRIoLEAST16 = PRIo16;
pub const PRIuLEAST16 = PRIu16;
pub const PRIxLEAST16 = PRIx16;
pub const PRIXLEAST16 = PRIX16;
pub const PRIdLEAST32 = PRId32;
pub const PRIiLEAST32 = PRIi32;
pub const PRIoLEAST32 = PRIo32;
pub const PRIuLEAST32 = PRIu32;
pub const PRIxLEAST32 = PRIx32;
pub const PRIXLEAST32 = PRIX32;
pub const PRIdLEAST64 = PRId64;
pub const PRIiLEAST64 = PRIi64;
pub const PRIoLEAST64 = PRIo64;
pub const PRIuLEAST64 = PRIu64;
pub const PRIxLEAST64 = PRIx64;
pub const PRIXLEAST64 = PRIX64;
pub const PRIdFAST8 = PRId8;
pub const PRIiFAST8 = PRIi8;
pub const PRIoFAST8 = PRIo8;
pub const PRIuFAST8 = PRIu8;
pub const PRIxFAST8 = PRIx8;
pub const PRIXFAST8 = PRIX8;
pub const PRIdFAST16 = PRId16;
pub const PRIiFAST16 = PRIi16;
pub const PRIoFAST16 = PRIo16;
pub const PRIuFAST16 = PRIu16;
pub const PRIxFAST16 = PRIx16;
pub const PRIXFAST16 = PRIX16;
pub const PRIdFAST32 = PRId32;
pub const PRIiFAST32 = PRIi32;
pub const PRIoFAST32 = PRIo32;
pub const PRIuFAST32 = PRIu32;
pub const PRIxFAST32 = PRIx32;
pub const PRIXFAST32 = PRIX32;
pub const PRIdFAST64 = PRId64;
pub const PRIiFAST64 = PRIi64;
pub const PRIoFAST64 = PRIo64;
pub const PRIuFAST64 = PRIu64;
pub const PRIxFAST64 = PRIx64;
pub const PRIXFAST64 = PRIX64;
pub const PRIdPTR = "ld";
pub const PRIiPTR = "li";
pub const PRIoPTR = "lo";
pub const PRIuPTR = "lu";
pub const PRIxPTR = "lx";
pub const PRIXPTR = "lX";
pub const PRIdMAX = __PRI_MAX_LENGTH_MODIFIER__ ++ "d";
pub const PRIiMAX = __PRI_MAX_LENGTH_MODIFIER__ ++ "i";
pub const PRIoMAX = __PRI_MAX_LENGTH_MODIFIER__ ++ "o";
pub const PRIuMAX = __PRI_MAX_LENGTH_MODIFIER__ ++ "u";
pub const PRIxMAX = __PRI_MAX_LENGTH_MODIFIER__ ++ "x";
pub const PRIXMAX = __PRI_MAX_LENGTH_MODIFIER__ ++ "X";
pub const SCNd8 = __PRI_8_LENGTH_MODIFIER__ ++ "d";
pub const SCNi8 = __PRI_8_LENGTH_MODIFIER__ ++ "i";
pub const SCNo8 = __PRI_8_LENGTH_MODIFIER__ ++ "o";
pub const SCNu8 = __PRI_8_LENGTH_MODIFIER__ ++ "u";
pub const SCNx8 = __PRI_8_LENGTH_MODIFIER__ ++ "x";
pub const SCNd16 = "hd";
pub const SCNi16 = "hi";
pub const SCNo16 = "ho";
pub const SCNu16 = "hu";
pub const SCNx16 = "hx";
pub const SCNd32 = "d";
pub const SCNi32 = "i";
pub const SCNo32 = "o";
pub const SCNu32 = "u";
pub const SCNx32 = "x";
pub const SCNd64 = __SCN_64_LENGTH_MODIFIER__ ++ "d";
pub const SCNi64 = __SCN_64_LENGTH_MODIFIER__ ++ "i";
pub const SCNo64 = __SCN_64_LENGTH_MODIFIER__ ++ "o";
pub const SCNu64 = __SCN_64_LENGTH_MODIFIER__ ++ "u";
pub const SCNx64 = __SCN_64_LENGTH_MODIFIER__ ++ "x";
pub const SCNdLEAST8 = SCNd8;
pub const SCNiLEAST8 = SCNi8;
pub const SCNoLEAST8 = SCNo8;
pub const SCNuLEAST8 = SCNu8;
pub const SCNxLEAST8 = SCNx8;
pub const SCNdLEAST16 = SCNd16;
pub const SCNiLEAST16 = SCNi16;
pub const SCNoLEAST16 = SCNo16;
pub const SCNuLEAST16 = SCNu16;
pub const SCNxLEAST16 = SCNx16;
pub const SCNdLEAST32 = SCNd32;
pub const SCNiLEAST32 = SCNi32;
pub const SCNoLEAST32 = SCNo32;
pub const SCNuLEAST32 = SCNu32;
pub const SCNxLEAST32 = SCNx32;
pub const SCNdLEAST64 = SCNd64;
pub const SCNiLEAST64 = SCNi64;
pub const SCNoLEAST64 = SCNo64;
pub const SCNuLEAST64 = SCNu64;
pub const SCNxLEAST64 = SCNx64;
pub const SCNdFAST8 = SCNd8;
pub const SCNiFAST8 = SCNi8;
pub const SCNoFAST8 = SCNo8;
pub const SCNuFAST8 = SCNu8;
pub const SCNxFAST8 = SCNx8;
pub const SCNdFAST16 = SCNd16;
pub const SCNiFAST16 = SCNi16;
pub const SCNoFAST16 = SCNo16;
pub const SCNuFAST16 = SCNu16;
pub const SCNxFAST16 = SCNx16;
pub const SCNdFAST32 = SCNd32;
pub const SCNiFAST32 = SCNi32;
pub const SCNoFAST32 = SCNo32;
pub const SCNuFAST32 = SCNu32;
pub const SCNxFAST32 = SCNx32;
pub const SCNdFAST64 = SCNd64;
pub const SCNiFAST64 = SCNi64;
pub const SCNoFAST64 = SCNo64;
pub const SCNuFAST64 = SCNu64;
pub const SCNxFAST64 = SCNx64;
pub const SCNdPTR = "ld";
pub const SCNiPTR = "li";
pub const SCNoPTR = "lo";
pub const SCNuPTR = "lu";
pub const SCNxPTR = "lx";
pub const SCNdMAX = __SCN_MAX_LENGTH_MODIFIER__ ++ "d";
pub const SCNiMAX = __SCN_MAX_LENGTH_MODIFIER__ ++ "i";
pub const SCNoMAX = __SCN_MAX_LENGTH_MODIFIER__ ++ "o";
pub const SCNuMAX = __SCN_MAX_LENGTH_MODIFIER__ ++ "u";
pub const SCNxMAX = __SCN_MAX_LENGTH_MODIFIER__ ++ "x";
pub const __TYPES_H_ = "";
pub const __strfmonlike = @compileError("unable to translate macro: undefined identifier `__format__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/_types.h:31:9
pub const __strftimelike = @compileError("unable to translate macro: undefined identifier `__format__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/_types.h:33:9
pub const __DARWIN_WCHAR_MAX = __WCHAR_MAX__;
pub const __DARWIN_WCHAR_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffff, .hex) - @as(c_int, 1);
pub const __DARWIN_WEOF = @import("std").zig.c_translation.cast(__darwin_wint_t, -@as(c_int, 1));
pub const _FORTIFY_SOURCE = @as(c_int, 2);
pub const _WCHAR_T = "";
pub const ossl_inline = @compileError("unable to translate C expr: unexpected token 'inline'");
// /opt/homebrew/opt/openssl@3/include/openssl/e_os2.h:274:12
pub const ossl_noreturn = @compileError("unable to translate C expr: unexpected token '_Noreturn'");
// /opt/homebrew/opt/openssl@3/include/openssl/e_os2.h:293:11
pub const ossl_unused = @compileError("unable to translate macro: undefined identifier `unused`");
// /opt/homebrew/opt/openssl@3/include/openssl/e_os2.h:302:11
pub const OPENSSL_E_OSTIME_H = "";
pub const _SYS_TIME_H_ = "";
pub const _STRUCT_TIMESPEC = struct_timespec;
pub const _STRUCT_TIMEVAL = struct_timeval;
pub const _STRUCT_TIMEVAL64 = "";
pub const ITIMER_REAL = @as(c_int, 0);
pub const ITIMER_VIRTUAL = @as(c_int, 1);
pub const ITIMER_PROF = @as(c_int, 2);
pub const TIMEVAL_TO_TIMESPEC = @compileError("unable to translate C expr: unexpected token '{'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/time.h:121:9
pub const TIMESPEC_TO_TIMEVAL = @compileError("unable to translate C expr: unexpected token '{'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/time.h:125:9
pub const DST_NONE = @as(c_int, 0);
pub const DST_USA = @as(c_int, 1);
pub const DST_AUST = @as(c_int, 2);
pub const DST_WET = @as(c_int, 3);
pub const DST_MET = @as(c_int, 4);
pub const DST_EET = @as(c_int, 5);
pub const DST_CAN = @as(c_int, 6);
pub const timerclear = @compileError("unable to translate C expr: unexpected token '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/time.h:143:9
pub inline fn timerisset(tvp: anytype) @TypeOf((tvp.*.tv_sec != 0) or (tvp.*.tv_usec != 0)) {
    _ = &tvp;
    return (tvp.*.tv_sec != 0) or (tvp.*.tv_usec != 0);
}
pub inline fn timercmp(tvp: anytype, uvp: anytype, cmp: anytype) @TypeOf(if (tvp.*.tv_sec == uvp.*.tv_sec) tvp.*.tv_usec ++ cmp(uvp).*.tv_usec else tvp.*.tv_sec ++ cmp(uvp).*.tv_sec) {
    _ = &tvp;
    _ = &uvp;
    _ = &cmp;
    return if (tvp.*.tv_sec == uvp.*.tv_sec) tvp.*.tv_usec ++ cmp(uvp).*.tv_usec else tvp.*.tv_sec ++ cmp(uvp).*.tv_sec;
}
pub const timeradd = @compileError("unable to translate C expr: unexpected token 'do'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/time.h:149:9
pub const timersub = @compileError("unable to translate C expr: unexpected token 'do'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/time.h:158:9
pub inline fn timevalcmp(l: anytype, r: anytype, cmp: anytype) @TypeOf(timercmp(l, r, cmp)) {
    _ = &l;
    _ = &r;
    _ = &cmp;
    return timercmp(l, r, cmp);
}
pub const _TIME_H_ = "";
pub const NULL = __DARWIN_NULL;
pub const CLOCKS_PER_SEC = @import("std").zig.c_translation.cast(clock_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const __CLOCK_AVAILABILITY = __OSX_AVAILABLE(@as(f64, 10.12)) ++ __IOS_AVAILABLE(@as(f64, 10.0)) ++ __TVOS_AVAILABLE(@as(f64, 10.0)) ++ __WATCHOS_AVAILABLE(@as(f64, 3.0));
pub const CLOCK_REALTIME = _CLOCK_REALTIME;
pub const CLOCK_MONOTONIC = _CLOCK_MONOTONIC;
pub const CLOCK_MONOTONIC_RAW = _CLOCK_MONOTONIC_RAW;
pub const CLOCK_MONOTONIC_RAW_APPROX = _CLOCK_MONOTONIC_RAW_APPROX;
pub const CLOCK_UPTIME_RAW = _CLOCK_UPTIME_RAW;
pub const CLOCK_UPTIME_RAW_APPROX = _CLOCK_UPTIME_RAW_APPROX;
pub const CLOCK_PROCESS_CPUTIME_ID = _CLOCK_PROCESS_CPUTIME_ID;
pub const CLOCK_THREAD_CPUTIME_ID = _CLOCK_THREAD_CPUTIME_ID;
pub const TIME_UTC = @as(c_int, 1);
pub const _SYS__SELECT_H_ = "";
pub const OPENSSL_COMP_H = "";
pub const HEADER_COMP_H = "";
pub const OPENSSL_CRYPTO_H = "";
pub const HEADER_CRYPTO_H = "";
pub const _STDLIB_H_ = "";
pub const _SYS_WAIT_H_ = "";
pub const _SYS_SIGNAL_H_ = "";
pub const __DARWIN_NSIG = @as(c_int, 32);
pub const NSIG = __DARWIN_NSIG;
pub const _BSD_MACHINE_SIGNAL_H_ = "";
pub const _ARM_SIGNAL_ = @as(c_int, 1);
pub const SIGHUP = @as(c_int, 1);
pub const SIGINT = @as(c_int, 2);
pub const SIGQUIT = @as(c_int, 3);
pub const SIGILL = @as(c_int, 4);
pub const SIGTRAP = @as(c_int, 5);
pub const SIGABRT = @as(c_int, 6);
pub const SIGIOT = SIGABRT;
pub const SIGEMT = @as(c_int, 7);
pub const SIGFPE = @as(c_int, 8);
pub const SIGKILL = @as(c_int, 9);
pub const SIGBUS = @as(c_int, 10);
pub const SIGSEGV = @as(c_int, 11);
pub const SIGSYS = @as(c_int, 12);
pub const SIGPIPE = @as(c_int, 13);
pub const SIGALRM = @as(c_int, 14);
pub const SIGTERM = @as(c_int, 15);
pub const SIGURG = @as(c_int, 16);
pub const SIGSTOP = @as(c_int, 17);
pub const SIGTSTP = @as(c_int, 18);
pub const SIGCONT = @as(c_int, 19);
pub const SIGCHLD = @as(c_int, 20);
pub const SIGTTIN = @as(c_int, 21);
pub const SIGTTOU = @as(c_int, 22);
pub const SIGIO = @as(c_int, 23);
pub const SIGXCPU = @as(c_int, 24);
pub const SIGXFSZ = @as(c_int, 25);
pub const SIGVTALRM = @as(c_int, 26);
pub const SIGPROF = @as(c_int, 27);
pub const SIGWINCH = @as(c_int, 28);
pub const SIGINFO = @as(c_int, 29);
pub const SIGUSR1 = @as(c_int, 30);
pub const SIGUSR2 = @as(c_int, 31);
pub const SIG_DFL = @compileError("unable to translate C expr: expected ')' instead got '('");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/signal.h:131:9
pub const SIG_IGN = @compileError("unable to translate C expr: expected ')' instead got '('");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/signal.h:132:9
pub const SIG_HOLD = @compileError("unable to translate C expr: expected ')' instead got '('");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/signal.h:133:9
pub const SIG_ERR = @compileError("unable to translate C expr: expected ')' instead got '('");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/signal.h:134:9
pub const _BSD_MACHINE__MCONTEXT_H_ = "";
pub const __ARM_MCONTEXT_H_ = "";
pub const _MACH_MACHINE__STRUCTS_H_ = "";
pub const _MACH_ARM__STRUCTS_H_ = "";
pub const _STRUCT_ARM_EXCEPTION_STATE = struct___darwin_arm_exception_state;
pub const _STRUCT_ARM_EXCEPTION_STATE64 = struct___darwin_arm_exception_state64;
pub const _STRUCT_ARM_THREAD_STATE = struct___darwin_arm_thread_state;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64 = @as(c_int, 0);
pub const _STRUCT_ARM_THREAD_STATE64 = struct___darwin_arm_thread_state64;
pub inline fn __darwin_arm_thread_state64_get_pc(ts: anytype) @TypeOf(ts.__pc) {
    _ = &ts;
    return ts.__pc;
}
pub inline fn __darwin_arm_thread_state64_get_pc_fptr(ts: anytype) ?*anyopaque {
    _ = &ts;
    return @import("std").zig.c_translation.cast(?*anyopaque, @import("std").zig.c_translation.cast(usize, ts.__pc));
}
pub const __darwin_arm_thread_state64_set_pc_fptr = @compileError("unable to translate C expr: expected ')' instead got '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/mach/arm/_structs.h:406:9
pub inline fn __darwin_arm_thread_state64_get_lr(ts: anytype) @TypeOf(ts.__lr) {
    _ = &ts;
    return ts.__lr;
}
pub inline fn __darwin_arm_thread_state64_get_lr_fptr(ts: anytype) ?*anyopaque {
    _ = &ts;
    return @import("std").zig.c_translation.cast(?*anyopaque, @import("std").zig.c_translation.cast(usize, ts.__lr));
}
pub const __darwin_arm_thread_state64_set_lr_fptr = @compileError("unable to translate C expr: expected ')' instead got '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/mach/arm/_structs.h:415:9
pub inline fn __darwin_arm_thread_state64_get_sp(ts: anytype) @TypeOf(ts.__sp) {
    _ = &ts;
    return ts.__sp;
}
pub const __darwin_arm_thread_state64_set_sp = @compileError("unable to translate C expr: expected ')' instead got '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/mach/arm/_structs.h:421:9
pub inline fn __darwin_arm_thread_state64_get_fp(ts: anytype) @TypeOf(ts.__fp) {
    _ = &ts;
    return ts.__fp;
}
pub const __darwin_arm_thread_state64_set_fp = @compileError("unable to translate C expr: expected ')' instead got '='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/mach/arm/_structs.h:427:9
pub const __darwin_arm_thread_state64_ptrauth_strip = @import("std").zig.c_translation.Macros.DISCARD;
pub const _STRUCT_ARM_VFP_STATE = struct___darwin_arm_vfp_state;
pub const _STRUCT_ARM_NEON_STATE64 = struct___darwin_arm_neon_state64;
pub const _STRUCT_ARM_NEON_STATE = struct___darwin_arm_neon_state;
pub const _STRUCT_ARM_PAGEIN_STATE = struct___arm_pagein_state;
pub const _STRUCT_ARM_LEGACY_DEBUG_STATE = struct___arm_legacy_debug_state;
pub const _STRUCT_ARM_DEBUG_STATE32 = struct___darwin_arm_debug_state32;
pub const _STRUCT_ARM_DEBUG_STATE64 = struct___darwin_arm_debug_state64;
pub const _STRUCT_ARM_CPMU_STATE64 = struct___darwin_arm_cpmu_state64;
pub const _STRUCT_MCONTEXT32 = struct___darwin_mcontext32;
pub const _STRUCT_MCONTEXT64 = struct___darwin_mcontext64;
pub const _MCONTEXT_T = "";
pub const _STRUCT_MCONTEXT = _STRUCT_MCONTEXT64;
pub const _STRUCT_SIGALTSTACK = struct___darwin_sigaltstack;
pub const _STRUCT_UCONTEXT = struct___darwin_ucontext;
pub const _SIGSET_T = "";
pub const SIGEV_NONE = @as(c_int, 0);
pub const SIGEV_SIGNAL = @as(c_int, 1);
pub const SIGEV_THREAD = @as(c_int, 3);
pub const ILL_NOOP = @as(c_int, 0);
pub const ILL_ILLOPC = @as(c_int, 1);
pub const ILL_ILLTRP = @as(c_int, 2);
pub const ILL_PRVOPC = @as(c_int, 3);
pub const ILL_ILLOPN = @as(c_int, 4);
pub const ILL_ILLADR = @as(c_int, 5);
pub const ILL_PRVREG = @as(c_int, 6);
pub const ILL_COPROC = @as(c_int, 7);
pub const ILL_BADSTK = @as(c_int, 8);
pub const FPE_NOOP = @as(c_int, 0);
pub const FPE_FLTDIV = @as(c_int, 1);
pub const FPE_FLTOVF = @as(c_int, 2);
pub const FPE_FLTUND = @as(c_int, 3);
pub const FPE_FLTRES = @as(c_int, 4);
pub const FPE_FLTINV = @as(c_int, 5);
pub const FPE_FLTSUB = @as(c_int, 6);
pub const FPE_INTDIV = @as(c_int, 7);
pub const FPE_INTOVF = @as(c_int, 8);
pub const SEGV_NOOP = @as(c_int, 0);
pub const SEGV_MAPERR = @as(c_int, 1);
pub const SEGV_ACCERR = @as(c_int, 2);
pub const BUS_NOOP = @as(c_int, 0);
pub const BUS_ADRALN = @as(c_int, 1);
pub const BUS_ADRERR = @as(c_int, 2);
pub const BUS_OBJERR = @as(c_int, 3);
pub const TRAP_BRKPT = @as(c_int, 1);
pub const TRAP_TRACE = @as(c_int, 2);
pub const CLD_NOOP = @as(c_int, 0);
pub const CLD_EXITED = @as(c_int, 1);
pub const CLD_KILLED = @as(c_int, 2);
pub const CLD_DUMPED = @as(c_int, 3);
pub const CLD_TRAPPED = @as(c_int, 4);
pub const CLD_STOPPED = @as(c_int, 5);
pub const CLD_CONTINUED = @as(c_int, 6);
pub const POLL_IN = @as(c_int, 1);
pub const POLL_OUT = @as(c_int, 2);
pub const POLL_MSG = @as(c_int, 3);
pub const POLL_ERR = @as(c_int, 4);
pub const POLL_PRI = @as(c_int, 5);
pub const POLL_HUP = @as(c_int, 6);
pub const sa_handler = __sigaction_u.__sa_handler;
pub const sa_sigaction = __sigaction_u.__sa_sigaction;
pub const SA_ONSTACK = @as(c_int, 0x0001);
pub const SA_RESTART = @as(c_int, 0x0002);
pub const SA_RESETHAND = @as(c_int, 0x0004);
pub const SA_NOCLDSTOP = @as(c_int, 0x0008);
pub const SA_NODEFER = @as(c_int, 0x0010);
pub const SA_NOCLDWAIT = @as(c_int, 0x0020);
pub const SA_SIGINFO = @as(c_int, 0x0040);
pub const SA_USERTRAMP = @as(c_int, 0x0100);
pub const SA_64REGSET = @as(c_int, 0x0200);
pub const SA_USERSPACE_MASK = (((((SA_ONSTACK | SA_RESTART) | SA_RESETHAND) | SA_NOCLDSTOP) | SA_NODEFER) | SA_NOCLDWAIT) | SA_SIGINFO;
pub const SIG_BLOCK = @as(c_int, 1);
pub const SIG_UNBLOCK = @as(c_int, 2);
pub const SIG_SETMASK = @as(c_int, 3);
pub const SI_USER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001, .hex);
pub const SI_QUEUE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10002, .hex);
pub const SI_TIMER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10003, .hex);
pub const SI_ASYNCIO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004, .hex);
pub const SI_MESGQ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10005, .hex);
pub const SS_ONSTACK = @as(c_int, 0x0001);
pub const SS_DISABLE = @as(c_int, 0x0004);
pub const MINSIGSTKSZ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const SIGSTKSZ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 131072, .decimal);
pub const SV_ONSTACK = SA_ONSTACK;
pub const SV_INTERRUPT = SA_RESTART;
pub const SV_RESETHAND = SA_RESETHAND;
pub const SV_NODEFER = SA_NODEFER;
pub const SV_NOCLDSTOP = SA_NOCLDSTOP;
pub const SV_SIGINFO = SA_SIGINFO;
pub const sv_onstack = @compileError("unable to translate macro: undefined identifier `sv_flags`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/signal.h:361:9
pub inline fn sigmask(m: anytype) @TypeOf(@as(c_int, 1) << (m - @as(c_int, 1))) {
    _ = &m;
    return @as(c_int, 1) << (m - @as(c_int, 1));
}
pub const BADSIG = SIG_ERR;
pub const _SYS_RESOURCE_H_ = "";
pub const PRIO_PROCESS = @as(c_int, 0);
pub const PRIO_PGRP = @as(c_int, 1);
pub const PRIO_USER = @as(c_int, 2);
pub const PRIO_DARWIN_THREAD = @as(c_int, 3);
pub const PRIO_DARWIN_PROCESS = @as(c_int, 4);
pub const PRIO_MIN = -@as(c_int, 20);
pub const PRIO_MAX = @as(c_int, 20);
pub const PRIO_DARWIN_BG = @as(c_int, 0x1000);
pub const PRIO_DARWIN_NONUI = @as(c_int, 0x1001);
pub const RUSAGE_SELF = @as(c_int, 0);
pub const RUSAGE_CHILDREN = -@as(c_int, 1);
pub const ru_first = @compileError("unable to translate macro: undefined identifier `ru_ixrss`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/resource.h:164:9
pub const ru_last = @compileError("unable to translate macro: undefined identifier `ru_nivcsw`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/resource.h:178:9
pub const RUSAGE_INFO_V0 = @as(c_int, 0);
pub const RUSAGE_INFO_V1 = @as(c_int, 1);
pub const RUSAGE_INFO_V2 = @as(c_int, 2);
pub const RUSAGE_INFO_V3 = @as(c_int, 3);
pub const RUSAGE_INFO_V4 = @as(c_int, 4);
pub const RUSAGE_INFO_V5 = @as(c_int, 5);
pub const RUSAGE_INFO_V6 = @as(c_int, 6);
pub const RUSAGE_INFO_CURRENT = RUSAGE_INFO_V6;
pub const RU_PROC_RUNS_RESLIDE = @as(c_int, 0x00000001);
pub const RLIM_INFINITY = (@import("std").zig.c_translation.cast(__uint64_t, @as(c_int, 1)) << @as(c_int, 63)) - @as(c_int, 1);
pub const RLIM_SAVED_MAX = RLIM_INFINITY;
pub const RLIM_SAVED_CUR = RLIM_INFINITY;
pub const RLIMIT_CPU = @as(c_int, 0);
pub const RLIMIT_FSIZE = @as(c_int, 1);
pub const RLIMIT_DATA = @as(c_int, 2);
pub const RLIMIT_STACK = @as(c_int, 3);
pub const RLIMIT_CORE = @as(c_int, 4);
pub const RLIMIT_AS = @as(c_int, 5);
pub const RLIMIT_RSS = RLIMIT_AS;
pub const RLIMIT_MEMLOCK = @as(c_int, 6);
pub const RLIMIT_NPROC = @as(c_int, 7);
pub const RLIMIT_NOFILE = @as(c_int, 8);
pub const RLIM_NLIMITS = @as(c_int, 9);
pub const _RLIMIT_POSIX_FLAG = @as(c_int, 0x1000);
pub const RLIMIT_WAKEUPS_MONITOR = @as(c_int, 0x1);
pub const RLIMIT_CPU_USAGE_MONITOR = @as(c_int, 0x2);
pub const RLIMIT_THREAD_CPULIMITS = @as(c_int, 0x3);
pub const RLIMIT_FOOTPRINT_INTERVAL = @as(c_int, 0x4);
pub const WAKEMON_ENABLE = @as(c_int, 0x01);
pub const WAKEMON_DISABLE = @as(c_int, 0x02);
pub const WAKEMON_GET_PARAMS = @as(c_int, 0x04);
pub const WAKEMON_SET_DEFAULTS = @as(c_int, 0x08);
pub const WAKEMON_MAKE_FATAL = @as(c_int, 0x10);
pub const CPUMON_MAKE_FATAL = @as(c_int, 0x1000);
pub const FOOTPRINT_INTERVAL_RESET = @as(c_int, 0x1);
pub const IOPOL_TYPE_DISK = @as(c_int, 0);
pub const IOPOL_TYPE_VFS_ATIME_UPDATES = @as(c_int, 2);
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = @as(c_int, 3);
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = @as(c_int, 4);
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE = @as(c_int, 5);
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = @as(c_int, 6);
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = @as(c_int, 7);
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = @as(c_int, 8);
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = @as(c_int, 9);
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = @as(c_int, 10);
pub const IOPOL_SCOPE_PROCESS = @as(c_int, 0);
pub const IOPOL_SCOPE_THREAD = @as(c_int, 1);
pub const IOPOL_SCOPE_DARWIN_BG = @as(c_int, 2);
pub const IOPOL_DEFAULT = @as(c_int, 0);
pub const IOPOL_IMPORTANT = @as(c_int, 1);
pub const IOPOL_PASSIVE = @as(c_int, 2);
pub const IOPOL_THROTTLE = @as(c_int, 3);
pub const IOPOL_UTILITY = @as(c_int, 4);
pub const IOPOL_STANDARD = @as(c_int, 5);
pub const IOPOL_APPLICATION = IOPOL_STANDARD;
pub const IOPOL_NORMAL = IOPOL_IMPORTANT;
pub const IOPOL_ATIME_UPDATES_DEFAULT = @as(c_int, 0);
pub const IOPOL_ATIME_UPDATES_OFF = @as(c_int, 1);
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = @as(c_int, 0);
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF = @as(c_int, 1);
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON = @as(c_int, 2);
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = @as(c_int, 0);
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = @as(c_int, 1);
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = @as(c_int, 0);
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF = @as(c_int, 1);
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = @as(c_int, 0);
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE = @as(c_int, 1);
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF = @as(c_int, 0);
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON = @as(c_int, 1);
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = @as(c_int, 0);
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON = @as(c_int, 1);
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = @as(c_int, 0);
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = @as(c_int, 1);
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = @as(c_int, 0);
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = @as(c_int, 1);
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = @as(c_int, 0);
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = @as(c_int, 1);
pub const WNOHANG = @as(c_int, 0x00000001);
pub const WUNTRACED = @as(c_int, 0x00000002);
pub inline fn _W_INT(w: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]c_int, &w).*) {
    _ = &w;
    return @import("std").zig.c_translation.cast([*c]c_int, &w).*;
}
pub const WCOREFLAG = @as(c_int, 0o200);
pub inline fn _WSTATUS(x: anytype) @TypeOf(_W_INT(x) & @as(c_int, 0o177)) {
    _ = &x;
    return _W_INT(x) & @as(c_int, 0o177);
}
pub const _WSTOPPED = @as(c_int, 0o177);
pub inline fn WEXITSTATUS(x: anytype) @TypeOf((_W_INT(x) >> @as(c_int, 8)) & @as(c_int, 0x000000ff)) {
    _ = &x;
    return (_W_INT(x) >> @as(c_int, 8)) & @as(c_int, 0x000000ff);
}
pub inline fn WSTOPSIG(x: anytype) @TypeOf(_W_INT(x) >> @as(c_int, 8)) {
    _ = &x;
    return _W_INT(x) >> @as(c_int, 8);
}
pub inline fn WIFCONTINUED(x: anytype) @TypeOf((_WSTATUS(x) == _WSTOPPED) and (WSTOPSIG(x) == @as(c_int, 0x13))) {
    _ = &x;
    return (_WSTATUS(x) == _WSTOPPED) and (WSTOPSIG(x) == @as(c_int, 0x13));
}
pub inline fn WIFSTOPPED(x: anytype) @TypeOf((_WSTATUS(x) == _WSTOPPED) and (WSTOPSIG(x) != @as(c_int, 0x13))) {
    _ = &x;
    return (_WSTATUS(x) == _WSTOPPED) and (WSTOPSIG(x) != @as(c_int, 0x13));
}
pub inline fn WIFEXITED(x: anytype) @TypeOf(_WSTATUS(x) == @as(c_int, 0)) {
    _ = &x;
    return _WSTATUS(x) == @as(c_int, 0);
}
pub inline fn WIFSIGNALED(x: anytype) @TypeOf((_WSTATUS(x) != _WSTOPPED) and (_WSTATUS(x) != @as(c_int, 0))) {
    _ = &x;
    return (_WSTATUS(x) != _WSTOPPED) and (_WSTATUS(x) != @as(c_int, 0));
}
pub inline fn WTERMSIG(x: anytype) @TypeOf(_WSTATUS(x)) {
    _ = &x;
    return _WSTATUS(x);
}
pub inline fn WCOREDUMP(x: anytype) @TypeOf(_W_INT(x) & WCOREFLAG) {
    _ = &x;
    return _W_INT(x) & WCOREFLAG;
}
pub inline fn W_EXITCODE(ret: anytype, sig: anytype) @TypeOf((ret << @as(c_int, 8)) | sig) {
    _ = &ret;
    _ = &sig;
    return (ret << @as(c_int, 8)) | sig;
}
pub inline fn W_STOPCODE(sig: anytype) @TypeOf((sig << @as(c_int, 8)) | _WSTOPPED) {
    _ = &sig;
    return (sig << @as(c_int, 8)) | _WSTOPPED;
}
pub const WEXITED = @as(c_int, 0x00000004);
pub const WSTOPPED = @as(c_int, 0x00000008);
pub const WCONTINUED = @as(c_int, 0x00000010);
pub const WNOWAIT = @as(c_int, 0x00000020);
pub const WAIT_ANY = -@as(c_int, 1);
pub const WAIT_MYPGRP = @as(c_int, 0);
pub const w_termsig = @compileError("unable to translate macro: undefined identifier `w_T`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/wait.h:231:9
pub const w_coredump = @compileError("unable to translate macro: undefined identifier `w_T`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/wait.h:232:9
pub const w_retcode = @compileError("unable to translate macro: undefined identifier `w_T`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/wait.h:233:9
pub const w_stopval = @compileError("unable to translate macro: undefined identifier `w_S`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/wait.h:234:9
pub const w_stopsig = @compileError("unable to translate macro: undefined identifier `w_S`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/wait.h:235:9
pub const _ALLOCA_H_ = "";
pub const __alloca = @compileError("unable to translate macro: undefined identifier `__builtin_alloca`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/alloca.h:40:9
pub const _CT_RUNE_T = "";
pub const _RUNE_T = "";
pub const EXIT_FAILURE = @as(c_int, 1);
pub const EXIT_SUCCESS = @as(c_int, 0);
pub const RAND_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffff, .hex);
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:119:9: warning: macro 'MB_CUR_MAX' contains a runtime value, translated to function
pub inline fn MB_CUR_MAX() @TypeOf(__mb_cur_max) {
    return __mb_cur_max;
}
pub const _MALLOC_UNDERSCORE_MALLOC_H_ = "";
pub const _MALLOC_UNDERSCORE_MALLOC_TYPE_H_ = "";
pub const _MALLOC_UNDERSCORE_PTRCHECK_H_ = "";
pub const _MALLOC_TYPE_AVAILABILITY = @compileError("unable to translate macro: undefined identifier `macos`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/malloc/_malloc_type.h:51:9
pub const _MALLOC_TYPED = @compileError("unable to translate C expr: unexpected token ''");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/malloc/_malloc_type.h:91:9
pub const __bsearch_noescape = @compileError("unable to translate macro: undefined identifier `__noescape__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:277:9
pub const __sort_noescape = @compileError("unable to translate macro: undefined identifier `__noescape__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdlib.h:310:9
pub const _STDIO_H_ = "";
pub const __STDIO_H_ = "";
pub const _VA_LIST_T = "";
pub const _SYS_STDIO_H_ = "";
pub const RENAME_SECLUDE = @as(c_int, 0x00000001);
pub const RENAME_SWAP = @as(c_int, 0x00000002);
pub const RENAME_EXCL = @as(c_int, 0x00000004);
pub const RENAME_RESERVED1 = @as(c_int, 0x00000008);
pub const RENAME_NOFOLLOW_ANY = @as(c_int, 0x00000010);
pub const _FSTDIO = "";
pub const _SEEK_SET_H_ = "";
pub const SEEK_SET = @as(c_int, 0);
pub const SEEK_CUR = @as(c_int, 1);
pub const SEEK_END = @as(c_int, 2);
pub const SEEK_HOLE = @as(c_int, 3);
pub const SEEK_DATA = @as(c_int, 4);
pub const __SLBF = @as(c_int, 0x0001);
pub const __SNBF = @as(c_int, 0x0002);
pub const __SRD = @as(c_int, 0x0004);
pub const __SWR = @as(c_int, 0x0008);
pub const __SRW = @as(c_int, 0x0010);
pub const __SEOF = @as(c_int, 0x0020);
pub const __SERR = @as(c_int, 0x0040);
pub const __SMBF = @as(c_int, 0x0080);
pub const __SAPP = @as(c_int, 0x0100);
pub const __SSTR = @as(c_int, 0x0200);
pub const __SOPT = @as(c_int, 0x0400);
pub const __SNPT = @as(c_int, 0x0800);
pub const __SOFF = @as(c_int, 0x1000);
pub const __SMOD = @as(c_int, 0x2000);
pub const __SALC = @as(c_int, 0x4000);
pub const __SIGN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const _IOFBF = @as(c_int, 0);
pub const _IOLBF = @as(c_int, 1);
pub const _IONBF = @as(c_int, 2);
pub const BUFSIZ = @as(c_int, 1024);
pub const EOF = -@as(c_int, 1);
pub const FOPEN_MAX = @as(c_int, 20);
pub const FILENAME_MAX = @as(c_int, 1024);
pub const P_tmpdir = "/var/tmp/";
pub const L_tmpnam = @as(c_int, 1024);
pub const TMP_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 308915776, .decimal);
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdio.h:119:9: warning: macro 'stdin' contains a runtime value, translated to function
pub inline fn stdin() @TypeOf(__stdinp) {
    return __stdinp;
}
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdio.h:120:9: warning: macro 'stdout' contains a runtime value, translated to function
pub inline fn stdout() @TypeOf(__stdoutp) {
    return __stdoutp;
}
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdio.h:121:9: warning: macro 'stderr' contains a runtime value, translated to function
pub inline fn stderr() @TypeOf(__stderrp) {
    return __stderrp;
}
pub const L_ctermid = @as(c_int, 1024);
pub const _CTERMID_H_ = "";
pub const __sgetc = @compileError("TODO unary inc/dec expr");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdio.h:261:9
pub inline fn __sfeof(p: anytype) @TypeOf((p.*._flags & __SEOF) != @as(c_int, 0)) {
    _ = &p;
    return (p.*._flags & __SEOF) != @as(c_int, 0);
}
pub inline fn __sferror(p: anytype) @TypeOf((p.*._flags & __SERR) != @as(c_int, 0)) {
    _ = &p;
    return (p.*._flags & __SERR) != @as(c_int, 0);
}
pub const __sclearerr = @compileError("unable to translate C expr: expected ')' instead got '&='");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/stdio.h:285:9
pub inline fn __sfileno(p: anytype) @TypeOf(p.*._file) {
    _ = &p;
    return p.*._file;
}
pub inline fn fropen(cookie: anytype, @"fn": anytype) @TypeOf(funopen(cookie, @"fn", @as(c_int, 0), @as(c_int, 0), @as(c_int, 0))) {
    _ = &cookie;
    _ = &@"fn";
    return funopen(cookie, @"fn", @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
}
pub inline fn fwopen(cookie: anytype, @"fn": anytype) @TypeOf(funopen(cookie, @as(c_int, 0), @"fn", @as(c_int, 0), @as(c_int, 0))) {
    _ = &cookie;
    _ = &@"fn";
    return funopen(cookie, @as(c_int, 0), @"fn", @as(c_int, 0), @as(c_int, 0));
}
pub inline fn feof_unlocked(p: anytype) @TypeOf(__sfeof(p)) {
    _ = &p;
    return __sfeof(p);
}
pub inline fn ferror_unlocked(p: anytype) @TypeOf(__sferror(p)) {
    _ = &p;
    return __sferror(p);
}
pub inline fn clearerr_unlocked(p: anytype) @TypeOf(__sclearerr(p)) {
    _ = &p;
    return __sclearerr(p);
}
pub inline fn fileno_unlocked(p: anytype) @TypeOf(__sfileno(p)) {
    _ = &p;
    return __sfileno(p);
}
pub const _SECURE__STDIO_H_ = "";
pub const _SECURE__COMMON_H_ = "";
pub const _USE_FORTIFY_LEVEL = @as(c_int, 2);
pub inline fn __darwin_obsz0(object: anytype) @TypeOf(__builtin_object_size(object, @as(c_int, 0))) {
    _ = &object;
    return __builtin_object_size(object, @as(c_int, 0));
}
pub inline fn __darwin_obsz(object: anytype) @TypeOf(__builtin_object_size(object, if (_USE_FORTIFY_LEVEL > @as(c_int, 1)) @as(c_int, 1) else @as(c_int, 0))) {
    _ = &object;
    return __builtin_object_size(object, if (_USE_FORTIFY_LEVEL > @as(c_int, 1)) @as(c_int, 1) else @as(c_int, 0));
}
pub const OPENSSL_SAFESTACK_H = "";
pub const HEADER_SAFESTACK_H = "";
pub const OPENSSL_STACK_H = "";
pub const HEADER_STACK_H = "";
pub const _STACK = OPENSSL_STACK;
pub const sk_num = OPENSSL_sk_num;
pub const sk_value = OPENSSL_sk_value;
pub const sk_set = OPENSSL_sk_set;
pub const sk_new = OPENSSL_sk_new;
pub const sk_new_null = OPENSSL_sk_new_null;
pub const sk_free = OPENSSL_sk_free;
pub const sk_pop_free = OPENSSL_sk_pop_free;
pub const sk_deep_copy = OPENSSL_sk_deep_copy;
pub const sk_insert = OPENSSL_sk_insert;
pub const sk_delete = OPENSSL_sk_delete;
pub const sk_delete_ptr = OPENSSL_sk_delete_ptr;
pub const sk_find = OPENSSL_sk_find;
pub const sk_find_ex = OPENSSL_sk_find_ex;
pub const sk_push = OPENSSL_sk_push;
pub const sk_unshift = OPENSSL_sk_unshift;
pub const sk_shift = OPENSSL_sk_shift;
pub const sk_pop = OPENSSL_sk_pop;
pub const sk_zero = OPENSSL_sk_zero;
pub const sk_set_cmp_func = OPENSSL_sk_set_cmp_func;
pub const sk_dup = OPENSSL_sk_dup;
pub const sk_sort = OPENSSL_sk_sort;
pub const sk_is_sorted = OPENSSL_sk_is_sorted;
pub const STACK_OF = @compileError("unable to translate macro: undefined identifier `stack_st_`");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:31:10
pub const SKM_DEFINE_STACK_OF_INTERNAL = @compileError("unable to translate macro: undefined identifier `sk_`");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:34:10
pub const SKM_DEFINE_STACK_OF = @compileError("unable to translate macro: undefined identifier `sk_`");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:64:10
pub inline fn DEFINE_STACK_OF(t: anytype) @TypeOf(SKM_DEFINE_STACK_OF(t, t, t)) {
    _ = &t;
    return SKM_DEFINE_STACK_OF(t, t, t);
}
pub const DEFINE_STACK_OF_CONST = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:176:10
pub inline fn DEFINE_SPECIAL_STACK_OF(t1: anytype, t2: anytype) @TypeOf(SKM_DEFINE_STACK_OF(t1, t2, t2)) {
    _ = &t1;
    _ = &t2;
    return SKM_DEFINE_STACK_OF(t1, t2, t2);
}
pub const DEFINE_SPECIAL_STACK_OF_CONST = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:178:10
pub inline fn sk_OPENSSL_STRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OPENSSL_STRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_STRING_value(sk: anytype, idx: anytype) [*c]u8 {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_value(ossl_check_const_OPENSSL_STRING_sk_type(sk), idx));
}
pub const sk_OPENSSL_STRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:208:9
pub const sk_OPENSSL_STRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:209:9
pub const sk_OPENSSL_STRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:210:9
pub inline fn sk_OPENSSL_STRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OPENSSL_STRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OPENSSL_STRING_sk_type(sk), n);
}
pub inline fn sk_OPENSSL_STRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OPENSSL_STRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_STRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OPENSSL_STRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_STRING_delete(sk: anytype, i: anytype) [*c]u8 {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_delete(ossl_check_OPENSSL_STRING_sk_type(sk), i));
}
pub inline fn sk_OPENSSL_STRING_delete_ptr(sk: anytype, ptr: anytype) [*c]u8 {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_delete_ptr(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr)));
}
pub inline fn sk_OPENSSL_STRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr));
}
pub inline fn sk_OPENSSL_STRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr));
}
pub inline fn sk_OPENSSL_STRING_pop(sk: anytype) [*c]u8 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_pop(ossl_check_OPENSSL_STRING_sk_type(sk)));
}
pub inline fn sk_OPENSSL_STRING_shift(sk: anytype) [*c]u8 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_shift(ossl_check_OPENSSL_STRING_sk_type(sk)));
}
pub inline fn sk_OPENSSL_STRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_freefunc_type(freefunc));
}
pub inline fn sk_OPENSSL_STRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr), idx);
}
pub inline fn sk_OPENSSL_STRING_set(sk: anytype, idx: anytype, ptr: anytype) [*c]u8 {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_set(ossl_check_OPENSSL_STRING_sk_type(sk), idx, ossl_check_OPENSSL_STRING_type(ptr)));
}
pub inline fn sk_OPENSSL_STRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr));
}
pub inline fn sk_OPENSSL_STRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr));
}
pub inline fn sk_OPENSSL_STRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr), pnum);
}
pub inline fn sk_OPENSSL_STRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OPENSSL_STRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_STRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_STRING_sk_type(sk));
}
pub const sk_OPENSSL_STRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:228:9
pub const sk_OPENSSL_STRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:229:9
pub inline fn sk_OPENSSL_STRING_set_cmp_func(sk: anytype, cmp: anytype) sk_OPENSSL_STRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OPENSSL_STRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_compfunc_type(cmp)));
}
pub inline fn sk_OPENSSL_CSTRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OPENSSL_CSTRING_sk_type(sk));
}
pub const sk_OPENSSL_CSTRING_value = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:233:9
pub const sk_OPENSSL_CSTRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:234:9
pub const sk_OPENSSL_CSTRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:235:9
pub const sk_OPENSSL_CSTRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:236:9
pub inline fn sk_OPENSSL_CSTRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OPENSSL_CSTRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OPENSSL_CSTRING_sk_type(sk), n);
}
pub inline fn sk_OPENSSL_CSTRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OPENSSL_CSTRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_CSTRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OPENSSL_CSTRING_sk_type(sk));
}
pub const sk_OPENSSL_CSTRING_delete = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:240:9
pub const sk_OPENSSL_CSTRING_delete_ptr = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:241:9
pub inline fn sk_OPENSSL_CSTRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr));
}
pub inline fn sk_OPENSSL_CSTRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr));
}
pub const sk_OPENSSL_CSTRING_pop = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:244:9
pub const sk_OPENSSL_CSTRING_shift = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:245:9
pub inline fn sk_OPENSSL_CSTRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_freefunc_type(freefunc));
}
pub inline fn sk_OPENSSL_CSTRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr), idx);
}
pub const sk_OPENSSL_CSTRING_set = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:248:9
pub inline fn sk_OPENSSL_CSTRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr));
}
pub inline fn sk_OPENSSL_CSTRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr));
}
pub inline fn sk_OPENSSL_CSTRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr), pnum);
}
pub inline fn sk_OPENSSL_CSTRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OPENSSL_CSTRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_CSTRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_CSTRING_sk_type(sk));
}
pub const sk_OPENSSL_CSTRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:254:9
pub const sk_OPENSSL_CSTRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:255:9
pub inline fn sk_OPENSSL_CSTRING_set_cmp_func(sk: anytype, cmp: anytype) sk_OPENSSL_CSTRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OPENSSL_CSTRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_compfunc_type(cmp)));
}
pub inline fn sk_OPENSSL_BLOCK_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OPENSSL_BLOCK_sk_type(sk));
}
pub inline fn sk_OPENSSL_BLOCK_value(sk: anytype, idx: anytype) ?*anyopaque {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_value(ossl_check_const_OPENSSL_BLOCK_sk_type(sk), idx));
}
pub const sk_OPENSSL_BLOCK_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:268:9
pub const sk_OPENSSL_BLOCK_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:269:9
pub const sk_OPENSSL_BLOCK_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:270:9
pub inline fn sk_OPENSSL_BLOCK_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OPENSSL_BLOCK_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OPENSSL_BLOCK_sk_type(sk), n);
}
pub inline fn sk_OPENSSL_BLOCK_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OPENSSL_BLOCK_sk_type(sk));
}
pub inline fn sk_OPENSSL_BLOCK_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OPENSSL_BLOCK_sk_type(sk));
}
pub inline fn sk_OPENSSL_BLOCK_delete(sk: anytype, i: anytype) ?*anyopaque {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_delete(ossl_check_OPENSSL_BLOCK_sk_type(sk), i));
}
pub inline fn sk_OPENSSL_BLOCK_delete_ptr(sk: anytype, ptr: anytype) ?*anyopaque {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_delete_ptr(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr)));
}
pub inline fn sk_OPENSSL_BLOCK_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr));
}
pub inline fn sk_OPENSSL_BLOCK_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr));
}
pub inline fn sk_OPENSSL_BLOCK_pop(sk: anytype) ?*anyopaque {
    _ = &sk;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_pop(ossl_check_OPENSSL_BLOCK_sk_type(sk)));
}
pub inline fn sk_OPENSSL_BLOCK_shift(sk: anytype) ?*anyopaque {
    _ = &sk;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_shift(ossl_check_OPENSSL_BLOCK_sk_type(sk)));
}
pub inline fn sk_OPENSSL_BLOCK_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_freefunc_type(freefunc));
}
pub inline fn sk_OPENSSL_BLOCK_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr), idx);
}
pub inline fn sk_OPENSSL_BLOCK_set(sk: anytype, idx: anytype, ptr: anytype) ?*anyopaque {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_set(ossl_check_OPENSSL_BLOCK_sk_type(sk), idx, ossl_check_OPENSSL_BLOCK_type(ptr)));
}
pub inline fn sk_OPENSSL_BLOCK_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr));
}
pub inline fn sk_OPENSSL_BLOCK_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr));
}
pub inline fn sk_OPENSSL_BLOCK_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr), pnum);
}
pub inline fn sk_OPENSSL_BLOCK_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OPENSSL_BLOCK_sk_type(sk));
}
pub inline fn sk_OPENSSL_BLOCK_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_BLOCK_sk_type(sk));
}
pub const sk_OPENSSL_BLOCK_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:288:9
pub const sk_OPENSSL_BLOCK_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/safestack.h:289:9
pub inline fn sk_OPENSSL_BLOCK_set_cmp_func(sk: anytype, cmp: anytype) sk_OPENSSL_BLOCK_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OPENSSL_BLOCK_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_compfunc_type(cmp)));
}
pub const OPENSSL_TYPES_H = "";
pub const __CLANG_LIMITS_H = "";
pub const _GCC_LIMITS_H_ = "";
pub const _LIMITS_H_ = "";
pub const _BSD_MACHINE_LIMITS_H_ = "";
pub const _ARM_LIMITS_H_ = "";
pub const _ARM__LIMITS_H_ = "";
pub const __DARWIN_CLK_TCK = @as(c_int, 100);
pub const MB_LEN_MAX = @as(c_int, 6);
pub const CLK_TCK = __DARWIN_CLK_TCK;
pub const CHAR_BIT = @as(c_int, 8);
pub const SCHAR_MAX = @as(c_int, 127);
pub const SCHAR_MIN = -@as(c_int, 128);
pub const UCHAR_MAX = @as(c_int, 255);
pub const CHAR_MAX = @as(c_int, 127);
pub const CHAR_MIN = -@as(c_int, 128);
pub const USHRT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const SHRT_MAX = @as(c_int, 32767);
pub const SHRT_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const UINT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex);
pub const INT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const ULONG_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 0xffffffffffffffff, .hex);
pub const LONG_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 0x7fffffffffffffff, .hex);
pub const LONG_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 0x7fffffffffffffff, .hex) - @as(c_int, 1);
pub const ULLONG_MAX = @as(c_ulonglong, 0xffffffffffffffff);
pub const LLONG_MAX = @as(c_longlong, 0x7fffffffffffffff);
pub const LLONG_MIN = -@as(c_longlong, 0x7fffffffffffffff) - @as(c_int, 1);
pub const LONG_BIT = @as(c_int, 64);
pub const SSIZE_MAX = LONG_MAX;
pub const WORD_BIT = @as(c_int, 32);
pub const SIZE_T_MAX = ULONG_MAX;
pub const UQUAD_MAX = ULLONG_MAX;
pub const QUAD_MAX = LLONG_MAX;
pub const QUAD_MIN = LLONG_MIN;
pub const _SYS_SYSLIMITS_H_ = "";
pub const ARG_MAX = @as(c_int, 1024) * @as(c_int, 1024);
pub const CHILD_MAX = @as(c_int, 266);
pub const GID_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 2147483647, .decimal);
pub const LINK_MAX = @as(c_int, 32767);
pub const MAX_CANON = @as(c_int, 1024);
pub const MAX_INPUT = @as(c_int, 1024);
pub const NAME_MAX = @as(c_int, 255);
pub const NGROUPS_MAX = @as(c_int, 16);
pub const UID_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 2147483647, .decimal);
pub const OPEN_MAX = @as(c_int, 10240);
pub const PATH_MAX = @as(c_int, 1024);
pub const PIPE_BUF = @as(c_int, 512);
pub const BC_BASE_MAX = @as(c_int, 99);
pub const BC_DIM_MAX = @as(c_int, 2048);
pub const BC_SCALE_MAX = @as(c_int, 99);
pub const BC_STRING_MAX = @as(c_int, 1000);
pub const CHARCLASS_NAME_MAX = @as(c_int, 14);
pub const COLL_WEIGHTS_MAX = @as(c_int, 2);
pub const EQUIV_CLASS_MAX = @as(c_int, 2);
pub const EXPR_NEST_MAX = @as(c_int, 32);
pub const LINE_MAX = @as(c_int, 2048);
pub const RE_DUP_MAX = @as(c_int, 255);
pub const NZERO = @as(c_int, 20);
pub const _POSIX_ARG_MAX = @as(c_int, 4096);
pub const _POSIX_CHILD_MAX = @as(c_int, 25);
pub const _POSIX_LINK_MAX = @as(c_int, 8);
pub const _POSIX_MAX_CANON = @as(c_int, 255);
pub const _POSIX_MAX_INPUT = @as(c_int, 255);
pub const _POSIX_NAME_MAX = @as(c_int, 14);
pub const _POSIX_NGROUPS_MAX = @as(c_int, 8);
pub const _POSIX_OPEN_MAX = @as(c_int, 20);
pub const _POSIX_PATH_MAX = @as(c_int, 256);
pub const _POSIX_PIPE_BUF = @as(c_int, 512);
pub const _POSIX_SSIZE_MAX = @as(c_int, 32767);
pub const _POSIX_STREAM_MAX = @as(c_int, 8);
pub const _POSIX_TZNAME_MAX = @as(c_int, 6);
pub const _POSIX2_BC_BASE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_DIM_MAX = @as(c_int, 2048);
pub const _POSIX2_BC_SCALE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_STRING_MAX = @as(c_int, 1000);
pub const _POSIX2_EQUIV_CLASS_MAX = @as(c_int, 2);
pub const _POSIX2_EXPR_NEST_MAX = @as(c_int, 32);
pub const _POSIX2_LINE_MAX = @as(c_int, 2048);
pub const _POSIX2_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX_AIO_LISTIO_MAX = @as(c_int, 2);
pub const _POSIX_AIO_MAX = @as(c_int, 1);
pub const _POSIX_DELAYTIMER_MAX = @as(c_int, 32);
pub const _POSIX_MQ_OPEN_MAX = @as(c_int, 8);
pub const _POSIX_MQ_PRIO_MAX = @as(c_int, 32);
pub const _POSIX_RTSIG_MAX = @as(c_int, 8);
pub const _POSIX_SEM_NSEMS_MAX = @as(c_int, 256);
pub const _POSIX_SEM_VALUE_MAX = @as(c_int, 32767);
pub const _POSIX_SIGQUEUE_MAX = @as(c_int, 32);
pub const _POSIX_TIMER_MAX = @as(c_int, 32);
pub const _POSIX_CLOCKRES_MIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 20000000, .decimal);
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS = @as(c_int, 4);
pub const _POSIX_THREAD_KEYS_MAX = @as(c_int, 128);
pub const _POSIX_THREAD_THREADS_MAX = @as(c_int, 64);
pub const PTHREAD_DESTRUCTOR_ITERATIONS = @as(c_int, 4);
pub const PTHREAD_KEYS_MAX = @as(c_int, 512);
pub const PTHREAD_STACK_MIN = @as(c_int, 16384);
pub const _POSIX_HOST_NAME_MAX = @as(c_int, 255);
pub const _POSIX_LOGIN_NAME_MAX = @as(c_int, 9);
pub const _POSIX_SS_REPL_MAX = @as(c_int, 4);
pub const _POSIX_SYMLINK_MAX = @as(c_int, 255);
pub const _POSIX_SYMLOOP_MAX = @as(c_int, 8);
pub const _POSIX_TRACE_EVENT_NAME_MAX = @as(c_int, 30);
pub const _POSIX_TRACE_NAME_MAX = @as(c_int, 8);
pub const _POSIX_TRACE_SYS_MAX = @as(c_int, 8);
pub const _POSIX_TRACE_USER_EVENT_MAX = @as(c_int, 32);
pub const _POSIX_TTY_NAME_MAX = @as(c_int, 9);
pub const _POSIX2_CHARCLASS_NAME_MAX = @as(c_int, 14);
pub const _POSIX2_COLL_WEIGHTS_MAX = @as(c_int, 2);
pub const _POSIX_RE_DUP_MAX = _POSIX2_RE_DUP_MAX;
pub const OFF_MIN = LLONG_MIN;
pub const OFF_MAX = LLONG_MAX;
pub const PASS_MAX = @as(c_int, 128);
pub const NL_ARGMAX = @as(c_int, 9);
pub const NL_LANGMAX = @as(c_int, 14);
pub const NL_MSGMAX = @as(c_int, 32767);
pub const NL_NMAX = @as(c_int, 1);
pub const NL_SETMAX = @as(c_int, 255);
pub const NL_TEXTMAX = @as(c_int, 2048);
pub const _XOPEN_IOV_MAX = @as(c_int, 16);
pub const IOV_MAX = @as(c_int, 1024);
pub const _XOPEN_NAME_MAX = @as(c_int, 255);
pub const _XOPEN_PATH_MAX = @as(c_int, 1024);
pub const LONG_LONG_MAX = __LONG_LONG_MAX__;
pub const LONG_LONG_MIN = -__LONG_LONG_MAX__ - @as(c_longlong, 1);
pub const ULONG_LONG_MAX = (__LONG_LONG_MAX__ * @as(c_ulonglong, 2)) + @as(c_ulonglong, 1);
pub const OSSL_FUTURE_CONST = "";
pub const OPENSSL_CRYPTOERR_H = "";
pub const OPENSSL_SYMHACKS_H = "";
pub const HEADER_SYMHACKS_H = "";
pub const OPENSSL_CRYPTOERR_LEGACY_H = "";
pub const ASN1_F_A2D_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_A2I_ASN1_INTEGER = @as(c_int, 0);
pub const ASN1_F_A2I_ASN1_STRING = @as(c_int, 0);
pub const ASN1_F_APPEND_EXP = @as(c_int, 0);
pub const ASN1_F_ASN1_BIO_INIT = @as(c_int, 0);
pub const ASN1_F_ASN1_BIT_STRING_SET_BIT = @as(c_int, 0);
pub const ASN1_F_ASN1_CB = @as(c_int, 0);
pub const ASN1_F_ASN1_CHECK_TLEN = @as(c_int, 0);
pub const ASN1_F_ASN1_COLLECT = @as(c_int, 0);
pub const ASN1_F_ASN1_D2I_EX_PRIMITIVE = @as(c_int, 0);
pub const ASN1_F_ASN1_D2I_FP = @as(c_int, 0);
pub const ASN1_F_ASN1_D2I_READ_BIO = @as(c_int, 0);
pub const ASN1_F_ASN1_DIGEST = @as(c_int, 0);
pub const ASN1_F_ASN1_DO_ADB = @as(c_int, 0);
pub const ASN1_F_ASN1_DO_LOCK = @as(c_int, 0);
pub const ASN1_F_ASN1_DUP = @as(c_int, 0);
pub const ASN1_F_ASN1_ENC_SAVE = @as(c_int, 0);
pub const ASN1_F_ASN1_EX_C2I = @as(c_int, 0);
pub const ASN1_F_ASN1_FIND_END = @as(c_int, 0);
pub const ASN1_F_ASN1_GENERALIZEDTIME_ADJ = @as(c_int, 0);
pub const ASN1_F_ASN1_GENERATE_V3 = @as(c_int, 0);
pub const ASN1_F_ASN1_GET_INT64 = @as(c_int, 0);
pub const ASN1_F_ASN1_GET_OBJECT = @as(c_int, 0);
pub const ASN1_F_ASN1_GET_UINT64 = @as(c_int, 0);
pub const ASN1_F_ASN1_I2D_BIO = @as(c_int, 0);
pub const ASN1_F_ASN1_I2D_FP = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_D2I_FP = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_DUP = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_EMBED_D2I = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_EMBED_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_FLAGS_I2D = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_I2D_BIO = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_I2D_FP = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_PACK = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_SIGN = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_SIGN_CTX = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_UNPACK = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_VERIFY = @as(c_int, 0);
pub const ASN1_F_ASN1_MBSTRING_NCOPY = @as(c_int, 0);
pub const ASN1_F_ASN1_OBJECT_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_OUTPUT_DATA = @as(c_int, 0);
pub const ASN1_F_ASN1_PCTX_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_PRIMITIVE_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_SCTX_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_SIGN = @as(c_int, 0);
pub const ASN1_F_ASN1_STR2TYPE = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_GET_INT64 = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_GET_UINT64 = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_SET = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_TABLE_ADD = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_TO_BN = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_TYPE_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_TEMPLATE_EX_D2I = @as(c_int, 0);
pub const ASN1_F_ASN1_TEMPLATE_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_TEMPLATE_NOEXP_D2I = @as(c_int, 0);
pub const ASN1_F_ASN1_TIME_ADJ = @as(c_int, 0);
pub const ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING = @as(c_int, 0);
pub const ASN1_F_ASN1_TYPE_GET_OCTETSTRING = @as(c_int, 0);
pub const ASN1_F_ASN1_UTCTIME_ADJ = @as(c_int, 0);
pub const ASN1_F_ASN1_VERIFY = @as(c_int, 0);
pub const ASN1_F_B64_READ_ASN1 = @as(c_int, 0);
pub const ASN1_F_B64_WRITE_ASN1 = @as(c_int, 0);
pub const ASN1_F_BIO_NEW_NDEF = @as(c_int, 0);
pub const ASN1_F_BITSTR_CB = @as(c_int, 0);
pub const ASN1_F_BN_TO_ASN1_STRING = @as(c_int, 0);
pub const ASN1_F_C2I_ASN1_BIT_STRING = @as(c_int, 0);
pub const ASN1_F_C2I_ASN1_INTEGER = @as(c_int, 0);
pub const ASN1_F_C2I_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_C2I_IBUF = @as(c_int, 0);
pub const ASN1_F_C2I_UINT64_INT = @as(c_int, 0);
pub const ASN1_F_COLLECT_DATA = @as(c_int, 0);
pub const ASN1_F_D2I_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_D2I_ASN1_UINTEGER = @as(c_int, 0);
pub const ASN1_F_D2I_AUTOPRIVATEKEY = @as(c_int, 0);
pub const ASN1_F_D2I_PRIVATEKEY = @as(c_int, 0);
pub const ASN1_F_D2I_PUBLICKEY = @as(c_int, 0);
pub const ASN1_F_DO_BUF = @as(c_int, 0);
pub const ASN1_F_DO_CREATE = @as(c_int, 0);
pub const ASN1_F_DO_DUMP = @as(c_int, 0);
pub const ASN1_F_DO_TCREATE = @as(c_int, 0);
pub const ASN1_F_I2A_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_I2D_ASN1_BIO_STREAM = @as(c_int, 0);
pub const ASN1_F_I2D_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_I2D_DSA_PUBKEY = @as(c_int, 0);
pub const ASN1_F_I2D_EC_PUBKEY = @as(c_int, 0);
pub const ASN1_F_I2D_PRIVATEKEY = @as(c_int, 0);
pub const ASN1_F_I2D_PUBLICKEY = @as(c_int, 0);
pub const ASN1_F_I2D_RSA_PUBKEY = @as(c_int, 0);
pub const ASN1_F_LONG_C2I = @as(c_int, 0);
pub const ASN1_F_NDEF_PREFIX = @as(c_int, 0);
pub const ASN1_F_NDEF_SUFFIX = @as(c_int, 0);
pub const ASN1_F_OID_MODULE_INIT = @as(c_int, 0);
pub const ASN1_F_PARSE_TAGGING = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBE2_SET_IV = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBE2_SET_SCRYPT = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBE_SET = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBE_SET0_ALGOR = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBKDF2_SET = @as(c_int, 0);
pub const ASN1_F_PKCS5_SCRYPT_SET = @as(c_int, 0);
pub const ASN1_F_SMIME_READ_ASN1 = @as(c_int, 0);
pub const ASN1_F_SMIME_TEXT = @as(c_int, 0);
pub const ASN1_F_STABLE_GET = @as(c_int, 0);
pub const ASN1_F_STBL_MODULE_INIT = @as(c_int, 0);
pub const ASN1_F_UINT32_C2I = @as(c_int, 0);
pub const ASN1_F_UINT32_NEW = @as(c_int, 0);
pub const ASN1_F_UINT64_C2I = @as(c_int, 0);
pub const ASN1_F_UINT64_NEW = @as(c_int, 0);
pub const ASN1_F_X509_CRL_ADD0_REVOKED = @as(c_int, 0);
pub const ASN1_F_X509_INFO_NEW = @as(c_int, 0);
pub const ASN1_F_X509_NAME_ENCODE = @as(c_int, 0);
pub const ASN1_F_X509_NAME_EX_D2I = @as(c_int, 0);
pub const ASN1_F_X509_NAME_EX_NEW = @as(c_int, 0);
pub const ASN1_F_X509_PKEY_NEW = @as(c_int, 0);
pub const ASYNC_F_ASYNC_CTX_NEW = @as(c_int, 0);
pub const ASYNC_F_ASYNC_INIT_THREAD = @as(c_int, 0);
pub const ASYNC_F_ASYNC_JOB_NEW = @as(c_int, 0);
pub const ASYNC_F_ASYNC_PAUSE_JOB = @as(c_int, 0);
pub const ASYNC_F_ASYNC_START_FUNC = @as(c_int, 0);
pub const ASYNC_F_ASYNC_START_JOB = @as(c_int, 0);
pub const ASYNC_F_ASYNC_WAIT_CTX_SET_WAIT_FD = @as(c_int, 0);
pub const BIO_F_ACPT_STATE = @as(c_int, 0);
pub const BIO_F_ADDRINFO_WRAP = @as(c_int, 0);
pub const BIO_F_ADDR_STRINGS = @as(c_int, 0);
pub const BIO_F_BIO_ACCEPT = @as(c_int, 0);
pub const BIO_F_BIO_ACCEPT_EX = @as(c_int, 0);
pub const BIO_F_BIO_ACCEPT_NEW = @as(c_int, 0);
pub const BIO_F_BIO_ADDR_NEW = @as(c_int, 0);
pub const BIO_F_BIO_BIND = @as(c_int, 0);
pub const BIO_F_BIO_CALLBACK_CTRL = @as(c_int, 0);
pub const BIO_F_BIO_CONNECT = @as(c_int, 0);
pub const BIO_F_BIO_CONNECT_NEW = @as(c_int, 0);
pub const BIO_F_BIO_CTRL = @as(c_int, 0);
pub const BIO_F_BIO_GETS = @as(c_int, 0);
pub const BIO_F_BIO_GET_HOST_IP = @as(c_int, 0);
pub const BIO_F_BIO_GET_NEW_INDEX = @as(c_int, 0);
pub const BIO_F_BIO_GET_PORT = @as(c_int, 0);
pub const BIO_F_BIO_LISTEN = @as(c_int, 0);
pub const BIO_F_BIO_LOOKUP = @as(c_int, 0);
pub const BIO_F_BIO_LOOKUP_EX = @as(c_int, 0);
pub const BIO_F_BIO_MAKE_PAIR = @as(c_int, 0);
pub const BIO_F_BIO_METH_NEW = @as(c_int, 0);
pub const BIO_F_BIO_NEW = @as(c_int, 0);
pub const BIO_F_BIO_NEW_DGRAM_SCTP = @as(c_int, 0);
pub const BIO_F_BIO_NEW_FILE = @as(c_int, 0);
pub const BIO_F_BIO_NEW_MEM_BUF = @as(c_int, 0);
pub const BIO_F_BIO_NREAD = @as(c_int, 0);
pub const BIO_F_BIO_NREAD0 = @as(c_int, 0);
pub const BIO_F_BIO_NWRITE = @as(c_int, 0);
pub const BIO_F_BIO_NWRITE0 = @as(c_int, 0);
pub const BIO_F_BIO_PARSE_HOSTSERV = @as(c_int, 0);
pub const BIO_F_BIO_PUTS = @as(c_int, 0);
pub const BIO_F_BIO_READ = @as(c_int, 0);
pub const BIO_F_BIO_READ_EX = @as(c_int, 0);
pub const BIO_F_BIO_READ_INTERN = @as(c_int, 0);
pub const BIO_F_BIO_SOCKET = @as(c_int, 0);
pub const BIO_F_BIO_SOCKET_NBIO = @as(c_int, 0);
pub const BIO_F_BIO_SOCK_INFO = @as(c_int, 0);
pub const BIO_F_BIO_SOCK_INIT = @as(c_int, 0);
pub const BIO_F_BIO_WRITE = @as(c_int, 0);
pub const BIO_F_BIO_WRITE_EX = @as(c_int, 0);
pub const BIO_F_BIO_WRITE_INTERN = @as(c_int, 0);
pub const BIO_F_BUFFER_CTRL = @as(c_int, 0);
pub const BIO_F_CONN_CTRL = @as(c_int, 0);
pub const BIO_F_CONN_STATE = @as(c_int, 0);
pub const BIO_F_DGRAM_SCTP_NEW = @as(c_int, 0);
pub const BIO_F_DGRAM_SCTP_READ = @as(c_int, 0);
pub const BIO_F_DGRAM_SCTP_WRITE = @as(c_int, 0);
pub const BIO_F_DOAPR_OUTCH = @as(c_int, 0);
pub const BIO_F_FILE_CTRL = @as(c_int, 0);
pub const BIO_F_FILE_READ = @as(c_int, 0);
pub const BIO_F_LINEBUFFER_CTRL = @as(c_int, 0);
pub const BIO_F_LINEBUFFER_NEW = @as(c_int, 0);
pub const BIO_F_MEM_WRITE = @as(c_int, 0);
pub const BIO_F_NBIOF_NEW = @as(c_int, 0);
pub const BIO_F_SLG_WRITE = @as(c_int, 0);
pub const BIO_F_SSL_NEW = @as(c_int, 0);
pub const BN_F_BNRAND = @as(c_int, 0);
pub const BN_F_BNRAND_RANGE = @as(c_int, 0);
pub const BN_F_BN_BLINDING_CONVERT_EX = @as(c_int, 0);
pub const BN_F_BN_BLINDING_CREATE_PARAM = @as(c_int, 0);
pub const BN_F_BN_BLINDING_INVERT_EX = @as(c_int, 0);
pub const BN_F_BN_BLINDING_NEW = @as(c_int, 0);
pub const BN_F_BN_BLINDING_UPDATE = @as(c_int, 0);
pub const BN_F_BN_BN2DEC = @as(c_int, 0);
pub const BN_F_BN_BN2HEX = @as(c_int, 0);
pub const BN_F_BN_COMPUTE_WNAF = @as(c_int, 0);
pub const BN_F_BN_CTX_GET = @as(c_int, 0);
pub const BN_F_BN_CTX_NEW = @as(c_int, 0);
pub const BN_F_BN_CTX_START = @as(c_int, 0);
pub const BN_F_BN_DIV = @as(c_int, 0);
pub const BN_F_BN_DIV_RECP = @as(c_int, 0);
pub const BN_F_BN_EXP = @as(c_int, 0);
pub const BN_F_BN_EXPAND_INTERNAL = @as(c_int, 0);
pub const BN_F_BN_GENCB_NEW = @as(c_int, 0);
pub const BN_F_BN_GENERATE_DSA_NONCE = @as(c_int, 0);
pub const BN_F_BN_GENERATE_PRIME_EX = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_EXP = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_MUL = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_SQR = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_SQRT = @as(c_int, 0);
pub const BN_F_BN_LSHIFT = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP2_MONT = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_MONT = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_MONT_CONSTTIME = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_MONT_WORD = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_RECP = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_SIMPLE = @as(c_int, 0);
pub const BN_F_BN_MOD_INVERSE = @as(c_int, 0);
pub const BN_F_BN_MOD_INVERSE_NO_BRANCH = @as(c_int, 0);
pub const BN_F_BN_MOD_LSHIFT_QUICK = @as(c_int, 0);
pub const BN_F_BN_MOD_SQRT = @as(c_int, 0);
pub const BN_F_BN_MONT_CTX_NEW = @as(c_int, 0);
pub const BN_F_BN_MPI2BN = @as(c_int, 0);
pub const BN_F_BN_NEW = @as(c_int, 0);
pub const BN_F_BN_POOL_GET = @as(c_int, 0);
pub const BN_F_BN_RAND = @as(c_int, 0);
pub const BN_F_BN_RAND_RANGE = @as(c_int, 0);
pub const BN_F_BN_RECP_CTX_NEW = @as(c_int, 0);
pub const BN_F_BN_RSHIFT = @as(c_int, 0);
pub const BN_F_BN_SET_WORDS = @as(c_int, 0);
pub const BN_F_BN_STACK_PUSH = @as(c_int, 0);
pub const BN_F_BN_USUB = @as(c_int, 0);
pub const BUF_F_BUF_MEM_GROW = @as(c_int, 0);
pub const BUF_F_BUF_MEM_GROW_CLEAN = @as(c_int, 0);
pub const BUF_F_BUF_MEM_NEW = @as(c_int, 0);
pub const CMS_F_CHECK_CONTENT = @as(c_int, 0);
pub const CMS_F_CMS_ADD0_CERT = @as(c_int, 0);
pub const CMS_F_CMS_ADD0_RECIPIENT_KEY = @as(c_int, 0);
pub const CMS_F_CMS_ADD0_RECIPIENT_PASSWORD = @as(c_int, 0);
pub const CMS_F_CMS_ADD1_RECEIPTREQUEST = @as(c_int, 0);
pub const CMS_F_CMS_ADD1_RECIPIENT_CERT = @as(c_int, 0);
pub const CMS_F_CMS_ADD1_SIGNER = @as(c_int, 0);
pub const CMS_F_CMS_ADD1_SIGNINGTIME = @as(c_int, 0);
pub const CMS_F_CMS_COMPRESS = @as(c_int, 0);
pub const CMS_F_CMS_COMPRESSEDDATA_CREATE = @as(c_int, 0);
pub const CMS_F_CMS_COMPRESSEDDATA_INIT_BIO = @as(c_int, 0);
pub const CMS_F_CMS_COPY_CONTENT = @as(c_int, 0);
pub const CMS_F_CMS_COPY_MESSAGEDIGEST = @as(c_int, 0);
pub const CMS_F_CMS_DATA = @as(c_int, 0);
pub const CMS_F_CMS_DATAFINAL = @as(c_int, 0);
pub const CMS_F_CMS_DATAINIT = @as(c_int, 0);
pub const CMS_F_CMS_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_DECRYPT_SET1_KEY = @as(c_int, 0);
pub const CMS_F_CMS_DECRYPT_SET1_PASSWORD = @as(c_int, 0);
pub const CMS_F_CMS_DECRYPT_SET1_PKEY = @as(c_int, 0);
pub const CMS_F_CMS_DIGESTALGORITHM_FIND_CTX = @as(c_int, 0);
pub const CMS_F_CMS_DIGESTALGORITHM_INIT_BIO = @as(c_int, 0);
pub const CMS_F_CMS_DIGESTEDDATA_DO_FINAL = @as(c_int, 0);
pub const CMS_F_CMS_DIGEST_VERIFY = @as(c_int, 0);
pub const CMS_F_CMS_ENCODE_RECEIPT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDCONTENT_INIT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDDATA_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDDATA_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY = @as(c_int, 0);
pub const CMS_F_CMS_ENVELOPEDDATA_CREATE = @as(c_int, 0);
pub const CMS_F_CMS_ENVELOPEDDATA_INIT_BIO = @as(c_int, 0);
pub const CMS_F_CMS_ENVELOPED_DATA_INIT = @as(c_int, 0);
pub const CMS_F_CMS_ENV_ASN1_CTRL = @as(c_int, 0);
pub const CMS_F_CMS_FINAL = @as(c_int, 0);
pub const CMS_F_CMS_GET0_CERTIFICATE_CHOICES = @as(c_int, 0);
pub const CMS_F_CMS_GET0_CONTENT = @as(c_int, 0);
pub const CMS_F_CMS_GET0_ECONTENT_TYPE = @as(c_int, 0);
pub const CMS_F_CMS_GET0_ENVELOPED = @as(c_int, 0);
pub const CMS_F_CMS_GET0_REVOCATION_CHOICES = @as(c_int, 0);
pub const CMS_F_CMS_GET0_SIGNED = @as(c_int, 0);
pub const CMS_F_CMS_MSGSIGDIGEST_ADD1 = @as(c_int, 0);
pub const CMS_F_CMS_RECEIPTREQUEST_CREATE0 = @as(c_int, 0);
pub const CMS_F_CMS_RECEIPT_VERIFY = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ALG = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ORIG_ID = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_GET0_REKS = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_ORIG_ID_CMP = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_GET0_ID = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_ID_CMP = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_CERT_CMP = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_ALGS = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_SIGNER_ID = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_SET0_KEY = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_SET0_PASSWORD = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_SET0_PKEY = @as(c_int, 0);
pub const CMS_F_CMS_SD_ASN1_CTRL = @as(c_int, 0);
pub const CMS_F_CMS_SET1_IAS = @as(c_int, 0);
pub const CMS_F_CMS_SET1_KEYID = @as(c_int, 0);
pub const CMS_F_CMS_SET1_SIGNERIDENTIFIER = @as(c_int, 0);
pub const CMS_F_CMS_SET_DETACHED = @as(c_int, 0);
pub const CMS_F_CMS_SIGN = @as(c_int, 0);
pub const CMS_F_CMS_SIGNED_DATA_INIT = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_CONTENT_SIGN = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_SIGN = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_VERIFY = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_VERIFY_CERT = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT = @as(c_int, 0);
pub const CMS_F_CMS_SIGN_RECEIPT = @as(c_int, 0);
pub const CMS_F_CMS_SI_CHECK_ATTRIBUTES = @as(c_int, 0);
pub const CMS_F_CMS_STREAM = @as(c_int, 0);
pub const CMS_F_CMS_UNCOMPRESS = @as(c_int, 0);
pub const CMS_F_CMS_VERIFY = @as(c_int, 0);
pub const CMS_F_KEK_UNWRAP_KEY = @as(c_int, 0);
pub const COMP_F_BIO_ZLIB_FLUSH = @as(c_int, 0);
pub const COMP_F_BIO_ZLIB_NEW = @as(c_int, 0);
pub const COMP_F_BIO_ZLIB_READ = @as(c_int, 0);
pub const COMP_F_BIO_ZLIB_WRITE = @as(c_int, 0);
pub const COMP_F_COMP_CTX_NEW = @as(c_int, 0);
pub const CONF_F_CONF_DUMP_FP = @as(c_int, 0);
pub const CONF_F_CONF_LOAD = @as(c_int, 0);
pub const CONF_F_CONF_LOAD_FP = @as(c_int, 0);
pub const CONF_F_CONF_PARSE_LIST = @as(c_int, 0);
pub const CONF_F_DEF_LOAD = @as(c_int, 0);
pub const CONF_F_DEF_LOAD_BIO = @as(c_int, 0);
pub const CONF_F_GET_NEXT_FILE = @as(c_int, 0);
pub const CONF_F_MODULE_ADD = @as(c_int, 0);
pub const CONF_F_MODULE_INIT = @as(c_int, 0);
pub const CONF_F_MODULE_LOAD_DSO = @as(c_int, 0);
pub const CONF_F_MODULE_RUN = @as(c_int, 0);
pub const CONF_F_NCONF_DUMP_BIO = @as(c_int, 0);
pub const CONF_F_NCONF_DUMP_FP = @as(c_int, 0);
pub const CONF_F_NCONF_GET_NUMBER_E = @as(c_int, 0);
pub const CONF_F_NCONF_GET_SECTION = @as(c_int, 0);
pub const CONF_F_NCONF_GET_STRING = @as(c_int, 0);
pub const CONF_F_NCONF_LOAD = @as(c_int, 0);
pub const CONF_F_NCONF_LOAD_BIO = @as(c_int, 0);
pub const CONF_F_NCONF_LOAD_FP = @as(c_int, 0);
pub const CONF_F_NCONF_NEW = @as(c_int, 0);
pub const CONF_F_PROCESS_INCLUDE = @as(c_int, 0);
pub const CONF_F_SSL_MODULE_INIT = @as(c_int, 0);
pub const CONF_F_STR_COPY = @as(c_int, 0);
pub const CRYPTO_F_CMAC_CTX_NEW = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_DUP_EX_DATA = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_FREE_EX_DATA = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_MEMDUP = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_NEW_EX_DATA = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_OCB128_COPY_CTX = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_OCB128_INIT = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_SET_EX_DATA = @as(c_int, 0);
pub const CRYPTO_F_GET_AND_LOCK = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_ATEXIT = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_BUF2HEXSTR = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_FOPEN = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_HEXSTR2BUF = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_INIT_CRYPTO = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_LH_NEW = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_SK_DEEP_COPY = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_SK_DUP = @as(c_int, 0);
pub const CRYPTO_F_PKEY_HMAC_INIT = @as(c_int, 0);
pub const CRYPTO_F_PKEY_POLY1305_INIT = @as(c_int, 0);
pub const CRYPTO_F_PKEY_SIPHASH_INIT = @as(c_int, 0);
pub const CRYPTO_F_SK_RESERVE = @as(c_int, 0);
pub const CT_F_CTLOG_NEW = @as(c_int, 0);
pub const CT_F_CTLOG_NEW_FROM_BASE64 = @as(c_int, 0);
pub const CT_F_CTLOG_NEW_FROM_CONF = @as(c_int, 0);
pub const CT_F_CTLOG_STORE_LOAD_CTX_NEW = @as(c_int, 0);
pub const CT_F_CTLOG_STORE_LOAD_FILE = @as(c_int, 0);
pub const CT_F_CTLOG_STORE_LOAD_LOG = @as(c_int, 0);
pub const CT_F_CTLOG_STORE_NEW = @as(c_int, 0);
pub const CT_F_CT_BASE64_DECODE = @as(c_int, 0);
pub const CT_F_CT_POLICY_EVAL_CTX_NEW = @as(c_int, 0);
pub const CT_F_CT_V1_LOG_ID_FROM_PKEY = @as(c_int, 0);
pub const CT_F_I2O_SCT = @as(c_int, 0);
pub const CT_F_I2O_SCT_LIST = @as(c_int, 0);
pub const CT_F_I2O_SCT_SIGNATURE = @as(c_int, 0);
pub const CT_F_O2I_SCT = @as(c_int, 0);
pub const CT_F_O2I_SCT_LIST = @as(c_int, 0);
pub const CT_F_O2I_SCT_SIGNATURE = @as(c_int, 0);
pub const CT_F_SCT_CTX_NEW = @as(c_int, 0);
pub const CT_F_SCT_CTX_VERIFY = @as(c_int, 0);
pub const CT_F_SCT_NEW = @as(c_int, 0);
pub const CT_F_SCT_NEW_FROM_BASE64 = @as(c_int, 0);
pub const CT_F_SCT_SET0_LOG_ID = @as(c_int, 0);
pub const CT_F_SCT_SET1_EXTENSIONS = @as(c_int, 0);
pub const CT_F_SCT_SET1_LOG_ID = @as(c_int, 0);
pub const CT_F_SCT_SET1_SIGNATURE = @as(c_int, 0);
pub const CT_F_SCT_SET_LOG_ENTRY_TYPE = @as(c_int, 0);
pub const CT_F_SCT_SET_SIGNATURE_NID = @as(c_int, 0);
pub const CT_F_SCT_SET_VERSION = @as(c_int, 0);
pub const DH_F_COMPUTE_KEY = @as(c_int, 0);
pub const DH_F_DHPARAMS_PRINT_FP = @as(c_int, 0);
pub const DH_F_DH_BUILTIN_GENPARAMS = @as(c_int, 0);
pub const DH_F_DH_CHECK_EX = @as(c_int, 0);
pub const DH_F_DH_CHECK_PARAMS_EX = @as(c_int, 0);
pub const DH_F_DH_CHECK_PUB_KEY_EX = @as(c_int, 0);
pub const DH_F_DH_CMS_DECRYPT = @as(c_int, 0);
pub const DH_F_DH_CMS_SET_PEERKEY = @as(c_int, 0);
pub const DH_F_DH_CMS_SET_SHARED_INFO = @as(c_int, 0);
pub const DH_F_DH_METH_DUP = @as(c_int, 0);
pub const DH_F_DH_METH_NEW = @as(c_int, 0);
pub const DH_F_DH_METH_SET1_NAME = @as(c_int, 0);
pub const DH_F_DH_NEW_BY_NID = @as(c_int, 0);
pub const DH_F_DH_NEW_METHOD = @as(c_int, 0);
pub const DH_F_DH_PARAM_DECODE = @as(c_int, 0);
pub const DH_F_DH_PKEY_PUBLIC_CHECK = @as(c_int, 0);
pub const DH_F_DH_PRIV_DECODE = @as(c_int, 0);
pub const DH_F_DH_PRIV_ENCODE = @as(c_int, 0);
pub const DH_F_DH_PUB_DECODE = @as(c_int, 0);
pub const DH_F_DH_PUB_ENCODE = @as(c_int, 0);
pub const DH_F_DO_DH_PRINT = @as(c_int, 0);
pub const DH_F_GENERATE_KEY = @as(c_int, 0);
pub const DH_F_PKEY_DH_CTRL_STR = @as(c_int, 0);
pub const DH_F_PKEY_DH_DERIVE = @as(c_int, 0);
pub const DH_F_PKEY_DH_INIT = @as(c_int, 0);
pub const DH_F_PKEY_DH_KEYGEN = @as(c_int, 0);
pub const DSA_F_DSAPARAMS_PRINT = @as(c_int, 0);
pub const DSA_F_DSAPARAMS_PRINT_FP = @as(c_int, 0);
pub const DSA_F_DSA_BUILTIN_PARAMGEN = @as(c_int, 0);
pub const DSA_F_DSA_BUILTIN_PARAMGEN2 = @as(c_int, 0);
pub const DSA_F_DSA_DO_SIGN = @as(c_int, 0);
pub const DSA_F_DSA_DO_VERIFY = @as(c_int, 0);
pub const DSA_F_DSA_METH_DUP = @as(c_int, 0);
pub const DSA_F_DSA_METH_NEW = @as(c_int, 0);
pub const DSA_F_DSA_METH_SET1_NAME = @as(c_int, 0);
pub const DSA_F_DSA_NEW_METHOD = @as(c_int, 0);
pub const DSA_F_DSA_PARAM_DECODE = @as(c_int, 0);
pub const DSA_F_DSA_PRINT_FP = @as(c_int, 0);
pub const DSA_F_DSA_PRIV_DECODE = @as(c_int, 0);
pub const DSA_F_DSA_PRIV_ENCODE = @as(c_int, 0);
pub const DSA_F_DSA_PUB_DECODE = @as(c_int, 0);
pub const DSA_F_DSA_PUB_ENCODE = @as(c_int, 0);
pub const DSA_F_DSA_SIGN = @as(c_int, 0);
pub const DSA_F_DSA_SIGN_SETUP = @as(c_int, 0);
pub const DSA_F_DSA_SIG_NEW = @as(c_int, 0);
pub const DSA_F_OLD_DSA_PRIV_DECODE = @as(c_int, 0);
pub const DSA_F_PKEY_DSA_CTRL = @as(c_int, 0);
pub const DSA_F_PKEY_DSA_CTRL_STR = @as(c_int, 0);
pub const DSA_F_PKEY_DSA_KEYGEN = @as(c_int, 0);
pub const EC_F_BN_TO_FELEM = @as(c_int, 0);
pub const EC_F_D2I_ECPARAMETERS = @as(c_int, 0);
pub const EC_F_D2I_ECPKPARAMETERS = @as(c_int, 0);
pub const EC_F_D2I_ECPRIVATEKEY = @as(c_int, 0);
pub const EC_F_DO_EC_KEY_PRINT = @as(c_int, 0);
pub const EC_F_ECDH_CMS_DECRYPT = @as(c_int, 0);
pub const EC_F_ECDH_CMS_SET_SHARED_INFO = @as(c_int, 0);
pub const EC_F_ECDH_COMPUTE_KEY = @as(c_int, 0);
pub const EC_F_ECDH_SIMPLE_COMPUTE_KEY = @as(c_int, 0);
pub const EC_F_ECDSA_DO_SIGN_EX = @as(c_int, 0);
pub const EC_F_ECDSA_DO_VERIFY = @as(c_int, 0);
pub const EC_F_ECDSA_SIGN_EX = @as(c_int, 0);
pub const EC_F_ECDSA_SIGN_SETUP = @as(c_int, 0);
pub const EC_F_ECDSA_SIG_NEW = @as(c_int, 0);
pub const EC_F_ECDSA_VERIFY = @as(c_int, 0);
pub const EC_F_ECD_ITEM_VERIFY = @as(c_int, 0);
pub const EC_F_ECKEY_PARAM2TYPE = @as(c_int, 0);
pub const EC_F_ECKEY_PARAM_DECODE = @as(c_int, 0);
pub const EC_F_ECKEY_PRIV_DECODE = @as(c_int, 0);
pub const EC_F_ECKEY_PRIV_ENCODE = @as(c_int, 0);
pub const EC_F_ECKEY_PUB_DECODE = @as(c_int, 0);
pub const EC_F_ECKEY_PUB_ENCODE = @as(c_int, 0);
pub const EC_F_ECKEY_TYPE2PARAM = @as(c_int, 0);
pub const EC_F_ECPARAMETERS_PRINT = @as(c_int, 0);
pub const EC_F_ECPARAMETERS_PRINT_FP = @as(c_int, 0);
pub const EC_F_ECPKPARAMETERS_PRINT = @as(c_int, 0);
pub const EC_F_ECPKPARAMETERS_PRINT_FP = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_GET_AFFINE = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_INV_MOD_ORD = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_MULT_PRECOMPUTE = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_POINTS_MUL = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_WINDOWED_MUL = @as(c_int, 0);
pub const EC_F_ECX_KEY_OP = @as(c_int, 0);
pub const EC_F_ECX_PRIV_ENCODE = @as(c_int, 0);
pub const EC_F_ECX_PUB_ENCODE = @as(c_int, 0);
pub const EC_F_EC_ASN1_GROUP2CURVE = @as(c_int, 0);
pub const EC_F_EC_ASN1_GROUP2FIELDID = @as(c_int, 0);
pub const EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_FIELD_INV = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_LADDER_POST = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_LADDER_PRE = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_OCT2POINT = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_POINT2OCT = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_DECODE = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_ENCODE = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_INV = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_SQR = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP224_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP256_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP521_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP521_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_NIST_FIELD_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_NIST_FIELD_SQR = @as(c_int, 0);
pub const EC_F_EC_GFP_NIST_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_BLIND_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_FIELD_INV = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_MAKE_AFFINE = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_OCT2POINT = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_POINT2OCT = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GROUP_CHECK = @as(c_int, 0);
pub const EC_F_EC_GROUP_CHECK_DISCRIMINANT = @as(c_int, 0);
pub const EC_F_EC_GROUP_COPY = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_CURVE_GF2M = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_CURVE_GFP = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_DEGREE = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_ECPARAMETERS = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_ECPKPARAMETERS = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_TRINOMIAL_BASIS = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW_BY_CURVE_NAME = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW_FROM_DATA = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_CURVE_GF2M = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_CURVE_GFP = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_GENERATOR = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_SEED = @as(c_int, 0);
pub const EC_F_EC_KEY_CHECK_KEY = @as(c_int, 0);
pub const EC_F_EC_KEY_COPY = @as(c_int, 0);
pub const EC_F_EC_KEY_GENERATE_KEY = @as(c_int, 0);
pub const EC_F_EC_KEY_NEW = @as(c_int, 0);
pub const EC_F_EC_KEY_NEW_METHOD = @as(c_int, 0);
pub const EC_F_EC_KEY_OCT2PRIV = @as(c_int, 0);
pub const EC_F_EC_KEY_PRINT = @as(c_int, 0);
pub const EC_F_EC_KEY_PRINT_FP = @as(c_int, 0);
pub const EC_F_EC_KEY_PRIV2BUF = @as(c_int, 0);
pub const EC_F_EC_KEY_PRIV2OCT = @as(c_int, 0);
pub const EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_KEY_SIMPLE_CHECK_KEY = @as(c_int, 0);
pub const EC_F_EC_KEY_SIMPLE_OCT2PRIV = @as(c_int, 0);
pub const EC_F_EC_KEY_SIMPLE_PRIV2OCT = @as(c_int, 0);
pub const EC_F_EC_PKEY_CHECK = @as(c_int, 0);
pub const EC_F_EC_PKEY_PARAM_CHECK = @as(c_int, 0);
pub const EC_F_EC_POINTS_MAKE_AFFINE = @as(c_int, 0);
pub const EC_F_EC_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_POINT_ADD = @as(c_int, 0);
pub const EC_F_EC_POINT_BN2POINT = @as(c_int, 0);
pub const EC_F_EC_POINT_CMP = @as(c_int, 0);
pub const EC_F_EC_POINT_COPY = @as(c_int, 0);
pub const EC_F_EC_POINT_DBL = @as(c_int, 0);
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M = @as(c_int, 0);
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_INVERT = @as(c_int, 0);
pub const EC_F_EC_POINT_IS_AT_INFINITY = @as(c_int, 0);
pub const EC_F_EC_POINT_IS_ON_CURVE = @as(c_int, 0);
pub const EC_F_EC_POINT_MAKE_AFFINE = @as(c_int, 0);
pub const EC_F_EC_POINT_NEW = @as(c_int, 0);
pub const EC_F_EC_POINT_OCT2POINT = @as(c_int, 0);
pub const EC_F_EC_POINT_POINT2BUF = @as(c_int, 0);
pub const EC_F_EC_POINT_POINT2OCT = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_TO_INFINITY = @as(c_int, 0);
pub const EC_F_EC_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_EC_SCALAR_MUL_LADDER = @as(c_int, 0);
pub const EC_F_EC_WNAF_MUL = @as(c_int, 0);
pub const EC_F_EC_WNAF_PRECOMPUTE_MULT = @as(c_int, 0);
pub const EC_F_I2D_ECPARAMETERS = @as(c_int, 0);
pub const EC_F_I2D_ECPKPARAMETERS = @as(c_int, 0);
pub const EC_F_I2D_ECPRIVATEKEY = @as(c_int, 0);
pub const EC_F_I2O_ECPUBLICKEY = @as(c_int, 0);
pub const EC_F_NISTP224_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_NISTP256_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_NISTP521_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_O2I_ECPUBLICKEY = @as(c_int, 0);
pub const EC_F_OLD_EC_PRIV_DECODE = @as(c_int, 0);
pub const EC_F_OSSL_ECDH_COMPUTE_KEY = @as(c_int, 0);
pub const EC_F_OSSL_ECDSA_SIGN_SIG = @as(c_int, 0);
pub const EC_F_OSSL_ECDSA_VERIFY_SIG = @as(c_int, 0);
pub const EC_F_PKEY_ECD_CTRL = @as(c_int, 0);
pub const EC_F_PKEY_ECD_DIGESTSIGN = @as(c_int, 0);
pub const EC_F_PKEY_ECD_DIGESTSIGN25519 = @as(c_int, 0);
pub const EC_F_PKEY_ECD_DIGESTSIGN448 = @as(c_int, 0);
pub const EC_F_PKEY_ECX_DERIVE = @as(c_int, 0);
pub const EC_F_PKEY_EC_CTRL = @as(c_int, 0);
pub const EC_F_PKEY_EC_CTRL_STR = @as(c_int, 0);
pub const EC_F_PKEY_EC_DERIVE = @as(c_int, 0);
pub const EC_F_PKEY_EC_INIT = @as(c_int, 0);
pub const EC_F_PKEY_EC_KDF_DERIVE = @as(c_int, 0);
pub const EC_F_PKEY_EC_KEYGEN = @as(c_int, 0);
pub const EC_F_PKEY_EC_PARAMGEN = @as(c_int, 0);
pub const EC_F_PKEY_EC_SIGN = @as(c_int, 0);
pub const EC_F_VALIDATE_ECX_DERIVE = @as(c_int, 0);
pub const ENGINE_F_DIGEST_UPDATE = @as(c_int, 0);
pub const ENGINE_F_DYNAMIC_CTRL = @as(c_int, 0);
pub const ENGINE_F_DYNAMIC_GET_DATA_CTX = @as(c_int, 0);
pub const ENGINE_F_DYNAMIC_LOAD = @as(c_int, 0);
pub const ENGINE_F_DYNAMIC_SET_DATA_CTX = @as(c_int, 0);
pub const ENGINE_F_ENGINE_ADD = @as(c_int, 0);
pub const ENGINE_F_ENGINE_BY_ID = @as(c_int, 0);
pub const ENGINE_F_ENGINE_CMD_IS_EXECUTABLE = @as(c_int, 0);
pub const ENGINE_F_ENGINE_CTRL = @as(c_int, 0);
pub const ENGINE_F_ENGINE_CTRL_CMD = @as(c_int, 0);
pub const ENGINE_F_ENGINE_CTRL_CMD_STRING = @as(c_int, 0);
pub const ENGINE_F_ENGINE_FINISH = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_CIPHER = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_DIGEST = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_FIRST = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_LAST = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_NEXT = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_PKEY_ASN1_METH = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_PKEY_METH = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_PREV = @as(c_int, 0);
pub const ENGINE_F_ENGINE_INIT = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LIST_ADD = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LIST_REMOVE = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LOAD_PRIVATE_KEY = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LOAD_PUBLIC_KEY = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT = @as(c_int, 0);
pub const ENGINE_F_ENGINE_NEW = @as(c_int, 0);
pub const ENGINE_F_ENGINE_PKEY_ASN1_FIND_STR = @as(c_int, 0);
pub const ENGINE_F_ENGINE_REMOVE = @as(c_int, 0);
pub const ENGINE_F_ENGINE_SET_DEFAULT_STRING = @as(c_int, 0);
pub const ENGINE_F_ENGINE_SET_ID = @as(c_int, 0);
pub const ENGINE_F_ENGINE_SET_NAME = @as(c_int, 0);
pub const ENGINE_F_ENGINE_TABLE_REGISTER = @as(c_int, 0);
pub const ENGINE_F_ENGINE_UNLOCKED_FINISH = @as(c_int, 0);
pub const ENGINE_F_ENGINE_UP_REF = @as(c_int, 0);
pub const ENGINE_F_INT_CLEANUP_ITEM = @as(c_int, 0);
pub const ENGINE_F_INT_CTRL_HELPER = @as(c_int, 0);
pub const ENGINE_F_INT_ENGINE_CONFIGURE = @as(c_int, 0);
pub const ENGINE_F_INT_ENGINE_MODULE_INIT = @as(c_int, 0);
pub const ENGINE_F_OSSL_HMAC_INIT = @as(c_int, 0);
pub const EVP_F_AESNI_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AESNI_XTS_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AES_GCM_CTRL = @as(c_int, 0);
pub const EVP_F_AES_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AES_OCB_CIPHER = @as(c_int, 0);
pub const EVP_F_AES_T4_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AES_T4_XTS_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AES_WRAP_CIPHER = @as(c_int, 0);
pub const EVP_F_AES_XTS_INIT_KEY = @as(c_int, 0);
pub const EVP_F_ALG_MODULE_INIT = @as(c_int, 0);
pub const EVP_F_ARIA_CCM_INIT_KEY = @as(c_int, 0);
pub const EVP_F_ARIA_GCM_CTRL = @as(c_int, 0);
pub const EVP_F_ARIA_GCM_INIT_KEY = @as(c_int, 0);
pub const EVP_F_ARIA_INIT_KEY = @as(c_int, 0);
pub const EVP_F_B64_NEW = @as(c_int, 0);
pub const EVP_F_CAMELLIA_INIT_KEY = @as(c_int, 0);
pub const EVP_F_CHACHA20_POLY1305_CTRL = @as(c_int, 0);
pub const EVP_F_CMLL_T4_INIT_KEY = @as(c_int, 0);
pub const EVP_F_DES_EDE3_WRAP_CIPHER = @as(c_int, 0);
pub const EVP_F_DO_SIGVER_INIT = @as(c_int, 0);
pub const EVP_F_ENC_NEW = @as(c_int, 0);
pub const EVP_F_EVP_CIPHERINIT_EX = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_ASN1_TO_PARAM = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_CTX_COPY = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_CTX_CTRL = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_PARAM_TO_ASN1 = @as(c_int, 0);
pub const EVP_F_EVP_DECRYPTFINAL_EX = @as(c_int, 0);
pub const EVP_F_EVP_DECRYPTUPDATE = @as(c_int, 0);
pub const EVP_F_EVP_DIGESTFINALXOF = @as(c_int, 0);
pub const EVP_F_EVP_DIGESTINIT_EX = @as(c_int, 0);
pub const EVP_F_EVP_ENCRYPTDECRYPTUPDATE = @as(c_int, 0);
pub const EVP_F_EVP_ENCRYPTFINAL_EX = @as(c_int, 0);
pub const EVP_F_EVP_ENCRYPTUPDATE = @as(c_int, 0);
pub const EVP_F_EVP_MD_CTX_COPY_EX = @as(c_int, 0);
pub const EVP_F_EVP_MD_SIZE = @as(c_int, 0);
pub const EVP_F_EVP_OPENINIT = @as(c_int, 0);
pub const EVP_F_EVP_PBE_ALG_ADD = @as(c_int, 0);
pub const EVP_F_EVP_PBE_ALG_ADD_TYPE = @as(c_int, 0);
pub const EVP_F_EVP_PBE_CIPHERINIT = @as(c_int, 0);
pub const EVP_F_EVP_PBE_SCRYPT = @as(c_int, 0);
pub const EVP_F_EVP_PKCS82PKEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY2PKCS8 = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_ASN1_ADD0 = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CHECK = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_COPY_PARAMETERS = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CTX_CTRL = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CTX_CTRL_STR = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CTX_DUP = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CTX_MD = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DECRYPT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DECRYPT_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DECRYPT_OLD = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DERIVE = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DERIVE_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DERIVE_SET_PEER = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_ENCRYPT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_ENCRYPT_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_ENCRYPT_OLD = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_DH = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_DSA = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_EC_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_HMAC = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_POLY1305 = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_RSA = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_SIPHASH = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET_RAW_PRIVATE_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET_RAW_PUBLIC_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_KEYGEN = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_KEYGEN_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_METH_ADD0 = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_METH_NEW = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_NEW = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_NEW_CMAC_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_NEW_RAW_PRIVATE_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_NEW_RAW_PUBLIC_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_PARAMGEN = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_PARAMGEN_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_PARAM_CHECK = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_PUBLIC_CHECK = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_SET1_ENGINE = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_SET_ALIAS_TYPE = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_SIGN = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_SIGN_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_VERIFY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_VERIFY_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT = @as(c_int, 0);
pub const EVP_F_EVP_SIGNFINAL = @as(c_int, 0);
pub const EVP_F_EVP_VERIFYFINAL = @as(c_int, 0);
pub const EVP_F_INT_CTX_NEW = @as(c_int, 0);
pub const EVP_F_OK_NEW = @as(c_int, 0);
pub const EVP_F_PKCS5_PBE_KEYIVGEN = @as(c_int, 0);
pub const EVP_F_PKCS5_V2_PBE_KEYIVGEN = @as(c_int, 0);
pub const EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN = @as(c_int, 0);
pub const EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN = @as(c_int, 0);
pub const EVP_F_PKEY_SET_TYPE = @as(c_int, 0);
pub const EVP_F_RC2_MAGIC_TO_METH = @as(c_int, 0);
pub const EVP_F_RC5_CTRL = @as(c_int, 0);
pub const EVP_F_R_32_12_16_INIT_KEY = @as(c_int, 0);
pub const EVP_F_S390X_AES_GCM_CTRL = @as(c_int, 0);
pub const EVP_F_UPDATE = @as(c_int, 0);
pub const KDF_F_PKEY_HKDF_CTRL_STR = @as(c_int, 0);
pub const KDF_F_PKEY_HKDF_DERIVE = @as(c_int, 0);
pub const KDF_F_PKEY_HKDF_INIT = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_CTRL_STR = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_CTRL_UINT64 = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_DERIVE = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_INIT = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_SET_MEMBUF = @as(c_int, 0);
pub const KDF_F_PKEY_TLS1_PRF_CTRL_STR = @as(c_int, 0);
pub const KDF_F_PKEY_TLS1_PRF_DERIVE = @as(c_int, 0);
pub const KDF_F_PKEY_TLS1_PRF_INIT = @as(c_int, 0);
pub const KDF_F_TLS1_PRF_ALG = @as(c_int, 0);
pub const KDF_R_INVALID_DIGEST = @as(c_int, 0);
pub const KDF_R_MISSING_ITERATION_COUNT = @as(c_int, 0);
pub const KDF_R_MISSING_KEY = @as(c_int, 0);
pub const KDF_R_MISSING_MESSAGE_DIGEST = @as(c_int, 0);
pub const KDF_R_MISSING_PARAMETER = @as(c_int, 0);
pub const KDF_R_MISSING_PASS = @as(c_int, 0);
pub const KDF_R_MISSING_SALT = @as(c_int, 0);
pub const KDF_R_MISSING_SECRET = @as(c_int, 0);
pub const KDF_R_MISSING_SEED = @as(c_int, 0);
pub const KDF_R_UNKNOWN_PARAMETER_TYPE = @as(c_int, 0);
pub const KDF_R_VALUE_ERROR = @as(c_int, 0);
pub const KDF_R_VALUE_MISSING = @as(c_int, 0);
pub const OBJ_F_OBJ_ADD_OBJECT = @as(c_int, 0);
pub const OBJ_F_OBJ_ADD_SIGID = @as(c_int, 0);
pub const OBJ_F_OBJ_CREATE = @as(c_int, 0);
pub const OBJ_F_OBJ_DUP = @as(c_int, 0);
pub const OBJ_F_OBJ_NAME_NEW_INDEX = @as(c_int, 0);
pub const OBJ_F_OBJ_NID2LN = @as(c_int, 0);
pub const OBJ_F_OBJ_NID2OBJ = @as(c_int, 0);
pub const OBJ_F_OBJ_NID2SN = @as(c_int, 0);
pub const OBJ_F_OBJ_TXT2OBJ = @as(c_int, 0);
pub const OCSP_F_D2I_OCSP_NONCE = @as(c_int, 0);
pub const OCSP_F_OCSP_BASIC_ADD1_STATUS = @as(c_int, 0);
pub const OCSP_F_OCSP_BASIC_SIGN = @as(c_int, 0);
pub const OCSP_F_OCSP_BASIC_SIGN_CTX = @as(c_int, 0);
pub const OCSP_F_OCSP_BASIC_VERIFY = @as(c_int, 0);
pub const OCSP_F_OCSP_CERT_ID_NEW = @as(c_int, 0);
pub const OCSP_F_OCSP_CHECK_DELEGATED = @as(c_int, 0);
pub const OCSP_F_OCSP_CHECK_IDS = @as(c_int, 0);
pub const OCSP_F_OCSP_CHECK_ISSUER = @as(c_int, 0);
pub const OCSP_F_OCSP_CHECK_VALIDITY = @as(c_int, 0);
pub const OCSP_F_OCSP_MATCH_ISSUERID = @as(c_int, 0);
pub const OCSP_F_OCSP_PARSE_URL = @as(c_int, 0);
pub const OCSP_F_OCSP_REQUEST_SIGN = @as(c_int, 0);
pub const OCSP_F_OCSP_REQUEST_VERIFY = @as(c_int, 0);
pub const OCSP_F_OCSP_RESPONSE_GET1_BASIC = @as(c_int, 0);
pub const OCSP_F_PARSE_HTTP_LINE1 = @as(c_int, 0);
pub const PEM_F_B2I_DSS = @as(c_int, 0);
pub const PEM_F_B2I_PVK_BIO = @as(c_int, 0);
pub const PEM_F_B2I_RSA = @as(c_int, 0);
pub const PEM_F_CHECK_BITLEN_DSA = @as(c_int, 0);
pub const PEM_F_CHECK_BITLEN_RSA = @as(c_int, 0);
pub const PEM_F_D2I_PKCS8PRIVATEKEY_BIO = @as(c_int, 0);
pub const PEM_F_D2I_PKCS8PRIVATEKEY_FP = @as(c_int, 0);
pub const PEM_F_DO_B2I = @as(c_int, 0);
pub const PEM_F_DO_B2I_BIO = @as(c_int, 0);
pub const PEM_F_DO_BLOB_HEADER = @as(c_int, 0);
pub const PEM_F_DO_I2B = @as(c_int, 0);
pub const PEM_F_DO_PK8PKEY = @as(c_int, 0);
pub const PEM_F_DO_PK8PKEY_FP = @as(c_int, 0);
pub const PEM_F_DO_PVK_BODY = @as(c_int, 0);
pub const PEM_F_DO_PVK_HEADER = @as(c_int, 0);
pub const PEM_F_GET_HEADER_AND_DATA = @as(c_int, 0);
pub const PEM_F_GET_NAME = @as(c_int, 0);
pub const PEM_F_I2B_PVK = @as(c_int, 0);
pub const PEM_F_I2B_PVK_BIO = @as(c_int, 0);
pub const PEM_F_LOAD_IV = @as(c_int, 0);
pub const PEM_F_PEM_ASN1_READ = @as(c_int, 0);
pub const PEM_F_PEM_ASN1_READ_BIO = @as(c_int, 0);
pub const PEM_F_PEM_ASN1_WRITE = @as(c_int, 0);
pub const PEM_F_PEM_ASN1_WRITE_BIO = @as(c_int, 0);
pub const PEM_F_PEM_DEF_CALLBACK = @as(c_int, 0);
pub const PEM_F_PEM_DO_HEADER = @as(c_int, 0);
pub const PEM_F_PEM_GET_EVP_CIPHER_INFO = @as(c_int, 0);
pub const PEM_F_PEM_READ = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO_DHPARAMS = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO_EX = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO_PARAMETERS = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO_PRIVATEKEY = @as(c_int, 0);
pub const PEM_F_PEM_READ_DHPARAMS = @as(c_int, 0);
pub const PEM_F_PEM_READ_PRIVATEKEY = @as(c_int, 0);
pub const PEM_F_PEM_SIGNFINAL = @as(c_int, 0);
pub const PEM_F_PEM_WRITE = @as(c_int, 0);
pub const PEM_F_PEM_WRITE_BIO = @as(c_int, 0);
pub const PEM_F_PEM_WRITE_BIO_PRIVATEKEY_TRADITIONAL = @as(c_int, 0);
pub const PEM_F_PEM_WRITE_PRIVATEKEY = @as(c_int, 0);
pub const PEM_F_PEM_X509_INFO_READ = @as(c_int, 0);
pub const PEM_F_PEM_X509_INFO_READ_BIO = @as(c_int, 0);
pub const PEM_F_PEM_X509_INFO_WRITE_BIO = @as(c_int, 0);
pub const PKCS12_F_OPENSSL_ASC2UNI = @as(c_int, 0);
pub const PKCS12_F_OPENSSL_UNI2ASC = @as(c_int, 0);
pub const PKCS12_F_OPENSSL_UNI2UTF8 = @as(c_int, 0);
pub const PKCS12_F_OPENSSL_UTF82UNI = @as(c_int, 0);
pub const PKCS12_F_PKCS12_CREATE = @as(c_int, 0);
pub const PKCS12_F_PKCS12_GEN_MAC = @as(c_int, 0);
pub const PKCS12_F_PKCS12_INIT = @as(c_int, 0);
pub const PKCS12_F_PKCS12_ITEM_DECRYPT_D2I = @as(c_int, 0);
pub const PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT = @as(c_int, 0);
pub const PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG = @as(c_int, 0);
pub const PKCS12_F_PKCS12_KEY_GEN_ASC = @as(c_int, 0);
pub const PKCS12_F_PKCS12_KEY_GEN_UNI = @as(c_int, 0);
pub const PKCS12_F_PKCS12_KEY_GEN_UTF8 = @as(c_int, 0);
pub const PKCS12_F_PKCS12_NEWPASS = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PACK_P7DATA = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PACK_P7ENCDATA = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PARSE = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PBE_CRYPT = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PBE_KEYIVGEN = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SAFEBAG_CREATE0_P8INF = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SAFEBAG_CREATE0_PKCS8 = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SAFEBAG_CREATE_PKCS8_ENCRYPT = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SETUP_MAC = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SET_MAC = @as(c_int, 0);
pub const PKCS12_F_PKCS12_UNPACK_AUTHSAFES = @as(c_int, 0);
pub const PKCS12_F_PKCS12_UNPACK_P7DATA = @as(c_int, 0);
pub const PKCS12_F_PKCS12_VERIFY_MAC = @as(c_int, 0);
pub const PKCS12_F_PKCS8_ENCRYPT = @as(c_int, 0);
pub const PKCS12_F_PKCS8_SET0_PBE = @as(c_int, 0);
pub const PKCS7_F_DO_PKCS7_SIGNED_ATTRIB = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD0_ATTRIB_SIGNING_TIME = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_ATTRIB_SMIMECAP = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_CERTIFICATE = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_CRL = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_RECIPIENT_INFO = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_SIGNATURE = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_SIGNER = @as(c_int, 0);
pub const PKCS7_F_PKCS7_BIO_ADD_DIGEST = @as(c_int, 0);
pub const PKCS7_F_PKCS7_COPY_EXISTING_DIGEST = @as(c_int, 0);
pub const PKCS7_F_PKCS7_CTRL = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DATADECODE = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DATAFINAL = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DATAINIT = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DATAVERIFY = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DECRYPT = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DECRYPT_RINFO = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ENCODE_RINFO = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ENCRYPT = @as(c_int, 0);
pub const PKCS7_F_PKCS7_FINAL = @as(c_int, 0);
pub const PKCS7_F_PKCS7_FIND_DIGEST = @as(c_int, 0);
pub const PKCS7_F_PKCS7_GET0_SIGNERS = @as(c_int, 0);
pub const PKCS7_F_PKCS7_RECIP_INFO_SET = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SET_CIPHER = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SET_CONTENT = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SET_DIGEST = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SET_TYPE = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGN = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGNATUREVERIFY = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGNER_INFO_SET = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGNER_INFO_SIGN = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGN_ADD_SIGNER = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIMPLE_SMIMECAP = @as(c_int, 0);
pub const PKCS7_F_PKCS7_VERIFY = @as(c_int, 0);
pub const RAND_F_DATA_COLLECT_METHOD = @as(c_int, 0);
pub const RAND_F_DRBG_BYTES = @as(c_int, 0);
pub const RAND_F_DRBG_GET_ENTROPY = @as(c_int, 0);
pub const RAND_F_DRBG_SETUP = @as(c_int, 0);
pub const RAND_F_GET_ENTROPY = @as(c_int, 0);
pub const RAND_F_RAND_BYTES = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_ENABLE_LOCKING = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_GENERATE = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_GET_ENTROPY = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_GET_NONCE = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_INSTANTIATE = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_NEW = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_RESEED = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_RESTART = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_SET = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_SET_DEFAULTS = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_UNINSTANTIATE = @as(c_int, 0);
pub const RAND_F_RAND_LOAD_FILE = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ACQUIRE_ENTROPY = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ADD = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ADD_BEGIN = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ADD_END = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ATTACH = @as(c_int, 0);
pub const RAND_F_RAND_POOL_BYTES_NEEDED = @as(c_int, 0);
pub const RAND_F_RAND_POOL_GROW = @as(c_int, 0);
pub const RAND_F_RAND_POOL_NEW = @as(c_int, 0);
pub const RAND_F_RAND_PSEUDO_BYTES = @as(c_int, 0);
pub const RAND_F_RAND_WRITE_FILE = @as(c_int, 0);
pub const RSA_F_CHECK_PADDING_MD = @as(c_int, 0);
pub const RSA_F_ENCODE_PKCS1 = @as(c_int, 0);
pub const RSA_F_INT_RSA_VERIFY = @as(c_int, 0);
pub const RSA_F_OLD_RSA_PRIV_DECODE = @as(c_int, 0);
pub const RSA_F_PKEY_PSS_INIT = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_CTRL = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_CTRL_STR = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_SIGN = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_VERIFY = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_VERIFYRECOVER = @as(c_int, 0);
pub const RSA_F_RSA_ALGOR_TO_MD = @as(c_int, 0);
pub const RSA_F_RSA_BUILTIN_KEYGEN = @as(c_int, 0);
pub const RSA_F_RSA_CHECK_KEY = @as(c_int, 0);
pub const RSA_F_RSA_CHECK_KEY_EX = @as(c_int, 0);
pub const RSA_F_RSA_CMS_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_CMS_VERIFY = @as(c_int, 0);
pub const RSA_F_RSA_ITEM_VERIFY = @as(c_int, 0);
pub const RSA_F_RSA_METH_DUP = @as(c_int, 0);
pub const RSA_F_RSA_METH_NEW = @as(c_int, 0);
pub const RSA_F_RSA_METH_SET1_NAME = @as(c_int, 0);
pub const RSA_F_RSA_MGF1_TO_MD = @as(c_int, 0);
pub const RSA_F_RSA_MULTIP_INFO_NEW = @as(c_int, 0);
pub const RSA_F_RSA_NEW_METHOD = @as(c_int, 0);
pub const RSA_F_RSA_NULL = @as(c_int, 0);
pub const RSA_F_RSA_NULL_PRIVATE_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_NULL_PRIVATE_ENCRYPT = @as(c_int, 0);
pub const RSA_F_RSA_NULL_PUBLIC_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_NULL_PUBLIC_ENCRYPT = @as(c_int, 0);
pub const RSA_F_RSA_OSSL_PRIVATE_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_OSSL_PRIVATE_ENCRYPT = @as(c_int, 0);
pub const RSA_F_RSA_OSSL_PUBLIC_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_OSSL_PUBLIC_ENCRYPT = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_NONE = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_SSLV23 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_X931 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_NONE = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_SSLV23 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_X931 = @as(c_int, 0);
pub const RSA_F_RSA_PARAM_DECODE = @as(c_int, 0);
pub const RSA_F_RSA_PRINT = @as(c_int, 0);
pub const RSA_F_RSA_PRINT_FP = @as(c_int, 0);
pub const RSA_F_RSA_PRIV_DECODE = @as(c_int, 0);
pub const RSA_F_RSA_PRIV_ENCODE = @as(c_int, 0);
pub const RSA_F_RSA_PSS_GET_PARAM = @as(c_int, 0);
pub const RSA_F_RSA_PSS_TO_CTX = @as(c_int, 0);
pub const RSA_F_RSA_PUB_DECODE = @as(c_int, 0);
pub const RSA_F_RSA_SETUP_BLINDING = @as(c_int, 0);
pub const RSA_F_RSA_SIGN = @as(c_int, 0);
pub const RSA_F_RSA_SIGN_ASN1_OCTET_STRING = @as(c_int, 0);
pub const RSA_F_RSA_VERIFY = @as(c_int, 0);
pub const RSA_F_RSA_VERIFY_ASN1_OCTET_STRING = @as(c_int, 0);
pub const RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1 = @as(c_int, 0);
pub const RSA_F_SETUP_TBUF = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_CTRL = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_FIND = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_GET_PASS = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_LOAD = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_LOAD_TRY_DECODE = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_NAME_TO_URI = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_OPEN = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_ATTACH_PEM_BIO = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_EXPECT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_FILE_ATTACH_PEM_BIO_INT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_FIND = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_GET0_LOADER_INT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_CERT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_CRL = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME_DESCRIPTION = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_PARAMS = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_PKEY = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_CERT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_CRL = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_EMBEDDED = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_NAME = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_PARAMS = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_PKEY = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_SET0_NAME_DESCRIPTION = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INIT_ONCE = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_LOADER_NEW = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_OPEN = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_OPEN_INT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_REGISTER_LOADER_INT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_ALIAS = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_ISSUER_SERIAL = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_KEY_FINGERPRINT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_NAME = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_UNREGISTER_LOADER_INT = @as(c_int, 0);
pub const OSSL_STORE_F_TRY_DECODE_PARAMS = @as(c_int, 0);
pub const OSSL_STORE_F_TRY_DECODE_PKCS12 = @as(c_int, 0);
pub const OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED = @as(c_int, 0);
pub const TS_F_DEF_SERIAL_CB = @as(c_int, 0);
pub const TS_F_DEF_TIME_CB = @as(c_int, 0);
pub const TS_F_ESS_ADD_SIGNING_CERT = @as(c_int, 0);
pub const TS_F_ESS_ADD_SIGNING_CERT_V2 = @as(c_int, 0);
pub const TS_F_ESS_CERT_ID_NEW_INIT = @as(c_int, 0);
pub const TS_F_ESS_CERT_ID_V2_NEW_INIT = @as(c_int, 0);
pub const TS_F_ESS_SIGNING_CERT_NEW_INIT = @as(c_int, 0);
pub const TS_F_ESS_SIGNING_CERT_V2_NEW_INIT = @as(c_int, 0);
pub const TS_F_INT_TS_RESP_VERIFY_TOKEN = @as(c_int, 0);
pub const TS_F_PKCS7_TO_TS_TST_INFO = @as(c_int, 0);
pub const TS_F_TS_ACCURACY_SET_MICROS = @as(c_int, 0);
pub const TS_F_TS_ACCURACY_SET_MILLIS = @as(c_int, 0);
pub const TS_F_TS_ACCURACY_SET_SECONDS = @as(c_int, 0);
pub const TS_F_TS_CHECK_IMPRINTS = @as(c_int, 0);
pub const TS_F_TS_CHECK_NONCES = @as(c_int, 0);
pub const TS_F_TS_CHECK_POLICY = @as(c_int, 0);
pub const TS_F_TS_CHECK_SIGNING_CERTS = @as(c_int, 0);
pub const TS_F_TS_CHECK_STATUS_INFO = @as(c_int, 0);
pub const TS_F_TS_COMPUTE_IMPRINT = @as(c_int, 0);
pub const TS_F_TS_CONF_INVALID = @as(c_int, 0);
pub const TS_F_TS_CONF_LOAD_CERT = @as(c_int, 0);
pub const TS_F_TS_CONF_LOAD_CERTS = @as(c_int, 0);
pub const TS_F_TS_CONF_LOAD_KEY = @as(c_int, 0);
pub const TS_F_TS_CONF_LOOKUP_FAIL = @as(c_int, 0);
pub const TS_F_TS_CONF_SET_DEFAULT_ENGINE = @as(c_int, 0);
pub const TS_F_TS_GET_STATUS_TEXT = @as(c_int, 0);
pub const TS_F_TS_MSG_IMPRINT_SET_ALGO = @as(c_int, 0);
pub const TS_F_TS_REQ_SET_MSG_IMPRINT = @as(c_int, 0);
pub const TS_F_TS_REQ_SET_NONCE = @as(c_int, 0);
pub const TS_F_TS_REQ_SET_POLICY_ID = @as(c_int, 0);
pub const TS_F_TS_RESP_CREATE_RESPONSE = @as(c_int, 0);
pub const TS_F_TS_RESP_CREATE_TST_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_ADD_FAILURE_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_ADD_MD = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_ADD_POLICY = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_NEW = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_ACCURACY = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_CERTS = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_DEF_POLICY = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_SIGNER_CERT = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_STATUS_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_GET_POLICY = @as(c_int, 0);
pub const TS_F_TS_RESP_SET_GENTIME_WITH_PRECISION = @as(c_int, 0);
pub const TS_F_TS_RESP_SET_STATUS_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_SET_TST_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_SIGN = @as(c_int, 0);
pub const TS_F_TS_RESP_VERIFY_SIGNATURE = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_ACCURACY = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_MSG_IMPRINT = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_NONCE = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_POLICY_ID = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_SERIAL = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_TIME = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_TSA = @as(c_int, 0);
pub const TS_F_TS_VERIFY = @as(c_int, 0);
pub const TS_F_TS_VERIFY_CERT = @as(c_int, 0);
pub const TS_F_TS_VERIFY_CTX_NEW = @as(c_int, 0);
pub const UI_F_CLOSE_CONSOLE = @as(c_int, 0);
pub const UI_F_ECHO_CONSOLE = @as(c_int, 0);
pub const UI_F_GENERAL_ALLOCATE_BOOLEAN = @as(c_int, 0);
pub const UI_F_GENERAL_ALLOCATE_PROMPT = @as(c_int, 0);
pub const UI_F_NOECHO_CONSOLE = @as(c_int, 0);
pub const UI_F_OPEN_CONSOLE = @as(c_int, 0);
pub const UI_F_UI_CONSTRUCT_PROMPT = @as(c_int, 0);
pub const UI_F_UI_CREATE_METHOD = @as(c_int, 0);
pub const UI_F_UI_CTRL = @as(c_int, 0);
pub const UI_F_UI_DUP_ERROR_STRING = @as(c_int, 0);
pub const UI_F_UI_DUP_INFO_STRING = @as(c_int, 0);
pub const UI_F_UI_DUP_INPUT_BOOLEAN = @as(c_int, 0);
pub const UI_F_UI_DUP_INPUT_STRING = @as(c_int, 0);
pub const UI_F_UI_DUP_USER_DATA = @as(c_int, 0);
pub const UI_F_UI_DUP_VERIFY_STRING = @as(c_int, 0);
pub const UI_F_UI_GET0_RESULT = @as(c_int, 0);
pub const UI_F_UI_GET_RESULT_LENGTH = @as(c_int, 0);
pub const UI_F_UI_NEW_METHOD = @as(c_int, 0);
pub const UI_F_UI_PROCESS = @as(c_int, 0);
pub const UI_F_UI_SET_RESULT = @as(c_int, 0);
pub const UI_F_UI_SET_RESULT_EX = @as(c_int, 0);
pub const X509_F_ADD_CERT_DIR = @as(c_int, 0);
pub const X509_F_BUILD_CHAIN = @as(c_int, 0);
pub const X509_F_BY_FILE_CTRL = @as(c_int, 0);
pub const X509_F_CHECK_NAME_CONSTRAINTS = @as(c_int, 0);
pub const X509_F_CHECK_POLICY = @as(c_int, 0);
pub const X509_F_DANE_I2D = @as(c_int, 0);
pub const X509_F_DIR_CTRL = @as(c_int, 0);
pub const X509_F_GET_CERT_BY_SUBJECT = @as(c_int, 0);
pub const X509_F_I2D_X509_AUX = @as(c_int, 0);
pub const X509_F_LOOKUP_CERTS_SK = @as(c_int, 0);
pub const X509_F_NETSCAPE_SPKI_B64_DECODE = @as(c_int, 0);
pub const X509_F_NETSCAPE_SPKI_B64_ENCODE = @as(c_int, 0);
pub const X509_F_NEW_DIR = @as(c_int, 0);
pub const X509_F_X509AT_ADD1_ATTR = @as(c_int, 0);
pub const X509_F_X509V3_ADD_EXT = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_NID = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_OBJ = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_TXT = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_GET0_DATA = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_SET1_DATA = @as(c_int, 0);
pub const X509_F_X509_CHECK_PRIVATE_KEY = @as(c_int, 0);
pub const X509_F_X509_CRL_DIFF = @as(c_int, 0);
pub const X509_F_X509_CRL_METHOD_NEW = @as(c_int, 0);
pub const X509_F_X509_CRL_PRINT_FP = @as(c_int, 0);
pub const X509_F_X509_EXTENSION_CREATE_BY_NID = @as(c_int, 0);
pub const X509_F_X509_EXTENSION_CREATE_BY_OBJ = @as(c_int, 0);
pub const X509_F_X509_GET_PUBKEY_PARAMETERS = @as(c_int, 0);
pub const X509_F_X509_LOAD_CERT_CRL_FILE = @as(c_int, 0);
pub const X509_F_X509_LOAD_CERT_FILE = @as(c_int, 0);
pub const X509_F_X509_LOAD_CRL_FILE = @as(c_int, 0);
pub const X509_F_X509_LOOKUP_METH_NEW = @as(c_int, 0);
pub const X509_F_X509_LOOKUP_NEW = @as(c_int, 0);
pub const X509_F_X509_NAME_ADD_ENTRY = @as(c_int, 0);
pub const X509_F_X509_NAME_CANON = @as(c_int, 0);
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_NID = @as(c_int, 0);
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_TXT = @as(c_int, 0);
pub const X509_F_X509_NAME_ENTRY_SET_OBJECT = @as(c_int, 0);
pub const X509_F_X509_NAME_ONELINE = @as(c_int, 0);
pub const X509_F_X509_NAME_PRINT = @as(c_int, 0);
pub const X509_F_X509_OBJECT_NEW = @as(c_int, 0);
pub const X509_F_X509_PRINT_EX_FP = @as(c_int, 0);
pub const X509_F_X509_PUBKEY_DECODE = @as(c_int, 0);
pub const X509_F_X509_PUBKEY_GET = @as(c_int, 0);
pub const X509_F_X509_PUBKEY_GET0 = @as(c_int, 0);
pub const X509_F_X509_PUBKEY_SET = @as(c_int, 0);
pub const X509_F_X509_REQ_CHECK_PRIVATE_KEY = @as(c_int, 0);
pub const X509_F_X509_REQ_PRINT_EX = @as(c_int, 0);
pub const X509_F_X509_REQ_PRINT_FP = @as(c_int, 0);
pub const X509_F_X509_REQ_TO_X509 = @as(c_int, 0);
pub const X509_F_X509_STORE_ADD_CERT = @as(c_int, 0);
pub const X509_F_X509_STORE_ADD_CRL = @as(c_int, 0);
pub const X509_F_X509_STORE_ADD_LOOKUP = @as(c_int, 0);
pub const X509_F_X509_STORE_CTX_GET1_ISSUER = @as(c_int, 0);
pub const X509_F_X509_STORE_CTX_INIT = @as(c_int, 0);
pub const X509_F_X509_STORE_CTX_NEW = @as(c_int, 0);
pub const X509_F_X509_STORE_CTX_PURPOSE_INHERIT = @as(c_int, 0);
pub const X509_F_X509_STORE_NEW = @as(c_int, 0);
pub const X509_F_X509_TO_X509_REQ = @as(c_int, 0);
pub const X509_F_X509_TRUST_ADD = @as(c_int, 0);
pub const X509_F_X509_TRUST_SET = @as(c_int, 0);
pub const X509_F_X509_VERIFY_CERT = @as(c_int, 0);
pub const X509_F_X509_VERIFY_PARAM_NEW = @as(c_int, 0);
pub const X509V3_F_A2I_GENERAL_NAME = @as(c_int, 0);
pub const X509V3_F_ADDR_VALIDATE_PATH_INTERNAL = @as(c_int, 0);
pub const X509V3_F_ASIDENTIFIERCHOICE_CANONIZE = @as(c_int, 0);
pub const X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL = @as(c_int, 0);
pub const X509V3_F_BIGNUM_TO_STRING = @as(c_int, 0);
pub const X509V3_F_COPY_EMAIL = @as(c_int, 0);
pub const X509V3_F_COPY_ISSUER = @as(c_int, 0);
pub const X509V3_F_DO_DIRNAME = @as(c_int, 0);
pub const X509V3_F_DO_EXT_I2D = @as(c_int, 0);
pub const X509V3_F_DO_EXT_NCONF = @as(c_int, 0);
pub const X509V3_F_GNAMES_FROM_SECTNAME = @as(c_int, 0);
pub const X509V3_F_I2S_ASN1_ENUMERATED = @as(c_int, 0);
pub const X509V3_F_I2S_ASN1_IA5STRING = @as(c_int, 0);
pub const X509V3_F_I2S_ASN1_INTEGER = @as(c_int, 0);
pub const X509V3_F_I2V_AUTHORITY_INFO_ACCESS = @as(c_int, 0);
pub const X509V3_F_LEVEL_ADD_NODE = @as(c_int, 0);
pub const X509V3_F_NOTICE_SECTION = @as(c_int, 0);
pub const X509V3_F_NREF_NOS = @as(c_int, 0);
pub const X509V3_F_POLICY_CACHE_CREATE = @as(c_int, 0);
pub const X509V3_F_POLICY_CACHE_NEW = @as(c_int, 0);
pub const X509V3_F_POLICY_DATA_NEW = @as(c_int, 0);
pub const X509V3_F_POLICY_SECTION = @as(c_int, 0);
pub const X509V3_F_PROCESS_PCI_VALUE = @as(c_int, 0);
pub const X509V3_F_R2I_CERTPOL = @as(c_int, 0);
pub const X509V3_F_R2I_PCI = @as(c_int, 0);
pub const X509V3_F_S2I_ASN1_IA5STRING = @as(c_int, 0);
pub const X509V3_F_S2I_ASN1_INTEGER = @as(c_int, 0);
pub const X509V3_F_S2I_ASN1_OCTET_STRING = @as(c_int, 0);
pub const X509V3_F_S2I_SKEY_ID = @as(c_int, 0);
pub const X509V3_F_SET_DIST_POINT_NAME = @as(c_int, 0);
pub const X509V3_F_SXNET_ADD_ID_ASC = @as(c_int, 0);
pub const X509V3_F_SXNET_ADD_ID_INTEGER = @as(c_int, 0);
pub const X509V3_F_SXNET_ADD_ID_ULONG = @as(c_int, 0);
pub const X509V3_F_SXNET_GET_ID_ASC = @as(c_int, 0);
pub const X509V3_F_SXNET_GET_ID_ULONG = @as(c_int, 0);
pub const X509V3_F_TREE_INIT = @as(c_int, 0);
pub const X509V3_F_V2I_ASIDENTIFIERS = @as(c_int, 0);
pub const X509V3_F_V2I_ASN1_BIT_STRING = @as(c_int, 0);
pub const X509V3_F_V2I_AUTHORITY_INFO_ACCESS = @as(c_int, 0);
pub const X509V3_F_V2I_AUTHORITY_KEYID = @as(c_int, 0);
pub const X509V3_F_V2I_BASIC_CONSTRAINTS = @as(c_int, 0);
pub const X509V3_F_V2I_CRLD = @as(c_int, 0);
pub const X509V3_F_V2I_EXTENDED_KEY_USAGE = @as(c_int, 0);
pub const X509V3_F_V2I_GENERAL_NAMES = @as(c_int, 0);
pub const X509V3_F_V2I_GENERAL_NAME_EX = @as(c_int, 0);
pub const X509V3_F_V2I_IDP = @as(c_int, 0);
pub const X509V3_F_V2I_IPADDRBLOCKS = @as(c_int, 0);
pub const X509V3_F_V2I_ISSUER_ALT = @as(c_int, 0);
pub const X509V3_F_V2I_NAME_CONSTRAINTS = @as(c_int, 0);
pub const X509V3_F_V2I_POLICY_CONSTRAINTS = @as(c_int, 0);
pub const X509V3_F_V2I_POLICY_MAPPINGS = @as(c_int, 0);
pub const X509V3_F_V2I_SUBJECT_ALT = @as(c_int, 0);
pub const X509V3_F_V2I_TLS_FEATURE = @as(c_int, 0);
pub const X509V3_F_V3_GENERIC_EXTENSION = @as(c_int, 0);
pub const X509V3_F_X509V3_ADD1_I2D = @as(c_int, 0);
pub const X509V3_F_X509V3_ADD_VALUE = @as(c_int, 0);
pub const X509V3_F_X509V3_EXT_ADD = @as(c_int, 0);
pub const X509V3_F_X509V3_EXT_ADD_ALIAS = @as(c_int, 0);
pub const X509V3_F_X509V3_EXT_I2D = @as(c_int, 0);
pub const X509V3_F_X509V3_EXT_NCONF = @as(c_int, 0);
pub const X509V3_F_X509V3_GET_SECTION = @as(c_int, 0);
pub const X509V3_F_X509V3_GET_STRING = @as(c_int, 0);
pub const X509V3_F_X509V3_GET_VALUE_BOOL = @as(c_int, 0);
pub const X509V3_F_X509V3_PARSE_LIST = @as(c_int, 0);
pub const X509V3_F_X509_PURPOSE_ADD = @as(c_int, 0);
pub const X509V3_F_X509_PURPOSE_SET = @as(c_int, 0);
pub const EVP_R_OPERATON_NOT_INITIALIZED = EVP_R_OPERATION_NOT_INITIALIZED;
pub const CRYPTO_R_BAD_ALGORITHM_NAME = @as(c_int, 117);
pub const CRYPTO_R_CONFLICTING_NAMES = @as(c_int, 118);
pub const CRYPTO_R_HEX_STRING_TOO_SHORT = @as(c_int, 121);
pub const CRYPTO_R_ILLEGAL_HEX_DIGIT = @as(c_int, 102);
pub const CRYPTO_R_INSUFFICIENT_DATA_SPACE = @as(c_int, 106);
pub const CRYPTO_R_INSUFFICIENT_PARAM_SIZE = @as(c_int, 107);
pub const CRYPTO_R_INSUFFICIENT_SECURE_DATA_SPACE = @as(c_int, 108);
pub const CRYPTO_R_INTEGER_OVERFLOW = @as(c_int, 127);
pub const CRYPTO_R_INVALID_NEGATIVE_VALUE = @as(c_int, 122);
pub const CRYPTO_R_INVALID_NULL_ARGUMENT = @as(c_int, 109);
pub const CRYPTO_R_INVALID_OSSL_PARAM_TYPE = @as(c_int, 110);
pub const CRYPTO_R_NO_PARAMS_TO_MERGE = @as(c_int, 131);
pub const CRYPTO_R_NO_SPACE_FOR_TERMINATING_NULL = @as(c_int, 128);
pub const CRYPTO_R_ODD_NUMBER_OF_DIGITS = @as(c_int, 103);
pub const CRYPTO_R_PARAM_CANNOT_BE_REPRESENTED_EXACTLY = @as(c_int, 123);
pub const CRYPTO_R_PARAM_NOT_INTEGER_TYPE = @as(c_int, 124);
pub const CRYPTO_R_PARAM_OF_INCOMPATIBLE_TYPE = @as(c_int, 129);
pub const CRYPTO_R_PARAM_UNSIGNED_INTEGER_NEGATIVE_VALUE_UNSUPPORTED = @as(c_int, 125);
pub const CRYPTO_R_PARAM_UNSUPPORTED_FLOATING_POINT_FORMAT = @as(c_int, 130);
pub const CRYPTO_R_PARAM_VALUE_TOO_LARGE_FOR_DESTINATION = @as(c_int, 126);
pub const CRYPTO_R_PROVIDER_ALREADY_EXISTS = @as(c_int, 104);
pub const CRYPTO_R_PROVIDER_SECTION_ERROR = @as(c_int, 105);
pub const CRYPTO_R_RANDOM_SECTION_ERROR = @as(c_int, 119);
pub const CRYPTO_R_SECURE_MALLOC_FAILURE = @as(c_int, 111);
pub const CRYPTO_R_STRING_TOO_LONG = @as(c_int, 112);
pub const CRYPTO_R_TOO_MANY_BYTES = @as(c_int, 113);
pub const CRYPTO_R_TOO_MANY_NAMES = @as(c_int, 132);
pub const CRYPTO_R_TOO_MANY_RECORDS = @as(c_int, 114);
pub const CRYPTO_R_TOO_SMALL_BUFFER = @as(c_int, 116);
pub const CRYPTO_R_UNKNOWN_NAME_IN_RANDOM_SECTION = @as(c_int, 120);
pub const CRYPTO_R_ZERO_LENGTH_NUMBER = @as(c_int, 115);
pub const OPENSSL_CORE_H = "";
pub const __STDDEF_H = "";
pub const __need_ptrdiff_t = "";
pub const __need_size_t = "";
pub const __need_rsize_t = "";
pub const __need_wchar_t = "";
pub const __need_NULL = "";
pub const __need_max_align_t = "";
pub const __need_offsetof = "";
pub const _PTRDIFF_T = "";
pub const __CLANG_MAX_ALIGN_T_DEFINED = "";
pub const offsetof = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// /Users/vic-augustrokx-nellemann/.zvm/0.13.0/lib/include/__stddef_offsetof.h:16:9
pub const OSSL_DISPATCH_END = @compileError("unable to translate C expr: unexpected token '{'");
// /opt/homebrew/opt/openssl@3/include/openssl/core.h:45:10
pub const OSSL_PARAM_INTEGER = @as(c_int, 1);
pub const OSSL_PARAM_UNSIGNED_INTEGER = @as(c_int, 2);
pub const OSSL_PARAM_REAL = @as(c_int, 3);
pub const OSSL_PARAM_UTF8_STRING = @as(c_int, 4);
pub const OSSL_PARAM_OCTET_STRING = @as(c_int, 5);
pub const OSSL_PARAM_UTF8_PTR = @as(c_int, 6);
pub const OSSL_PARAM_OCTET_PTR = @as(c_int, 7);
pub const SSLeay = OpenSSL_version_num;
pub const SSLeay_version = OpenSSL_version;
pub const SSLEAY_VERSION_NUMBER = OPENSSL_VERSION_NUMBER;
pub const SSLEAY_VERSION = OPENSSL_VERSION;
pub const SSLEAY_CFLAGS = OPENSSL_CFLAGS;
pub const SSLEAY_BUILT_ON = OPENSSL_BUILT_ON;
pub const SSLEAY_PLATFORM = OPENSSL_PLATFORM;
pub const SSLEAY_DIR = OPENSSL_DIR;
pub const OPENSSL_malloc_init = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:99:9
pub inline fn OPENSSL_malloc(num: anytype) @TypeOf(CRYPTO_malloc(num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    return CRYPTO_malloc(num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_zalloc(num: anytype) @TypeOf(CRYPTO_zalloc(num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    return CRYPTO_zalloc(num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_aligned_alloc(num: anytype, alignment: anytype, freeptr: anytype) @TypeOf(CRYPTO_aligned_alloc(num, alignment, freeptr, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    _ = &alignment;
    _ = &freeptr;
    return CRYPTO_aligned_alloc(num, alignment, freeptr, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_realloc(addr: anytype, num: anytype) @TypeOf(CRYPTO_realloc(addr, num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    _ = &num;
    return CRYPTO_realloc(addr, num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_clear_realloc(addr: anytype, old_num: anytype, num: anytype) @TypeOf(CRYPTO_clear_realloc(addr, old_num, num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    _ = &old_num;
    _ = &num;
    return CRYPTO_clear_realloc(addr, old_num, num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_clear_free(addr: anytype, num: anytype) @TypeOf(CRYPTO_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    _ = &num;
    return CRYPTO_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_free(addr: anytype) @TypeOf(CRYPTO_free(addr, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    return CRYPTO_free(addr, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_memdup(str: anytype, s: anytype) @TypeOf(CRYPTO_memdup(str, s, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &str;
    _ = &s;
    return CRYPTO_memdup(str, s, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_strdup(str: anytype) @TypeOf(CRYPTO_strdup(str, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &str;
    return CRYPTO_strdup(str, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_strndup(str: anytype, n: anytype) @TypeOf(CRYPTO_strndup(str, n, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &str;
    _ = &n;
    return CRYPTO_strndup(str, n, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_malloc(num: anytype) @TypeOf(CRYPTO_secure_malloc(num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    return CRYPTO_secure_malloc(num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_zalloc(num: anytype) @TypeOf(CRYPTO_secure_zalloc(num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    return CRYPTO_secure_zalloc(num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_free(addr: anytype) @TypeOf(CRYPTO_secure_free(addr, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    return CRYPTO_secure_free(addr, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_clear_free(addr: anytype, num: anytype) @TypeOf(CRYPTO_secure_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    _ = &num;
    return CRYPTO_secure_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_actual_size(ptr: anytype) @TypeOf(CRYPTO_secure_actual_size(ptr)) {
    _ = &ptr;
    return CRYPTO_secure_actual_size(ptr);
}
pub inline fn OPENSSL_MALLOC_MAX_NELEMS(@"type": anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div((@as(c_uint, 1) << ((@import("std").zig.c_translation.sizeof(c_int) * @as(c_int, 8)) - @as(c_int, 1))) - @as(c_int, 1), @import("std").zig.c_translation.sizeof(@"type"))) {
    _ = &@"type";
    return @import("std").zig.c_translation.MacroArithmetic.div((@as(c_uint, 1) << ((@import("std").zig.c_translation.sizeof(c_int) * @as(c_int, 8)) - @as(c_int, 1))) - @as(c_int, 1), @import("std").zig.c_translation.sizeof(@"type"));
}
pub const OPENSSL_VERSION = @as(c_int, 0);
pub const OPENSSL_CFLAGS = @as(c_int, 1);
pub const OPENSSL_BUILT_ON = @as(c_int, 2);
pub const OPENSSL_PLATFORM = @as(c_int, 3);
pub const OPENSSL_DIR = @as(c_int, 4);
pub const OPENSSL_ENGINES_DIR = @as(c_int, 5);
pub const OPENSSL_VERSION_STRING = @as(c_int, 6);
pub const OPENSSL_FULL_VERSION_STRING = @as(c_int, 7);
pub const OPENSSL_MODULES_DIR = @as(c_int, 8);
pub const OPENSSL_CPU_INFO = @as(c_int, 9);
pub const OPENSSL_WINCTX = @as(c_int, 10);
pub const OPENSSL_INFO_CONFIG_DIR = @as(c_int, 1001);
pub const OPENSSL_INFO_ENGINES_DIR = @as(c_int, 1002);
pub const OPENSSL_INFO_MODULES_DIR = @as(c_int, 1003);
pub const OPENSSL_INFO_DSO_EXTENSION = @as(c_int, 1004);
pub const OPENSSL_INFO_DIR_FILENAME_SEPARATOR = @as(c_int, 1005);
pub const OPENSSL_INFO_LIST_SEPARATOR = @as(c_int, 1006);
pub const OPENSSL_INFO_SEED_SOURCE = @as(c_int, 1007);
pub const OPENSSL_INFO_CPU_SETTINGS = @as(c_int, 1008);
pub const OPENSSL_INFO_WINDOWS_CONTEXT = @as(c_int, 1009);
pub inline fn sk_void_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_void_sk_type(sk));
}
pub inline fn sk_void_value(sk: anytype, idx: anytype) ?*anyopaque {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_value(ossl_check_const_void_sk_type(sk), idx));
}
pub const sk_void_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:200:9
pub const sk_void_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:201:9
pub const sk_void_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:202:9
pub inline fn sk_void_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_void_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_void_sk_type(sk), n);
}
pub inline fn sk_void_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_void_sk_type(sk));
}
pub inline fn sk_void_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_void_sk_type(sk));
}
pub inline fn sk_void_delete(sk: anytype, i: anytype) ?*anyopaque {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_delete(ossl_check_void_sk_type(sk), i));
}
pub inline fn sk_void_delete_ptr(sk: anytype, ptr: anytype) ?*anyopaque {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_delete_ptr(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr)));
}
pub inline fn sk_void_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr));
}
pub inline fn sk_void_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr));
}
pub inline fn sk_void_pop(sk: anytype) ?*anyopaque {
    _ = &sk;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_pop(ossl_check_void_sk_type(sk)));
}
pub inline fn sk_void_shift(sk: anytype) ?*anyopaque {
    _ = &sk;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_shift(ossl_check_void_sk_type(sk)));
}
pub inline fn sk_void_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_void_sk_type(sk), ossl_check_void_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_void_sk_type(sk), ossl_check_void_freefunc_type(freefunc));
}
pub inline fn sk_void_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr), idx);
}
pub inline fn sk_void_set(sk: anytype, idx: anytype, ptr: anytype) ?*anyopaque {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_set(ossl_check_void_sk_type(sk), idx, ossl_check_void_type(ptr)));
}
pub inline fn sk_void_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr));
}
pub inline fn sk_void_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr));
}
pub inline fn sk_void_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr), pnum);
}
pub inline fn sk_void_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_void_sk_type(sk));
}
pub inline fn sk_void_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_void_sk_type(sk));
}
pub const sk_void_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:220:9
pub const sk_void_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:221:9
pub inline fn sk_void_set_cmp_func(sk: anytype, cmp: anytype) sk_void_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_void_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_void_sk_type(sk), ossl_check_void_compfunc_type(cmp)));
}
pub const CRYPTO_EX_INDEX_SSL = @as(c_int, 0);
pub const CRYPTO_EX_INDEX_SSL_CTX = @as(c_int, 1);
pub const CRYPTO_EX_INDEX_SSL_SESSION = @as(c_int, 2);
pub const CRYPTO_EX_INDEX_X509 = @as(c_int, 3);
pub const CRYPTO_EX_INDEX_X509_STORE = @as(c_int, 4);
pub const CRYPTO_EX_INDEX_X509_STORE_CTX = @as(c_int, 5);
pub const CRYPTO_EX_INDEX_DH = @as(c_int, 6);
pub const CRYPTO_EX_INDEX_DSA = @as(c_int, 7);
pub const CRYPTO_EX_INDEX_EC_KEY = @as(c_int, 8);
pub const CRYPTO_EX_INDEX_RSA = @as(c_int, 9);
pub const CRYPTO_EX_INDEX_ENGINE = @as(c_int, 10);
pub const CRYPTO_EX_INDEX_UI = @as(c_int, 11);
pub const CRYPTO_EX_INDEX_BIO = @as(c_int, 12);
pub const CRYPTO_EX_INDEX_APP = @as(c_int, 13);
pub const CRYPTO_EX_INDEX_UI_METHOD = @as(c_int, 14);
pub const CRYPTO_EX_INDEX_RAND_DRBG = @as(c_int, 15);
pub const CRYPTO_EX_INDEX_DRBG = CRYPTO_EX_INDEX_RAND_DRBG;
pub const CRYPTO_EX_INDEX_OSSL_LIB_CTX = @as(c_int, 16);
pub const CRYPTO_EX_INDEX_EVP_PKEY = @as(c_int, 17);
pub const CRYPTO_EX_INDEX__COUNT = @as(c_int, 18);
pub const CRYPTO_cleanup_all_ex_data = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:289:10
pub inline fn CRYPTO_num_locks() @TypeOf(@as(c_int, 1)) {
    return @as(c_int, 1);
}
pub const CRYPTO_set_locking_callback = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:302:11
pub inline fn CRYPTO_get_locking_callback() @TypeOf(NULL) {
    return NULL;
}
pub const CRYPTO_set_add_lock_callback = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:304:11
pub inline fn CRYPTO_get_add_lock_callback() @TypeOf(NULL) {
    return NULL;
}
pub const CRYPTO_LOCK = @as(c_int, 1);
pub const CRYPTO_UNLOCK = @as(c_int, 2);
pub const CRYPTO_READ = @as(c_int, 4);
pub const CRYPTO_WRITE = @as(c_int, 8);
pub const CRYPTO_THREADID_set_numeric = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:322:11
pub const CRYPTO_THREADID_set_pointer = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:323:11
pub inline fn CRYPTO_THREADID_set_callback(threadid_func: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &threadid_func;
    return @as(c_int, 0);
}
pub inline fn CRYPTO_THREADID_get_callback() @TypeOf(NULL) {
    return NULL;
}
pub const CRYPTO_THREADID_current = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:326:11
pub inline fn CRYPTO_THREADID_cmp(a: anytype, b: anytype) @TypeOf(-@as(c_int, 1)) {
    _ = &a;
    _ = &b;
    return -@as(c_int, 1);
}
pub const CRYPTO_THREADID_cpy = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:328:11
pub inline fn CRYPTO_THREADID_hash(id: anytype) @TypeOf(@as(c_ulong, 0)) {
    _ = &id;
    return @as(c_ulong, 0);
}
pub const CRYPTO_set_id_callback = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:332:12
pub inline fn CRYPTO_get_id_callback() @TypeOf(NULL) {
    return NULL;
}
pub inline fn CRYPTO_thread_id() @TypeOf(@as(c_ulong, 0)) {
    return @as(c_ulong, 0);
}
pub const CRYPTO_set_dynlock_create_callback = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:337:11
pub const CRYPTO_set_dynlock_lock_callback = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:338:11
pub const CRYPTO_set_dynlock_destroy_callback = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:339:11
pub inline fn CRYPTO_get_dynlock_create_callback() @TypeOf(NULL) {
    return NULL;
}
pub inline fn CRYPTO_get_dynlock_lock_callback() @TypeOf(NULL) {
    return NULL;
}
pub inline fn CRYPTO_get_dynlock_destroy_callback() @TypeOf(NULL) {
    return NULL;
}
pub inline fn OpenSSLDie(f: anytype, l: anytype, a: anytype) @TypeOf(OPENSSL_die(a, f, l)) {
    _ = &f;
    _ = &l;
    _ = &a;
    return OPENSSL_die(a, f, l);
}
pub const OPENSSL_assert = @compileError("unable to translate C expr: expected ',' or ')' instead got '#'");
// /opt/homebrew/opt/openssl@3/include/openssl/crypto.h:434:10
pub const OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS = @as(c_long, 0x00000001);
pub const OPENSSL_INIT_LOAD_CRYPTO_STRINGS = @as(c_long, 0x00000002);
pub const OPENSSL_INIT_ADD_ALL_CIPHERS = @as(c_long, 0x00000004);
pub const OPENSSL_INIT_ADD_ALL_DIGESTS = @as(c_long, 0x00000008);
pub const OPENSSL_INIT_NO_ADD_ALL_CIPHERS = @as(c_long, 0x00000010);
pub const OPENSSL_INIT_NO_ADD_ALL_DIGESTS = @as(c_long, 0x00000020);
pub const OPENSSL_INIT_LOAD_CONFIG = @as(c_long, 0x00000040);
pub const OPENSSL_INIT_NO_LOAD_CONFIG = @as(c_long, 0x00000080);
pub const OPENSSL_INIT_ASYNC = @as(c_long, 0x00000100);
pub const OPENSSL_INIT_ENGINE_RDRAND = @as(c_long, 0x00000200);
pub const OPENSSL_INIT_ENGINE_DYNAMIC = @as(c_long, 0x00000400);
pub const OPENSSL_INIT_ENGINE_OPENSSL = @as(c_long, 0x00000800);
pub const OPENSSL_INIT_ENGINE_CRYPTODEV = @as(c_long, 0x00001000);
pub const OPENSSL_INIT_ENGINE_CAPI = @as(c_long, 0x00002000);
pub const OPENSSL_INIT_ENGINE_PADLOCK = @as(c_long, 0x00004000);
pub const OPENSSL_INIT_ENGINE_AFALG = @as(c_long, 0x00008000);
pub const OPENSSL_INIT_ATFORK = @as(c_long, 0x00020000);
pub const OPENSSL_INIT_NO_ATEXIT = @as(c_long, 0x00080000);
pub const OPENSSL_INIT_ENGINE_ALL_BUILTIN = (((OPENSSL_INIT_ENGINE_RDRAND | OPENSSL_INIT_ENGINE_DYNAMIC) | OPENSSL_INIT_ENGINE_CRYPTODEV) | OPENSSL_INIT_ENGINE_CAPI) | OPENSSL_INIT_ENGINE_PADLOCK;
pub const _PTHREAD_H = "";
pub const _SCHED_H_ = "";
pub const _PTHREAD_IMPL_H_ = "";
pub const _PTHREAD_MUTEX_SIG_init = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x32AAABA7, .hex);
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x32AAABA1, .hex);
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x32AAABA2, .hex);
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x32AAABA3, .hex);
pub const _PTHREAD_COND_SIG_init = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x3CB0B1BB, .hex);
pub const _PTHREAD_ONCE_SIG_init = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x30B1BCBA, .hex);
pub const _PTHREAD_RWLOCK_SIG_init = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x2DA8B3B4, .hex);
pub const SCHED_OTHER = @as(c_int, 1);
pub const SCHED_FIFO = @as(c_int, 4);
pub const SCHED_RR = @as(c_int, 2);
pub const __SCHED_PARAM_SIZE__ = @as(c_int, 4);
pub const _PTHREAD_QOS_H = "";
pub const _SYS_QOS_H = "";
pub const __QOS_ENUM = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/qos.h:114:9
pub const __QOS_CLASS_AVAILABLE = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/sys/qos.h:115:9
pub const QOS_MIN_RELATIVE_PRIORITY = -@as(c_int, 15);
pub const _MACH_PORT_T = "";
pub const pthread_cleanup_push = @compileError("unable to translate macro: undefined identifier `__handler`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:116:9
pub const pthread_cleanup_pop = @compileError("unable to translate macro: undefined identifier `__self`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:125:9
pub const PTHREAD_CREATE_JOINABLE = @as(c_int, 1);
pub const PTHREAD_CREATE_DETACHED = @as(c_int, 2);
pub const PTHREAD_INHERIT_SCHED = @as(c_int, 1);
pub const PTHREAD_EXPLICIT_SCHED = @as(c_int, 2);
pub const PTHREAD_CANCEL_ENABLE = @as(c_int, 0x01);
pub const PTHREAD_CANCEL_DISABLE = @as(c_int, 0x00);
pub const PTHREAD_CANCEL_DEFERRED = @as(c_int, 0x02);
pub const PTHREAD_CANCEL_ASYNCHRONOUS = @as(c_int, 0x00);
pub const PTHREAD_CANCELED = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 1));
pub const PTHREAD_SCOPE_SYSTEM = @as(c_int, 1);
pub const PTHREAD_SCOPE_PROCESS = @as(c_int, 2);
pub const PTHREAD_PROCESS_SHARED = @as(c_int, 1);
pub const PTHREAD_PROCESS_PRIVATE = @as(c_int, 2);
pub const PTHREAD_PRIO_NONE = @as(c_int, 0);
pub const PTHREAD_PRIO_INHERIT = @as(c_int, 1);
pub const PTHREAD_PRIO_PROTECT = @as(c_int, 2);
pub const PTHREAD_MUTEX_NORMAL = @as(c_int, 0);
pub const PTHREAD_MUTEX_ERRORCHECK = @as(c_int, 1);
pub const PTHREAD_MUTEX_RECURSIVE = @as(c_int, 2);
pub const PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP = @as(c_int, 1);
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP = @as(c_int, 3);
pub const PTHREAD_RWLOCK_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:180:9
pub const PTHREAD_MUTEX_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:185:9
pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:190:11
pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:191:11
pub const _PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT = @compileError("unable to translate macro: undefined identifier `SWIFT_CLASS_EXTRA`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:196:9
pub const __PTHREAD_SWIFT_UNAVAILABLE_FROM_ASYNC = @compileError("unable to translate macro: undefined identifier `__swift_attr__`");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:200:9
pub const PTHREAD_COND_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:214:9
pub const PTHREAD_ONCE_INIT = @compileError("unable to translate C expr: unexpected token '{'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:220:9
pub const PTHREAD_JIT_WRITE_ALLOW_CALLBACKS_NP = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/usr/include/pthread.h:621:9
pub const CRYPTO_ONCE_STATIC_INIT = PTHREAD_ONCE_INIT;
pub const OPENSSL_COMPERR_H = "";
pub const COMP_R_BROTLI_DECODE_ERROR = @as(c_int, 102);
pub const COMP_R_BROTLI_ENCODE_ERROR = @as(c_int, 103);
pub const COMP_R_BROTLI_NOT_SUPPORTED = @as(c_int, 104);
pub const COMP_R_ZLIB_DEFLATE_ERROR = @as(c_int, 99);
pub const COMP_R_ZLIB_INFLATE_ERROR = @as(c_int, 100);
pub const COMP_R_ZLIB_NOT_SUPPORTED = @as(c_int, 101);
pub const COMP_R_ZSTD_COMPRESS_ERROR = @as(c_int, 105);
pub const COMP_R_ZSTD_DECODE_ERROR = @as(c_int, 106);
pub const COMP_R_ZSTD_DECOMPRESS_ERROR = @as(c_int, 107);
pub const COMP_R_ZSTD_NOT_SUPPORTED = @as(c_int, 108);
pub const COMP_zlib_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/comp.h:53:12
pub inline fn sk_SSL_COMP_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_SSL_COMP_sk_type(sk));
}
pub inline fn sk_SSL_COMP_value(sk: anytype, idx: anytype) [*c]SSL_COMP {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_value(ossl_check_const_SSL_COMP_sk_type(sk), idx));
}
pub const sk_SSL_COMP_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/comp.h:69:9
pub const sk_SSL_COMP_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/comp.h:70:9
pub const sk_SSL_COMP_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/comp.h:71:9
pub inline fn sk_SSL_COMP_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_SSL_COMP_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_SSL_COMP_sk_type(sk), n);
}
pub inline fn sk_SSL_COMP_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_SSL_COMP_sk_type(sk));
}
pub inline fn sk_SSL_COMP_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_SSL_COMP_sk_type(sk));
}
pub inline fn sk_SSL_COMP_delete(sk: anytype, i: anytype) [*c]SSL_COMP {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_delete(ossl_check_SSL_COMP_sk_type(sk), i));
}
pub inline fn sk_SSL_COMP_delete_ptr(sk: anytype, ptr: anytype) [*c]SSL_COMP {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_delete_ptr(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr)));
}
pub inline fn sk_SSL_COMP_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr));
}
pub inline fn sk_SSL_COMP_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr));
}
pub inline fn sk_SSL_COMP_pop(sk: anytype) [*c]SSL_COMP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_pop(ossl_check_SSL_COMP_sk_type(sk)));
}
pub inline fn sk_SSL_COMP_shift(sk: anytype) [*c]SSL_COMP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_shift(ossl_check_SSL_COMP_sk_type(sk)));
}
pub inline fn sk_SSL_COMP_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_freefunc_type(freefunc));
}
pub inline fn sk_SSL_COMP_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr), idx);
}
pub inline fn sk_SSL_COMP_set(sk: anytype, idx: anytype, ptr: anytype) [*c]SSL_COMP {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_set(ossl_check_SSL_COMP_sk_type(sk), idx, ossl_check_SSL_COMP_type(ptr)));
}
pub inline fn sk_SSL_COMP_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr));
}
pub inline fn sk_SSL_COMP_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr));
}
pub inline fn sk_SSL_COMP_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr), pnum);
}
pub inline fn sk_SSL_COMP_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_SSL_COMP_sk_type(sk));
}
pub inline fn sk_SSL_COMP_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_SSL_COMP_sk_type(sk));
}
pub const sk_SSL_COMP_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/comp.h:89:9
pub const sk_SSL_COMP_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/comp.h:90:9
pub inline fn sk_SSL_COMP_set_cmp_func(sk: anytype, cmp: anytype) sk_SSL_COMP_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_SSL_COMP_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_compfunc_type(cmp)));
}
pub const OPENSSL_BIO_H = "";
pub const HEADER_BIO_H = "";
pub const __STDARG_H = "";
pub const __need___va_list = "";
pub const __need_va_list = "";
pub const __need_va_arg = "";
pub const __need___va_copy = "";
pub const __need_va_copy = "";
pub const __GNUC_VA_LIST = "";
pub const _VA_LIST = "";
pub const va_start = @compileError("unable to translate macro: undefined identifier `__builtin_va_start`");
// /Users/vic-augustrokx-nellemann/.zvm/0.13.0/lib/include/__stdarg_va_arg.h:17:9
pub const va_end = @compileError("unable to translate macro: undefined identifier `__builtin_va_end`");
// /Users/vic-augustrokx-nellemann/.zvm/0.13.0/lib/include/__stdarg_va_arg.h:19:9
pub const va_arg = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// /Users/vic-augustrokx-nellemann/.zvm/0.13.0/lib/include/__stdarg_va_arg.h:20:9
pub const __va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`");
// /Users/vic-augustrokx-nellemann/.zvm/0.13.0/lib/include/__stdarg___va_copy.h:11:9
pub const va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`");
// /Users/vic-augustrokx-nellemann/.zvm/0.13.0/lib/include/__stdarg_va_copy.h:11:9
pub const OPENSSL_BIOERR_H = "";
pub const BIO_R_ACCEPT_ERROR = @as(c_int, 100);
pub const BIO_R_ADDRINFO_ADDR_IS_NOT_AF_INET = @as(c_int, 141);
pub const BIO_R_AMBIGUOUS_HOST_OR_SERVICE = @as(c_int, 129);
pub const BIO_R_BAD_FOPEN_MODE = @as(c_int, 101);
pub const BIO_R_BROKEN_PIPE = @as(c_int, 124);
pub const BIO_R_CONNECT_ERROR = @as(c_int, 103);
pub const BIO_R_CONNECT_TIMEOUT = @as(c_int, 147);
pub const BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET = @as(c_int, 107);
pub const BIO_R_GETSOCKNAME_ERROR = @as(c_int, 132);
pub const BIO_R_GETSOCKNAME_TRUNCATED_ADDRESS = @as(c_int, 133);
pub const BIO_R_GETTING_SOCKTYPE = @as(c_int, 134);
pub const BIO_R_INVALID_ARGUMENT = @as(c_int, 125);
pub const BIO_R_INVALID_SOCKET = @as(c_int, 135);
pub const BIO_R_IN_USE = @as(c_int, 123);
pub const BIO_R_LENGTH_TOO_LONG = @as(c_int, 102);
pub const BIO_R_LISTEN_V6_ONLY = @as(c_int, 136);
pub const BIO_R_LOCAL_ADDR_NOT_AVAILABLE = @as(c_int, 111);
pub const BIO_R_LOOKUP_RETURNED_NOTHING = @as(c_int, 142);
pub const BIO_R_MALFORMED_HOST_OR_SERVICE = @as(c_int, 130);
pub const BIO_R_NBIO_CONNECT_ERROR = @as(c_int, 110);
pub const BIO_R_NON_FATAL = @as(c_int, 112);
pub const BIO_R_NO_ACCEPT_ADDR_OR_SERVICE_SPECIFIED = @as(c_int, 143);
pub const BIO_R_NO_HOSTNAME_OR_SERVICE_SPECIFIED = @as(c_int, 144);
pub const BIO_R_NO_PORT_DEFINED = @as(c_int, 113);
pub const BIO_R_NO_SUCH_FILE = @as(c_int, 128);
pub const BIO_R_NULL_PARAMETER = @as(c_int, 115);
pub const BIO_R_TFO_DISABLED = @as(c_int, 106);
pub const BIO_R_TFO_NO_KERNEL_SUPPORT = @as(c_int, 108);
pub const BIO_R_TRANSFER_ERROR = @as(c_int, 104);
pub const BIO_R_TRANSFER_TIMEOUT = @as(c_int, 105);
pub const BIO_R_UNABLE_TO_BIND_SOCKET = @as(c_int, 117);
pub const BIO_R_UNABLE_TO_CREATE_SOCKET = @as(c_int, 118);
pub const BIO_R_UNABLE_TO_KEEPALIVE = @as(c_int, 137);
pub const BIO_R_UNABLE_TO_LISTEN_SOCKET = @as(c_int, 119);
pub const BIO_R_UNABLE_TO_NODELAY = @as(c_int, 138);
pub const BIO_R_UNABLE_TO_REUSEADDR = @as(c_int, 139);
pub const BIO_R_UNABLE_TO_TFO = @as(c_int, 109);
pub const BIO_R_UNAVAILABLE_IP_FAMILY = @as(c_int, 145);
pub const BIO_R_UNINITIALIZED = @as(c_int, 120);
pub const BIO_R_UNKNOWN_INFO_TYPE = @as(c_int, 140);
pub const BIO_R_UNSUPPORTED_IP_FAMILY = @as(c_int, 146);
pub const BIO_R_UNSUPPORTED_METHOD = @as(c_int, 121);
pub const BIO_R_UNSUPPORTED_PROTOCOL_FAMILY = @as(c_int, 131);
pub const BIO_R_WRITE_TO_READ_ONLY_BIO = @as(c_int, 126);
pub const BIO_R_WSASTARTUP = @as(c_int, 122);
pub const BIO_R_PORT_MISMATCH = @as(c_int, 150);
pub const BIO_R_PEER_ADDR_NOT_AVAILABLE = @as(c_int, 151);
pub const BIO_TYPE_DESCRIPTOR = @as(c_int, 0x0100);
pub const BIO_TYPE_FILTER = @as(c_int, 0x0200);
pub const BIO_TYPE_SOURCE_SINK = @as(c_int, 0x0400);
pub const BIO_TYPE_NONE = @as(c_int, 0);
pub const BIO_TYPE_MEM = @as(c_int, 1) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_FILE = @as(c_int, 2) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_FD = (@as(c_int, 4) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_SOCKET = (@as(c_int, 5) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_NULL = @as(c_int, 6) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_SSL = @as(c_int, 7) | BIO_TYPE_FILTER;
pub const BIO_TYPE_MD = @as(c_int, 8) | BIO_TYPE_FILTER;
pub const BIO_TYPE_BUFFER = @as(c_int, 9) | BIO_TYPE_FILTER;
pub const BIO_TYPE_CIPHER = @as(c_int, 10) | BIO_TYPE_FILTER;
pub const BIO_TYPE_BASE64 = @as(c_int, 11) | BIO_TYPE_FILTER;
pub const BIO_TYPE_CONNECT = (@as(c_int, 12) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_ACCEPT = (@as(c_int, 13) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_NBIO_TEST = @as(c_int, 16) | BIO_TYPE_FILTER;
pub const BIO_TYPE_NULL_FILTER = @as(c_int, 17) | BIO_TYPE_FILTER;
pub const BIO_TYPE_BIO = @as(c_int, 19) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_LINEBUFFER = @as(c_int, 20) | BIO_TYPE_FILTER;
pub const BIO_TYPE_DGRAM = (@as(c_int, 21) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_ASN1 = @as(c_int, 22) | BIO_TYPE_FILTER;
pub const BIO_TYPE_COMP = @as(c_int, 23) | BIO_TYPE_FILTER;
pub const BIO_TYPE_CORE_TO_PROV = @as(c_int, 25) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_DGRAM_PAIR = @as(c_int, 26) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_DGRAM_MEM = @as(c_int, 27) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_START = @as(c_int, 128);
pub const BIO_TYPE_MASK = @as(c_int, 0xFF);
pub const BIO_NOCLOSE = @as(c_int, 0x00);
pub const BIO_CLOSE = @as(c_int, 0x01);
pub const BIO_CTRL_RESET = @as(c_int, 1);
pub const BIO_CTRL_EOF = @as(c_int, 2);
pub const BIO_CTRL_INFO = @as(c_int, 3);
pub const BIO_CTRL_SET = @as(c_int, 4);
pub const BIO_CTRL_GET = @as(c_int, 5);
pub const BIO_CTRL_PUSH = @as(c_int, 6);
pub const BIO_CTRL_POP = @as(c_int, 7);
pub const BIO_CTRL_GET_CLOSE = @as(c_int, 8);
pub const BIO_CTRL_SET_CLOSE = @as(c_int, 9);
pub const BIO_CTRL_PENDING = @as(c_int, 10);
pub const BIO_CTRL_FLUSH = @as(c_int, 11);
pub const BIO_CTRL_DUP = @as(c_int, 12);
pub const BIO_CTRL_WPENDING = @as(c_int, 13);
pub const BIO_CTRL_SET_CALLBACK = @as(c_int, 14);
pub const BIO_CTRL_GET_CALLBACK = @as(c_int, 15);
pub const BIO_CTRL_PEEK = @as(c_int, 29);
pub const BIO_CTRL_SET_FILENAME = @as(c_int, 30);
pub const BIO_CTRL_DGRAM_CONNECT = @as(c_int, 31);
pub const BIO_CTRL_DGRAM_SET_CONNECTED = @as(c_int, 32);
pub const BIO_CTRL_DGRAM_SET_RECV_TIMEOUT = @as(c_int, 33);
pub const BIO_CTRL_DGRAM_GET_RECV_TIMEOUT = @as(c_int, 34);
pub const BIO_CTRL_DGRAM_SET_SEND_TIMEOUT = @as(c_int, 35);
pub const BIO_CTRL_DGRAM_GET_SEND_TIMEOUT = @as(c_int, 36);
pub const BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP = @as(c_int, 37);
pub const BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP = @as(c_int, 38);
pub const BIO_CTRL_DGRAM_MTU_DISCOVER = @as(c_int, 39);
pub const BIO_CTRL_DGRAM_QUERY_MTU = @as(c_int, 40);
pub const BIO_CTRL_DGRAM_GET_FALLBACK_MTU = @as(c_int, 47);
pub const BIO_CTRL_DGRAM_GET_MTU = @as(c_int, 41);
pub const BIO_CTRL_DGRAM_SET_MTU = @as(c_int, 42);
pub const BIO_CTRL_DGRAM_MTU_EXCEEDED = @as(c_int, 43);
pub const BIO_CTRL_DGRAM_GET_PEER = @as(c_int, 46);
pub const BIO_CTRL_DGRAM_SET_PEER = @as(c_int, 44);
pub const BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT = @as(c_int, 45);
pub const BIO_CTRL_DGRAM_SET_DONT_FRAG = @as(c_int, 48);
pub const BIO_CTRL_DGRAM_GET_MTU_OVERHEAD = @as(c_int, 49);
pub const BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE = @as(c_int, 50);
pub const BIO_CTRL_DGRAM_SET_PEEK_MODE = @as(c_int, 71);
pub const BIO_CTRL_GET_KTLS_SEND = @as(c_int, 73);
pub const BIO_CTRL_GET_KTLS_RECV = @as(c_int, 76);
pub const BIO_CTRL_DGRAM_SCTP_WAIT_FOR_DRY = @as(c_int, 77);
pub const BIO_CTRL_DGRAM_SCTP_MSG_WAITING = @as(c_int, 78);
pub const BIO_CTRL_SET_PREFIX = @as(c_int, 79);
pub const BIO_CTRL_SET_INDENT = @as(c_int, 80);
pub const BIO_CTRL_GET_INDENT = @as(c_int, 81);
pub const BIO_CTRL_DGRAM_GET_LOCAL_ADDR_CAP = @as(c_int, 82);
pub const BIO_CTRL_DGRAM_GET_LOCAL_ADDR_ENABLE = @as(c_int, 83);
pub const BIO_CTRL_DGRAM_SET_LOCAL_ADDR_ENABLE = @as(c_int, 84);
pub const BIO_CTRL_DGRAM_GET_EFFECTIVE_CAPS = @as(c_int, 85);
pub const BIO_CTRL_DGRAM_GET_CAPS = @as(c_int, 86);
pub const BIO_CTRL_DGRAM_SET_CAPS = @as(c_int, 87);
pub const BIO_CTRL_DGRAM_GET_NO_TRUNC = @as(c_int, 88);
pub const BIO_CTRL_DGRAM_SET_NO_TRUNC = @as(c_int, 89);
pub const BIO_CTRL_GET_RPOLL_DESCRIPTOR = @as(c_int, 91);
pub const BIO_CTRL_GET_WPOLL_DESCRIPTOR = @as(c_int, 92);
pub const BIO_CTRL_DGRAM_DETECT_PEER_ADDR = @as(c_int, 93);
pub const BIO_DGRAM_CAP_NONE = @as(c_uint, 0);
pub const BIO_DGRAM_CAP_HANDLES_SRC_ADDR = @as(c_uint, 1) << @as(c_int, 0);
pub const BIO_DGRAM_CAP_HANDLES_DST_ADDR = @as(c_uint, 1) << @as(c_int, 1);
pub const BIO_DGRAM_CAP_PROVIDES_SRC_ADDR = @as(c_uint, 1) << @as(c_int, 2);
pub const BIO_DGRAM_CAP_PROVIDES_DST_ADDR = @as(c_uint, 1) << @as(c_int, 3);
pub inline fn BIO_get_ktls_send(b: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &b;
    return @as(c_int, 0);
}
pub inline fn BIO_get_ktls_recv(b: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &b;
    return @as(c_int, 0);
}
pub const BIO_FP_READ = @as(c_int, 0x02);
pub const BIO_FP_WRITE = @as(c_int, 0x04);
pub const BIO_FP_APPEND = @as(c_int, 0x08);
pub const BIO_FP_TEXT = @as(c_int, 0x10);
pub const BIO_FLAGS_READ = @as(c_int, 0x01);
pub const BIO_FLAGS_WRITE = @as(c_int, 0x02);
pub const BIO_FLAGS_IO_SPECIAL = @as(c_int, 0x04);
pub const BIO_FLAGS_RWS = (BIO_FLAGS_READ | BIO_FLAGS_WRITE) | BIO_FLAGS_IO_SPECIAL;
pub const BIO_FLAGS_SHOULD_RETRY = @as(c_int, 0x08);
pub const BIO_FLAGS_UPLINK = @as(c_int, 0);
pub const BIO_FLAGS_BASE64_NO_NL = @as(c_int, 0x100);
pub const BIO_FLAGS_MEM_RDONLY = @as(c_int, 0x200);
pub const BIO_FLAGS_NONCLEAR_RST = @as(c_int, 0x400);
pub const BIO_FLAGS_IN_EOF = @as(c_int, 0x800);
pub inline fn BIO_get_flags(b: anytype) @TypeOf(BIO_test_flags(b, ~@as(c_int, 0x0))) {
    _ = &b;
    return BIO_test_flags(b, ~@as(c_int, 0x0));
}
pub inline fn BIO_set_retry_special(b: anytype) @TypeOf(BIO_set_flags(b, BIO_FLAGS_IO_SPECIAL | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_set_flags(b, BIO_FLAGS_IO_SPECIAL | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_set_retry_read(b: anytype) @TypeOf(BIO_set_flags(b, BIO_FLAGS_READ | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_set_flags(b, BIO_FLAGS_READ | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_set_retry_write(b: anytype) @TypeOf(BIO_set_flags(b, BIO_FLAGS_WRITE | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_set_flags(b, BIO_FLAGS_WRITE | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_clear_retry_flags(b: anytype) @TypeOf(BIO_clear_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_clear_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_get_retry_flags(b: anytype) @TypeOf(BIO_test_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_test_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_should_read(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_READ)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_READ);
}
pub inline fn BIO_should_write(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_WRITE)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_WRITE);
}
pub inline fn BIO_should_io_special(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_IO_SPECIAL)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_IO_SPECIAL);
}
pub inline fn BIO_retry_type(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_RWS)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_RWS);
}
pub inline fn BIO_should_retry(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_SHOULD_RETRY)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_SHOULD_RETRY);
}
pub const BIO_RR_SSL_X509_LOOKUP = @as(c_int, 0x01);
pub const BIO_RR_CONNECT = @as(c_int, 0x02);
pub const BIO_RR_ACCEPT = @as(c_int, 0x03);
pub const BIO_CB_FREE = @as(c_int, 0x01);
pub const BIO_CB_READ = @as(c_int, 0x02);
pub const BIO_CB_WRITE = @as(c_int, 0x03);
pub const BIO_CB_PUTS = @as(c_int, 0x04);
pub const BIO_CB_GETS = @as(c_int, 0x05);
pub const BIO_CB_CTRL = @as(c_int, 0x06);
pub const BIO_CB_RECVMMSG = @as(c_int, 0x07);
pub const BIO_CB_SENDMMSG = @as(c_int, 0x08);
pub const BIO_CB_RETURN = @as(c_int, 0x80);
pub inline fn BIO_CB_return(a: anytype) @TypeOf(a | BIO_CB_RETURN) {
    _ = &a;
    return a | BIO_CB_RETURN;
}
pub inline fn BIO_cb_pre(a: anytype) @TypeOf(!((a & BIO_CB_RETURN) != 0)) {
    _ = &a;
    return !((a & BIO_CB_RETURN) != 0);
}
pub inline fn BIO_cb_post(a: anytype) @TypeOf(a & BIO_CB_RETURN) {
    _ = &a;
    return a & BIO_CB_RETURN;
}
pub inline fn sk_BIO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_BIO_sk_type(sk));
}
pub inline fn sk_BIO_value(sk: anytype, idx: anytype) [*c]BIO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_value(ossl_check_const_BIO_sk_type(sk), idx));
}
pub const sk_BIO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:338:9
pub const sk_BIO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:339:9
pub const sk_BIO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:340:9
pub inline fn sk_BIO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_BIO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_BIO_sk_type(sk), n);
}
pub inline fn sk_BIO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_BIO_sk_type(sk));
}
pub inline fn sk_BIO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_BIO_sk_type(sk));
}
pub inline fn sk_BIO_delete(sk: anytype, i: anytype) [*c]BIO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_delete(ossl_check_BIO_sk_type(sk), i));
}
pub inline fn sk_BIO_delete_ptr(sk: anytype, ptr: anytype) [*c]BIO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_delete_ptr(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr)));
}
pub inline fn sk_BIO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr));
}
pub inline fn sk_BIO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr));
}
pub inline fn sk_BIO_pop(sk: anytype) [*c]BIO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_pop(ossl_check_BIO_sk_type(sk)));
}
pub inline fn sk_BIO_shift(sk: anytype) [*c]BIO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_shift(ossl_check_BIO_sk_type(sk)));
}
pub inline fn sk_BIO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_BIO_sk_type(sk), ossl_check_BIO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_BIO_sk_type(sk), ossl_check_BIO_freefunc_type(freefunc));
}
pub inline fn sk_BIO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr), idx);
}
pub inline fn sk_BIO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]BIO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_set(ossl_check_BIO_sk_type(sk), idx, ossl_check_BIO_type(ptr)));
}
pub inline fn sk_BIO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr));
}
pub inline fn sk_BIO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr));
}
pub inline fn sk_BIO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr), pnum);
}
pub inline fn sk_BIO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_BIO_sk_type(sk));
}
pub inline fn sk_BIO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_BIO_sk_type(sk));
}
pub const sk_BIO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:358:9
pub const sk_BIO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:359:9
pub inline fn sk_BIO_set_cmp_func(sk: anytype, cmp: anytype) sk_BIO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_BIO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_BIO_sk_type(sk), ossl_check_BIO_compfunc_type(cmp)));
}
pub const BIO_POLL_DESCRIPTOR_TYPE_NONE = @as(c_int, 0);
pub const BIO_POLL_DESCRIPTOR_TYPE_SOCK_FD = @as(c_int, 1);
pub const BIO_POLL_DESCRIPTOR_TYPE_SSL = @as(c_int, 2);
pub const BIO_POLL_DESCRIPTOR_CUSTOM_START = @as(c_int, 8192);
pub const BIO_C_SET_CONNECT = @as(c_int, 100);
pub const BIO_C_DO_STATE_MACHINE = @as(c_int, 101);
pub const BIO_C_SET_NBIO = @as(c_int, 102);
pub const BIO_C_SET_FD = @as(c_int, 104);
pub const BIO_C_GET_FD = @as(c_int, 105);
pub const BIO_C_SET_FILE_PTR = @as(c_int, 106);
pub const BIO_C_GET_FILE_PTR = @as(c_int, 107);
pub const BIO_C_SET_FILENAME = @as(c_int, 108);
pub const BIO_C_SET_SSL = @as(c_int, 109);
pub const BIO_C_GET_SSL = @as(c_int, 110);
pub const BIO_C_SET_MD = @as(c_int, 111);
pub const BIO_C_GET_MD = @as(c_int, 112);
pub const BIO_C_GET_CIPHER_STATUS = @as(c_int, 113);
pub const BIO_C_SET_BUF_MEM = @as(c_int, 114);
pub const BIO_C_GET_BUF_MEM_PTR = @as(c_int, 115);
pub const BIO_C_GET_BUFF_NUM_LINES = @as(c_int, 116);
pub const BIO_C_SET_BUFF_SIZE = @as(c_int, 117);
pub const BIO_C_SET_ACCEPT = @as(c_int, 118);
pub const BIO_C_SSL_MODE = @as(c_int, 119);
pub const BIO_C_GET_MD_CTX = @as(c_int, 120);
pub const BIO_C_SET_BUFF_READ_DATA = @as(c_int, 122);
pub const BIO_C_GET_CONNECT = @as(c_int, 123);
pub const BIO_C_GET_ACCEPT = @as(c_int, 124);
pub const BIO_C_SET_SSL_RENEGOTIATE_BYTES = @as(c_int, 125);
pub const BIO_C_GET_SSL_NUM_RENEGOTIATES = @as(c_int, 126);
pub const BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT = @as(c_int, 127);
pub const BIO_C_FILE_SEEK = @as(c_int, 128);
pub const BIO_C_GET_CIPHER_CTX = @as(c_int, 129);
pub const BIO_C_SET_BUF_MEM_EOF_RETURN = @as(c_int, 130);
pub const BIO_C_SET_BIND_MODE = @as(c_int, 131);
pub const BIO_C_GET_BIND_MODE = @as(c_int, 132);
pub const BIO_C_FILE_TELL = @as(c_int, 133);
pub const BIO_C_GET_SOCKS = @as(c_int, 134);
pub const BIO_C_SET_SOCKS = @as(c_int, 135);
pub const BIO_C_SET_WRITE_BUF_SIZE = @as(c_int, 136);
pub const BIO_C_GET_WRITE_BUF_SIZE = @as(c_int, 137);
pub const BIO_C_MAKE_BIO_PAIR = @as(c_int, 138);
pub const BIO_C_DESTROY_BIO_PAIR = @as(c_int, 139);
pub const BIO_C_GET_WRITE_GUARANTEE = @as(c_int, 140);
pub const BIO_C_GET_READ_REQUEST = @as(c_int, 141);
pub const BIO_C_SHUTDOWN_WR = @as(c_int, 142);
pub const BIO_C_NREAD0 = @as(c_int, 143);
pub const BIO_C_NREAD = @as(c_int, 144);
pub const BIO_C_NWRITE0 = @as(c_int, 145);
pub const BIO_C_NWRITE = @as(c_int, 146);
pub const BIO_C_RESET_READ_REQUEST = @as(c_int, 147);
pub const BIO_C_SET_MD_CTX = @as(c_int, 148);
pub const BIO_C_SET_PREFIX = @as(c_int, 149);
pub const BIO_C_GET_PREFIX = @as(c_int, 150);
pub const BIO_C_SET_SUFFIX = @as(c_int, 151);
pub const BIO_C_GET_SUFFIX = @as(c_int, 152);
pub const BIO_C_SET_EX_ARG = @as(c_int, 153);
pub const BIO_C_GET_EX_ARG = @as(c_int, 154);
pub const BIO_C_SET_CONNECT_MODE = @as(c_int, 155);
pub const BIO_C_SET_TFO = @as(c_int, 156);
pub const BIO_C_SET_SOCK_TYPE = @as(c_int, 157);
pub const BIO_C_GET_SOCK_TYPE = @as(c_int, 158);
pub const BIO_C_GET_DGRAM_BIO = @as(c_int, 159);
pub inline fn BIO_set_app_data(s: anytype, arg: anytype) @TypeOf(BIO_set_ex_data(s, @as(c_int, 0), arg)) {
    _ = &s;
    _ = &arg;
    return BIO_set_ex_data(s, @as(c_int, 0), arg);
}
pub inline fn BIO_get_app_data(s: anytype) @TypeOf(BIO_get_ex_data(s, @as(c_int, 0))) {
    _ = &s;
    return BIO_get_ex_data(s, @as(c_int, 0));
}
pub inline fn BIO_set_nbio(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_NBIO, n, NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_NBIO, n, NULL);
}
pub inline fn BIO_set_tfo(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_TFO, n, NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_TFO, n, NULL);
}
pub const BIO_FAMILY_IPV4 = @as(c_int, 4);
pub const BIO_FAMILY_IPV6 = @as(c_int, 6);
pub const BIO_FAMILY_IPANY = @as(c_int, 256);
pub inline fn BIO_set_conn_hostname(b: anytype, name: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, name))) {
    _ = &b;
    _ = &name;
    return BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, name));
}
pub inline fn BIO_set_conn_port(b: anytype, port: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, port))) {
    _ = &b;
    _ = &port;
    return BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, port));
}
pub inline fn BIO_set_conn_address(b: anytype, addr: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 2), @import("std").zig.c_translation.cast([*c]u8, addr))) {
    _ = &b;
    _ = &addr;
    return BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 2), @import("std").zig.c_translation.cast([*c]u8, addr));
}
pub inline fn BIO_set_conn_ip_family(b: anytype, f: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 3), f)) {
    _ = &b;
    _ = &f;
    return BIO_int_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 3), f);
}
pub const BIO_get_conn_hostname = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:519:11
pub const BIO_get_conn_port = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:520:11
pub const BIO_get_conn_address = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:521:11
pub inline fn BIO_get_conn_ip_family(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_CONNECT, @as(c_int, 3), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_CONNECT, @as(c_int, 3), NULL);
}
pub inline fn BIO_get_conn_mode(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_CONNECT, @as(c_int, 4), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_CONNECT, @as(c_int, 4), NULL);
}
pub inline fn BIO_set_conn_mode(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_CONNECT_MODE, n, NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_CONNECT_MODE, n, NULL);
}
pub inline fn BIO_set_sock_type(b: anytype, t: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_SOCK_TYPE, t, NULL)) {
    _ = &b;
    _ = &t;
    return BIO_ctrl(b, BIO_C_SET_SOCK_TYPE, t, NULL);
}
pub inline fn BIO_get_sock_type(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_SOCK_TYPE, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_SOCK_TYPE, @as(c_int, 0), NULL);
}
pub const BIO_get0_dgram_bio = @compileError("unable to translate C expr: expected ')' instead got '*'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:527:11
pub inline fn BIO_set_accept_name(b: anytype, name: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, name))) {
    _ = &b;
    _ = &name;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, name));
}
pub inline fn BIO_set_accept_port(b: anytype, port: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, port))) {
    _ = &b;
    _ = &port;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, port));
}
pub const BIO_get_accept_name = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:534:11
pub const BIO_get_accept_port = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:535:11
pub const BIO_get_peer_name = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:536:11
pub const BIO_get_peer_port = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:537:11
pub inline fn BIO_set_nbio_accept(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 2), if (n) @import("std").zig.c_translation.cast(?*anyopaque, "a") else NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 2), if (n) @import("std").zig.c_translation.cast(?*anyopaque, "a") else NULL);
}
pub inline fn BIO_set_accept_bios(b: anytype, bio: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 3), @import("std").zig.c_translation.cast([*c]u8, bio))) {
    _ = &b;
    _ = &bio;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 3), @import("std").zig.c_translation.cast([*c]u8, bio));
}
pub inline fn BIO_set_accept_ip_family(b: anytype, f: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 4), f)) {
    _ = &b;
    _ = &f;
    return BIO_int_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 4), f);
}
pub inline fn BIO_get_accept_ip_family(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_ACCEPT, @as(c_int, 4), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_ACCEPT, @as(c_int, 4), NULL);
}
pub inline fn BIO_set_tfo_accept(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 5), if (n) @import("std").zig.c_translation.cast(?*anyopaque, "a") else NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 5), if (n) @import("std").zig.c_translation.cast(?*anyopaque, "a") else NULL);
}
pub const BIO_BIND_NORMAL = @as(c_int, 0);
pub const BIO_BIND_REUSEADDR = BIO_SOCK_REUSEADDR;
pub const BIO_BIND_REUSEADDR_IF_UNUSED = BIO_SOCK_REUSEADDR;
pub inline fn BIO_set_bind_mode(b: anytype, mode: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BIND_MODE, mode, NULL)) {
    _ = &b;
    _ = &mode;
    return BIO_ctrl(b, BIO_C_SET_BIND_MODE, mode, NULL);
}
pub inline fn BIO_get_bind_mode(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_BIND_MODE, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_BIND_MODE, @as(c_int, 0), NULL);
}
pub inline fn BIO_do_connect(b: anytype) @TypeOf(BIO_do_handshake(b)) {
    _ = &b;
    return BIO_do_handshake(b);
}
pub inline fn BIO_do_accept(b: anytype) @TypeOf(BIO_do_handshake(b)) {
    _ = &b;
    return BIO_do_handshake(b);
}
pub inline fn BIO_do_handshake(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_DO_STATE_MACHINE, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_DO_STATE_MACHINE, @as(c_int, 0), NULL);
}
pub inline fn BIO_set_fd(b: anytype, fd: anytype, c: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_FD, c, fd)) {
    _ = &b;
    _ = &fd;
    _ = &c;
    return BIO_int_ctrl(b, BIO_C_SET_FD, c, fd);
}
pub inline fn BIO_get_fd(b: anytype, c: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_FD, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, c))) {
    _ = &b;
    _ = &c;
    return BIO_ctrl(b, BIO_C_GET_FD, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, c));
}
pub inline fn BIO_set_fp(b: anytype, fp: anytype, c: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_FILE_PTR, c, @import("std").zig.c_translation.cast([*c]u8, fp))) {
    _ = &b;
    _ = &fp;
    _ = &c;
    return BIO_ctrl(b, BIO_C_SET_FILE_PTR, c, @import("std").zig.c_translation.cast([*c]u8, fp));
}
pub inline fn BIO_get_fp(b: anytype, fpp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_FILE_PTR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, fpp))) {
    _ = &b;
    _ = &fpp;
    return BIO_ctrl(b, BIO_C_GET_FILE_PTR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, fpp));
}
pub inline fn BIO_seek(b: anytype, ofs: anytype) c_int {
    _ = &b;
    _ = &ofs;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_FILE_SEEK, ofs, NULL));
}
pub inline fn BIO_tell(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_FILE_TELL, @as(c_int, 0), NULL));
}
pub inline fn BIO_read_filename(b: anytype, name: anytype) c_int {
    _ = &b;
    _ = &name;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_FILENAME, BIO_CLOSE | BIO_FP_READ, @import("std").zig.c_translation.cast([*c]u8, name)));
}
pub inline fn BIO_write_filename(b: anytype, name: anytype) c_int {
    _ = &b;
    _ = &name;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_FILENAME, BIO_CLOSE | BIO_FP_WRITE, name));
}
pub inline fn BIO_append_filename(b: anytype, name: anytype) c_int {
    _ = &b;
    _ = &name;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_FILENAME, BIO_CLOSE | BIO_FP_APPEND, name));
}
pub inline fn BIO_rw_filename(b: anytype, name: anytype) c_int {
    _ = &b;
    _ = &name;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_FILENAME, (BIO_CLOSE | BIO_FP_READ) | BIO_FP_WRITE, name));
}
pub inline fn BIO_set_ssl(b: anytype, ssl: anytype, c: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_SSL, c, @import("std").zig.c_translation.cast([*c]u8, ssl))) {
    _ = &b;
    _ = &ssl;
    _ = &c;
    return BIO_ctrl(b, BIO_C_SET_SSL, c, @import("std").zig.c_translation.cast([*c]u8, ssl));
}
pub inline fn BIO_get_ssl(b: anytype, sslp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_SSL, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sslp))) {
    _ = &b;
    _ = &sslp;
    return BIO_ctrl(b, BIO_C_GET_SSL, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sslp));
}
pub inline fn BIO_set_ssl_mode(b: anytype, client: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SSL_MODE, client, NULL)) {
    _ = &b;
    _ = &client;
    return BIO_ctrl(b, BIO_C_SSL_MODE, client, NULL);
}
pub inline fn BIO_set_ssl_renegotiate_bytes(b: anytype, num: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_SSL_RENEGOTIATE_BYTES, num, NULL)) {
    _ = &b;
    _ = &num;
    return BIO_ctrl(b, BIO_C_SET_SSL_RENEGOTIATE_BYTES, num, NULL);
}
pub inline fn BIO_get_num_renegotiates(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_SSL_NUM_RENEGOTIATES, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_SSL_NUM_RENEGOTIATES, @as(c_int, 0), NULL);
}
pub inline fn BIO_set_ssl_renegotiate_timeout(b: anytype, seconds: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT, seconds, NULL)) {
    _ = &b;
    _ = &seconds;
    return BIO_ctrl(b, BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT, seconds, NULL);
}
pub inline fn BIO_get_mem_data(b: anytype, pp: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_INFO, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, pp))) {
    _ = &b;
    _ = &pp;
    return BIO_ctrl(b, BIO_CTRL_INFO, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, pp));
}
pub inline fn BIO_set_mem_buf(b: anytype, bm: anytype, c: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BUF_MEM, c, @import("std").zig.c_translation.cast([*c]u8, bm))) {
    _ = &b;
    _ = &bm;
    _ = &c;
    return BIO_ctrl(b, BIO_C_SET_BUF_MEM, c, @import("std").zig.c_translation.cast([*c]u8, bm));
}
pub inline fn BIO_get_mem_ptr(b: anytype, pp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_BUF_MEM_PTR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, pp))) {
    _ = &b;
    _ = &pp;
    return BIO_ctrl(b, BIO_C_GET_BUF_MEM_PTR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, pp));
}
pub inline fn BIO_set_mem_eof_return(b: anytype, v: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BUF_MEM_EOF_RETURN, v, NULL)) {
    _ = &b;
    _ = &v;
    return BIO_ctrl(b, BIO_C_SET_BUF_MEM_EOF_RETURN, v, NULL);
}
pub inline fn BIO_get_buffer_num_lines(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_BUFF_NUM_LINES, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_BUFF_NUM_LINES, @as(c_int, 0), NULL);
}
pub inline fn BIO_set_buffer_size(b: anytype, size: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BUFF_SIZE, size, NULL)) {
    _ = &b;
    _ = &size;
    return BIO_ctrl(b, BIO_C_SET_BUFF_SIZE, size, NULL);
}
pub inline fn BIO_set_read_buffer_size(b: anytype, size: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_BUFF_SIZE, size, @as(c_int, 0))) {
    _ = &b;
    _ = &size;
    return BIO_int_ctrl(b, BIO_C_SET_BUFF_SIZE, size, @as(c_int, 0));
}
pub inline fn BIO_set_write_buffer_size(b: anytype, size: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_BUFF_SIZE, size, @as(c_int, 1))) {
    _ = &b;
    _ = &size;
    return BIO_int_ctrl(b, BIO_C_SET_BUFF_SIZE, size, @as(c_int, 1));
}
pub inline fn BIO_set_buffer_read_data(b: anytype, buf: anytype, num: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BUFF_READ_DATA, num, buf)) {
    _ = &b;
    _ = &buf;
    _ = &num;
    return BIO_ctrl(b, BIO_C_SET_BUFF_READ_DATA, num, buf);
}
pub inline fn BIO_dup_state(b: anytype, ret: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_DUP, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ret))) {
    _ = &b;
    _ = &ret;
    return BIO_ctrl(b, BIO_CTRL_DUP, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ret));
}
pub inline fn BIO_reset(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_RESET, @as(c_int, 0), NULL));
}
pub inline fn BIO_eof(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_EOF, @as(c_int, 0), NULL));
}
pub inline fn BIO_set_close(b: anytype, c: anytype) c_int {
    _ = &b;
    _ = &c;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_SET_CLOSE, c, NULL));
}
pub inline fn BIO_get_close(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_GET_CLOSE, @as(c_int, 0), NULL));
}
pub inline fn BIO_pending(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_PENDING, @as(c_int, 0), NULL));
}
pub inline fn BIO_wpending(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_WPENDING, @as(c_int, 0), NULL));
}
pub inline fn BIO_flush(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_FLUSH, @as(c_int, 0), NULL));
}
pub inline fn BIO_get_info_callback(b: anytype, cbp: anytype) c_int {
    _ = &b;
    _ = &cbp;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_GET_CALLBACK, @as(c_int, 0), cbp));
}
pub inline fn BIO_set_info_callback(b: anytype, cb: anytype) c_int {
    _ = &b;
    _ = &cb;
    return @import("std").zig.c_translation.cast(c_int, BIO_callback_ctrl(b, BIO_CTRL_SET_CALLBACK, cb));
}
pub inline fn BIO_buffer_get_num_lines(b: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_GET, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_CTRL_GET, @as(c_int, 0), NULL);
}
pub inline fn BIO_buffer_peek(b: anytype, s: anytype, l: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_PEEK, l, s)) {
    _ = &b;
    _ = &s;
    _ = &l;
    return BIO_ctrl(b, BIO_CTRL_PEEK, l, s);
}
pub inline fn BIO_set_write_buf_size(b: anytype, size: anytype) c_int {
    _ = &b;
    _ = &size;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_WRITE_BUF_SIZE, size, NULL));
}
pub inline fn BIO_get_write_buf_size(b: anytype, size: anytype) usize {
    _ = &b;
    _ = &size;
    return @import("std").zig.c_translation.cast(usize, BIO_ctrl(b, BIO_C_GET_WRITE_BUF_SIZE, size, NULL));
}
pub inline fn BIO_make_bio_pair(b1: anytype, b2: anytype) c_int {
    _ = &b1;
    _ = &b2;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b1, BIO_C_MAKE_BIO_PAIR, @as(c_int, 0), b2));
}
pub inline fn BIO_destroy_bio_pair(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_DESTROY_BIO_PAIR, @as(c_int, 0), NULL));
}
pub inline fn BIO_shutdown_wr(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SHUTDOWN_WR, @as(c_int, 0), NULL));
}
pub inline fn BIO_get_write_guarantee(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_GET_WRITE_GUARANTEE, @as(c_int, 0), NULL));
}
pub inline fn BIO_get_read_request(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_GET_READ_REQUEST, @as(c_int, 0), NULL));
}
pub inline fn BIO_ctrl_dgram_connect(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_CONNECT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_ctrl_set_connected(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_CONNECTED, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_dgram_recv_timedout(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_send_timedout(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_get_peer(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_PEER, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_dgram_set_peer(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_PEER, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_dgram_detect_peer_addr(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_DETECT_PEER_ADDR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_dgram_get_mtu_overhead(b: anytype) c_uint {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_uint, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_MTU_OVERHEAD, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_get_local_addr_cap(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_LOCAL_ADDR_CAP, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_get_local_addr_enable(b: anytype, penable: anytype) c_int {
    _ = &b;
    _ = &penable;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_LOCAL_ADDR_ENABLE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, penable)));
}
pub inline fn BIO_dgram_set_local_addr_enable(b: anytype, enable: anytype) c_int {
    _ = &b;
    _ = &enable;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_LOCAL_ADDR_ENABLE, enable, NULL));
}
pub inline fn BIO_dgram_get_effective_caps(b: anytype) u32 {
    _ = &b;
    return @import("std").zig.c_translation.cast(u32, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_EFFECTIVE_CAPS, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_get_caps(b: anytype) u32 {
    _ = &b;
    return @import("std").zig.c_translation.cast(u32, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_CAPS, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_set_caps(b: anytype, caps: anytype) c_int {
    _ = &b;
    _ = &caps;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_CAPS, @import("std").zig.c_translation.cast(c_long, caps), NULL));
}
pub inline fn BIO_dgram_get_no_trunc(b: anytype) c_uint {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_uint, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_NO_TRUNC, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_set_no_trunc(b: anytype, enable: anytype) c_int {
    _ = &b;
    _ = &enable;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_NO_TRUNC, enable, NULL));
}
pub inline fn BIO_dgram_get_mtu(b: anytype) c_uint {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_uint, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_MTU, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_set_mtu(b: anytype, mtu: anytype) c_int {
    _ = &b;
    _ = &mtu;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_MTU, mtu, NULL));
}
pub inline fn BIO_set_prefix(b: anytype, p: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_SET_PREFIX, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, p))) {
    _ = &b;
    _ = &p;
    return BIO_ctrl(b, BIO_CTRL_SET_PREFIX, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, p));
}
pub inline fn BIO_set_indent(b: anytype, i: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_SET_INDENT, i, NULL)) {
    _ = &b;
    _ = &i;
    return BIO_ctrl(b, BIO_CTRL_SET_INDENT, i, NULL);
}
pub inline fn BIO_get_indent(b: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_GET_INDENT, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_CTRL_GET_INDENT, @as(c_int, 0), NULL);
}
pub inline fn BIO_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_BIO, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_BIO, l, p, newf, dupf, freef);
}
pub const BIO_sock_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:876:11
pub const BIO_SOCK_REUSEADDR = @as(c_int, 0x01);
pub const BIO_SOCK_V6_ONLY = @as(c_int, 0x02);
pub const BIO_SOCK_KEEPALIVE = @as(c_int, 0x04);
pub const BIO_SOCK_NONBLOCK = @as(c_int, 0x08);
pub const BIO_SOCK_NODELAY = @as(c_int, 0x10);
pub const BIO_SOCK_TFO = @as(c_int, 0x20);
pub const ossl_bio__attr__ = @compileError("unable to translate C expr: unexpected token ''");
// /opt/homebrew/opt/openssl@3/include/openssl/bio.h:936:10
pub const OPENSSL_X509_H = "";
pub const HEADER_X509_H = "";
pub const OPENSSL_BUFFER_H = "";
pub const HEADER_BUFFER_H = "";
pub const OPENSSL_BUFFERERR_H = "";
pub inline fn BUF_strdup(s: anytype) @TypeOf(OPENSSL_strdup(s)) {
    _ = &s;
    return OPENSSL_strdup(s);
}
pub inline fn BUF_strndup(s: anytype, size: anytype) @TypeOf(OPENSSL_strndup(s, size)) {
    _ = &s;
    _ = &size;
    return OPENSSL_strndup(s, size);
}
pub inline fn BUF_memdup(data: anytype, size: anytype) @TypeOf(OPENSSL_memdup(data, size)) {
    _ = &data;
    _ = &size;
    return OPENSSL_memdup(data, size);
}
pub inline fn BUF_strlcpy(dst: anytype, src: anytype, size: anytype) @TypeOf(OPENSSL_strlcpy(dst, src, size)) {
    _ = &dst;
    _ = &src;
    _ = &size;
    return OPENSSL_strlcpy(dst, src, size);
}
pub inline fn BUF_strlcat(dst: anytype, src: anytype, size: anytype) @TypeOf(OPENSSL_strlcat(dst, src, size)) {
    _ = &dst;
    _ = &src;
    _ = &size;
    return OPENSSL_strlcat(dst, src, size);
}
pub inline fn BUF_strnlen(str: anytype, maxlen: anytype) @TypeOf(OPENSSL_strnlen(str, maxlen)) {
    _ = &str;
    _ = &maxlen;
    return OPENSSL_strnlen(str, maxlen);
}
pub const BUF_MEM_FLAG_SECURE = @as(c_int, 0x01);
pub const OPENSSL_EVP_H = "";
pub const HEADER_ENVELOPE_H = "";
pub const OPENSSL_CORE_NUMBERS_H = "";
pub const OPENSSL_INDICATOR_H = "";
pub const OPENSSL_PARAMS_H = "";
pub const OPENSSL_BN_H = "";
pub const HEADER_BN_H = "";
pub const OPENSSL_BNERR_H = "";
pub const BN_R_ARG2_LT_ARG3 = @as(c_int, 100);
pub const BN_R_BAD_RECIPROCAL = @as(c_int, 101);
pub const BN_R_BIGNUM_TOO_LONG = @as(c_int, 114);
pub const BN_R_BITS_TOO_SMALL = @as(c_int, 118);
pub const BN_R_CALLED_WITH_EVEN_MODULUS = @as(c_int, 102);
pub const BN_R_DIV_BY_ZERO = @as(c_int, 103);
pub const BN_R_ENCODING_ERROR = @as(c_int, 104);
pub const BN_R_EXPAND_ON_STATIC_BIGNUM_DATA = @as(c_int, 105);
pub const BN_R_INPUT_NOT_REDUCED = @as(c_int, 110);
pub const BN_R_INVALID_LENGTH = @as(c_int, 106);
pub const BN_R_INVALID_RANGE = @as(c_int, 115);
pub const BN_R_INVALID_SHIFT = @as(c_int, 119);
pub const BN_R_NOT_A_SQUARE = @as(c_int, 111);
pub const BN_R_NOT_INITIALIZED = @as(c_int, 107);
pub const BN_R_NO_INVERSE = @as(c_int, 108);
pub const BN_R_NO_PRIME_CANDIDATE = @as(c_int, 121);
pub const BN_R_NO_SOLUTION = @as(c_int, 116);
pub const BN_R_NO_SUITABLE_DIGEST = @as(c_int, 120);
pub const BN_R_PRIVATE_KEY_TOO_LARGE = @as(c_int, 117);
pub const BN_R_P_IS_NOT_PRIME = @as(c_int, 112);
pub const BN_R_TOO_MANY_ITERATIONS = @as(c_int, 113);
pub const BN_R_TOO_MANY_TEMPORARY_VARIABLES = @as(c_int, 109);
pub const BN_ULONG = c_ulong;
pub const BN_BYTES = @as(c_int, 8);
pub const BN_BITS2 = BN_BYTES * @as(c_int, 8);
pub const BN_BITS = BN_BITS2 * @as(c_int, 2);
pub const BN_TBIT = @compileError("unable to translate C expr: expected ')' instead got 'A number'");
// /opt/homebrew/opt/openssl@3/include/openssl/bn.h:56:10
pub const BN_FLG_MALLOCED = @as(c_int, 0x01);
pub const BN_FLG_STATIC_DATA = @as(c_int, 0x02);
pub const BN_FLG_CONSTTIME = @as(c_int, 0x04);
pub const BN_FLG_SECURE = @as(c_int, 0x08);
pub const BN_FLG_EXP_CONSTTIME = BN_FLG_CONSTTIME;
pub const BN_FLG_FREE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const BN_RAND_TOP_ANY = -@as(c_int, 1);
pub const BN_RAND_TOP_ONE = @as(c_int, 0);
pub const BN_RAND_TOP_TWO = @as(c_int, 1);
pub const BN_RAND_BOTTOM_ANY = @as(c_int, 0);
pub const BN_RAND_BOTTOM_ODD = @as(c_int, 1);
pub const BN_prime_checks = @as(c_int, 0);
pub inline fn BN_prime_checks_for_size(b: anytype) @TypeOf(if (b >= @as(c_int, 3747)) @as(c_int, 3) else if (b >= @as(c_int, 1345)) @as(c_int, 4) else if (b >= @as(c_int, 476)) @as(c_int, 5) else if (b >= @as(c_int, 400)) @as(c_int, 6) else if (b >= @as(c_int, 347)) @as(c_int, 7) else if (b >= @as(c_int, 308)) @as(c_int, 8) else if (b >= @as(c_int, 55)) @as(c_int, 27) else @as(c_int, 34)) {
    _ = &b;
    return if (b >= @as(c_int, 3747)) @as(c_int, 3) else if (b >= @as(c_int, 1345)) @as(c_int, 4) else if (b >= @as(c_int, 476)) @as(c_int, 5) else if (b >= @as(c_int, 400)) @as(c_int, 6) else if (b >= @as(c_int, 347)) @as(c_int, 7) else if (b >= @as(c_int, 308)) @as(c_int, 8) else if (b >= @as(c_int, 55)) @as(c_int, 27) else @as(c_int, 34);
}
pub inline fn BN_num_bytes(a: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(BN_num_bits(a) + @as(c_int, 7), @as(c_int, 8))) {
    _ = &a;
    return @import("std").zig.c_translation.MacroArithmetic.div(BN_num_bits(a) + @as(c_int, 7), @as(c_int, 8));
}
pub inline fn BN_one(a: anytype) @TypeOf(BN_set_word(a, @as(c_int, 1))) {
    _ = &a;
    return BN_set_word(a, @as(c_int, 1));
}
pub inline fn BN_zero(a: anytype) @TypeOf(BN_zero_ex(a)) {
    _ = &a;
    return BN_zero_ex(a);
}
pub inline fn BN_mod(rem: anytype, m: anytype, d: anytype, ctx: anytype) @TypeOf(BN_div(NULL, rem, m, d, ctx)) {
    _ = &rem;
    _ = &m;
    _ = &d;
    _ = &ctx;
    return BN_div(NULL, rem, m, d, ctx);
}
pub const BN_BLINDING_NO_UPDATE = @as(c_int, 0x00000001);
pub const BN_BLINDING_NO_RECREATE = @as(c_int, 0x00000002);
pub inline fn BN_GF2m_sub(r: anytype, a: anytype, b: anytype) @TypeOf(BN_GF2m_add(r, a, b)) {
    _ = &r;
    _ = &a;
    _ = &b;
    return BN_GF2m_add(r, a, b);
}
pub inline fn BN_GF2m_cmp(a: anytype, b: anytype) @TypeOf(BN_ucmp(a, b)) {
    _ = &a;
    _ = &b;
    return BN_ucmp(a, b);
}
pub const get_rfc2409_prime_768 = BN_get_rfc2409_prime_768;
pub const get_rfc2409_prime_1024 = BN_get_rfc2409_prime_1024;
pub const get_rfc3526_prime_1536 = BN_get_rfc3526_prime_1536;
pub const get_rfc3526_prime_2048 = BN_get_rfc3526_prime_2048;
pub const get_rfc3526_prime_3072 = BN_get_rfc3526_prime_3072;
pub const get_rfc3526_prime_4096 = BN_get_rfc3526_prime_4096;
pub const get_rfc3526_prime_6144 = BN_get_rfc3526_prime_6144;
pub const get_rfc3526_prime_8192 = BN_get_rfc3526_prime_8192;
pub const OSSL_PARAM_UNMODIFIED = @import("std").zig.c_translation.cast(usize, -@as(c_int, 1));
pub const OSSL_PARAM_END = @compileError("unable to translate C expr: unexpected token '{'");
// /opt/homebrew/opt/openssl@3/include/openssl/params.h:24:10
pub const OSSL_PARAM_DEFN = @compileError("unable to translate C expr: unexpected token '{'");
// /opt/homebrew/opt/openssl@3/include/openssl/params.h:27:10
pub inline fn OSSL_PARAM_int(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_int))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_int));
}
pub inline fn OSSL_PARAM_uint(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_uint))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_uint));
}
pub inline fn OSSL_PARAM_long(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_long))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_long));
}
pub inline fn OSSL_PARAM_ulong(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_ulong))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_ulong));
}
pub inline fn OSSL_PARAM_int32(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(i32))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(i32));
}
pub inline fn OSSL_PARAM_uint32(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(u32))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(u32));
}
pub inline fn OSSL_PARAM_int64(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(i64))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(i64));
}
pub inline fn OSSL_PARAM_uint64(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(u64))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(u64));
}
pub inline fn OSSL_PARAM_size_t(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(usize))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(usize));
}
pub inline fn OSSL_PARAM_time_t(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(time_t))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(time_t));
}
pub inline fn OSSL_PARAM_double(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_REAL, addr, @import("std").zig.c_translation.sizeof(f64))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_REAL, addr, @import("std").zig.c_translation.sizeof(f64));
}
pub inline fn OSSL_PARAM_BN(key: anytype, bn: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, bn, sz)) {
    _ = &key;
    _ = &bn;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, bn, sz);
}
pub inline fn OSSL_PARAM_utf8_string(key: anytype, addr: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UTF8_STRING, addr, sz)) {
    _ = &key;
    _ = &addr;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UTF8_STRING, addr, sz);
}
pub inline fn OSSL_PARAM_octet_string(key: anytype, addr: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_OCTET_STRING, addr, sz)) {
    _ = &key;
    _ = &addr;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_OCTET_STRING, addr, sz);
}
pub inline fn OSSL_PARAM_utf8_ptr(key: anytype, addr: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UTF8_PTR, addr, sz)) {
    _ = &key;
    _ = &addr;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UTF8_PTR, addr, sz);
}
pub inline fn OSSL_PARAM_octet_ptr(key: anytype, addr: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_OCTET_PTR, addr, sz)) {
    _ = &key;
    _ = &addr;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_OCTET_PTR, addr, sz);
}
pub const OSSL_CORE_MAKE_FUNC = @compileError("unable to translate macro: undefined identifier `OSSL_FUNC_`");
// /opt/homebrew/opt/openssl@3/include/openssl/core_dispatch.h:48:9
pub const OSSL_FUNC_CORE_GETTABLE_PARAMS = @as(c_int, 1);
pub const OSSL_FUNC_CORE_GET_PARAMS = @as(c_int, 2);
pub const OSSL_FUNC_CORE_THREAD_START = @as(c_int, 3);
pub const OSSL_FUNC_CORE_GET_LIBCTX = @as(c_int, 4);
pub const OSSL_FUNC_CORE_NEW_ERROR = @as(c_int, 5);
pub const OSSL_FUNC_CORE_SET_ERROR_DEBUG = @as(c_int, 6);
pub const OSSL_FUNC_CORE_VSET_ERROR = @as(c_int, 7);
pub const OSSL_FUNC_CORE_SET_ERROR_MARK = @as(c_int, 8);
pub const OSSL_FUNC_CORE_CLEAR_LAST_ERROR_MARK = @as(c_int, 9);
pub const OSSL_FUNC_CORE_POP_ERROR_TO_MARK = @as(c_int, 10);
pub const OSSL_FUNC_CORE_OBJ_ADD_SIGID = @as(c_int, 11);
pub const OSSL_FUNC_CORE_OBJ_CREATE = @as(c_int, 12);
pub const OSSL_FUNC_CRYPTO_MALLOC = @as(c_int, 20);
pub const OSSL_FUNC_CRYPTO_ZALLOC = @as(c_int, 21);
pub const OSSL_FUNC_CRYPTO_FREE = @as(c_int, 22);
pub const OSSL_FUNC_CRYPTO_CLEAR_FREE = @as(c_int, 23);
pub const OSSL_FUNC_CRYPTO_REALLOC = @as(c_int, 24);
pub const OSSL_FUNC_CRYPTO_CLEAR_REALLOC = @as(c_int, 25);
pub const OSSL_FUNC_CRYPTO_SECURE_MALLOC = @as(c_int, 26);
pub const OSSL_FUNC_CRYPTO_SECURE_ZALLOC = @as(c_int, 27);
pub const OSSL_FUNC_CRYPTO_SECURE_FREE = @as(c_int, 28);
pub const OSSL_FUNC_CRYPTO_SECURE_CLEAR_FREE = @as(c_int, 29);
pub const OSSL_FUNC_CRYPTO_SECURE_ALLOCATED = @as(c_int, 30);
pub const OSSL_FUNC_OPENSSL_CLEANSE = @as(c_int, 31);
pub const OSSL_FUNC_BIO_NEW_FILE = @as(c_int, 40);
pub const OSSL_FUNC_BIO_NEW_MEMBUF = @as(c_int, 41);
pub const OSSL_FUNC_BIO_READ_EX = @as(c_int, 42);
pub const OSSL_FUNC_BIO_WRITE_EX = @as(c_int, 43);
pub const OSSL_FUNC_BIO_UP_REF = @as(c_int, 44);
pub const OSSL_FUNC_BIO_FREE = @as(c_int, 45);
pub const OSSL_FUNC_BIO_VPRINTF = @as(c_int, 46);
pub const OSSL_FUNC_BIO_VSNPRINTF = @as(c_int, 47);
pub const OSSL_FUNC_BIO_PUTS = @as(c_int, 48);
pub const OSSL_FUNC_BIO_GETS = @as(c_int, 49);
pub const OSSL_FUNC_BIO_CTRL = @as(c_int, 50);
pub const OSSL_FUNC_CLEANUP_USER_ENTROPY = @as(c_int, 96);
pub const OSSL_FUNC_CLEANUP_USER_NONCE = @as(c_int, 97);
pub const OSSL_FUNC_GET_USER_ENTROPY = @as(c_int, 98);
pub const OSSL_FUNC_GET_USER_NONCE = @as(c_int, 99);
pub const OSSL_FUNC_INDICATOR_CB = @as(c_int, 95);
pub const OSSL_FUNC_SELF_TEST_CB = @as(c_int, 100);
pub const OSSL_FUNC_GET_ENTROPY = @as(c_int, 101);
pub const OSSL_FUNC_CLEANUP_ENTROPY = @as(c_int, 102);
pub const OSSL_FUNC_GET_NONCE = @as(c_int, 103);
pub const OSSL_FUNC_CLEANUP_NONCE = @as(c_int, 104);
pub const OSSL_FUNC_PROVIDER_REGISTER_CHILD_CB = @as(c_int, 105);
pub const OSSL_FUNC_PROVIDER_DEREGISTER_CHILD_CB = @as(c_int, 106);
pub const OSSL_FUNC_PROVIDER_NAME = @as(c_int, 107);
pub const OSSL_FUNC_PROVIDER_GET0_PROVIDER_CTX = @as(c_int, 108);
pub const OSSL_FUNC_PROVIDER_GET0_DISPATCH = @as(c_int, 109);
pub const OSSL_FUNC_PROVIDER_UP_REF = @as(c_int, 110);
pub const OSSL_FUNC_PROVIDER_FREE = @as(c_int, 111);
pub const OSSL_FUNC_PROVIDER_TEARDOWN = @as(c_int, 1024);
pub const OSSL_FUNC_PROVIDER_GETTABLE_PARAMS = @as(c_int, 1025);
pub const OSSL_FUNC_PROVIDER_GET_PARAMS = @as(c_int, 1026);
pub const OSSL_FUNC_PROVIDER_QUERY_OPERATION = @as(c_int, 1027);
pub const OSSL_FUNC_PROVIDER_UNQUERY_OPERATION = @as(c_int, 1028);
pub const OSSL_FUNC_PROVIDER_GET_REASON_STRINGS = @as(c_int, 1029);
pub const OSSL_FUNC_PROVIDER_GET_CAPABILITIES = @as(c_int, 1030);
pub const OSSL_FUNC_PROVIDER_SELF_TEST = @as(c_int, 1031);
pub const OSSL_OP_DIGEST = @as(c_int, 1);
pub const OSSL_OP_CIPHER = @as(c_int, 2);
pub const OSSL_OP_MAC = @as(c_int, 3);
pub const OSSL_OP_KDF = @as(c_int, 4);
pub const OSSL_OP_RAND = @as(c_int, 5);
pub const OSSL_OP_KEYMGMT = @as(c_int, 10);
pub const OSSL_OP_KEYEXCH = @as(c_int, 11);
pub const OSSL_OP_SIGNATURE = @as(c_int, 12);
pub const OSSL_OP_ASYM_CIPHER = @as(c_int, 13);
pub const OSSL_OP_KEM = @as(c_int, 14);
pub const OSSL_OP_ENCODER = @as(c_int, 20);
pub const OSSL_OP_DECODER = @as(c_int, 21);
pub const OSSL_OP_STORE = @as(c_int, 22);
pub const OSSL_OP__HIGHEST = @as(c_int, 22);
pub const OSSL_FUNC_DIGEST_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_DIGEST_INIT = @as(c_int, 2);
pub const OSSL_FUNC_DIGEST_UPDATE = @as(c_int, 3);
pub const OSSL_FUNC_DIGEST_FINAL = @as(c_int, 4);
pub const OSSL_FUNC_DIGEST_DIGEST = @as(c_int, 5);
pub const OSSL_FUNC_DIGEST_FREECTX = @as(c_int, 6);
pub const OSSL_FUNC_DIGEST_DUPCTX = @as(c_int, 7);
pub const OSSL_FUNC_DIGEST_GET_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_DIGEST_SET_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_DIGEST_GET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_DIGEST_GETTABLE_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS = @as(c_int, 13);
pub const OSSL_FUNC_DIGEST_SQUEEZE = @as(c_int, 14);
pub const OSSL_FUNC_CIPHER_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_CIPHER_ENCRYPT_INIT = @as(c_int, 2);
pub const OSSL_FUNC_CIPHER_DECRYPT_INIT = @as(c_int, 3);
pub const OSSL_FUNC_CIPHER_UPDATE = @as(c_int, 4);
pub const OSSL_FUNC_CIPHER_FINAL = @as(c_int, 5);
pub const OSSL_FUNC_CIPHER_CIPHER = @as(c_int, 6);
pub const OSSL_FUNC_CIPHER_FREECTX = @as(c_int, 7);
pub const OSSL_FUNC_CIPHER_DUPCTX = @as(c_int, 8);
pub const OSSL_FUNC_CIPHER_GET_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_CIPHER_GET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_CIPHER_SET_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_CIPHER_GETTABLE_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_CIPHER_GETTABLE_CTX_PARAMS = @as(c_int, 13);
pub const OSSL_FUNC_CIPHER_SETTABLE_CTX_PARAMS = @as(c_int, 14);
pub const OSSL_FUNC_MAC_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_MAC_DUPCTX = @as(c_int, 2);
pub const OSSL_FUNC_MAC_FREECTX = @as(c_int, 3);
pub const OSSL_FUNC_MAC_INIT = @as(c_int, 4);
pub const OSSL_FUNC_MAC_UPDATE = @as(c_int, 5);
pub const OSSL_FUNC_MAC_FINAL = @as(c_int, 6);
pub const OSSL_FUNC_MAC_GET_PARAMS = @as(c_int, 7);
pub const OSSL_FUNC_MAC_GET_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_MAC_SET_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_MAC_GETTABLE_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_MAC_GETTABLE_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_MAC_SETTABLE_CTX_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_KDF_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_KDF_DUPCTX = @as(c_int, 2);
pub const OSSL_FUNC_KDF_FREECTX = @as(c_int, 3);
pub const OSSL_FUNC_KDF_RESET = @as(c_int, 4);
pub const OSSL_FUNC_KDF_DERIVE = @as(c_int, 5);
pub const OSSL_FUNC_KDF_GETTABLE_PARAMS = @as(c_int, 6);
pub const OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS = @as(c_int, 7);
pub const OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_KDF_GET_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_KDF_GET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_KDF_SET_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_RAND_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_RAND_FREECTX = @as(c_int, 2);
pub const OSSL_FUNC_RAND_INSTANTIATE = @as(c_int, 3);
pub const OSSL_FUNC_RAND_UNINSTANTIATE = @as(c_int, 4);
pub const OSSL_FUNC_RAND_GENERATE = @as(c_int, 5);
pub const OSSL_FUNC_RAND_RESEED = @as(c_int, 6);
pub const OSSL_FUNC_RAND_NONCE = @as(c_int, 7);
pub const OSSL_FUNC_RAND_ENABLE_LOCKING = @as(c_int, 8);
pub const OSSL_FUNC_RAND_LOCK = @as(c_int, 9);
pub const OSSL_FUNC_RAND_UNLOCK = @as(c_int, 10);
pub const OSSL_FUNC_RAND_GETTABLE_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_RAND_GETTABLE_CTX_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_RAND_SETTABLE_CTX_PARAMS = @as(c_int, 13);
pub const OSSL_FUNC_RAND_GET_PARAMS = @as(c_int, 14);
pub const OSSL_FUNC_RAND_GET_CTX_PARAMS = @as(c_int, 15);
pub const OSSL_FUNC_RAND_SET_CTX_PARAMS = @as(c_int, 16);
pub const OSSL_FUNC_RAND_VERIFY_ZEROIZATION = @as(c_int, 17);
pub const OSSL_FUNC_RAND_GET_SEED = @as(c_int, 18);
pub const OSSL_FUNC_RAND_CLEAR_SEED = @as(c_int, 19);
pub const OSSL_KEYMGMT_SELECT_PRIVATE_KEY = @as(c_int, 0x01);
pub const OSSL_KEYMGMT_SELECT_PUBLIC_KEY = @as(c_int, 0x02);
pub const OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS = @as(c_int, 0x04);
pub const OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS = @as(c_int, 0x80);
pub const OSSL_KEYMGMT_SELECT_ALL_PARAMETERS = OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS | OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS;
pub const OSSL_KEYMGMT_SELECT_KEYPAIR = OSSL_KEYMGMT_SELECT_PRIVATE_KEY | OSSL_KEYMGMT_SELECT_PUBLIC_KEY;
pub const OSSL_KEYMGMT_SELECT_ALL = OSSL_KEYMGMT_SELECT_KEYPAIR | OSSL_KEYMGMT_SELECT_ALL_PARAMETERS;
pub const OSSL_KEYMGMT_VALIDATE_FULL_CHECK = @as(c_int, 0);
pub const OSSL_KEYMGMT_VALIDATE_QUICK_CHECK = @as(c_int, 1);
pub const OSSL_FUNC_KEYMGMT_NEW = @as(c_int, 1);
pub const OSSL_FUNC_KEYMGMT_GEN_INIT = @as(c_int, 2);
pub const OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE = @as(c_int, 3);
pub const OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS = @as(c_int, 4);
pub const OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS = @as(c_int, 5);
pub const OSSL_FUNC_KEYMGMT_GEN = @as(c_int, 6);
pub const OSSL_FUNC_KEYMGMT_GEN_CLEANUP = @as(c_int, 7);
pub const OSSL_FUNC_KEYMGMT_GEN_GET_PARAMS = @as(c_int, 15);
pub const OSSL_FUNC_KEYMGMT_GEN_GETTABLE_PARAMS = @as(c_int, 16);
pub const OSSL_FUNC_KEYMGMT_LOAD = @as(c_int, 8);
pub const OSSL_FUNC_KEYMGMT_FREE = @as(c_int, 10);
pub const OSSL_FUNC_KEYMGMT_GET_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_KEYMGMT_SET_PARAMS = @as(c_int, 13);
pub const OSSL_FUNC_KEYMGMT_SETTABLE_PARAMS = @as(c_int, 14);
pub const OSSL_FUNC_KEYMGMT_QUERY_OPERATION_NAME = @as(c_int, 20);
pub const OSSL_FUNC_KEYMGMT_HAS = @as(c_int, 21);
pub const OSSL_FUNC_KEYMGMT_VALIDATE = @as(c_int, 22);
pub const OSSL_FUNC_KEYMGMT_MATCH = @as(c_int, 23);
pub const OSSL_FUNC_KEYMGMT_IMPORT = @as(c_int, 40);
pub const OSSL_FUNC_KEYMGMT_IMPORT_TYPES = @as(c_int, 41);
pub const OSSL_FUNC_KEYMGMT_EXPORT = @as(c_int, 42);
pub const OSSL_FUNC_KEYMGMT_EXPORT_TYPES = @as(c_int, 43);
pub const OSSL_FUNC_KEYMGMT_DUP = @as(c_int, 44);
pub const OSSL_FUNC_KEYMGMT_IMPORT_TYPES_EX = @as(c_int, 45);
pub const OSSL_FUNC_KEYMGMT_EXPORT_TYPES_EX = @as(c_int, 46);
pub const OSSL_FUNC_KEYEXCH_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_KEYEXCH_INIT = @as(c_int, 2);
pub const OSSL_FUNC_KEYEXCH_DERIVE = @as(c_int, 3);
pub const OSSL_FUNC_KEYEXCH_SET_PEER = @as(c_int, 4);
pub const OSSL_FUNC_KEYEXCH_FREECTX = @as(c_int, 5);
pub const OSSL_FUNC_KEYEXCH_DUPCTX = @as(c_int, 6);
pub const OSSL_FUNC_KEYEXCH_SET_CTX_PARAMS = @as(c_int, 7);
pub const OSSL_FUNC_KEYEXCH_SETTABLE_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_KEYEXCH_GET_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_KEYEXCH_GETTABLE_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_SIGNATURE_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_SIGNATURE_SIGN_INIT = @as(c_int, 2);
pub const OSSL_FUNC_SIGNATURE_SIGN = @as(c_int, 3);
pub const OSSL_FUNC_SIGNATURE_VERIFY_INIT = @as(c_int, 4);
pub const OSSL_FUNC_SIGNATURE_VERIFY = @as(c_int, 5);
pub const OSSL_FUNC_SIGNATURE_VERIFY_RECOVER_INIT = @as(c_int, 6);
pub const OSSL_FUNC_SIGNATURE_VERIFY_RECOVER = @as(c_int, 7);
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN_INIT = @as(c_int, 8);
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN_UPDATE = @as(c_int, 9);
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN_FINAL = @as(c_int, 10);
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN = @as(c_int, 11);
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_INIT = @as(c_int, 12);
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_UPDATE = @as(c_int, 13);
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_FINAL = @as(c_int, 14);
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY = @as(c_int, 15);
pub const OSSL_FUNC_SIGNATURE_FREECTX = @as(c_int, 16);
pub const OSSL_FUNC_SIGNATURE_DUPCTX = @as(c_int, 17);
pub const OSSL_FUNC_SIGNATURE_GET_CTX_PARAMS = @as(c_int, 18);
pub const OSSL_FUNC_SIGNATURE_GETTABLE_CTX_PARAMS = @as(c_int, 19);
pub const OSSL_FUNC_SIGNATURE_SET_CTX_PARAMS = @as(c_int, 20);
pub const OSSL_FUNC_SIGNATURE_SETTABLE_CTX_PARAMS = @as(c_int, 21);
pub const OSSL_FUNC_SIGNATURE_GET_CTX_MD_PARAMS = @as(c_int, 22);
pub const OSSL_FUNC_SIGNATURE_GETTABLE_CTX_MD_PARAMS = @as(c_int, 23);
pub const OSSL_FUNC_SIGNATURE_SET_CTX_MD_PARAMS = @as(c_int, 24);
pub const OSSL_FUNC_SIGNATURE_SETTABLE_CTX_MD_PARAMS = @as(c_int, 25);
pub const OSSL_FUNC_SIGNATURE_QUERY_KEY_TYPES = @as(c_int, 26);
pub const OSSL_FUNC_SIGNATURE_SIGN_MESSAGE_INIT = @as(c_int, 27);
pub const OSSL_FUNC_SIGNATURE_SIGN_MESSAGE_UPDATE = @as(c_int, 28);
pub const OSSL_FUNC_SIGNATURE_SIGN_MESSAGE_FINAL = @as(c_int, 29);
pub const OSSL_FUNC_SIGNATURE_VERIFY_MESSAGE_INIT = @as(c_int, 30);
pub const OSSL_FUNC_SIGNATURE_VERIFY_MESSAGE_UPDATE = @as(c_int, 31);
pub const OSSL_FUNC_SIGNATURE_VERIFY_MESSAGE_FINAL = @as(c_int, 32);
pub const OSSL_FUNC_ASYM_CIPHER_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_ASYM_CIPHER_ENCRYPT_INIT = @as(c_int, 2);
pub const OSSL_FUNC_ASYM_CIPHER_ENCRYPT = @as(c_int, 3);
pub const OSSL_FUNC_ASYM_CIPHER_DECRYPT_INIT = @as(c_int, 4);
pub const OSSL_FUNC_ASYM_CIPHER_DECRYPT = @as(c_int, 5);
pub const OSSL_FUNC_ASYM_CIPHER_FREECTX = @as(c_int, 6);
pub const OSSL_FUNC_ASYM_CIPHER_DUPCTX = @as(c_int, 7);
pub const OSSL_FUNC_ASYM_CIPHER_GET_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_ASYM_CIPHER_GETTABLE_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_ASYM_CIPHER_SET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_ASYM_CIPHER_SETTABLE_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_KEM_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_KEM_ENCAPSULATE_INIT = @as(c_int, 2);
pub const OSSL_FUNC_KEM_ENCAPSULATE = @as(c_int, 3);
pub const OSSL_FUNC_KEM_DECAPSULATE_INIT = @as(c_int, 4);
pub const OSSL_FUNC_KEM_DECAPSULATE = @as(c_int, 5);
pub const OSSL_FUNC_KEM_FREECTX = @as(c_int, 6);
pub const OSSL_FUNC_KEM_DUPCTX = @as(c_int, 7);
pub const OSSL_FUNC_KEM_GET_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_KEM_GETTABLE_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_KEM_SET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_KEM_AUTH_ENCAPSULATE_INIT = @as(c_int, 12);
pub const OSSL_FUNC_KEM_AUTH_DECAPSULATE_INIT = @as(c_int, 13);
pub const OSSL_FUNC_ENCODER_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_ENCODER_FREECTX = @as(c_int, 2);
pub const OSSL_FUNC_ENCODER_GET_PARAMS = @as(c_int, 3);
pub const OSSL_FUNC_ENCODER_GETTABLE_PARAMS = @as(c_int, 4);
pub const OSSL_FUNC_ENCODER_SET_CTX_PARAMS = @as(c_int, 5);
pub const OSSL_FUNC_ENCODER_SETTABLE_CTX_PARAMS = @as(c_int, 6);
pub const OSSL_FUNC_ENCODER_DOES_SELECTION = @as(c_int, 10);
pub const OSSL_FUNC_ENCODER_ENCODE = @as(c_int, 11);
pub const OSSL_FUNC_ENCODER_IMPORT_OBJECT = @as(c_int, 20);
pub const OSSL_FUNC_ENCODER_FREE_OBJECT = @as(c_int, 21);
pub const OSSL_FUNC_DECODER_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_DECODER_FREECTX = @as(c_int, 2);
pub const OSSL_FUNC_DECODER_GET_PARAMS = @as(c_int, 3);
pub const OSSL_FUNC_DECODER_GETTABLE_PARAMS = @as(c_int, 4);
pub const OSSL_FUNC_DECODER_SET_CTX_PARAMS = @as(c_int, 5);
pub const OSSL_FUNC_DECODER_SETTABLE_CTX_PARAMS = @as(c_int, 6);
pub const OSSL_FUNC_DECODER_DOES_SELECTION = @as(c_int, 10);
pub const OSSL_FUNC_DECODER_DECODE = @as(c_int, 11);
pub const OSSL_FUNC_DECODER_EXPORT_OBJECT = @as(c_int, 20);
pub const OSSL_FUNC_STORE_OPEN = @as(c_int, 1);
pub const OSSL_FUNC_STORE_ATTACH = @as(c_int, 2);
pub const OSSL_FUNC_STORE_SETTABLE_CTX_PARAMS = @as(c_int, 3);
pub const OSSL_FUNC_STORE_SET_CTX_PARAMS = @as(c_int, 4);
pub const OSSL_FUNC_STORE_LOAD = @as(c_int, 5);
pub const OSSL_FUNC_STORE_EOF = @as(c_int, 6);
pub const OSSL_FUNC_STORE_CLOSE = @as(c_int, 7);
pub const OSSL_FUNC_STORE_EXPORT_OBJECT = @as(c_int, 8);
pub const OSSL_FUNC_STORE_DELETE = @as(c_int, 9);
pub const OSSL_FUNC_STORE_OPEN_EX = @as(c_int, 10);
pub const OPENSSL_EVPERR_H = "";
pub const EVP_R_AES_KEY_SETUP_FAILED = @as(c_int, 143);
pub const EVP_R_ARIA_KEY_SETUP_FAILED = @as(c_int, 176);
pub const EVP_R_BAD_ALGORITHM_NAME = @as(c_int, 200);
pub const EVP_R_BAD_DECRYPT = @as(c_int, 100);
pub const EVP_R_BAD_KEY_LENGTH = @as(c_int, 195);
pub const EVP_R_BUFFER_TOO_SMALL = @as(c_int, 155);
pub const EVP_R_CACHE_CONSTANTS_FAILED = @as(c_int, 225);
pub const EVP_R_CAMELLIA_KEY_SETUP_FAILED = @as(c_int, 157);
pub const EVP_R_CANNOT_GET_PARAMETERS = @as(c_int, 197);
pub const EVP_R_CANNOT_SET_PARAMETERS = @as(c_int, 198);
pub const EVP_R_CIPHER_NOT_GCM_MODE = @as(c_int, 184);
pub const EVP_R_CIPHER_PARAMETER_ERROR = @as(c_int, 122);
pub const EVP_R_COMMAND_NOT_SUPPORTED = @as(c_int, 147);
pub const EVP_R_CONFLICTING_ALGORITHM_NAME = @as(c_int, 201);
pub const EVP_R_COPY_ERROR = @as(c_int, 173);
pub const EVP_R_CTRL_NOT_IMPLEMENTED = @as(c_int, 132);
pub const EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED = @as(c_int, 133);
pub const EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH = @as(c_int, 138);
pub const EVP_R_DECODE_ERROR = @as(c_int, 114);
pub const EVP_R_DEFAULT_QUERY_PARSE_ERROR = @as(c_int, 210);
pub const EVP_R_DIFFERENT_KEY_TYPES = @as(c_int, 101);
pub const EVP_R_DIFFERENT_PARAMETERS = @as(c_int, 153);
pub const EVP_R_ERROR_LOADING_SECTION = @as(c_int, 165);
pub const EVP_R_EXPECTING_AN_HMAC_KEY = @as(c_int, 174);
pub const EVP_R_EXPECTING_AN_RSA_KEY = @as(c_int, 127);
pub const EVP_R_EXPECTING_A_DH_KEY = @as(c_int, 128);
pub const EVP_R_EXPECTING_A_DSA_KEY = @as(c_int, 129);
pub const EVP_R_EXPECTING_A_ECX_KEY = @as(c_int, 219);
pub const EVP_R_EXPECTING_A_EC_KEY = @as(c_int, 142);
pub const EVP_R_EXPECTING_A_POLY1305_KEY = @as(c_int, 164);
pub const EVP_R_EXPECTING_A_SIPHASH_KEY = @as(c_int, 175);
pub const EVP_R_FINAL_ERROR = @as(c_int, 188);
pub const EVP_R_GENERATE_ERROR = @as(c_int, 214);
pub const EVP_R_GETTING_ALGORITHMIDENTIFIER_NOT_SUPPORTED = @as(c_int, 229);
pub const EVP_R_GET_RAW_KEY_FAILED = @as(c_int, 182);
pub const EVP_R_ILLEGAL_SCRYPT_PARAMETERS = @as(c_int, 171);
pub const EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS = @as(c_int, 204);
pub const EVP_R_INACCESSIBLE_KEY = @as(c_int, 203);
pub const EVP_R_INITIALIZATION_ERROR = @as(c_int, 134);
pub const EVP_R_INPUT_NOT_INITIALIZED = @as(c_int, 111);
pub const EVP_R_INVALID_CUSTOM_LENGTH = @as(c_int, 185);
pub const EVP_R_INVALID_DIGEST = @as(c_int, 152);
pub const EVP_R_INVALID_IV_LENGTH = @as(c_int, 194);
pub const EVP_R_INVALID_KEY = @as(c_int, 163);
pub const EVP_R_INVALID_KEY_LENGTH = @as(c_int, 130);
pub const EVP_R_INVALID_LENGTH = @as(c_int, 221);
pub const EVP_R_INVALID_NULL_ALGORITHM = @as(c_int, 218);
pub const EVP_R_INVALID_OPERATION = @as(c_int, 148);
pub const EVP_R_INVALID_PROVIDER_FUNCTIONS = @as(c_int, 193);
pub const EVP_R_INVALID_SALT_LENGTH = @as(c_int, 186);
pub const EVP_R_INVALID_SECRET_LENGTH = @as(c_int, 223);
pub const EVP_R_INVALID_SEED_LENGTH = @as(c_int, 220);
pub const EVP_R_INVALID_VALUE = @as(c_int, 222);
pub const EVP_R_KEYMGMT_EXPORT_FAILURE = @as(c_int, 205);
pub const EVP_R_KEY_SETUP_FAILED = @as(c_int, 180);
pub const EVP_R_LOCKING_NOT_SUPPORTED = @as(c_int, 213);
pub const EVP_R_MEMORY_LIMIT_EXCEEDED = @as(c_int, 172);
pub const EVP_R_MESSAGE_DIGEST_IS_NULL = @as(c_int, 159);
pub const EVP_R_METHOD_NOT_SUPPORTED = @as(c_int, 144);
pub const EVP_R_MISSING_PARAMETERS = @as(c_int, 103);
pub const EVP_R_NOT_ABLE_TO_COPY_CTX = @as(c_int, 190);
pub const EVP_R_NOT_XOF_OR_INVALID_LENGTH = @as(c_int, 178);
pub const EVP_R_NO_CIPHER_SET = @as(c_int, 131);
pub const EVP_R_NO_DEFAULT_DIGEST = @as(c_int, 158);
pub const EVP_R_NO_DIGEST_SET = @as(c_int, 139);
pub const EVP_R_NO_IMPORT_FUNCTION = @as(c_int, 206);
pub const EVP_R_NO_KEYMGMT_AVAILABLE = @as(c_int, 199);
pub const EVP_R_NO_KEYMGMT_PRESENT = @as(c_int, 196);
pub const EVP_R_NO_KEY_SET = @as(c_int, 154);
pub const EVP_R_NO_OPERATION_SET = @as(c_int, 149);
pub const EVP_R_NULL_MAC_PKEY_CTX = @as(c_int, 208);
pub const EVP_R_ONLY_ONESHOT_SUPPORTED = @as(c_int, 177);
pub const EVP_R_OPERATION_NOT_INITIALIZED = @as(c_int, 151);
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE = @as(c_int, 150);
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_SIGNATURE_TYPE = @as(c_int, 226);
pub const EVP_R_OUTPUT_WOULD_OVERFLOW = @as(c_int, 202);
pub const EVP_R_PARAMETER_TOO_LARGE = @as(c_int, 187);
pub const EVP_R_PARTIALLY_OVERLAPPING = @as(c_int, 162);
pub const EVP_R_PBKDF2_ERROR = @as(c_int, 181);
pub const EVP_R_PKEY_APPLICATION_ASN1_METHOD_ALREADY_REGISTERED = @as(c_int, 179);
pub const EVP_R_PRIVATE_KEY_DECODE_ERROR = @as(c_int, 145);
pub const EVP_R_PRIVATE_KEY_ENCODE_ERROR = @as(c_int, 146);
pub const EVP_R_PUBLIC_KEY_NOT_RSA = @as(c_int, 106);
pub const EVP_R_SETTING_XOF_FAILED = @as(c_int, 227);
pub const EVP_R_SET_DEFAULT_PROPERTY_FAILURE = @as(c_int, 209);
pub const EVP_R_SIGNATURE_TYPE_AND_KEY_TYPE_INCOMPATIBLE = @as(c_int, 228);
pub const EVP_R_TOO_MANY_RECORDS = @as(c_int, 183);
pub const EVP_R_UNABLE_TO_ENABLE_LOCKING = @as(c_int, 212);
pub const EVP_R_UNABLE_TO_GET_MAXIMUM_REQUEST_SIZE = @as(c_int, 215);
pub const EVP_R_UNABLE_TO_GET_RANDOM_STRENGTH = @as(c_int, 216);
pub const EVP_R_UNABLE_TO_LOCK_CONTEXT = @as(c_int, 211);
pub const EVP_R_UNABLE_TO_SET_CALLBACKS = @as(c_int, 217);
pub const EVP_R_UNKNOWN_BITS = @as(c_int, 166);
pub const EVP_R_UNKNOWN_CIPHER = @as(c_int, 160);
pub const EVP_R_UNKNOWN_DIGEST = @as(c_int, 161);
pub const EVP_R_UNKNOWN_KEY_TYPE = @as(c_int, 207);
pub const EVP_R_UNKNOWN_MAX_SIZE = @as(c_int, 167);
pub const EVP_R_UNKNOWN_OPTION = @as(c_int, 169);
pub const EVP_R_UNKNOWN_PBE_ALGORITHM = @as(c_int, 121);
pub const EVP_R_UNKNOWN_SECURITY_BITS = @as(c_int, 168);
pub const EVP_R_UNSUPPORTED_ALGORITHM = @as(c_int, 156);
pub const EVP_R_UNSUPPORTED_CIPHER = @as(c_int, 107);
pub const EVP_R_UNSUPPORTED_KEYLENGTH = @as(c_int, 123);
pub const EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION = @as(c_int, 124);
pub const EVP_R_UNSUPPORTED_KEY_SIZE = @as(c_int, 108);
pub const EVP_R_UNSUPPORTED_KEY_TYPE = @as(c_int, 224);
pub const EVP_R_UNSUPPORTED_NUMBER_OF_ROUNDS = @as(c_int, 135);
pub const EVP_R_UNSUPPORTED_PRF = @as(c_int, 125);
pub const EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM = @as(c_int, 118);
pub const EVP_R_UNSUPPORTED_SALT_TYPE = @as(c_int, 126);
pub const EVP_R_UPDATE_ERROR = @as(c_int, 189);
pub const EVP_R_WRAP_MODE_NOT_ALLOWED = @as(c_int, 170);
pub const EVP_R_WRONG_FINAL_BLOCK_LENGTH = @as(c_int, 109);
pub const EVP_R_XTS_DATA_UNIT_IS_TOO_LARGE = @as(c_int, 191);
pub const EVP_R_XTS_DUPLICATED_KEYS = @as(c_int, 192);
pub const EVP_MAX_MD_SIZE = @as(c_int, 64);
pub const EVP_MAX_KEY_LENGTH = @as(c_int, 64);
pub const EVP_MAX_IV_LENGTH = @as(c_int, 16);
pub const EVP_MAX_BLOCK_LENGTH = @as(c_int, 32);
pub const EVP_MAX_AEAD_TAG_LENGTH = @as(c_int, 16);
pub const PKCS5_SALT_LEN = @as(c_int, 8);
pub const PKCS5_DEFAULT_ITER = @as(c_int, 2048);
pub const OPENSSL_OBJECTS_H = "";
pub const HEADER_OBJECTS_H = "";
pub const OPENSSL_OBJ_MAC_H = "";
pub const SN_undef = "UNDEF";
pub const LN_undef = "undefined";
pub const NID_undef = @as(c_int, 0);
pub const OBJ_undef = @as(c_long, 0);
pub const SN_itu_t = "ITU-T";
pub const LN_itu_t = "itu-t";
pub const NID_itu_t = @as(c_int, 645);
pub const OBJ_itu_t = @as(c_long, 0);
pub const NID_ccitt = @as(c_int, 404);
pub const OBJ_ccitt = OBJ_itu_t;
pub const SN_iso = "ISO";
pub const LN_iso = "iso";
pub const NID_iso = @as(c_int, 181);
pub const OBJ_iso = @as(c_long, 1);
pub const SN_joint_iso_itu_t = "JOINT-ISO-ITU-T";
pub const LN_joint_iso_itu_t = "joint-iso-itu-t";
pub const NID_joint_iso_itu_t = @as(c_int, 646);
pub const OBJ_joint_iso_itu_t = @as(c_long, 2);
pub const NID_joint_iso_ccitt = @as(c_int, 393);
pub const OBJ_joint_iso_ccitt = OBJ_joint_iso_itu_t;
pub const SN_member_body = "member-body";
pub const LN_member_body = "ISO Member Body";
pub const NID_member_body = @as(c_int, 182);
pub const OBJ_member_body = blk: {
    _ = &OBJ_iso;
    break :blk @as(c_long, 2);
};
pub const SN_identified_organization = "identified-organization";
pub const NID_identified_organization = @as(c_int, 676);
pub const OBJ_identified_organization = blk: {
    _ = &OBJ_iso;
    break :blk @as(c_long, 3);
};
pub const SN_gmac = "GMAC";
pub const LN_gmac = "gmac";
pub const NID_gmac = @as(c_int, 1195);
pub const OBJ_gmac = blk: {
    _ = &OBJ_iso;
    _ = @as(c_long, 0);
    _ = @as(c_long, 9797);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const SN_hmac_md5 = "HMAC-MD5";
pub const LN_hmac_md5 = "hmac-md5";
pub const NID_hmac_md5 = @as(c_int, 780);
pub const OBJ_hmac_md5 = blk: {
    _ = &OBJ_identified_organization;
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    _ = @as(c_long, 5);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_hmac_sha1 = "HMAC-SHA1";
pub const LN_hmac_sha1 = "hmac-sha1";
pub const NID_hmac_sha1 = @as(c_int, 781);
pub const OBJ_hmac_sha1 = blk: {
    _ = &OBJ_identified_organization;
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    _ = @as(c_long, 5);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_x509ExtAdmission = "x509ExtAdmission";
pub const LN_x509ExtAdmission = "Professional Information or basis for Admission";
pub const NID_x509ExtAdmission = @as(c_int, 1093);
pub const OBJ_x509ExtAdmission = blk: {
    _ = &OBJ_identified_organization;
    _ = @as(c_long, 36);
    _ = @as(c_long, 8);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 3);
};
pub const SN_certicom_arc = "certicom-arc";
pub const NID_certicom_arc = @as(c_int, 677);
pub const OBJ_certicom_arc = blk: {
    _ = &OBJ_identified_organization;
    break :blk @as(c_long, 132);
};
pub const SN_ieee = "ieee";
pub const NID_ieee = @as(c_int, 1170);
pub const OBJ_ieee = blk: {
    _ = &OBJ_identified_organization;
    break :blk @as(c_long, 111);
};
pub const SN_ieee_siswg = "ieee-siswg";
pub const LN_ieee_siswg = "IEEE Security in Storage Working Group";
pub const NID_ieee_siswg = @as(c_int, 1171);
pub const OBJ_ieee_siswg = blk: {
    _ = &OBJ_ieee;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1619);
};
pub const SN_international_organizations = "international-organizations";
pub const LN_international_organizations = "International Organizations";
pub const NID_international_organizations = @as(c_int, 647);
pub const OBJ_international_organizations = blk: {
    _ = &OBJ_joint_iso_itu_t;
    break :blk @as(c_long, 23);
};
pub const SN_wap = "wap";
pub const NID_wap = @as(c_int, 678);
pub const OBJ_wap = blk: {
    _ = &OBJ_international_organizations;
    break :blk @as(c_long, 43);
};
pub const SN_wap_wsg = "wap-wsg";
pub const NID_wap_wsg = @as(c_int, 679);
pub const OBJ_wap_wsg = blk: {
    _ = &OBJ_wap;
    break :blk @as(c_long, 1);
};
pub const SN_selected_attribute_types = "selected-attribute-types";
pub const LN_selected_attribute_types = "Selected Attribute Types";
pub const NID_selected_attribute_types = @as(c_int, 394);
pub const OBJ_selected_attribute_types = blk: {
    _ = &OBJ_joint_iso_itu_t;
    _ = @as(c_long, 5);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 5);
};
pub const SN_clearance = "clearance";
pub const NID_clearance = @as(c_int, 395);
pub const OBJ_clearance = blk: {
    _ = &OBJ_selected_attribute_types;
    break :blk @as(c_long, 55);
};
pub const SN_ISO_US = "ISO-US";
pub const LN_ISO_US = "ISO US Member Body";
pub const NID_ISO_US = @as(c_int, 183);
pub const OBJ_ISO_US = blk: {
    _ = &OBJ_member_body;
    break :blk @as(c_long, 840);
};
pub const SN_X9_57 = "X9-57";
pub const LN_X9_57 = "X9.57";
pub const NID_X9_57 = @as(c_int, 184);
pub const OBJ_X9_57 = blk: {
    _ = &OBJ_ISO_US;
    break :blk @as(c_long, 10040);
};
pub const SN_X9cm = "X9cm";
pub const LN_X9cm = "X9.57 CM ?";
pub const NID_X9cm = @as(c_int, 185);
pub const OBJ_X9cm = blk: {
    _ = &OBJ_X9_57;
    break :blk @as(c_long, 4);
};
pub const SN_ISO_CN = "ISO-CN";
pub const LN_ISO_CN = "ISO CN Member Body";
pub const NID_ISO_CN = @as(c_int, 1140);
pub const OBJ_ISO_CN = blk: {
    _ = &OBJ_member_body;
    break :blk @as(c_long, 156);
};
pub const SN_oscca = "oscca";
pub const NID_oscca = @as(c_int, 1141);
pub const OBJ_oscca = blk: {
    _ = &OBJ_ISO_CN;
    break :blk @as(c_long, 10197);
};
pub const SN_sm_scheme = "sm-scheme";
pub const NID_sm_scheme = @as(c_int, 1142);
pub const OBJ_sm_scheme = blk: {
    _ = &OBJ_oscca;
    break :blk @as(c_long, 1);
};
pub const SN_dsa = "DSA";
pub const LN_dsa = "dsaEncryption";
pub const NID_dsa = @as(c_int, 116);
pub const OBJ_dsa = blk: {
    _ = &OBJ_X9cm;
    break :blk @as(c_long, 1);
};
pub const SN_dsaWithSHA1 = "DSA-SHA1";
pub const LN_dsaWithSHA1 = "dsaWithSHA1";
pub const NID_dsaWithSHA1 = @as(c_int, 113);
pub const OBJ_dsaWithSHA1 = blk: {
    _ = &OBJ_X9cm;
    break :blk @as(c_long, 3);
};
pub const SN_ansi_X9_62 = "ansi-X9-62";
pub const LN_ansi_X9_62 = "ANSI X9.62";
pub const NID_ansi_X9_62 = @as(c_int, 405);
pub const OBJ_ansi_X9_62 = blk: {
    _ = &OBJ_ISO_US;
    break :blk @as(c_long, 10045);
};
pub const OBJ_X9_62_id_fieldType = blk: {
    _ = &OBJ_ansi_X9_62;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_prime_field = "prime-field";
pub const NID_X9_62_prime_field = @as(c_int, 406);
pub const OBJ_X9_62_prime_field = blk: {
    _ = &OBJ_X9_62_id_fieldType;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_characteristic_two_field = "characteristic-two-field";
pub const NID_X9_62_characteristic_two_field = @as(c_int, 407);
pub const OBJ_X9_62_characteristic_two_field = blk: {
    _ = &OBJ_X9_62_id_fieldType;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_id_characteristic_two_basis = "id-characteristic-two-basis";
pub const NID_X9_62_id_characteristic_two_basis = @as(c_int, 680);
pub const OBJ_X9_62_id_characteristic_two_basis = blk: {
    _ = &OBJ_X9_62_characteristic_two_field;
    break :blk @as(c_long, 3);
};
pub const SN_X9_62_onBasis = "onBasis";
pub const NID_X9_62_onBasis = @as(c_int, 681);
pub const OBJ_X9_62_onBasis = blk: {
    _ = &OBJ_X9_62_id_characteristic_two_basis;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_tpBasis = "tpBasis";
pub const NID_X9_62_tpBasis = @as(c_int, 682);
pub const OBJ_X9_62_tpBasis = blk: {
    _ = &OBJ_X9_62_id_characteristic_two_basis;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_ppBasis = "ppBasis";
pub const NID_X9_62_ppBasis = @as(c_int, 683);
pub const OBJ_X9_62_ppBasis = blk: {
    _ = &OBJ_X9_62_id_characteristic_two_basis;
    break :blk @as(c_long, 3);
};
pub const OBJ_X9_62_id_publicKeyType = blk: {
    _ = &OBJ_ansi_X9_62;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_id_ecPublicKey = "id-ecPublicKey";
pub const NID_X9_62_id_ecPublicKey = @as(c_int, 408);
pub const OBJ_X9_62_id_ecPublicKey = blk: {
    _ = &OBJ_X9_62_id_publicKeyType;
    break :blk @as(c_long, 1);
};
pub const OBJ_X9_62_ellipticCurve = blk: {
    _ = &OBJ_ansi_X9_62;
    break :blk @as(c_long, 3);
};
pub const OBJ_X9_62_c_TwoCurve = blk: {
    _ = &OBJ_X9_62_ellipticCurve;
    break :blk @as(c_long, 0);
};
pub const SN_X9_62_c2pnb163v1 = "c2pnb163v1";
pub const NID_X9_62_c2pnb163v1 = @as(c_int, 684);
pub const OBJ_X9_62_c2pnb163v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_c2pnb163v2 = "c2pnb163v2";
pub const NID_X9_62_c2pnb163v2 = @as(c_int, 685);
pub const OBJ_X9_62_c2pnb163v2 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_c2pnb163v3 = "c2pnb163v3";
pub const NID_X9_62_c2pnb163v3 = @as(c_int, 686);
pub const OBJ_X9_62_c2pnb163v3 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 3);
};
pub const SN_X9_62_c2pnb176v1 = "c2pnb176v1";
pub const NID_X9_62_c2pnb176v1 = @as(c_int, 687);
pub const OBJ_X9_62_c2pnb176v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 4);
};
pub const SN_X9_62_c2tnb191v1 = "c2tnb191v1";
pub const NID_X9_62_c2tnb191v1 = @as(c_int, 688);
pub const OBJ_X9_62_c2tnb191v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 5);
};
pub const SN_X9_62_c2tnb191v2 = "c2tnb191v2";
pub const NID_X9_62_c2tnb191v2 = @as(c_int, 689);
pub const OBJ_X9_62_c2tnb191v2 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 6);
};
pub const SN_X9_62_c2tnb191v3 = "c2tnb191v3";
pub const NID_X9_62_c2tnb191v3 = @as(c_int, 690);
pub const OBJ_X9_62_c2tnb191v3 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 7);
};
pub const SN_X9_62_c2onb191v4 = "c2onb191v4";
pub const NID_X9_62_c2onb191v4 = @as(c_int, 691);
pub const OBJ_X9_62_c2onb191v4 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 8);
};
pub const SN_X9_62_c2onb191v5 = "c2onb191v5";
pub const NID_X9_62_c2onb191v5 = @as(c_int, 692);
pub const OBJ_X9_62_c2onb191v5 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 9);
};
pub const SN_X9_62_c2pnb208w1 = "c2pnb208w1";
pub const NID_X9_62_c2pnb208w1 = @as(c_int, 693);
pub const OBJ_X9_62_c2pnb208w1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 10);
};
pub const SN_X9_62_c2tnb239v1 = "c2tnb239v1";
pub const NID_X9_62_c2tnb239v1 = @as(c_int, 694);
pub const OBJ_X9_62_c2tnb239v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 11);
};
pub const SN_X9_62_c2tnb239v2 = "c2tnb239v2";
pub const NID_X9_62_c2tnb239v2 = @as(c_int, 695);
pub const OBJ_X9_62_c2tnb239v2 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 12);
};
pub const SN_X9_62_c2tnb239v3 = "c2tnb239v3";
pub const NID_X9_62_c2tnb239v3 = @as(c_int, 696);
pub const OBJ_X9_62_c2tnb239v3 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 13);
};
pub const SN_X9_62_c2onb239v4 = "c2onb239v4";
pub const NID_X9_62_c2onb239v4 = @as(c_int, 697);
pub const OBJ_X9_62_c2onb239v4 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 14);
};
pub const SN_X9_62_c2onb239v5 = "c2onb239v5";
pub const NID_X9_62_c2onb239v5 = @as(c_int, 698);
pub const OBJ_X9_62_c2onb239v5 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 15);
};
pub const SN_X9_62_c2pnb272w1 = "c2pnb272w1";
pub const NID_X9_62_c2pnb272w1 = @as(c_int, 699);
pub const OBJ_X9_62_c2pnb272w1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 16);
};
pub const SN_X9_62_c2pnb304w1 = "c2pnb304w1";
pub const NID_X9_62_c2pnb304w1 = @as(c_int, 700);
pub const OBJ_X9_62_c2pnb304w1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 17);
};
pub const SN_X9_62_c2tnb359v1 = "c2tnb359v1";
pub const NID_X9_62_c2tnb359v1 = @as(c_int, 701);
pub const OBJ_X9_62_c2tnb359v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 18);
};
pub const SN_X9_62_c2pnb368w1 = "c2pnb368w1";
pub const NID_X9_62_c2pnb368w1 = @as(c_int, 702);
pub const OBJ_X9_62_c2pnb368w1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 19);
};
pub const SN_X9_62_c2tnb431r1 = "c2tnb431r1";
pub const NID_X9_62_c2tnb431r1 = @as(c_int, 703);
pub const OBJ_X9_62_c2tnb431r1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 20);
};
pub const OBJ_X9_62_primeCurve = blk: {
    _ = &OBJ_X9_62_ellipticCurve;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_prime192v1 = "prime192v1";
pub const NID_X9_62_prime192v1 = @as(c_int, 409);
pub const OBJ_X9_62_prime192v1 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_prime192v2 = "prime192v2";
pub const NID_X9_62_prime192v2 = @as(c_int, 410);
pub const OBJ_X9_62_prime192v2 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_prime192v3 = "prime192v3";
pub const NID_X9_62_prime192v3 = @as(c_int, 411);
pub const OBJ_X9_62_prime192v3 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 3);
};
pub const SN_X9_62_prime239v1 = "prime239v1";
pub const NID_X9_62_prime239v1 = @as(c_int, 412);
pub const OBJ_X9_62_prime239v1 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 4);
};
pub const SN_X9_62_prime239v2 = "prime239v2";
pub const NID_X9_62_prime239v2 = @as(c_int, 413);
pub const OBJ_X9_62_prime239v2 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 5);
};
pub const SN_X9_62_prime239v3 = "prime239v3";
pub const NID_X9_62_prime239v3 = @as(c_int, 414);
pub const OBJ_X9_62_prime239v3 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 6);
};
pub const SN_X9_62_prime256v1 = "prime256v1";
pub const NID_X9_62_prime256v1 = @as(c_int, 415);
pub const OBJ_X9_62_prime256v1 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 7);
};
pub const OBJ_X9_62_id_ecSigType = blk: {
    _ = &OBJ_ansi_X9_62;
    break :blk @as(c_long, 4);
};
pub const SN_ecdsa_with_SHA1 = "ecdsa-with-SHA1";
pub const NID_ecdsa_with_SHA1 = @as(c_int, 416);
pub const OBJ_ecdsa_with_SHA1 = blk: {
    _ = &OBJ_X9_62_id_ecSigType;
    break :blk @as(c_long, 1);
};
pub const SN_ecdsa_with_Recommended = "ecdsa-with-Recommended";
pub const NID_ecdsa_with_Recommended = @as(c_int, 791);
pub const OBJ_ecdsa_with_Recommended = blk: {
    _ = &OBJ_X9_62_id_ecSigType;
    break :blk @as(c_long, 2);
};
pub const SN_ecdsa_with_Specified = "ecdsa-with-Specified";
pub const NID_ecdsa_with_Specified = @as(c_int, 792);
pub const OBJ_ecdsa_with_Specified = blk: {
    _ = &OBJ_X9_62_id_ecSigType;
    break :blk @as(c_long, 3);
};
pub const SN_ecdsa_with_SHA224 = "ecdsa-with-SHA224";
pub const NID_ecdsa_with_SHA224 = @as(c_int, 793);
pub const OBJ_ecdsa_with_SHA224 = blk: {
    _ = &OBJ_ecdsa_with_Specified;
    break :blk @as(c_long, 1);
};
pub const SN_ecdsa_with_SHA256 = "ecdsa-with-SHA256";
pub const NID_ecdsa_with_SHA256 = @as(c_int, 794);
pub const OBJ_ecdsa_with_SHA256 = blk: {
    _ = &OBJ_ecdsa_with_Specified;
    break :blk @as(c_long, 2);
};
pub const SN_ecdsa_with_SHA384 = "ecdsa-with-SHA384";
pub const NID_ecdsa_with_SHA384 = @as(c_int, 795);
pub const OBJ_ecdsa_with_SHA384 = blk: {
    _ = &OBJ_ecdsa_with_Specified;
    break :blk @as(c_long, 3);
};
pub const SN_ecdsa_with_SHA512 = "ecdsa-with-SHA512";
pub const NID_ecdsa_with_SHA512 = @as(c_int, 796);
pub const OBJ_ecdsa_with_SHA512 = blk: {
    _ = &OBJ_ecdsa_with_Specified;
    break :blk @as(c_long, 4);
};
pub const OBJ_secg_ellipticCurve = blk: {
    _ = &OBJ_certicom_arc;
    break :blk @as(c_long, 0);
};
pub const SN_secp112r1 = "secp112r1";
pub const NID_secp112r1 = @as(c_int, 704);
pub const OBJ_secp112r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 6);
};
pub const SN_secp112r2 = "secp112r2";
pub const NID_secp112r2 = @as(c_int, 705);
pub const OBJ_secp112r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 7);
};
pub const SN_secp128r1 = "secp128r1";
pub const NID_secp128r1 = @as(c_int, 706);
pub const OBJ_secp128r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 28);
};
pub const SN_secp128r2 = "secp128r2";
pub const NID_secp128r2 = @as(c_int, 707);
pub const OBJ_secp128r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 29);
};
pub const SN_secp160k1 = "secp160k1";
pub const NID_secp160k1 = @as(c_int, 708);
pub const OBJ_secp160k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 9);
};
pub const SN_secp160r1 = "secp160r1";
pub const NID_secp160r1 = @as(c_int, 709);
pub const OBJ_secp160r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 8);
};
pub const SN_secp160r2 = "secp160r2";
pub const NID_secp160r2 = @as(c_int, 710);
pub const OBJ_secp160r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 30);
};
pub const SN_secp192k1 = "secp192k1";
pub const NID_secp192k1 = @as(c_int, 711);
pub const OBJ_secp192k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 31);
};
pub const SN_secp224k1 = "secp224k1";
pub const NID_secp224k1 = @as(c_int, 712);
pub const OBJ_secp224k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 32);
};
pub const SN_secp224r1 = "secp224r1";
pub const NID_secp224r1 = @as(c_int, 713);
pub const OBJ_secp224r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 33);
};
pub const SN_secp256k1 = "secp256k1";
pub const NID_secp256k1 = @as(c_int, 714);
pub const OBJ_secp256k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 10);
};
pub const SN_secp384r1 = "secp384r1";
pub const NID_secp384r1 = @as(c_int, 715);
pub const OBJ_secp384r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 34);
};
pub const SN_secp521r1 = "secp521r1";
pub const NID_secp521r1 = @as(c_int, 716);
pub const OBJ_secp521r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 35);
};
pub const SN_sect113r1 = "sect113r1";
pub const NID_sect113r1 = @as(c_int, 717);
pub const OBJ_sect113r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 4);
};
pub const SN_sect113r2 = "sect113r2";
pub const NID_sect113r2 = @as(c_int, 718);
pub const OBJ_sect113r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 5);
};
pub const SN_sect131r1 = "sect131r1";
pub const NID_sect131r1 = @as(c_int, 719);
pub const OBJ_sect131r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 22);
};
pub const SN_sect131r2 = "sect131r2";
pub const NID_sect131r2 = @as(c_int, 720);
pub const OBJ_sect131r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 23);
};
pub const SN_sect163k1 = "sect163k1";
pub const NID_sect163k1 = @as(c_int, 721);
pub const OBJ_sect163k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 1);
};
pub const SN_sect163r1 = "sect163r1";
pub const NID_sect163r1 = @as(c_int, 722);
pub const OBJ_sect163r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 2);
};
pub const SN_sect163r2 = "sect163r2";
pub const NID_sect163r2 = @as(c_int, 723);
pub const OBJ_sect163r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 15);
};
pub const SN_sect193r1 = "sect193r1";
pub const NID_sect193r1 = @as(c_int, 724);
pub const OBJ_sect193r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 24);
};
pub const SN_sect193r2 = "sect193r2";
pub const NID_sect193r2 = @as(c_int, 725);
pub const OBJ_sect193r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 25);
};
pub const SN_sect233k1 = "sect233k1";
pub const NID_sect233k1 = @as(c_int, 726);
pub const OBJ_sect233k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 26);
};
pub const SN_sect233r1 = "sect233r1";
pub const NID_sect233r1 = @as(c_int, 727);
pub const OBJ_sect233r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 27);
};
pub const SN_sect239k1 = "sect239k1";
pub const NID_sect239k1 = @as(c_int, 728);
pub const OBJ_sect239k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 3);
};
pub const SN_sect283k1 = "sect283k1";
pub const NID_sect283k1 = @as(c_int, 729);
pub const OBJ_sect283k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 16);
};
pub const SN_sect283r1 = "sect283r1";
pub const NID_sect283r1 = @as(c_int, 730);
pub const OBJ_sect283r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 17);
};
pub const SN_sect409k1 = "sect409k1";
pub const NID_sect409k1 = @as(c_int, 731);
pub const OBJ_sect409k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 36);
};
pub const SN_sect409r1 = "sect409r1";
pub const NID_sect409r1 = @as(c_int, 732);
pub const OBJ_sect409r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 37);
};
pub const SN_sect571k1 = "sect571k1";
pub const NID_sect571k1 = @as(c_int, 733);
pub const OBJ_sect571k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 38);
};
pub const SN_sect571r1 = "sect571r1";
pub const NID_sect571r1 = @as(c_int, 734);
pub const OBJ_sect571r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 39);
};
pub const OBJ_wap_wsg_idm_ecid = blk: {
    _ = &OBJ_wap_wsg;
    break :blk @as(c_long, 4);
};
pub const SN_wap_wsg_idm_ecid_wtls1 = "wap-wsg-idm-ecid-wtls1";
pub const NID_wap_wsg_idm_ecid_wtls1 = @as(c_int, 735);
pub const OBJ_wap_wsg_idm_ecid_wtls1 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 1);
};
pub const SN_wap_wsg_idm_ecid_wtls3 = "wap-wsg-idm-ecid-wtls3";
pub const NID_wap_wsg_idm_ecid_wtls3 = @as(c_int, 736);
pub const OBJ_wap_wsg_idm_ecid_wtls3 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 3);
};
pub const SN_wap_wsg_idm_ecid_wtls4 = "wap-wsg-idm-ecid-wtls4";
pub const NID_wap_wsg_idm_ecid_wtls4 = @as(c_int, 737);
pub const OBJ_wap_wsg_idm_ecid_wtls4 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 4);
};
pub const SN_wap_wsg_idm_ecid_wtls5 = "wap-wsg-idm-ecid-wtls5";
pub const NID_wap_wsg_idm_ecid_wtls5 = @as(c_int, 738);
pub const OBJ_wap_wsg_idm_ecid_wtls5 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 5);
};
pub const SN_wap_wsg_idm_ecid_wtls6 = "wap-wsg-idm-ecid-wtls6";
pub const NID_wap_wsg_idm_ecid_wtls6 = @as(c_int, 739);
pub const OBJ_wap_wsg_idm_ecid_wtls6 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 6);
};
pub const SN_wap_wsg_idm_ecid_wtls7 = "wap-wsg-idm-ecid-wtls7";
pub const NID_wap_wsg_idm_ecid_wtls7 = @as(c_int, 740);
pub const OBJ_wap_wsg_idm_ecid_wtls7 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 7);
};
pub const SN_wap_wsg_idm_ecid_wtls8 = "wap-wsg-idm-ecid-wtls8";
pub const NID_wap_wsg_idm_ecid_wtls8 = @as(c_int, 741);
pub const OBJ_wap_wsg_idm_ecid_wtls8 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 8);
};
pub const SN_wap_wsg_idm_ecid_wtls9 = "wap-wsg-idm-ecid-wtls9";
pub const NID_wap_wsg_idm_ecid_wtls9 = @as(c_int, 742);
pub const OBJ_wap_wsg_idm_ecid_wtls9 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 9);
};
pub const SN_wap_wsg_idm_ecid_wtls10 = "wap-wsg-idm-ecid-wtls10";
pub const NID_wap_wsg_idm_ecid_wtls10 = @as(c_int, 743);
pub const OBJ_wap_wsg_idm_ecid_wtls10 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 10);
};
pub const SN_wap_wsg_idm_ecid_wtls11 = "wap-wsg-idm-ecid-wtls11";
pub const NID_wap_wsg_idm_ecid_wtls11 = @as(c_int, 744);
pub const OBJ_wap_wsg_idm_ecid_wtls11 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 11);
};
pub const SN_wap_wsg_idm_ecid_wtls12 = "wap-wsg-idm-ecid-wtls12";
pub const NID_wap_wsg_idm_ecid_wtls12 = @as(c_int, 745);
pub const OBJ_wap_wsg_idm_ecid_wtls12 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 12);
};
pub const SN_cast5_cbc = "CAST5-CBC";
pub const LN_cast5_cbc = "cast5-cbc";
pub const NID_cast5_cbc = @as(c_int, 108);
pub const OBJ_cast5_cbc = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 113533);
    _ = @as(c_long, 7);
    _ = @as(c_long, 66);
    break :blk @as(c_long, 10);
};
pub const SN_cast5_ecb = "CAST5-ECB";
pub const LN_cast5_ecb = "cast5-ecb";
pub const NID_cast5_ecb = @as(c_int, 109);
pub const SN_cast5_cfb64 = "CAST5-CFB";
pub const LN_cast5_cfb64 = "cast5-cfb";
pub const NID_cast5_cfb64 = @as(c_int, 110);
pub const SN_cast5_ofb64 = "CAST5-OFB";
pub const LN_cast5_ofb64 = "cast5-ofb";
pub const NID_cast5_ofb64 = @as(c_int, 111);
pub const LN_pbeWithMD5AndCast5_CBC = "pbeWithMD5AndCast5CBC";
pub const NID_pbeWithMD5AndCast5_CBC = @as(c_int, 112);
pub const OBJ_pbeWithMD5AndCast5_CBC = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 113533);
    _ = @as(c_long, 7);
    _ = @as(c_long, 66);
    break :blk @as(c_long, 12);
};
pub const SN_id_PasswordBasedMAC = "id-PasswordBasedMAC";
pub const LN_id_PasswordBasedMAC = "password based MAC";
pub const NID_id_PasswordBasedMAC = @as(c_int, 782);
pub const OBJ_id_PasswordBasedMAC = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 113533);
    _ = @as(c_long, 7);
    _ = @as(c_long, 66);
    break :blk @as(c_long, 13);
};
pub const SN_id_DHBasedMac = "id-DHBasedMac";
pub const LN_id_DHBasedMac = "Diffie-Hellman based MAC";
pub const NID_id_DHBasedMac = @as(c_int, 783);
pub const OBJ_id_DHBasedMac = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 113533);
    _ = @as(c_long, 7);
    _ = @as(c_long, 66);
    break :blk @as(c_long, 30);
};
pub const SN_rsadsi = "rsadsi";
pub const LN_rsadsi = "RSA Data Security, Inc.";
pub const NID_rsadsi = @as(c_int, 1);
pub const OBJ_rsadsi = blk: {
    _ = &OBJ_ISO_US;
    break :blk @as(c_long, 113549);
};
pub const SN_pkcs = "pkcs";
pub const LN_pkcs = "RSA Data Security, Inc. PKCS";
pub const NID_pkcs = @as(c_int, 2);
pub const OBJ_pkcs = blk: {
    _ = &OBJ_rsadsi;
    break :blk @as(c_long, 1);
};
pub const SN_pkcs1 = "pkcs1";
pub const NID_pkcs1 = @as(c_int, 186);
pub const OBJ_pkcs1 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 1);
};
pub const LN_rsaEncryption = "rsaEncryption";
pub const NID_rsaEncryption = @as(c_int, 6);
pub const OBJ_rsaEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 1);
};
pub const SN_md2WithRSAEncryption = "RSA-MD2";
pub const LN_md2WithRSAEncryption = "md2WithRSAEncryption";
pub const NID_md2WithRSAEncryption = @as(c_int, 7);
pub const OBJ_md2WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 2);
};
pub const SN_md4WithRSAEncryption = "RSA-MD4";
pub const LN_md4WithRSAEncryption = "md4WithRSAEncryption";
pub const NID_md4WithRSAEncryption = @as(c_int, 396);
pub const OBJ_md4WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 3);
};
pub const SN_md5WithRSAEncryption = "RSA-MD5";
pub const LN_md5WithRSAEncryption = "md5WithRSAEncryption";
pub const NID_md5WithRSAEncryption = @as(c_int, 8);
pub const OBJ_md5WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 4);
};
pub const SN_sha1WithRSAEncryption = "RSA-SHA1";
pub const LN_sha1WithRSAEncryption = "sha1WithRSAEncryption";
pub const NID_sha1WithRSAEncryption = @as(c_int, 65);
pub const OBJ_sha1WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 5);
};
pub const SN_rsaesOaep = "RSAES-OAEP";
pub const LN_rsaesOaep = "rsaesOaep";
pub const NID_rsaesOaep = @as(c_int, 919);
pub const OBJ_rsaesOaep = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 7);
};
pub const SN_mgf1 = "MGF1";
pub const LN_mgf1 = "mgf1";
pub const NID_mgf1 = @as(c_int, 911);
pub const OBJ_mgf1 = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 8);
};
pub const SN_pSpecified = "PSPECIFIED";
pub const LN_pSpecified = "pSpecified";
pub const NID_pSpecified = @as(c_int, 935);
pub const OBJ_pSpecified = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 9);
};
pub const SN_rsassaPss = "RSASSA-PSS";
pub const LN_rsassaPss = "rsassaPss";
pub const NID_rsassaPss = @as(c_int, 912);
pub const OBJ_rsassaPss = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 10);
};
pub const SN_sha256WithRSAEncryption = "RSA-SHA256";
pub const LN_sha256WithRSAEncryption = "sha256WithRSAEncryption";
pub const NID_sha256WithRSAEncryption = @as(c_int, 668);
pub const OBJ_sha256WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 11);
};
pub const SN_sha384WithRSAEncryption = "RSA-SHA384";
pub const LN_sha384WithRSAEncryption = "sha384WithRSAEncryption";
pub const NID_sha384WithRSAEncryption = @as(c_int, 669);
pub const OBJ_sha384WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 12);
};
pub const SN_sha512WithRSAEncryption = "RSA-SHA512";
pub const LN_sha512WithRSAEncryption = "sha512WithRSAEncryption";
pub const NID_sha512WithRSAEncryption = @as(c_int, 670);
pub const OBJ_sha512WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 13);
};
pub const SN_sha224WithRSAEncryption = "RSA-SHA224";
pub const LN_sha224WithRSAEncryption = "sha224WithRSAEncryption";
pub const NID_sha224WithRSAEncryption = @as(c_int, 671);
pub const OBJ_sha224WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 14);
};
pub const SN_sha512_224WithRSAEncryption = "RSA-SHA512/224";
pub const LN_sha512_224WithRSAEncryption = "sha512-224WithRSAEncryption";
pub const NID_sha512_224WithRSAEncryption = @as(c_int, 1145);
pub const OBJ_sha512_224WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 15);
};
pub const SN_sha512_256WithRSAEncryption = "RSA-SHA512/256";
pub const LN_sha512_256WithRSAEncryption = "sha512-256WithRSAEncryption";
pub const NID_sha512_256WithRSAEncryption = @as(c_int, 1146);
pub const OBJ_sha512_256WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 16);
};
pub const SN_pkcs3 = "pkcs3";
pub const NID_pkcs3 = @as(c_int, 27);
pub const OBJ_pkcs3 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 3);
};
pub const LN_dhKeyAgreement = "dhKeyAgreement";
pub const NID_dhKeyAgreement = @as(c_int, 28);
pub const OBJ_dhKeyAgreement = blk: {
    _ = &OBJ_pkcs3;
    break :blk @as(c_long, 1);
};
pub const SN_pkcs5 = "pkcs5";
pub const NID_pkcs5 = @as(c_int, 187);
pub const OBJ_pkcs5 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 5);
};
pub const SN_pbeWithMD2AndDES_CBC = "PBE-MD2-DES";
pub const LN_pbeWithMD2AndDES_CBC = "pbeWithMD2AndDES-CBC";
pub const NID_pbeWithMD2AndDES_CBC = @as(c_int, 9);
pub const OBJ_pbeWithMD2AndDES_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 1);
};
pub const SN_pbeWithMD5AndDES_CBC = "PBE-MD5-DES";
pub const LN_pbeWithMD5AndDES_CBC = "pbeWithMD5AndDES-CBC";
pub const NID_pbeWithMD5AndDES_CBC = @as(c_int, 10);
pub const OBJ_pbeWithMD5AndDES_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 3);
};
pub const SN_pbeWithMD2AndRC2_CBC = "PBE-MD2-RC2-64";
pub const LN_pbeWithMD2AndRC2_CBC = "pbeWithMD2AndRC2-CBC";
pub const NID_pbeWithMD2AndRC2_CBC = @as(c_int, 168);
pub const OBJ_pbeWithMD2AndRC2_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 4);
};
pub const SN_pbeWithMD5AndRC2_CBC = "PBE-MD5-RC2-64";
pub const LN_pbeWithMD5AndRC2_CBC = "pbeWithMD5AndRC2-CBC";
pub const NID_pbeWithMD5AndRC2_CBC = @as(c_int, 169);
pub const OBJ_pbeWithMD5AndRC2_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 6);
};
pub const SN_pbeWithSHA1AndDES_CBC = "PBE-SHA1-DES";
pub const LN_pbeWithSHA1AndDES_CBC = "pbeWithSHA1AndDES-CBC";
pub const NID_pbeWithSHA1AndDES_CBC = @as(c_int, 170);
pub const OBJ_pbeWithSHA1AndDES_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 10);
};
pub const SN_pbeWithSHA1AndRC2_CBC = "PBE-SHA1-RC2-64";
pub const LN_pbeWithSHA1AndRC2_CBC = "pbeWithSHA1AndRC2-CBC";
pub const NID_pbeWithSHA1AndRC2_CBC = @as(c_int, 68);
pub const OBJ_pbeWithSHA1AndRC2_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 11);
};
pub const LN_id_pbkdf2 = "PBKDF2";
pub const NID_id_pbkdf2 = @as(c_int, 69);
pub const OBJ_id_pbkdf2 = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 12);
};
pub const LN_pbes2 = "PBES2";
pub const NID_pbes2 = @as(c_int, 161);
pub const OBJ_pbes2 = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 13);
};
pub const LN_pbmac1 = "PBMAC1";
pub const NID_pbmac1 = @as(c_int, 162);
pub const OBJ_pbmac1 = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 14);
};
pub const SN_pkcs7 = "pkcs7";
pub const NID_pkcs7 = @as(c_int, 20);
pub const OBJ_pkcs7 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 7);
};
pub const LN_pkcs7_data = "pkcs7-data";
pub const NID_pkcs7_data = @as(c_int, 21);
pub const OBJ_pkcs7_data = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 1);
};
pub const LN_pkcs7_signed = "pkcs7-signedData";
pub const NID_pkcs7_signed = @as(c_int, 22);
pub const OBJ_pkcs7_signed = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 2);
};
pub const LN_pkcs7_enveloped = "pkcs7-envelopedData";
pub const NID_pkcs7_enveloped = @as(c_int, 23);
pub const OBJ_pkcs7_enveloped = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 3);
};
pub const LN_pkcs7_signedAndEnveloped = "pkcs7-signedAndEnvelopedData";
pub const NID_pkcs7_signedAndEnveloped = @as(c_int, 24);
pub const OBJ_pkcs7_signedAndEnveloped = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 4);
};
pub const LN_pkcs7_digest = "pkcs7-digestData";
pub const NID_pkcs7_digest = @as(c_int, 25);
pub const OBJ_pkcs7_digest = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 5);
};
pub const LN_pkcs7_encrypted = "pkcs7-encryptedData";
pub const NID_pkcs7_encrypted = @as(c_int, 26);
pub const OBJ_pkcs7_encrypted = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 6);
};
pub const SN_pkcs9 = "pkcs9";
pub const NID_pkcs9 = @as(c_int, 47);
pub const OBJ_pkcs9 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 9);
};
pub const LN_pkcs9_emailAddress = "emailAddress";
pub const NID_pkcs9_emailAddress = @as(c_int, 48);
pub const OBJ_pkcs9_emailAddress = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 1);
};
pub const LN_pkcs9_unstructuredName = "unstructuredName";
pub const NID_pkcs9_unstructuredName = @as(c_int, 49);
pub const OBJ_pkcs9_unstructuredName = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 2);
};
pub const LN_pkcs9_contentType = "contentType";
pub const NID_pkcs9_contentType = @as(c_int, 50);
pub const OBJ_pkcs9_contentType = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 3);
};
pub const LN_pkcs9_messageDigest = "messageDigest";
pub const NID_pkcs9_messageDigest = @as(c_int, 51);
pub const OBJ_pkcs9_messageDigest = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 4);
};
pub const LN_pkcs9_signingTime = "signingTime";
pub const NID_pkcs9_signingTime = @as(c_int, 52);
pub const OBJ_pkcs9_signingTime = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 5);
};
pub const LN_pkcs9_countersignature = "countersignature";
pub const NID_pkcs9_countersignature = @as(c_int, 53);
pub const OBJ_pkcs9_countersignature = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 6);
};
pub const LN_pkcs9_challengePassword = "challengePassword";
pub const NID_pkcs9_challengePassword = @as(c_int, 54);
pub const OBJ_pkcs9_challengePassword = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 7);
};
pub const LN_pkcs9_unstructuredAddress = "unstructuredAddress";
pub const NID_pkcs9_unstructuredAddress = @as(c_int, 55);
pub const OBJ_pkcs9_unstructuredAddress = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 8);
};
pub const LN_pkcs9_extCertAttributes = "extendedCertificateAttributes";
pub const NID_pkcs9_extCertAttributes = @as(c_int, 56);
pub const OBJ_pkcs9_extCertAttributes = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 9);
};
pub const SN_ext_req = "extReq";
pub const LN_ext_req = "Extension Request";
pub const NID_ext_req = @as(c_int, 172);
pub const OBJ_ext_req = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 14);
};
pub const SN_SMIMECapabilities = "SMIME-CAPS";
pub const LN_SMIMECapabilities = "S/MIME Capabilities";
pub const NID_SMIMECapabilities = @as(c_int, 167);
pub const OBJ_SMIMECapabilities = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 15);
};
pub const SN_SMIME = "SMIME";
pub const LN_SMIME = "S/MIME";
pub const NID_SMIME = @as(c_int, 188);
pub const OBJ_SMIME = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 16);
};
pub const SN_id_smime_mod = "id-smime-mod";
pub const NID_id_smime_mod = @as(c_int, 189);
pub const OBJ_id_smime_mod = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 0);
};
pub const SN_id_smime_ct = "id-smime-ct";
pub const NID_id_smime_ct = @as(c_int, 190);
pub const OBJ_id_smime_ct = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_aa = "id-smime-aa";
pub const NID_id_smime_aa = @as(c_int, 191);
pub const OBJ_id_smime_aa = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_alg = "id-smime-alg";
pub const NID_id_smime_alg = @as(c_int, 192);
pub const OBJ_id_smime_alg = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_cd = "id-smime-cd";
pub const NID_id_smime_cd = @as(c_int, 193);
pub const OBJ_id_smime_cd = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_spq = "id-smime-spq";
pub const NID_id_smime_spq = @as(c_int, 194);
pub const OBJ_id_smime_spq = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_cti = "id-smime-cti";
pub const NID_id_smime_cti = @as(c_int, 195);
pub const OBJ_id_smime_cti = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_mod_cms = "id-smime-mod-cms";
pub const NID_id_smime_mod_cms = @as(c_int, 196);
pub const OBJ_id_smime_mod_cms = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_mod_ess = "id-smime-mod-ess";
pub const NID_id_smime_mod_ess = @as(c_int, 197);
pub const OBJ_id_smime_mod_ess = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_mod_oid = "id-smime-mod-oid";
pub const NID_id_smime_mod_oid = @as(c_int, 198);
pub const OBJ_id_smime_mod_oid = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_mod_msg_v3 = "id-smime-mod-msg-v3";
pub const NID_id_smime_mod_msg_v3 = @as(c_int, 199);
pub const OBJ_id_smime_mod_msg_v3 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_mod_ets_eSignature_88 = "id-smime-mod-ets-eSignature-88";
pub const NID_id_smime_mod_ets_eSignature_88 = @as(c_int, 200);
pub const OBJ_id_smime_mod_ets_eSignature_88 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_mod_ets_eSignature_97 = "id-smime-mod-ets-eSignature-97";
pub const NID_id_smime_mod_ets_eSignature_97 = @as(c_int, 201);
pub const OBJ_id_smime_mod_ets_eSignature_97 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_mod_ets_eSigPolicy_88 = "id-smime-mod-ets-eSigPolicy-88";
pub const NID_id_smime_mod_ets_eSigPolicy_88 = @as(c_int, 202);
pub const OBJ_id_smime_mod_ets_eSigPolicy_88 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 7);
};
pub const SN_id_smime_mod_ets_eSigPolicy_97 = "id-smime-mod-ets-eSigPolicy-97";
pub const NID_id_smime_mod_ets_eSigPolicy_97 = @as(c_int, 203);
pub const OBJ_id_smime_mod_ets_eSigPolicy_97 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 8);
};
pub const SN_id_smime_ct_receipt = "id-smime-ct-receipt";
pub const NID_id_smime_ct_receipt = @as(c_int, 204);
pub const OBJ_id_smime_ct_receipt = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_ct_authData = "id-smime-ct-authData";
pub const NID_id_smime_ct_authData = @as(c_int, 205);
pub const OBJ_id_smime_ct_authData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_ct_publishCert = "id-smime-ct-publishCert";
pub const NID_id_smime_ct_publishCert = @as(c_int, 206);
pub const OBJ_id_smime_ct_publishCert = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_ct_TSTInfo = "id-smime-ct-TSTInfo";
pub const NID_id_smime_ct_TSTInfo = @as(c_int, 207);
pub const OBJ_id_smime_ct_TSTInfo = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_ct_TDTInfo = "id-smime-ct-TDTInfo";
pub const NID_id_smime_ct_TDTInfo = @as(c_int, 208);
pub const OBJ_id_smime_ct_TDTInfo = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_ct_contentInfo = "id-smime-ct-contentInfo";
pub const NID_id_smime_ct_contentInfo = @as(c_int, 209);
pub const OBJ_id_smime_ct_contentInfo = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_ct_DVCSRequestData = "id-smime-ct-DVCSRequestData";
pub const NID_id_smime_ct_DVCSRequestData = @as(c_int, 210);
pub const OBJ_id_smime_ct_DVCSRequestData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 7);
};
pub const SN_id_smime_ct_DVCSResponseData = "id-smime-ct-DVCSResponseData";
pub const NID_id_smime_ct_DVCSResponseData = @as(c_int, 211);
pub const OBJ_id_smime_ct_DVCSResponseData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 8);
};
pub const SN_id_smime_ct_compressedData = "id-smime-ct-compressedData";
pub const NID_id_smime_ct_compressedData = @as(c_int, 786);
pub const OBJ_id_smime_ct_compressedData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 9);
};
pub const SN_id_smime_ct_contentCollection = "id-smime-ct-contentCollection";
pub const NID_id_smime_ct_contentCollection = @as(c_int, 1058);
pub const OBJ_id_smime_ct_contentCollection = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 19);
};
pub const SN_id_smime_ct_authEnvelopedData = "id-smime-ct-authEnvelopedData";
pub const NID_id_smime_ct_authEnvelopedData = @as(c_int, 1059);
pub const OBJ_id_smime_ct_authEnvelopedData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 23);
};
pub const SN_id_ct_routeOriginAuthz = "id-ct-routeOriginAuthz";
pub const NID_id_ct_routeOriginAuthz = @as(c_int, 1234);
pub const OBJ_id_ct_routeOriginAuthz = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 24);
};
pub const SN_id_ct_rpkiManifest = "id-ct-rpkiManifest";
pub const NID_id_ct_rpkiManifest = @as(c_int, 1235);
pub const OBJ_id_ct_rpkiManifest = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 26);
};
pub const SN_id_ct_asciiTextWithCRLF = "id-ct-asciiTextWithCRLF";
pub const NID_id_ct_asciiTextWithCRLF = @as(c_int, 787);
pub const OBJ_id_ct_asciiTextWithCRLF = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 27);
};
pub const SN_id_ct_xml = "id-ct-xml";
pub const NID_id_ct_xml = @as(c_int, 1060);
pub const OBJ_id_ct_xml = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 28);
};
pub const SN_id_ct_rpkiGhostbusters = "id-ct-rpkiGhostbusters";
pub const NID_id_ct_rpkiGhostbusters = @as(c_int, 1236);
pub const OBJ_id_ct_rpkiGhostbusters = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 35);
};
pub const SN_id_ct_resourceTaggedAttest = "id-ct-resourceTaggedAttest";
pub const NID_id_ct_resourceTaggedAttest = @as(c_int, 1237);
pub const OBJ_id_ct_resourceTaggedAttest = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 36);
};
pub const SN_id_ct_geofeedCSVwithCRLF = "id-ct-geofeedCSVwithCRLF";
pub const NID_id_ct_geofeedCSVwithCRLF = @as(c_int, 1246);
pub const OBJ_id_ct_geofeedCSVwithCRLF = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 47);
};
pub const SN_id_ct_signedChecklist = "id-ct-signedChecklist";
pub const NID_id_ct_signedChecklist = @as(c_int, 1247);
pub const OBJ_id_ct_signedChecklist = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 48);
};
pub const SN_id_ct_ASPA = "id-ct-ASPA";
pub const NID_id_ct_ASPA = @as(c_int, 1250);
pub const OBJ_id_ct_ASPA = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 49);
};
pub const SN_id_ct_signedTAL = "id-ct-signedTAL";
pub const NID_id_ct_signedTAL = @as(c_int, 1284);
pub const OBJ_id_ct_signedTAL = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 50);
};
pub const SN_id_ct_rpkiSignedPrefixList = "id-ct-rpkiSignedPrefixList";
pub const NID_id_ct_rpkiSignedPrefixList = @as(c_int, 1320);
pub const OBJ_id_ct_rpkiSignedPrefixList = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 51);
};
pub const SN_id_smime_aa_receiptRequest = "id-smime-aa-receiptRequest";
pub const NID_id_smime_aa_receiptRequest = @as(c_int, 212);
pub const OBJ_id_smime_aa_receiptRequest = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_aa_securityLabel = "id-smime-aa-securityLabel";
pub const NID_id_smime_aa_securityLabel = @as(c_int, 213);
pub const OBJ_id_smime_aa_securityLabel = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_aa_mlExpandHistory = "id-smime-aa-mlExpandHistory";
pub const NID_id_smime_aa_mlExpandHistory = @as(c_int, 214);
pub const OBJ_id_smime_aa_mlExpandHistory = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_aa_contentHint = "id-smime-aa-contentHint";
pub const NID_id_smime_aa_contentHint = @as(c_int, 215);
pub const OBJ_id_smime_aa_contentHint = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_aa_msgSigDigest = "id-smime-aa-msgSigDigest";
pub const NID_id_smime_aa_msgSigDigest = @as(c_int, 216);
pub const OBJ_id_smime_aa_msgSigDigest = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_aa_encapContentType = "id-smime-aa-encapContentType";
pub const NID_id_smime_aa_encapContentType = @as(c_int, 217);
pub const OBJ_id_smime_aa_encapContentType = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_aa_contentIdentifier = "id-smime-aa-contentIdentifier";
pub const NID_id_smime_aa_contentIdentifier = @as(c_int, 218);
pub const OBJ_id_smime_aa_contentIdentifier = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 7);
};
pub const SN_id_smime_aa_macValue = "id-smime-aa-macValue";
pub const NID_id_smime_aa_macValue = @as(c_int, 219);
pub const OBJ_id_smime_aa_macValue = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 8);
};
pub const SN_id_smime_aa_equivalentLabels = "id-smime-aa-equivalentLabels";
pub const NID_id_smime_aa_equivalentLabels = @as(c_int, 220);
pub const OBJ_id_smime_aa_equivalentLabels = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 9);
};
pub const SN_id_smime_aa_contentReference = "id-smime-aa-contentReference";
pub const NID_id_smime_aa_contentReference = @as(c_int, 221);
pub const OBJ_id_smime_aa_contentReference = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 10);
};
pub const SN_id_smime_aa_encrypKeyPref = "id-smime-aa-encrypKeyPref";
pub const NID_id_smime_aa_encrypKeyPref = @as(c_int, 222);
pub const OBJ_id_smime_aa_encrypKeyPref = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 11);
};
pub const SN_id_smime_aa_signingCertificate = "id-smime-aa-signingCertificate";
pub const NID_id_smime_aa_signingCertificate = @as(c_int, 223);
pub const OBJ_id_smime_aa_signingCertificate = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 12);
};
pub const SN_id_smime_aa_smimeEncryptCerts = "id-smime-aa-smimeEncryptCerts";
pub const NID_id_smime_aa_smimeEncryptCerts = @as(c_int, 224);
pub const OBJ_id_smime_aa_smimeEncryptCerts = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 13);
};
pub const SN_id_smime_aa_timeStampToken = "id-smime-aa-timeStampToken";
pub const NID_id_smime_aa_timeStampToken = @as(c_int, 225);
pub const OBJ_id_smime_aa_timeStampToken = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 14);
};
pub const SN_id_smime_aa_ets_sigPolicyId = "id-smime-aa-ets-sigPolicyId";
pub const NID_id_smime_aa_ets_sigPolicyId = @as(c_int, 226);
pub const OBJ_id_smime_aa_ets_sigPolicyId = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 15);
};
pub const SN_id_smime_aa_ets_commitmentType = "id-smime-aa-ets-commitmentType";
pub const NID_id_smime_aa_ets_commitmentType = @as(c_int, 227);
pub const OBJ_id_smime_aa_ets_commitmentType = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 16);
};
pub const SN_id_smime_aa_ets_signerLocation = "id-smime-aa-ets-signerLocation";
pub const NID_id_smime_aa_ets_signerLocation = @as(c_int, 228);
pub const OBJ_id_smime_aa_ets_signerLocation = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 17);
};
pub const SN_id_smime_aa_ets_signerAttr = "id-smime-aa-ets-signerAttr";
pub const NID_id_smime_aa_ets_signerAttr = @as(c_int, 229);
pub const OBJ_id_smime_aa_ets_signerAttr = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 18);
};
pub const SN_id_smime_aa_ets_otherSigCert = "id-smime-aa-ets-otherSigCert";
pub const NID_id_smime_aa_ets_otherSigCert = @as(c_int, 230);
pub const OBJ_id_smime_aa_ets_otherSigCert = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 19);
};
pub const SN_id_smime_aa_ets_contentTimestamp = "id-smime-aa-ets-contentTimestamp";
pub const NID_id_smime_aa_ets_contentTimestamp = @as(c_int, 231);
pub const OBJ_id_smime_aa_ets_contentTimestamp = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 20);
};
pub const SN_id_smime_aa_ets_CertificateRefs = "id-smime-aa-ets-CertificateRefs";
pub const NID_id_smime_aa_ets_CertificateRefs = @as(c_int, 232);
pub const OBJ_id_smime_aa_ets_CertificateRefs = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 21);
};
pub const SN_id_smime_aa_ets_RevocationRefs = "id-smime-aa-ets-RevocationRefs";
pub const NID_id_smime_aa_ets_RevocationRefs = @as(c_int, 233);
pub const OBJ_id_smime_aa_ets_RevocationRefs = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 22);
};
pub const SN_id_smime_aa_ets_certValues = "id-smime-aa-ets-certValues";
pub const NID_id_smime_aa_ets_certValues = @as(c_int, 234);
pub const OBJ_id_smime_aa_ets_certValues = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 23);
};
pub const SN_id_smime_aa_ets_revocationValues = "id-smime-aa-ets-revocationValues";
pub const NID_id_smime_aa_ets_revocationValues = @as(c_int, 235);
pub const OBJ_id_smime_aa_ets_revocationValues = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 24);
};
pub const SN_id_smime_aa_ets_escTimeStamp = "id-smime-aa-ets-escTimeStamp";
pub const NID_id_smime_aa_ets_escTimeStamp = @as(c_int, 236);
pub const OBJ_id_smime_aa_ets_escTimeStamp = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 25);
};
pub const SN_id_smime_aa_ets_certCRLTimestamp = "id-smime-aa-ets-certCRLTimestamp";
pub const NID_id_smime_aa_ets_certCRLTimestamp = @as(c_int, 237);
pub const OBJ_id_smime_aa_ets_certCRLTimestamp = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 26);
};
pub const SN_id_smime_aa_ets_archiveTimeStamp = "id-smime-aa-ets-archiveTimeStamp";
pub const NID_id_smime_aa_ets_archiveTimeStamp = @as(c_int, 238);
pub const OBJ_id_smime_aa_ets_archiveTimeStamp = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 27);
};
pub const SN_id_smime_aa_signatureType = "id-smime-aa-signatureType";
pub const NID_id_smime_aa_signatureType = @as(c_int, 239);
pub const OBJ_id_smime_aa_signatureType = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 28);
};
pub const SN_id_smime_aa_dvcs_dvc = "id-smime-aa-dvcs-dvc";
pub const NID_id_smime_aa_dvcs_dvc = @as(c_int, 240);
pub const OBJ_id_smime_aa_dvcs_dvc = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 29);
};
pub const SN_id_aa_ets_attrCertificateRefs = "id-aa-ets-attrCertificateRefs";
pub const NID_id_aa_ets_attrCertificateRefs = @as(c_int, 1261);
pub const OBJ_id_aa_ets_attrCertificateRefs = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 44);
};
pub const SN_id_aa_ets_attrRevocationRefs = "id-aa-ets-attrRevocationRefs";
pub const NID_id_aa_ets_attrRevocationRefs = @as(c_int, 1262);
pub const OBJ_id_aa_ets_attrRevocationRefs = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 45);
};
pub const SN_id_smime_aa_signingCertificateV2 = "id-smime-aa-signingCertificateV2";
pub const NID_id_smime_aa_signingCertificateV2 = @as(c_int, 1086);
pub const OBJ_id_smime_aa_signingCertificateV2 = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 47);
};
pub const SN_id_aa_ets_archiveTimestampV2 = "id-aa-ets-archiveTimestampV2";
pub const NID_id_aa_ets_archiveTimestampV2 = @as(c_int, 1280);
pub const OBJ_id_aa_ets_archiveTimestampV2 = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 48);
};
pub const SN_id_smime_alg_ESDHwith3DES = "id-smime-alg-ESDHwith3DES";
pub const NID_id_smime_alg_ESDHwith3DES = @as(c_int, 241);
pub const OBJ_id_smime_alg_ESDHwith3DES = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_alg_ESDHwithRC2 = "id-smime-alg-ESDHwithRC2";
pub const NID_id_smime_alg_ESDHwithRC2 = @as(c_int, 242);
pub const OBJ_id_smime_alg_ESDHwithRC2 = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_alg_3DESwrap = "id-smime-alg-3DESwrap";
pub const NID_id_smime_alg_3DESwrap = @as(c_int, 243);
pub const OBJ_id_smime_alg_3DESwrap = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_alg_RC2wrap = "id-smime-alg-RC2wrap";
pub const NID_id_smime_alg_RC2wrap = @as(c_int, 244);
pub const OBJ_id_smime_alg_RC2wrap = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_alg_ESDH = "id-smime-alg-ESDH";
pub const NID_id_smime_alg_ESDH = @as(c_int, 245);
pub const OBJ_id_smime_alg_ESDH = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_alg_CMS3DESwrap = "id-smime-alg-CMS3DESwrap";
pub const NID_id_smime_alg_CMS3DESwrap = @as(c_int, 246);
pub const OBJ_id_smime_alg_CMS3DESwrap = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_alg_CMSRC2wrap = "id-smime-alg-CMSRC2wrap";
pub const NID_id_smime_alg_CMSRC2wrap = @as(c_int, 247);
pub const OBJ_id_smime_alg_CMSRC2wrap = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 7);
};
pub const SN_id_alg_PWRI_KEK = "id-alg-PWRI-KEK";
pub const NID_id_alg_PWRI_KEK = @as(c_int, 893);
pub const OBJ_id_alg_PWRI_KEK = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 9);
};
pub const SN_id_smime_cd_ldap = "id-smime-cd-ldap";
pub const NID_id_smime_cd_ldap = @as(c_int, 248);
pub const OBJ_id_smime_cd_ldap = blk: {
    _ = &OBJ_id_smime_cd;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_spq_ets_sqt_uri = "id-smime-spq-ets-sqt-uri";
pub const NID_id_smime_spq_ets_sqt_uri = @as(c_int, 249);
pub const OBJ_id_smime_spq_ets_sqt_uri = blk: {
    _ = &OBJ_id_smime_spq;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_spq_ets_sqt_unotice = "id-smime-spq-ets-sqt-unotice";
pub const NID_id_smime_spq_ets_sqt_unotice = @as(c_int, 250);
pub const OBJ_id_smime_spq_ets_sqt_unotice = blk: {
    _ = &OBJ_id_smime_spq;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_cti_ets_proofOfOrigin = "id-smime-cti-ets-proofOfOrigin";
pub const NID_id_smime_cti_ets_proofOfOrigin = @as(c_int, 251);
pub const OBJ_id_smime_cti_ets_proofOfOrigin = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_cti_ets_proofOfReceipt = "id-smime-cti-ets-proofOfReceipt";
pub const NID_id_smime_cti_ets_proofOfReceipt = @as(c_int, 252);
pub const OBJ_id_smime_cti_ets_proofOfReceipt = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_cti_ets_proofOfDelivery = "id-smime-cti-ets-proofOfDelivery";
pub const NID_id_smime_cti_ets_proofOfDelivery = @as(c_int, 253);
pub const OBJ_id_smime_cti_ets_proofOfDelivery = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_cti_ets_proofOfSender = "id-smime-cti-ets-proofOfSender";
pub const NID_id_smime_cti_ets_proofOfSender = @as(c_int, 254);
pub const OBJ_id_smime_cti_ets_proofOfSender = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_cti_ets_proofOfApproval = "id-smime-cti-ets-proofOfApproval";
pub const NID_id_smime_cti_ets_proofOfApproval = @as(c_int, 255);
pub const OBJ_id_smime_cti_ets_proofOfApproval = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_cti_ets_proofOfCreation = "id-smime-cti-ets-proofOfCreation";
pub const NID_id_smime_cti_ets_proofOfCreation = @as(c_int, 256);
pub const OBJ_id_smime_cti_ets_proofOfCreation = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 6);
};
pub const LN_friendlyName = "friendlyName";
pub const NID_friendlyName = @as(c_int, 156);
pub const OBJ_friendlyName = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 20);
};
pub const LN_localKeyID = "localKeyID";
pub const NID_localKeyID = @as(c_int, 157);
pub const OBJ_localKeyID = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 21);
};
pub const OBJ_ms_corp = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 311);
};
pub const SN_ms_csp_name = "CSPName";
pub const LN_ms_csp_name = "Microsoft CSP Name";
pub const NID_ms_csp_name = @as(c_int, 417);
pub const OBJ_ms_csp_name = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 17);
    break :blk @as(c_long, 1);
};
pub const SN_LocalKeySet = "LocalKeySet";
pub const LN_LocalKeySet = "Microsoft Local Key set";
pub const NID_LocalKeySet = @as(c_int, 856);
pub const OBJ_LocalKeySet = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 17);
    break :blk @as(c_long, 2);
};
pub const OBJ_certTypes = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 22);
};
pub const LN_x509Certificate = "x509Certificate";
pub const NID_x509Certificate = @as(c_int, 158);
pub const OBJ_x509Certificate = blk: {
    _ = &OBJ_certTypes;
    break :blk @as(c_long, 1);
};
pub const LN_sdsiCertificate = "sdsiCertificate";
pub const NID_sdsiCertificate = @as(c_int, 159);
pub const OBJ_sdsiCertificate = blk: {
    _ = &OBJ_certTypes;
    break :blk @as(c_long, 2);
};
pub const OBJ_crlTypes = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 23);
};
pub const LN_x509Crl = "x509Crl";
pub const NID_x509Crl = @as(c_int, 160);
pub const OBJ_x509Crl = blk: {
    _ = &OBJ_crlTypes;
    break :blk @as(c_long, 1);
};
pub const SN_id_aa_CMSAlgorithmProtection = "id-aa-CMSAlgorithmProtection";
pub const NID_id_aa_CMSAlgorithmProtection = @as(c_int, 1263);
pub const OBJ_id_aa_CMSAlgorithmProtection = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 52);
};
pub const OBJ_pkcs12 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 12);
};
pub const OBJ_pkcs12_pbeids = blk: {
    _ = &OBJ_pkcs12;
    break :blk @as(c_long, 1);
};
pub const SN_pbe_WithSHA1And128BitRC4 = "PBE-SHA1-RC4-128";
pub const LN_pbe_WithSHA1And128BitRC4 = "pbeWithSHA1And128BitRC4";
pub const NID_pbe_WithSHA1And128BitRC4 = @as(c_int, 144);
pub const OBJ_pbe_WithSHA1And128BitRC4 = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 1);
};
pub const SN_pbe_WithSHA1And40BitRC4 = "PBE-SHA1-RC4-40";
pub const LN_pbe_WithSHA1And40BitRC4 = "pbeWithSHA1And40BitRC4";
pub const NID_pbe_WithSHA1And40BitRC4 = @as(c_int, 145);
pub const OBJ_pbe_WithSHA1And40BitRC4 = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 2);
};
pub const SN_pbe_WithSHA1And3_Key_TripleDES_CBC = "PBE-SHA1-3DES";
pub const LN_pbe_WithSHA1And3_Key_TripleDES_CBC = "pbeWithSHA1And3-KeyTripleDES-CBC";
pub const NID_pbe_WithSHA1And3_Key_TripleDES_CBC = @as(c_int, 146);
pub const OBJ_pbe_WithSHA1And3_Key_TripleDES_CBC = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 3);
};
pub const SN_pbe_WithSHA1And2_Key_TripleDES_CBC = "PBE-SHA1-2DES";
pub const LN_pbe_WithSHA1And2_Key_TripleDES_CBC = "pbeWithSHA1And2-KeyTripleDES-CBC";
pub const NID_pbe_WithSHA1And2_Key_TripleDES_CBC = @as(c_int, 147);
pub const OBJ_pbe_WithSHA1And2_Key_TripleDES_CBC = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 4);
};
pub const SN_pbe_WithSHA1And128BitRC2_CBC = "PBE-SHA1-RC2-128";
pub const LN_pbe_WithSHA1And128BitRC2_CBC = "pbeWithSHA1And128BitRC2-CBC";
pub const NID_pbe_WithSHA1And128BitRC2_CBC = @as(c_int, 148);
pub const OBJ_pbe_WithSHA1And128BitRC2_CBC = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 5);
};
pub const SN_pbe_WithSHA1And40BitRC2_CBC = "PBE-SHA1-RC2-40";
pub const LN_pbe_WithSHA1And40BitRC2_CBC = "pbeWithSHA1And40BitRC2-CBC";
pub const NID_pbe_WithSHA1And40BitRC2_CBC = @as(c_int, 149);
pub const OBJ_pbe_WithSHA1And40BitRC2_CBC = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 6);
};
pub const OBJ_pkcs12_Version1 = blk: {
    _ = &OBJ_pkcs12;
    break :blk @as(c_long, 10);
};
pub const OBJ_pkcs12_BagIds = blk: {
    _ = &OBJ_pkcs12_Version1;
    break :blk @as(c_long, 1);
};
pub const LN_keyBag = "keyBag";
pub const NID_keyBag = @as(c_int, 150);
pub const OBJ_keyBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 1);
};
pub const LN_pkcs8ShroudedKeyBag = "pkcs8ShroudedKeyBag";
pub const NID_pkcs8ShroudedKeyBag = @as(c_int, 151);
pub const OBJ_pkcs8ShroudedKeyBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 2);
};
pub const LN_certBag = "certBag";
pub const NID_certBag = @as(c_int, 152);
pub const OBJ_certBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 3);
};
pub const LN_crlBag = "crlBag";
pub const NID_crlBag = @as(c_int, 153);
pub const OBJ_crlBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 4);
};
pub const LN_secretBag = "secretBag";
pub const NID_secretBag = @as(c_int, 154);
pub const OBJ_secretBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 5);
};
pub const LN_safeContentsBag = "safeContentsBag";
pub const NID_safeContentsBag = @as(c_int, 155);
pub const OBJ_safeContentsBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 6);
};
pub const SN_md2 = "MD2";
pub const LN_md2 = "md2";
pub const NID_md2 = @as(c_int, 3);
pub const OBJ_md2 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_md4 = "MD4";
pub const LN_md4 = "md4";
pub const NID_md4 = @as(c_int, 257);
pub const OBJ_md4 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 4);
};
pub const SN_md5 = "MD5";
pub const LN_md5 = "md5";
pub const NID_md5 = @as(c_int, 4);
pub const OBJ_md5 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 5);
};
pub const SN_md5_sha1 = "MD5-SHA1";
pub const LN_md5_sha1 = "md5-sha1";
pub const NID_md5_sha1 = @as(c_int, 114);
pub const LN_hmacWithMD5 = "hmacWithMD5";
pub const NID_hmacWithMD5 = @as(c_int, 797);
pub const OBJ_hmacWithMD5 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 6);
};
pub const LN_hmacWithSHA1 = "hmacWithSHA1";
pub const NID_hmacWithSHA1 = @as(c_int, 163);
pub const OBJ_hmacWithSHA1 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 7);
};
pub const SN_sm2 = "SM2";
pub const LN_sm2 = "sm2";
pub const NID_sm2 = @as(c_int, 1172);
pub const OBJ_sm2 = blk: {
    _ = &OBJ_sm_scheme;
    break :blk @as(c_long, 301);
};
pub const SN_sm3 = "SM3";
pub const LN_sm3 = "sm3";
pub const NID_sm3 = @as(c_int, 1143);
pub const OBJ_sm3 = blk: {
    _ = &OBJ_sm_scheme;
    break :blk @as(c_long, 401);
};
pub const SN_sm3WithRSAEncryption = "RSA-SM3";
pub const LN_sm3WithRSAEncryption = "sm3WithRSAEncryption";
pub const NID_sm3WithRSAEncryption = @as(c_int, 1144);
pub const OBJ_sm3WithRSAEncryption = blk: {
    _ = &OBJ_sm_scheme;
    break :blk @as(c_long, 504);
};
pub const SN_SM2_with_SM3 = "SM2-SM3";
pub const LN_SM2_with_SM3 = "SM2-with-SM3";
pub const NID_SM2_with_SM3 = @as(c_int, 1204);
pub const OBJ_SM2_with_SM3 = blk: {
    _ = &OBJ_sm_scheme;
    break :blk @as(c_long, 501);
};
pub const LN_hmacWithSM3 = "hmacWithSM3";
pub const NID_hmacWithSM3 = @as(c_int, 1281);
pub const OBJ_hmacWithSM3 = blk: {
    _ = &OBJ_sm3;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 1);
};
pub const LN_hmacWithSHA224 = "hmacWithSHA224";
pub const NID_hmacWithSHA224 = @as(c_int, 798);
pub const OBJ_hmacWithSHA224 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 8);
};
pub const LN_hmacWithSHA256 = "hmacWithSHA256";
pub const NID_hmacWithSHA256 = @as(c_int, 799);
pub const OBJ_hmacWithSHA256 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 9);
};
pub const LN_hmacWithSHA384 = "hmacWithSHA384";
pub const NID_hmacWithSHA384 = @as(c_int, 800);
pub const OBJ_hmacWithSHA384 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 10);
};
pub const LN_hmacWithSHA512 = "hmacWithSHA512";
pub const NID_hmacWithSHA512 = @as(c_int, 801);
pub const OBJ_hmacWithSHA512 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 11);
};
pub const LN_hmacWithSHA512_224 = "hmacWithSHA512-224";
pub const NID_hmacWithSHA512_224 = @as(c_int, 1193);
pub const OBJ_hmacWithSHA512_224 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 12);
};
pub const LN_hmacWithSHA512_256 = "hmacWithSHA512-256";
pub const NID_hmacWithSHA512_256 = @as(c_int, 1194);
pub const OBJ_hmacWithSHA512_256 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 13);
};
pub const SN_rc2_cbc = "RC2-CBC";
pub const LN_rc2_cbc = "rc2-cbc";
pub const NID_rc2_cbc = @as(c_int, 37);
pub const OBJ_rc2_cbc = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 2);
};
pub const SN_rc2_ecb = "RC2-ECB";
pub const LN_rc2_ecb = "rc2-ecb";
pub const NID_rc2_ecb = @as(c_int, 38);
pub const SN_rc2_cfb64 = "RC2-CFB";
pub const LN_rc2_cfb64 = "rc2-cfb";
pub const NID_rc2_cfb64 = @as(c_int, 39);
pub const SN_rc2_ofb64 = "RC2-OFB";
pub const LN_rc2_ofb64 = "rc2-ofb";
pub const NID_rc2_ofb64 = @as(c_int, 40);
pub const SN_rc2_40_cbc = "RC2-40-CBC";
pub const LN_rc2_40_cbc = "rc2-40-cbc";
pub const NID_rc2_40_cbc = @as(c_int, 98);
pub const SN_rc2_64_cbc = "RC2-64-CBC";
pub const LN_rc2_64_cbc = "rc2-64-cbc";
pub const NID_rc2_64_cbc = @as(c_int, 166);
pub const SN_rc4 = "RC4";
pub const LN_rc4 = "rc4";
pub const NID_rc4 = @as(c_int, 5);
pub const OBJ_rc4 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const SN_rc4_40 = "RC4-40";
pub const LN_rc4_40 = "rc4-40";
pub const NID_rc4_40 = @as(c_int, 97);
pub const SN_des_ede3_cbc = "DES-EDE3-CBC";
pub const LN_des_ede3_cbc = "des-ede3-cbc";
pub const NID_des_ede3_cbc = @as(c_int, 44);
pub const OBJ_des_ede3_cbc = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 7);
};
pub const SN_rc5_cbc = "RC5-CBC";
pub const LN_rc5_cbc = "rc5-cbc";
pub const NID_rc5_cbc = @as(c_int, 120);
pub const OBJ_rc5_cbc = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 8);
};
pub const SN_rc5_ecb = "RC5-ECB";
pub const LN_rc5_ecb = "rc5-ecb";
pub const NID_rc5_ecb = @as(c_int, 121);
pub const SN_rc5_cfb64 = "RC5-CFB";
pub const LN_rc5_cfb64 = "rc5-cfb";
pub const NID_rc5_cfb64 = @as(c_int, 122);
pub const SN_rc5_ofb64 = "RC5-OFB";
pub const LN_rc5_ofb64 = "rc5-ofb";
pub const NID_rc5_ofb64 = @as(c_int, 123);
pub const SN_ms_ext_req = "msExtReq";
pub const LN_ms_ext_req = "Microsoft Extension Request";
pub const NID_ms_ext_req = @as(c_int, 171);
pub const OBJ_ms_ext_req = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 14);
};
pub const SN_ms_code_ind = "msCodeInd";
pub const LN_ms_code_ind = "Microsoft Individual Code Signing";
pub const NID_ms_code_ind = @as(c_int, 134);
pub const OBJ_ms_code_ind = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 21);
};
pub const SN_ms_code_com = "msCodeCom";
pub const LN_ms_code_com = "Microsoft Commercial Code Signing";
pub const NID_ms_code_com = @as(c_int, 135);
pub const OBJ_ms_code_com = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 22);
};
pub const SN_ms_ctl_sign = "msCTLSign";
pub const LN_ms_ctl_sign = "Microsoft Trust List Signing";
pub const NID_ms_ctl_sign = @as(c_int, 136);
pub const OBJ_ms_ctl_sign = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 10);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 1);
};
pub const SN_ms_sgc = "msSGC";
pub const LN_ms_sgc = "Microsoft Server Gated Crypto";
pub const NID_ms_sgc = @as(c_int, 137);
pub const OBJ_ms_sgc = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 10);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 3);
};
pub const SN_ms_efs = "msEFS";
pub const LN_ms_efs = "Microsoft Encrypted File System";
pub const NID_ms_efs = @as(c_int, 138);
pub const OBJ_ms_efs = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 10);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const SN_ms_smartcard_login = "msSmartcardLogin";
pub const LN_ms_smartcard_login = "Microsoft Smartcard Login";
pub const NID_ms_smartcard_login = @as(c_int, 648);
pub const OBJ_ms_smartcard_login = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 20);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_ms_upn = "msUPN";
pub const LN_ms_upn = "Microsoft User Principal Name";
pub const NID_ms_upn = @as(c_int, 649);
pub const OBJ_ms_upn = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 20);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 3);
};
pub const SN_ms_ntds_sec_ext = "ms-ntds-sec-ext";
pub const LN_ms_ntds_sec_ext = "Microsoft NTDS CA Extension";
pub const NID_ms_ntds_sec_ext = @as(c_int, 1292);
pub const OBJ_ms_ntds_sec_ext = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 25);
    break :blk @as(c_long, 2);
};
pub const SN_ms_ntds_obj_sid = "ms-ntds-obj-sid";
pub const LN_ms_ntds_obj_sid = "Microsoft NTDS AD objectSid";
pub const NID_ms_ntds_obj_sid = @as(c_int, 1291);
pub const OBJ_ms_ntds_obj_sid = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 25);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_ms_cert_templ = "ms-cert-templ";
pub const LN_ms_cert_templ = "Microsoft certificate template";
pub const NID_ms_cert_templ = @as(c_int, 1293);
pub const OBJ_ms_cert_templ = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 21);
    break :blk @as(c_long, 7);
};
pub const SN_ms_app_policies = "ms-app-policies";
pub const LN_ms_app_policies = "Microsoft Application Policies Extension";
pub const NID_ms_app_policies = @as(c_int, 1294);
pub const OBJ_ms_app_policies = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 21);
    break :blk @as(c_long, 10);
};
pub const SN_idea_cbc = "IDEA-CBC";
pub const LN_idea_cbc = "idea-cbc";
pub const NID_idea_cbc = @as(c_int, 34);
pub const OBJ_idea_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 188);
    _ = @as(c_long, 7);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_idea_ecb = "IDEA-ECB";
pub const LN_idea_ecb = "idea-ecb";
pub const NID_idea_ecb = @as(c_int, 36);
pub const SN_idea_cfb64 = "IDEA-CFB";
pub const LN_idea_cfb64 = "idea-cfb";
pub const NID_idea_cfb64 = @as(c_int, 35);
pub const SN_idea_ofb64 = "IDEA-OFB";
pub const LN_idea_ofb64 = "idea-ofb";
pub const NID_idea_ofb64 = @as(c_int, 46);
pub const SN_bf_cbc = "BF-CBC";
pub const LN_bf_cbc = "bf-cbc";
pub const NID_bf_cbc = @as(c_int, 91);
pub const OBJ_bf_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 3029);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_bf_ecb = "BF-ECB";
pub const LN_bf_ecb = "bf-ecb";
pub const NID_bf_ecb = @as(c_int, 92);
pub const SN_bf_cfb64 = "BF-CFB";
pub const LN_bf_cfb64 = "bf-cfb";
pub const NID_bf_cfb64 = @as(c_int, 93);
pub const SN_bf_ofb64 = "BF-OFB";
pub const LN_bf_ofb64 = "bf-ofb";
pub const NID_bf_ofb64 = @as(c_int, 94);
pub const SN_id_pkix = "PKIX";
pub const NID_id_pkix = @as(c_int, 127);
pub const OBJ_id_pkix = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    _ = @as(c_long, 5);
    break :blk @as(c_long, 7);
};
pub const SN_id_pkix_mod = "id-pkix-mod";
pub const NID_id_pkix_mod = @as(c_int, 258);
pub const OBJ_id_pkix_mod = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 0);
};
pub const SN_id_pe = "id-pe";
pub const NID_id_pe = @as(c_int, 175);
pub const OBJ_id_pe = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 1);
};
pub const SN_id_qt = "id-qt";
pub const NID_id_qt = @as(c_int, 259);
pub const OBJ_id_qt = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 2);
};
pub const SN_id_kp = "id-kp";
pub const NID_id_kp = @as(c_int, 128);
pub const OBJ_id_kp = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 3);
};
pub const SN_id_it = "id-it";
pub const NID_id_it = @as(c_int, 260);
pub const OBJ_id_it = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 4);
};
pub const SN_id_pkip = "id-pkip";
pub const NID_id_pkip = @as(c_int, 261);
pub const OBJ_id_pkip = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 5);
};
pub const SN_id_alg = "id-alg";
pub const NID_id_alg = @as(c_int, 262);
pub const OBJ_id_alg = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 6);
};
pub const SN_id_cmc = "id-cmc";
pub const NID_id_cmc = @as(c_int, 263);
pub const OBJ_id_cmc = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 7);
};
pub const SN_id_on = "id-on";
pub const NID_id_on = @as(c_int, 264);
pub const OBJ_id_on = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 8);
};
pub const SN_id_pda = "id-pda";
pub const NID_id_pda = @as(c_int, 265);
pub const OBJ_id_pda = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 9);
};
pub const SN_id_aca = "id-aca";
pub const NID_id_aca = @as(c_int, 266);
pub const OBJ_id_aca = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 10);
};
pub const SN_id_qcs = "id-qcs";
pub const NID_id_qcs = @as(c_int, 267);
pub const OBJ_id_qcs = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 11);
};
pub const SN_id_cp = "id-cp";
pub const NID_id_cp = @as(c_int, 1238);
pub const OBJ_id_cp = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 14);
};
pub const SN_id_cct = "id-cct";
pub const NID_id_cct = @as(c_int, 268);
pub const OBJ_id_cct = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 12);
};
pub const SN_id_ppl = "id-ppl";
pub const NID_id_ppl = @as(c_int, 662);
pub const OBJ_id_ppl = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 21);
};
pub const SN_id_ad = "id-ad";
pub const NID_id_ad = @as(c_int, 176);
pub const OBJ_id_ad = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 48);
};
pub const SN_id_pkix1_explicit_88 = "id-pkix1-explicit-88";
pub const NID_id_pkix1_explicit_88 = @as(c_int, 269);
pub const OBJ_id_pkix1_explicit_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 1);
};
pub const SN_id_pkix1_implicit_88 = "id-pkix1-implicit-88";
pub const NID_id_pkix1_implicit_88 = @as(c_int, 270);
pub const OBJ_id_pkix1_implicit_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 2);
};
pub const SN_id_pkix1_explicit_93 = "id-pkix1-explicit-93";
pub const NID_id_pkix1_explicit_93 = @as(c_int, 271);
pub const OBJ_id_pkix1_explicit_93 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 3);
};
pub const SN_id_pkix1_implicit_93 = "id-pkix1-implicit-93";
pub const NID_id_pkix1_implicit_93 = @as(c_int, 272);
pub const OBJ_id_pkix1_implicit_93 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 4);
};
pub const SN_id_mod_crmf = "id-mod-crmf";
pub const NID_id_mod_crmf = @as(c_int, 273);
pub const OBJ_id_mod_crmf = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 5);
};
pub const SN_id_mod_cmc = "id-mod-cmc";
pub const NID_id_mod_cmc = @as(c_int, 274);
pub const OBJ_id_mod_cmc = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 6);
};
pub const SN_id_mod_kea_profile_88 = "id-mod-kea-profile-88";
pub const NID_id_mod_kea_profile_88 = @as(c_int, 275);
pub const OBJ_id_mod_kea_profile_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 7);
};
pub const SN_id_mod_kea_profile_93 = "id-mod-kea-profile-93";
pub const NID_id_mod_kea_profile_93 = @as(c_int, 276);
pub const OBJ_id_mod_kea_profile_93 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 8);
};
pub const SN_id_mod_cmp = "id-mod-cmp";
pub const NID_id_mod_cmp = @as(c_int, 277);
pub const OBJ_id_mod_cmp = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 9);
};
pub const SN_id_mod_qualified_cert_88 = "id-mod-qualified-cert-88";
pub const NID_id_mod_qualified_cert_88 = @as(c_int, 278);
pub const OBJ_id_mod_qualified_cert_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 10);
};
pub const SN_id_mod_qualified_cert_93 = "id-mod-qualified-cert-93";
pub const NID_id_mod_qualified_cert_93 = @as(c_int, 279);
pub const OBJ_id_mod_qualified_cert_93 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 11);
};
pub const SN_id_mod_attribute_cert = "id-mod-attribute-cert";
pub const NID_id_mod_attribute_cert = @as(c_int, 280);
pub const OBJ_id_mod_attribute_cert = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 12);
};
pub const SN_id_mod_timestamp_protocol = "id-mod-timestamp-protocol";
pub const NID_id_mod_timestamp_protocol = @as(c_int, 281);
pub const OBJ_id_mod_timestamp_protocol = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 13);
};
pub const SN_id_mod_ocsp = "id-mod-ocsp";
pub const NID_id_mod_ocsp = @as(c_int, 282);
pub const OBJ_id_mod_ocsp = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 14);
};
pub const SN_id_mod_dvcs = "id-mod-dvcs";
pub const NID_id_mod_dvcs = @as(c_int, 283);
pub const OBJ_id_mod_dvcs = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 15);
};
pub const SN_id_mod_cmp2000 = "id-mod-cmp2000";
pub const NID_id_mod_cmp2000 = @as(c_int, 284);
pub const OBJ_id_mod_cmp2000 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 16);
};
pub const SN_id_mod_cmp2000_02 = "id-mod-cmp2000-02";
pub const NID_id_mod_cmp2000_02 = @as(c_int, 1251);
pub const OBJ_id_mod_cmp2000_02 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 50);
};
pub const SN_id_mod_cmp2021_88 = "id-mod-cmp2021-88";
pub const NID_id_mod_cmp2021_88 = @as(c_int, 1252);
pub const OBJ_id_mod_cmp2021_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 99);
};
pub const SN_id_mod_cmp2021_02 = "id-mod-cmp2021-02";
pub const NID_id_mod_cmp2021_02 = @as(c_int, 1253);
pub const OBJ_id_mod_cmp2021_02 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 100);
};
pub const SN_info_access = "authorityInfoAccess";
pub const LN_info_access = "Authority Information Access";
pub const NID_info_access = @as(c_int, 177);
pub const OBJ_info_access = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 1);
};
pub const SN_biometricInfo = "biometricInfo";
pub const LN_biometricInfo = "Biometric Info";
pub const NID_biometricInfo = @as(c_int, 285);
pub const OBJ_biometricInfo = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 2);
};
pub const SN_qcStatements = "qcStatements";
pub const NID_qcStatements = @as(c_int, 286);
pub const OBJ_qcStatements = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 3);
};
pub const SN_ac_auditIdentity = "ac-auditIdentity";
pub const LN_ac_auditIdentity = "X509v3 Audit Identity";
pub const NID_ac_auditIdentity = @as(c_int, 287);
pub const OBJ_ac_auditIdentity = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 4);
};
pub const NID_ac_auditEntity = @as(c_int, 1323);
pub const OBJ_ac_auditEntity = OBJ_ac_auditIdentity;
pub const SN_ac_targeting = "ac-targeting";
pub const NID_ac_targeting = @as(c_int, 288);
pub const OBJ_ac_targeting = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 5);
};
pub const SN_aaControls = "aaControls";
pub const NID_aaControls = @as(c_int, 289);
pub const OBJ_aaControls = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 6);
};
pub const SN_sbgp_ipAddrBlock = "sbgp-ipAddrBlock";
pub const NID_sbgp_ipAddrBlock = @as(c_int, 290);
pub const OBJ_sbgp_ipAddrBlock = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 7);
};
pub const SN_sbgp_autonomousSysNum = "sbgp-autonomousSysNum";
pub const NID_sbgp_autonomousSysNum = @as(c_int, 291);
pub const OBJ_sbgp_autonomousSysNum = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 8);
};
pub const SN_sbgp_routerIdentifier = "sbgp-routerIdentifier";
pub const NID_sbgp_routerIdentifier = @as(c_int, 292);
pub const OBJ_sbgp_routerIdentifier = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 9);
};
pub const SN_ac_proxying = "ac-proxying";
pub const NID_ac_proxying = @as(c_int, 397);
pub const OBJ_ac_proxying = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 10);
};
pub const SN_sinfo_access = "subjectInfoAccess";
pub const LN_sinfo_access = "Subject Information Access";
pub const NID_sinfo_access = @as(c_int, 398);
pub const OBJ_sinfo_access = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 11);
};
pub const SN_proxyCertInfo = "proxyCertInfo";
pub const LN_proxyCertInfo = "Proxy Certificate Information";
pub const NID_proxyCertInfo = @as(c_int, 663);
pub const OBJ_proxyCertInfo = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 14);
};
pub const SN_tlsfeature = "tlsfeature";
pub const LN_tlsfeature = "TLS Feature";
pub const NID_tlsfeature = @as(c_int, 1020);
pub const OBJ_tlsfeature = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 24);
};
pub const SN_sbgp_ipAddrBlockv2 = "sbgp-ipAddrBlockv2";
pub const NID_sbgp_ipAddrBlockv2 = @as(c_int, 1239);
pub const OBJ_sbgp_ipAddrBlockv2 = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 28);
};
pub const SN_sbgp_autonomousSysNumv2 = "sbgp-autonomousSysNumv2";
pub const NID_sbgp_autonomousSysNumv2 = @as(c_int, 1240);
pub const OBJ_sbgp_autonomousSysNumv2 = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 29);
};
pub const SN_id_qt_cps = "id-qt-cps";
pub const LN_id_qt_cps = "Policy Qualifier CPS";
pub const NID_id_qt_cps = @as(c_int, 164);
pub const OBJ_id_qt_cps = blk: {
    _ = &OBJ_id_qt;
    break :blk @as(c_long, 1);
};
pub const SN_id_qt_unotice = "id-qt-unotice";
pub const LN_id_qt_unotice = "Policy Qualifier User Notice";
pub const NID_id_qt_unotice = @as(c_int, 165);
pub const OBJ_id_qt_unotice = blk: {
    _ = &OBJ_id_qt;
    break :blk @as(c_long, 2);
};
pub const SN_textNotice = "textNotice";
pub const NID_textNotice = @as(c_int, 293);
pub const OBJ_textNotice = blk: {
    _ = &OBJ_id_qt;
    break :blk @as(c_long, 3);
};
pub const SN_server_auth = "serverAuth";
pub const LN_server_auth = "TLS Web Server Authentication";
pub const NID_server_auth = @as(c_int, 129);
pub const OBJ_server_auth = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 1);
};
pub const SN_client_auth = "clientAuth";
pub const LN_client_auth = "TLS Web Client Authentication";
pub const NID_client_auth = @as(c_int, 130);
pub const OBJ_client_auth = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 2);
};
pub const SN_code_sign = "codeSigning";
pub const LN_code_sign = "Code Signing";
pub const NID_code_sign = @as(c_int, 131);
pub const OBJ_code_sign = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 3);
};
pub const SN_email_protect = "emailProtection";
pub const LN_email_protect = "E-mail Protection";
pub const NID_email_protect = @as(c_int, 132);
pub const OBJ_email_protect = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 4);
};
pub const SN_ipsecEndSystem = "ipsecEndSystem";
pub const LN_ipsecEndSystem = "IPSec End System";
pub const NID_ipsecEndSystem = @as(c_int, 294);
pub const OBJ_ipsecEndSystem = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 5);
};
pub const SN_ipsecTunnel = "ipsecTunnel";
pub const LN_ipsecTunnel = "IPSec Tunnel";
pub const NID_ipsecTunnel = @as(c_int, 295);
pub const OBJ_ipsecTunnel = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 6);
};
pub const SN_ipsecUser = "ipsecUser";
pub const LN_ipsecUser = "IPSec User";
pub const NID_ipsecUser = @as(c_int, 296);
pub const OBJ_ipsecUser = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 7);
};
pub const SN_time_stamp = "timeStamping";
pub const LN_time_stamp = "Time Stamping";
pub const NID_time_stamp = @as(c_int, 133);
pub const OBJ_time_stamp = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 8);
};
pub const SN_OCSP_sign = "OCSPSigning";
pub const LN_OCSP_sign = "OCSP Signing";
pub const NID_OCSP_sign = @as(c_int, 180);
pub const OBJ_OCSP_sign = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 9);
};
pub const SN_dvcs = "DVCS";
pub const LN_dvcs = "dvcs";
pub const NID_dvcs = @as(c_int, 297);
pub const OBJ_dvcs = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 10);
};
pub const SN_ipsec_IKE = "ipsecIKE";
pub const LN_ipsec_IKE = "ipsec Internet Key Exchange";
pub const NID_ipsec_IKE = @as(c_int, 1022);
pub const OBJ_ipsec_IKE = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 17);
};
pub const SN_capwapAC = "capwapAC";
pub const LN_capwapAC = "Ctrl/provision WAP Access";
pub const NID_capwapAC = @as(c_int, 1023);
pub const OBJ_capwapAC = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 18);
};
pub const SN_capwapWTP = "capwapWTP";
pub const LN_capwapWTP = "Ctrl/Provision WAP Termination";
pub const NID_capwapWTP = @as(c_int, 1024);
pub const OBJ_capwapWTP = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 19);
};
pub const SN_sshClient = "secureShellClient";
pub const LN_sshClient = "SSH Client";
pub const NID_sshClient = @as(c_int, 1025);
pub const OBJ_sshClient = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 21);
};
pub const SN_sshServer = "secureShellServer";
pub const LN_sshServer = "SSH Server";
pub const NID_sshServer = @as(c_int, 1026);
pub const OBJ_sshServer = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 22);
};
pub const SN_sendRouter = "sendRouter";
pub const LN_sendRouter = "Send Router";
pub const NID_sendRouter = @as(c_int, 1027);
pub const OBJ_sendRouter = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 23);
};
pub const SN_sendProxiedRouter = "sendProxiedRouter";
pub const LN_sendProxiedRouter = "Send Proxied Router";
pub const NID_sendProxiedRouter = @as(c_int, 1028);
pub const OBJ_sendProxiedRouter = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 24);
};
pub const SN_sendOwner = "sendOwner";
pub const LN_sendOwner = "Send Owner";
pub const NID_sendOwner = @as(c_int, 1029);
pub const OBJ_sendOwner = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 25);
};
pub const SN_sendProxiedOwner = "sendProxiedOwner";
pub const LN_sendProxiedOwner = "Send Proxied Owner";
pub const NID_sendProxiedOwner = @as(c_int, 1030);
pub const OBJ_sendProxiedOwner = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 26);
};
pub const SN_cmcCA = "cmcCA";
pub const LN_cmcCA = "CMC Certificate Authority";
pub const NID_cmcCA = @as(c_int, 1131);
pub const OBJ_cmcCA = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 27);
};
pub const SN_cmcRA = "cmcRA";
pub const LN_cmcRA = "CMC Registration Authority";
pub const NID_cmcRA = @as(c_int, 1132);
pub const OBJ_cmcRA = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 28);
};
pub const SN_cmcArchive = "cmcArchive";
pub const LN_cmcArchive = "CMC Archive Server";
pub const NID_cmcArchive = @as(c_int, 1219);
pub const OBJ_cmcArchive = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 29);
};
pub const SN_id_kp_bgpsec_router = "id-kp-bgpsec-router";
pub const LN_id_kp_bgpsec_router = "BGPsec Router";
pub const NID_id_kp_bgpsec_router = @as(c_int, 1220);
pub const OBJ_id_kp_bgpsec_router = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 30);
};
pub const SN_id_kp_BrandIndicatorforMessageIdentification = "id-kp-BrandIndicatorforMessageIdentification";
pub const LN_id_kp_BrandIndicatorforMessageIdentification = "Brand Indicator for Message Identification";
pub const NID_id_kp_BrandIndicatorforMessageIdentification = @as(c_int, 1221);
pub const OBJ_id_kp_BrandIndicatorforMessageIdentification = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 31);
};
pub const SN_cmKGA = "cmKGA";
pub const LN_cmKGA = "Certificate Management Key Generation Authority";
pub const NID_cmKGA = @as(c_int, 1222);
pub const OBJ_cmKGA = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 32);
};
pub const SN_id_it_caProtEncCert = "id-it-caProtEncCert";
pub const NID_id_it_caProtEncCert = @as(c_int, 298);
pub const OBJ_id_it_caProtEncCert = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 1);
};
pub const SN_id_it_signKeyPairTypes = "id-it-signKeyPairTypes";
pub const NID_id_it_signKeyPairTypes = @as(c_int, 299);
pub const OBJ_id_it_signKeyPairTypes = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 2);
};
pub const SN_id_it_encKeyPairTypes = "id-it-encKeyPairTypes";
pub const NID_id_it_encKeyPairTypes = @as(c_int, 300);
pub const OBJ_id_it_encKeyPairTypes = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 3);
};
pub const SN_id_it_preferredSymmAlg = "id-it-preferredSymmAlg";
pub const NID_id_it_preferredSymmAlg = @as(c_int, 301);
pub const OBJ_id_it_preferredSymmAlg = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 4);
};
pub const SN_id_it_caKeyUpdateInfo = "id-it-caKeyUpdateInfo";
pub const NID_id_it_caKeyUpdateInfo = @as(c_int, 302);
pub const OBJ_id_it_caKeyUpdateInfo = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 5);
};
pub const SN_id_it_currentCRL = "id-it-currentCRL";
pub const NID_id_it_currentCRL = @as(c_int, 303);
pub const OBJ_id_it_currentCRL = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 6);
};
pub const SN_id_it_unsupportedOIDs = "id-it-unsupportedOIDs";
pub const NID_id_it_unsupportedOIDs = @as(c_int, 304);
pub const OBJ_id_it_unsupportedOIDs = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 7);
};
pub const SN_id_it_subscriptionRequest = "id-it-subscriptionRequest";
pub const NID_id_it_subscriptionRequest = @as(c_int, 305);
pub const OBJ_id_it_subscriptionRequest = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 8);
};
pub const SN_id_it_subscriptionResponse = "id-it-subscriptionResponse";
pub const NID_id_it_subscriptionResponse = @as(c_int, 306);
pub const OBJ_id_it_subscriptionResponse = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 9);
};
pub const SN_id_it_keyPairParamReq = "id-it-keyPairParamReq";
pub const NID_id_it_keyPairParamReq = @as(c_int, 307);
pub const OBJ_id_it_keyPairParamReq = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 10);
};
pub const SN_id_it_keyPairParamRep = "id-it-keyPairParamRep";
pub const NID_id_it_keyPairParamRep = @as(c_int, 308);
pub const OBJ_id_it_keyPairParamRep = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 11);
};
pub const SN_id_it_revPassphrase = "id-it-revPassphrase";
pub const NID_id_it_revPassphrase = @as(c_int, 309);
pub const OBJ_id_it_revPassphrase = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 12);
};
pub const SN_id_it_implicitConfirm = "id-it-implicitConfirm";
pub const NID_id_it_implicitConfirm = @as(c_int, 310);
pub const OBJ_id_it_implicitConfirm = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 13);
};
pub const SN_id_it_confirmWaitTime = "id-it-confirmWaitTime";
pub const NID_id_it_confirmWaitTime = @as(c_int, 311);
pub const OBJ_id_it_confirmWaitTime = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 14);
};
pub const SN_id_it_origPKIMessage = "id-it-origPKIMessage";
pub const NID_id_it_origPKIMessage = @as(c_int, 312);
pub const OBJ_id_it_origPKIMessage = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 15);
};
pub const SN_id_it_suppLangTags = "id-it-suppLangTags";
pub const NID_id_it_suppLangTags = @as(c_int, 784);
pub const OBJ_id_it_suppLangTags = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 16);
};
pub const SN_id_it_caCerts = "id-it-caCerts";
pub const NID_id_it_caCerts = @as(c_int, 1223);
pub const OBJ_id_it_caCerts = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 17);
};
pub const SN_id_it_rootCaKeyUpdate = "id-it-rootCaKeyUpdate";
pub const NID_id_it_rootCaKeyUpdate = @as(c_int, 1224);
pub const OBJ_id_it_rootCaKeyUpdate = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 18);
};
pub const SN_id_it_certReqTemplate = "id-it-certReqTemplate";
pub const NID_id_it_certReqTemplate = @as(c_int, 1225);
pub const OBJ_id_it_certReqTemplate = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 19);
};
pub const SN_id_it_rootCaCert = "id-it-rootCaCert";
pub const NID_id_it_rootCaCert = @as(c_int, 1254);
pub const OBJ_id_it_rootCaCert = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 20);
};
pub const SN_id_it_certProfile = "id-it-certProfile";
pub const NID_id_it_certProfile = @as(c_int, 1255);
pub const OBJ_id_it_certProfile = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 21);
};
pub const SN_id_it_crlStatusList = "id-it-crlStatusList";
pub const NID_id_it_crlStatusList = @as(c_int, 1256);
pub const OBJ_id_it_crlStatusList = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 22);
};
pub const SN_id_it_crls = "id-it-crls";
pub const NID_id_it_crls = @as(c_int, 1257);
pub const OBJ_id_it_crls = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 23);
};
pub const SN_id_regCtrl = "id-regCtrl";
pub const NID_id_regCtrl = @as(c_int, 313);
pub const OBJ_id_regCtrl = blk: {
    _ = &OBJ_id_pkip;
    break :blk @as(c_long, 1);
};
pub const SN_id_regInfo = "id-regInfo";
pub const NID_id_regInfo = @as(c_int, 314);
pub const OBJ_id_regInfo = blk: {
    _ = &OBJ_id_pkip;
    break :blk @as(c_long, 2);
};
pub const SN_id_regCtrl_regToken = "id-regCtrl-regToken";
pub const NID_id_regCtrl_regToken = @as(c_int, 315);
pub const OBJ_id_regCtrl_regToken = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 1);
};
pub const SN_id_regCtrl_authenticator = "id-regCtrl-authenticator";
pub const NID_id_regCtrl_authenticator = @as(c_int, 316);
pub const OBJ_id_regCtrl_authenticator = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 2);
};
pub const SN_id_regCtrl_pkiPublicationInfo = "id-regCtrl-pkiPublicationInfo";
pub const NID_id_regCtrl_pkiPublicationInfo = @as(c_int, 317);
pub const OBJ_id_regCtrl_pkiPublicationInfo = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 3);
};
pub const SN_id_regCtrl_pkiArchiveOptions = "id-regCtrl-pkiArchiveOptions";
pub const NID_id_regCtrl_pkiArchiveOptions = @as(c_int, 318);
pub const OBJ_id_regCtrl_pkiArchiveOptions = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 4);
};
pub const SN_id_regCtrl_oldCertID = "id-regCtrl-oldCertID";
pub const NID_id_regCtrl_oldCertID = @as(c_int, 319);
pub const OBJ_id_regCtrl_oldCertID = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 5);
};
pub const SN_id_regCtrl_protocolEncrKey = "id-regCtrl-protocolEncrKey";
pub const NID_id_regCtrl_protocolEncrKey = @as(c_int, 320);
pub const OBJ_id_regCtrl_protocolEncrKey = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 6);
};
pub const SN_id_regCtrl_altCertTemplate = "id-regCtrl-altCertTemplate";
pub const NID_id_regCtrl_altCertTemplate = @as(c_int, 1258);
pub const OBJ_id_regCtrl_altCertTemplate = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 7);
};
pub const SN_id_regCtrl_algId = "id-regCtrl-algId";
pub const NID_id_regCtrl_algId = @as(c_int, 1259);
pub const OBJ_id_regCtrl_algId = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 11);
};
pub const SN_id_regCtrl_rsaKeyLen = "id-regCtrl-rsaKeyLen";
pub const NID_id_regCtrl_rsaKeyLen = @as(c_int, 1260);
pub const OBJ_id_regCtrl_rsaKeyLen = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 12);
};
pub const SN_id_regInfo_utf8Pairs = "id-regInfo-utf8Pairs";
pub const NID_id_regInfo_utf8Pairs = @as(c_int, 321);
pub const OBJ_id_regInfo_utf8Pairs = blk: {
    _ = &OBJ_id_regInfo;
    break :blk @as(c_long, 1);
};
pub const SN_id_regInfo_certReq = "id-regInfo-certReq";
pub const NID_id_regInfo_certReq = @as(c_int, 322);
pub const OBJ_id_regInfo_certReq = blk: {
    _ = &OBJ_id_regInfo;
    break :blk @as(c_long, 2);
};
pub const SN_id_alg_des40 = "id-alg-des40";
pub const NID_id_alg_des40 = @as(c_int, 323);
pub const OBJ_id_alg_des40 = blk: {
    _ = &OBJ_id_alg;
    break :blk @as(c_long, 1);
};
pub const SN_id_alg_noSignature = "id-alg-noSignature";
pub const NID_id_alg_noSignature = @as(c_int, 324);
pub const OBJ_id_alg_noSignature = blk: {
    _ = &OBJ_id_alg;
    break :blk @as(c_long, 2);
};
pub const SN_id_alg_dh_sig_hmac_sha1 = "id-alg-dh-sig-hmac-sha1";
pub const NID_id_alg_dh_sig_hmac_sha1 = @as(c_int, 325);
pub const OBJ_id_alg_dh_sig_hmac_sha1 = blk: {
    _ = &OBJ_id_alg;
    break :blk @as(c_long, 3);
};
pub const SN_id_alg_dh_pop = "id-alg-dh-pop";
pub const NID_id_alg_dh_pop = @as(c_int, 326);
pub const OBJ_id_alg_dh_pop = blk: {
    _ = &OBJ_id_alg;
    break :blk @as(c_long, 4);
};
pub const SN_id_cmc_statusInfo = "id-cmc-statusInfo";
pub const NID_id_cmc_statusInfo = @as(c_int, 327);
pub const OBJ_id_cmc_statusInfo = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 1);
};
pub const SN_id_cmc_identification = "id-cmc-identification";
pub const NID_id_cmc_identification = @as(c_int, 328);
pub const OBJ_id_cmc_identification = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 2);
};
pub const SN_id_cmc_identityProof = "id-cmc-identityProof";
pub const NID_id_cmc_identityProof = @as(c_int, 329);
pub const OBJ_id_cmc_identityProof = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 3);
};
pub const SN_id_cmc_dataReturn = "id-cmc-dataReturn";
pub const NID_id_cmc_dataReturn = @as(c_int, 330);
pub const OBJ_id_cmc_dataReturn = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 4);
};
pub const SN_id_cmc_transactionId = "id-cmc-transactionId";
pub const NID_id_cmc_transactionId = @as(c_int, 331);
pub const OBJ_id_cmc_transactionId = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 5);
};
pub const SN_id_cmc_senderNonce = "id-cmc-senderNonce";
pub const NID_id_cmc_senderNonce = @as(c_int, 332);
pub const OBJ_id_cmc_senderNonce = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 6);
};
pub const SN_id_cmc_recipientNonce = "id-cmc-recipientNonce";
pub const NID_id_cmc_recipientNonce = @as(c_int, 333);
pub const OBJ_id_cmc_recipientNonce = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 7);
};
pub const SN_id_cmc_addExtensions = "id-cmc-addExtensions";
pub const NID_id_cmc_addExtensions = @as(c_int, 334);
pub const OBJ_id_cmc_addExtensions = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 8);
};
pub const SN_id_cmc_encryptedPOP = "id-cmc-encryptedPOP";
pub const NID_id_cmc_encryptedPOP = @as(c_int, 335);
pub const OBJ_id_cmc_encryptedPOP = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 9);
};
pub const SN_id_cmc_decryptedPOP = "id-cmc-decryptedPOP";
pub const NID_id_cmc_decryptedPOP = @as(c_int, 336);
pub const OBJ_id_cmc_decryptedPOP = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 10);
};
pub const SN_id_cmc_lraPOPWitness = "id-cmc-lraPOPWitness";
pub const NID_id_cmc_lraPOPWitness = @as(c_int, 337);
pub const OBJ_id_cmc_lraPOPWitness = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 11);
};
pub const SN_id_cmc_getCert = "id-cmc-getCert";
pub const NID_id_cmc_getCert = @as(c_int, 338);
pub const OBJ_id_cmc_getCert = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 15);
};
pub const SN_id_cmc_getCRL = "id-cmc-getCRL";
pub const NID_id_cmc_getCRL = @as(c_int, 339);
pub const OBJ_id_cmc_getCRL = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 16);
};
pub const SN_id_cmc_revokeRequest = "id-cmc-revokeRequest";
pub const NID_id_cmc_revokeRequest = @as(c_int, 340);
pub const OBJ_id_cmc_revokeRequest = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 17);
};
pub const SN_id_cmc_regInfo = "id-cmc-regInfo";
pub const NID_id_cmc_regInfo = @as(c_int, 341);
pub const OBJ_id_cmc_regInfo = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 18);
};
pub const SN_id_cmc_responseInfo = "id-cmc-responseInfo";
pub const NID_id_cmc_responseInfo = @as(c_int, 342);
pub const OBJ_id_cmc_responseInfo = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 19);
};
pub const SN_id_cmc_queryPending = "id-cmc-queryPending";
pub const NID_id_cmc_queryPending = @as(c_int, 343);
pub const OBJ_id_cmc_queryPending = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 21);
};
pub const SN_id_cmc_popLinkRandom = "id-cmc-popLinkRandom";
pub const NID_id_cmc_popLinkRandom = @as(c_int, 344);
pub const OBJ_id_cmc_popLinkRandom = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 22);
};
pub const SN_id_cmc_popLinkWitness = "id-cmc-popLinkWitness";
pub const NID_id_cmc_popLinkWitness = @as(c_int, 345);
pub const OBJ_id_cmc_popLinkWitness = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 23);
};
pub const SN_id_cmc_confirmCertAcceptance = "id-cmc-confirmCertAcceptance";
pub const NID_id_cmc_confirmCertAcceptance = @as(c_int, 346);
pub const OBJ_id_cmc_confirmCertAcceptance = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 24);
};
pub const SN_id_on_personalData = "id-on-personalData";
pub const NID_id_on_personalData = @as(c_int, 347);
pub const OBJ_id_on_personalData = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 1);
};
pub const SN_id_on_permanentIdentifier = "id-on-permanentIdentifier";
pub const LN_id_on_permanentIdentifier = "Permanent Identifier";
pub const NID_id_on_permanentIdentifier = @as(c_int, 858);
pub const OBJ_id_on_permanentIdentifier = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 3);
};
pub const SN_id_on_hardwareModuleName = "id-on-hardwareModuleName";
pub const LN_id_on_hardwareModuleName = "Hardware Module Name";
pub const NID_id_on_hardwareModuleName = @as(c_int, 1321);
pub const OBJ_id_on_hardwareModuleName = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 4);
};
pub const SN_XmppAddr = "id-on-xmppAddr";
pub const LN_XmppAddr = "XmppAddr";
pub const NID_XmppAddr = @as(c_int, 1209);
pub const OBJ_XmppAddr = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 5);
};
pub const SN_SRVName = "id-on-dnsSRV";
pub const LN_SRVName = "SRVName";
pub const NID_SRVName = @as(c_int, 1210);
pub const OBJ_SRVName = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 7);
};
pub const SN_NAIRealm = "id-on-NAIRealm";
pub const LN_NAIRealm = "NAIRealm";
pub const NID_NAIRealm = @as(c_int, 1211);
pub const OBJ_NAIRealm = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 8);
};
pub const SN_id_on_SmtpUTF8Mailbox = "id-on-SmtpUTF8Mailbox";
pub const LN_id_on_SmtpUTF8Mailbox = "Smtp UTF8 Mailbox";
pub const NID_id_on_SmtpUTF8Mailbox = @as(c_int, 1208);
pub const OBJ_id_on_SmtpUTF8Mailbox = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 9);
};
pub const SN_id_pda_dateOfBirth = "id-pda-dateOfBirth";
pub const NID_id_pda_dateOfBirth = @as(c_int, 348);
pub const OBJ_id_pda_dateOfBirth = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 1);
};
pub const SN_id_pda_placeOfBirth = "id-pda-placeOfBirth";
pub const NID_id_pda_placeOfBirth = @as(c_int, 349);
pub const OBJ_id_pda_placeOfBirth = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 2);
};
pub const SN_id_pda_gender = "id-pda-gender";
pub const NID_id_pda_gender = @as(c_int, 351);
pub const OBJ_id_pda_gender = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 3);
};
pub const SN_id_pda_countryOfCitizenship = "id-pda-countryOfCitizenship";
pub const NID_id_pda_countryOfCitizenship = @as(c_int, 352);
pub const OBJ_id_pda_countryOfCitizenship = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 4);
};
pub const SN_id_pda_countryOfResidence = "id-pda-countryOfResidence";
pub const NID_id_pda_countryOfResidence = @as(c_int, 353);
pub const OBJ_id_pda_countryOfResidence = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 5);
};
pub const SN_id_aca_authenticationInfo = "id-aca-authenticationInfo";
pub const NID_id_aca_authenticationInfo = @as(c_int, 354);
pub const OBJ_id_aca_authenticationInfo = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 1);
};
pub const SN_id_aca_accessIdentity = "id-aca-accessIdentity";
pub const NID_id_aca_accessIdentity = @as(c_int, 355);
pub const OBJ_id_aca_accessIdentity = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 2);
};
pub const SN_id_aca_chargingIdentity = "id-aca-chargingIdentity";
pub const NID_id_aca_chargingIdentity = @as(c_int, 356);
pub const OBJ_id_aca_chargingIdentity = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 3);
};
pub const SN_id_aca_group = "id-aca-group";
pub const NID_id_aca_group = @as(c_int, 357);
pub const OBJ_id_aca_group = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 4);
};
pub const SN_id_aca_role = "id-aca-role";
pub const NID_id_aca_role = @as(c_int, 358);
pub const OBJ_id_aca_role = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 5);
};
pub const SN_id_aca_encAttrs = "id-aca-encAttrs";
pub const NID_id_aca_encAttrs = @as(c_int, 399);
pub const OBJ_id_aca_encAttrs = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 6);
};
pub const SN_id_qcs_pkixQCSyntax_v1 = "id-qcs-pkixQCSyntax-v1";
pub const NID_id_qcs_pkixQCSyntax_v1 = @as(c_int, 359);
pub const OBJ_id_qcs_pkixQCSyntax_v1 = blk: {
    _ = &OBJ_id_qcs;
    break :blk @as(c_long, 1);
};
pub const SN_ipAddr_asNumber = "ipAddr-asNumber";
pub const NID_ipAddr_asNumber = @as(c_int, 1241);
pub const OBJ_ipAddr_asNumber = blk: {
    _ = &OBJ_id_cp;
    break :blk @as(c_long, 2);
};
pub const SN_ipAddr_asNumberv2 = "ipAddr-asNumberv2";
pub const NID_ipAddr_asNumberv2 = @as(c_int, 1242);
pub const OBJ_ipAddr_asNumberv2 = blk: {
    _ = &OBJ_id_cp;
    break :blk @as(c_long, 3);
};
pub const SN_id_cct_crs = "id-cct-crs";
pub const NID_id_cct_crs = @as(c_int, 360);
pub const OBJ_id_cct_crs = blk: {
    _ = &OBJ_id_cct;
    break :blk @as(c_long, 1);
};
pub const SN_id_cct_PKIData = "id-cct-PKIData";
pub const NID_id_cct_PKIData = @as(c_int, 361);
pub const OBJ_id_cct_PKIData = blk: {
    _ = &OBJ_id_cct;
    break :blk @as(c_long, 2);
};
pub const SN_id_cct_PKIResponse = "id-cct-PKIResponse";
pub const NID_id_cct_PKIResponse = @as(c_int, 362);
pub const OBJ_id_cct_PKIResponse = blk: {
    _ = &OBJ_id_cct;
    break :blk @as(c_long, 3);
};
pub const SN_id_ppl_anyLanguage = "id-ppl-anyLanguage";
pub const LN_id_ppl_anyLanguage = "Any language";
pub const NID_id_ppl_anyLanguage = @as(c_int, 664);
pub const OBJ_id_ppl_anyLanguage = blk: {
    _ = &OBJ_id_ppl;
    break :blk @as(c_long, 0);
};
pub const SN_id_ppl_inheritAll = "id-ppl-inheritAll";
pub const LN_id_ppl_inheritAll = "Inherit all";
pub const NID_id_ppl_inheritAll = @as(c_int, 665);
pub const OBJ_id_ppl_inheritAll = blk: {
    _ = &OBJ_id_ppl;
    break :blk @as(c_long, 1);
};
pub const SN_Independent = "id-ppl-independent";
pub const LN_Independent = "Independent";
pub const NID_Independent = @as(c_int, 667);
pub const OBJ_Independent = blk: {
    _ = &OBJ_id_ppl;
    break :blk @as(c_long, 2);
};
pub const SN_ad_OCSP = "OCSP";
pub const LN_ad_OCSP = "OCSP";
pub const NID_ad_OCSP = @as(c_int, 178);
pub const OBJ_ad_OCSP = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 1);
};
pub const SN_ad_ca_issuers = "caIssuers";
pub const LN_ad_ca_issuers = "CA Issuers";
pub const NID_ad_ca_issuers = @as(c_int, 179);
pub const OBJ_ad_ca_issuers = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 2);
};
pub const SN_ad_timeStamping = "ad_timestamping";
pub const LN_ad_timeStamping = "AD Time Stamping";
pub const NID_ad_timeStamping = @as(c_int, 363);
pub const OBJ_ad_timeStamping = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 3);
};
pub const SN_ad_dvcs = "AD_DVCS";
pub const LN_ad_dvcs = "ad dvcs";
pub const NID_ad_dvcs = @as(c_int, 364);
pub const OBJ_ad_dvcs = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 4);
};
pub const SN_caRepository = "caRepository";
pub const LN_caRepository = "CA Repository";
pub const NID_caRepository = @as(c_int, 785);
pub const OBJ_caRepository = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 5);
};
pub const SN_rpkiManifest = "rpkiManifest";
pub const LN_rpkiManifest = "RPKI Manifest";
pub const NID_rpkiManifest = @as(c_int, 1243);
pub const OBJ_rpkiManifest = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 10);
};
pub const SN_signedObject = "signedObject";
pub const LN_signedObject = "Signed Object";
pub const NID_signedObject = @as(c_int, 1244);
pub const OBJ_signedObject = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 11);
};
pub const SN_rpkiNotify = "rpkiNotify";
pub const LN_rpkiNotify = "RPKI Notify";
pub const NID_rpkiNotify = @as(c_int, 1245);
pub const OBJ_rpkiNotify = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 13);
};
pub const OBJ_id_pkix_OCSP = OBJ_ad_OCSP;
pub const SN_id_pkix_OCSP_basic = "basicOCSPResponse";
pub const LN_id_pkix_OCSP_basic = "Basic OCSP Response";
pub const NID_id_pkix_OCSP_basic = @as(c_int, 365);
pub const OBJ_id_pkix_OCSP_basic = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 1);
};
pub const SN_id_pkix_OCSP_Nonce = "Nonce";
pub const LN_id_pkix_OCSP_Nonce = "OCSP Nonce";
pub const NID_id_pkix_OCSP_Nonce = @as(c_int, 366);
pub const OBJ_id_pkix_OCSP_Nonce = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 2);
};
pub const SN_id_pkix_OCSP_CrlID = "CrlID";
pub const LN_id_pkix_OCSP_CrlID = "OCSP CRL ID";
pub const NID_id_pkix_OCSP_CrlID = @as(c_int, 367);
pub const OBJ_id_pkix_OCSP_CrlID = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 3);
};
pub const SN_id_pkix_OCSP_acceptableResponses = "acceptableResponses";
pub const LN_id_pkix_OCSP_acceptableResponses = "Acceptable OCSP Responses";
pub const NID_id_pkix_OCSP_acceptableResponses = @as(c_int, 368);
pub const OBJ_id_pkix_OCSP_acceptableResponses = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 4);
};
pub const SN_id_pkix_OCSP_noCheck = "noCheck";
pub const LN_id_pkix_OCSP_noCheck = "OCSP No Check";
pub const NID_id_pkix_OCSP_noCheck = @as(c_int, 369);
pub const OBJ_id_pkix_OCSP_noCheck = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 5);
};
pub const SN_id_pkix_OCSP_archiveCutoff = "archiveCutoff";
pub const LN_id_pkix_OCSP_archiveCutoff = "OCSP Archive Cutoff";
pub const NID_id_pkix_OCSP_archiveCutoff = @as(c_int, 370);
pub const OBJ_id_pkix_OCSP_archiveCutoff = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 6);
};
pub const SN_id_pkix_OCSP_serviceLocator = "serviceLocator";
pub const LN_id_pkix_OCSP_serviceLocator = "OCSP Service Locator";
pub const NID_id_pkix_OCSP_serviceLocator = @as(c_int, 371);
pub const OBJ_id_pkix_OCSP_serviceLocator = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 7);
};
pub const SN_id_pkix_OCSP_extendedStatus = "extendedStatus";
pub const LN_id_pkix_OCSP_extendedStatus = "Extended OCSP Status";
pub const NID_id_pkix_OCSP_extendedStatus = @as(c_int, 372);
pub const OBJ_id_pkix_OCSP_extendedStatus = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 8);
};
pub const SN_id_pkix_OCSP_valid = "valid";
pub const NID_id_pkix_OCSP_valid = @as(c_int, 373);
pub const OBJ_id_pkix_OCSP_valid = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 9);
};
pub const SN_id_pkix_OCSP_path = "path";
pub const NID_id_pkix_OCSP_path = @as(c_int, 374);
pub const OBJ_id_pkix_OCSP_path = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 10);
};
pub const SN_id_pkix_OCSP_trustRoot = "trustRoot";
pub const LN_id_pkix_OCSP_trustRoot = "Trust Root";
pub const NID_id_pkix_OCSP_trustRoot = @as(c_int, 375);
pub const OBJ_id_pkix_OCSP_trustRoot = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 11);
};
pub const SN_algorithm = "algorithm";
pub const LN_algorithm = "algorithm";
pub const NID_algorithm = @as(c_int, 376);
pub const OBJ_algorithm = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 14);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 2);
};
pub const SN_md5WithRSA = "RSA-NP-MD5";
pub const LN_md5WithRSA = "md5WithRSA";
pub const NID_md5WithRSA = @as(c_int, 104);
pub const OBJ_md5WithRSA = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 3);
};
pub const SN_des_ecb = "DES-ECB";
pub const LN_des_ecb = "des-ecb";
pub const NID_des_ecb = @as(c_int, 29);
pub const OBJ_des_ecb = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 6);
};
pub const SN_des_cbc = "DES-CBC";
pub const LN_des_cbc = "des-cbc";
pub const NID_des_cbc = @as(c_int, 31);
pub const OBJ_des_cbc = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 7);
};
pub const SN_des_ofb64 = "DES-OFB";
pub const LN_des_ofb64 = "des-ofb";
pub const NID_des_ofb64 = @as(c_int, 45);
pub const OBJ_des_ofb64 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 8);
};
pub const SN_des_cfb64 = "DES-CFB";
pub const LN_des_cfb64 = "des-cfb";
pub const NID_des_cfb64 = @as(c_int, 30);
pub const OBJ_des_cfb64 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 9);
};
pub const SN_rsaSignature = "rsaSignature";
pub const NID_rsaSignature = @as(c_int, 377);
pub const OBJ_rsaSignature = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 11);
};
pub const SN_dsa_2 = "DSA-old";
pub const LN_dsa_2 = "dsaEncryption-old";
pub const NID_dsa_2 = @as(c_int, 67);
pub const OBJ_dsa_2 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 12);
};
pub const SN_dsaWithSHA = "DSA-SHA";
pub const LN_dsaWithSHA = "dsaWithSHA";
pub const NID_dsaWithSHA = @as(c_int, 66);
pub const OBJ_dsaWithSHA = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 13);
};
pub const SN_shaWithRSAEncryption = "RSA-SHA";
pub const LN_shaWithRSAEncryption = "shaWithRSAEncryption";
pub const NID_shaWithRSAEncryption = @as(c_int, 42);
pub const OBJ_shaWithRSAEncryption = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 15);
};
pub const SN_des_ede_ecb = "DES-EDE";
pub const LN_des_ede_ecb = "des-ede";
pub const NID_des_ede_ecb = @as(c_int, 32);
pub const OBJ_des_ede_ecb = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 17);
};
pub const SN_des_ede3_ecb = "DES-EDE3";
pub const LN_des_ede3_ecb = "des-ede3";
pub const NID_des_ede3_ecb = @as(c_int, 33);
pub const SN_des_ede_cbc = "DES-EDE-CBC";
pub const LN_des_ede_cbc = "des-ede-cbc";
pub const NID_des_ede_cbc = @as(c_int, 43);
pub const SN_des_ede_cfb64 = "DES-EDE-CFB";
pub const LN_des_ede_cfb64 = "des-ede-cfb";
pub const NID_des_ede_cfb64 = @as(c_int, 60);
pub const SN_des_ede3_cfb64 = "DES-EDE3-CFB";
pub const LN_des_ede3_cfb64 = "des-ede3-cfb";
pub const NID_des_ede3_cfb64 = @as(c_int, 61);
pub const SN_des_ede_ofb64 = "DES-EDE-OFB";
pub const LN_des_ede_ofb64 = "des-ede-ofb";
pub const NID_des_ede_ofb64 = @as(c_int, 62);
pub const SN_des_ede3_ofb64 = "DES-EDE3-OFB";
pub const LN_des_ede3_ofb64 = "des-ede3-ofb";
pub const NID_des_ede3_ofb64 = @as(c_int, 63);
pub const SN_desx_cbc = "DESX-CBC";
pub const LN_desx_cbc = "desx-cbc";
pub const NID_desx_cbc = @as(c_int, 80);
pub const SN_sha = "SHA";
pub const LN_sha = "sha";
pub const NID_sha = @as(c_int, 41);
pub const OBJ_sha = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 18);
};
pub const SN_sha1 = "SHA1";
pub const LN_sha1 = "sha1";
pub const NID_sha1 = @as(c_int, 64);
pub const OBJ_sha1 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 26);
};
pub const SN_dsaWithSHA1_2 = "DSA-SHA1-old";
pub const LN_dsaWithSHA1_2 = "dsaWithSHA1-old";
pub const NID_dsaWithSHA1_2 = @as(c_int, 70);
pub const OBJ_dsaWithSHA1_2 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 27);
};
pub const SN_sha1WithRSA = "RSA-SHA1-2";
pub const LN_sha1WithRSA = "sha1WithRSA";
pub const NID_sha1WithRSA = @as(c_int, 115);
pub const OBJ_sha1WithRSA = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 29);
};
pub const SN_ripemd160 = "RIPEMD160";
pub const LN_ripemd160 = "ripemd160";
pub const NID_ripemd160 = @as(c_int, 117);
pub const OBJ_ripemd160 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_ripemd160WithRSA = "RSA-RIPEMD160";
pub const LN_ripemd160WithRSA = "ripemd160WithRSA";
pub const NID_ripemd160WithRSA = @as(c_int, 119);
pub const OBJ_ripemd160WithRSA = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_blake2bmac = "BLAKE2BMAC";
pub const LN_blake2bmac = "blake2bmac";
pub const NID_blake2bmac = @as(c_int, 1201);
pub const OBJ_blake2bmac = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1722);
    _ = @as(c_long, 12);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_blake2smac = "BLAKE2SMAC";
pub const LN_blake2smac = "blake2smac";
pub const NID_blake2smac = @as(c_int, 1202);
pub const OBJ_blake2smac = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1722);
    _ = @as(c_long, 12);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_blake2b512 = "BLAKE2b512";
pub const LN_blake2b512 = "blake2b512";
pub const NID_blake2b512 = @as(c_int, 1056);
pub const OBJ_blake2b512 = blk: {
    _ = &OBJ_blake2bmac;
    break :blk @as(c_long, 16);
};
pub const SN_blake2s256 = "BLAKE2s256";
pub const LN_blake2s256 = "blake2s256";
pub const NID_blake2s256 = @as(c_int, 1057);
pub const OBJ_blake2s256 = blk: {
    _ = &OBJ_blake2smac;
    break :blk @as(c_long, 8);
};
pub const SN_sxnet = "SXNetID";
pub const LN_sxnet = "Strong Extranet ID";
pub const NID_sxnet = @as(c_int, 143);
pub const OBJ_sxnet = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 1);
};
pub const SN_X500 = "X500";
pub const LN_X500 = "directory services (X.500)";
pub const NID_X500 = @as(c_int, 11);
pub const OBJ_X500 = blk: {
    _ = @as(c_long, 2);
    break :blk @as(c_long, 5);
};
pub const SN_X509 = "X509";
pub const NID_X509 = @as(c_int, 12);
pub const OBJ_X509 = blk: {
    _ = &OBJ_X500;
    break :blk @as(c_long, 4);
};
pub const SN_commonName = "CN";
pub const LN_commonName = "commonName";
pub const NID_commonName = @as(c_int, 13);
pub const OBJ_commonName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 3);
};
pub const SN_surname = "SN";
pub const LN_surname = "surname";
pub const NID_surname = @as(c_int, 100);
pub const OBJ_surname = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 4);
};
pub const LN_serialNumber = "serialNumber";
pub const NID_serialNumber = @as(c_int, 105);
pub const OBJ_serialNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 5);
};
pub const SN_countryName = "C";
pub const LN_countryName = "countryName";
pub const NID_countryName = @as(c_int, 14);
pub const OBJ_countryName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 6);
};
pub const SN_localityName = "L";
pub const LN_localityName = "localityName";
pub const NID_localityName = @as(c_int, 15);
pub const OBJ_localityName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 7);
};
pub const SN_stateOrProvinceName = "ST";
pub const LN_stateOrProvinceName = "stateOrProvinceName";
pub const NID_stateOrProvinceName = @as(c_int, 16);
pub const OBJ_stateOrProvinceName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 8);
};
pub const SN_streetAddress = "street";
pub const LN_streetAddress = "streetAddress";
pub const NID_streetAddress = @as(c_int, 660);
pub const OBJ_streetAddress = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 9);
};
pub const SN_organizationName = "O";
pub const LN_organizationName = "organizationName";
pub const NID_organizationName = @as(c_int, 17);
pub const OBJ_organizationName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 10);
};
pub const SN_organizationalUnitName = "OU";
pub const LN_organizationalUnitName = "organizationalUnitName";
pub const NID_organizationalUnitName = @as(c_int, 18);
pub const OBJ_organizationalUnitName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 11);
};
pub const SN_title = "title";
pub const LN_title = "title";
pub const NID_title = @as(c_int, 106);
pub const OBJ_title = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 12);
};
pub const LN_description = "description";
pub const NID_description = @as(c_int, 107);
pub const OBJ_description = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 13);
};
pub const LN_searchGuide = "searchGuide";
pub const NID_searchGuide = @as(c_int, 859);
pub const OBJ_searchGuide = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 14);
};
pub const LN_businessCategory = "businessCategory";
pub const NID_businessCategory = @as(c_int, 860);
pub const OBJ_businessCategory = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 15);
};
pub const LN_postalAddress = "postalAddress";
pub const NID_postalAddress = @as(c_int, 861);
pub const OBJ_postalAddress = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 16);
};
pub const LN_postalCode = "postalCode";
pub const NID_postalCode = @as(c_int, 661);
pub const OBJ_postalCode = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 17);
};
pub const LN_postOfficeBox = "postOfficeBox";
pub const NID_postOfficeBox = @as(c_int, 862);
pub const OBJ_postOfficeBox = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 18);
};
pub const LN_physicalDeliveryOfficeName = "physicalDeliveryOfficeName";
pub const NID_physicalDeliveryOfficeName = @as(c_int, 863);
pub const OBJ_physicalDeliveryOfficeName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 19);
};
pub const LN_telephoneNumber = "telephoneNumber";
pub const NID_telephoneNumber = @as(c_int, 864);
pub const OBJ_telephoneNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 20);
};
pub const LN_telexNumber = "telexNumber";
pub const NID_telexNumber = @as(c_int, 865);
pub const OBJ_telexNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 21);
};
pub const LN_teletexTerminalIdentifier = "teletexTerminalIdentifier";
pub const NID_teletexTerminalIdentifier = @as(c_int, 866);
pub const OBJ_teletexTerminalIdentifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 22);
};
pub const LN_facsimileTelephoneNumber = "facsimileTelephoneNumber";
pub const NID_facsimileTelephoneNumber = @as(c_int, 867);
pub const OBJ_facsimileTelephoneNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 23);
};
pub const LN_x121Address = "x121Address";
pub const NID_x121Address = @as(c_int, 868);
pub const OBJ_x121Address = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 24);
};
pub const LN_internationaliSDNNumber = "internationaliSDNNumber";
pub const NID_internationaliSDNNumber = @as(c_int, 869);
pub const OBJ_internationaliSDNNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 25);
};
pub const LN_registeredAddress = "registeredAddress";
pub const NID_registeredAddress = @as(c_int, 870);
pub const OBJ_registeredAddress = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 26);
};
pub const LN_destinationIndicator = "destinationIndicator";
pub const NID_destinationIndicator = @as(c_int, 871);
pub const OBJ_destinationIndicator = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 27);
};
pub const LN_preferredDeliveryMethod = "preferredDeliveryMethod";
pub const NID_preferredDeliveryMethod = @as(c_int, 872);
pub const OBJ_preferredDeliveryMethod = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 28);
};
pub const LN_presentationAddress = "presentationAddress";
pub const NID_presentationAddress = @as(c_int, 873);
pub const OBJ_presentationAddress = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 29);
};
pub const LN_supportedApplicationContext = "supportedApplicationContext";
pub const NID_supportedApplicationContext = @as(c_int, 874);
pub const OBJ_supportedApplicationContext = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 30);
};
pub const SN_member = "member";
pub const NID_member = @as(c_int, 875);
pub const OBJ_member = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 31);
};
pub const SN_owner = "owner";
pub const NID_owner = @as(c_int, 876);
pub const OBJ_owner = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 32);
};
pub const LN_roleOccupant = "roleOccupant";
pub const NID_roleOccupant = @as(c_int, 877);
pub const OBJ_roleOccupant = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 33);
};
pub const SN_seeAlso = "seeAlso";
pub const NID_seeAlso = @as(c_int, 878);
pub const OBJ_seeAlso = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 34);
};
pub const LN_userPassword = "userPassword";
pub const NID_userPassword = @as(c_int, 879);
pub const OBJ_userPassword = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 35);
};
pub const LN_userCertificate = "userCertificate";
pub const NID_userCertificate = @as(c_int, 880);
pub const OBJ_userCertificate = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 36);
};
pub const LN_cACertificate = "cACertificate";
pub const NID_cACertificate = @as(c_int, 881);
pub const OBJ_cACertificate = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 37);
};
pub const LN_authorityRevocationList = "authorityRevocationList";
pub const NID_authorityRevocationList = @as(c_int, 882);
pub const OBJ_authorityRevocationList = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 38);
};
pub const LN_certificateRevocationList = "certificateRevocationList";
pub const NID_certificateRevocationList = @as(c_int, 883);
pub const OBJ_certificateRevocationList = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 39);
};
pub const LN_crossCertificatePair = "crossCertificatePair";
pub const NID_crossCertificatePair = @as(c_int, 884);
pub const OBJ_crossCertificatePair = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 40);
};
pub const SN_name = "name";
pub const LN_name = "name";
pub const NID_name = @as(c_int, 173);
pub const OBJ_name = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 41);
};
pub const SN_givenName = "GN";
pub const LN_givenName = "givenName";
pub const NID_givenName = @as(c_int, 99);
pub const OBJ_givenName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 42);
};
pub const SN_initials = "initials";
pub const LN_initials = "initials";
pub const NID_initials = @as(c_int, 101);
pub const OBJ_initials = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 43);
};
pub const LN_generationQualifier = "generationQualifier";
pub const NID_generationQualifier = @as(c_int, 509);
pub const OBJ_generationQualifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 44);
};
pub const LN_x500UniqueIdentifier = "x500UniqueIdentifier";
pub const NID_x500UniqueIdentifier = @as(c_int, 503);
pub const OBJ_x500UniqueIdentifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 45);
};
pub const SN_dnQualifier = "dnQualifier";
pub const LN_dnQualifier = "dnQualifier";
pub const NID_dnQualifier = @as(c_int, 174);
pub const OBJ_dnQualifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 46);
};
pub const LN_enhancedSearchGuide = "enhancedSearchGuide";
pub const NID_enhancedSearchGuide = @as(c_int, 885);
pub const OBJ_enhancedSearchGuide = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 47);
};
pub const LN_protocolInformation = "protocolInformation";
pub const NID_protocolInformation = @as(c_int, 886);
pub const OBJ_protocolInformation = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 48);
};
pub const LN_distinguishedName = "distinguishedName";
pub const NID_distinguishedName = @as(c_int, 887);
pub const OBJ_distinguishedName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 49);
};
pub const LN_uniqueMember = "uniqueMember";
pub const NID_uniqueMember = @as(c_int, 888);
pub const OBJ_uniqueMember = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 50);
};
pub const LN_houseIdentifier = "houseIdentifier";
pub const NID_houseIdentifier = @as(c_int, 889);
pub const OBJ_houseIdentifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 51);
};
pub const LN_supportedAlgorithms = "supportedAlgorithms";
pub const NID_supportedAlgorithms = @as(c_int, 890);
pub const OBJ_supportedAlgorithms = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 52);
};
pub const LN_deltaRevocationList = "deltaRevocationList";
pub const NID_deltaRevocationList = @as(c_int, 891);
pub const OBJ_deltaRevocationList = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 53);
};
pub const SN_dmdName = "dmdName";
pub const NID_dmdName = @as(c_int, 892);
pub const OBJ_dmdName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 54);
};
pub const LN_pseudonym = "pseudonym";
pub const NID_pseudonym = @as(c_int, 510);
pub const OBJ_pseudonym = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 65);
};
pub const SN_role = "role";
pub const LN_role = "role";
pub const NID_role = @as(c_int, 400);
pub const OBJ_role = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 72);
};
pub const LN_organizationIdentifier = "organizationIdentifier";
pub const NID_organizationIdentifier = @as(c_int, 1089);
pub const OBJ_organizationIdentifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 97);
};
pub const SN_countryCode3c = "c3";
pub const LN_countryCode3c = "countryCode3c";
pub const NID_countryCode3c = @as(c_int, 1090);
pub const OBJ_countryCode3c = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 98);
};
pub const SN_countryCode3n = "n3";
pub const LN_countryCode3n = "countryCode3n";
pub const NID_countryCode3n = @as(c_int, 1091);
pub const OBJ_countryCode3n = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 99);
};
pub const LN_dnsName = "dnsName";
pub const NID_dnsName = @as(c_int, 1092);
pub const OBJ_dnsName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 100);
};
pub const SN_X500algorithms = "X500algorithms";
pub const LN_X500algorithms = "directory services - algorithms";
pub const NID_X500algorithms = @as(c_int, 378);
pub const OBJ_X500algorithms = blk: {
    _ = &OBJ_X500;
    break :blk @as(c_long, 8);
};
pub const SN_rsa = "RSA";
pub const LN_rsa = "rsa";
pub const NID_rsa = @as(c_int, 19);
pub const OBJ_rsa = blk: {
    _ = &OBJ_X500algorithms;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_mdc2WithRSA = "RSA-MDC2";
pub const LN_mdc2WithRSA = "mdc2WithRSA";
pub const NID_mdc2WithRSA = @as(c_int, 96);
pub const OBJ_mdc2WithRSA = blk: {
    _ = &OBJ_X500algorithms;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 100);
};
pub const SN_mdc2 = "MDC2";
pub const LN_mdc2 = "mdc2";
pub const NID_mdc2 = @as(c_int, 95);
pub const OBJ_mdc2 = blk: {
    _ = &OBJ_X500algorithms;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 101);
};
pub const SN_id_ce = "id-ce";
pub const NID_id_ce = @as(c_int, 81);
pub const OBJ_id_ce = blk: {
    _ = &OBJ_X500;
    break :blk @as(c_long, 29);
};
pub const SN_subject_directory_attributes = "subjectDirectoryAttributes";
pub const LN_subject_directory_attributes = "X509v3 Subject Directory Attributes";
pub const NID_subject_directory_attributes = @as(c_int, 769);
pub const OBJ_subject_directory_attributes = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 9);
};
pub const SN_subject_key_identifier = "subjectKeyIdentifier";
pub const LN_subject_key_identifier = "X509v3 Subject Key Identifier";
pub const NID_subject_key_identifier = @as(c_int, 82);
pub const OBJ_subject_key_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 14);
};
pub const SN_key_usage = "keyUsage";
pub const LN_key_usage = "X509v3 Key Usage";
pub const NID_key_usage = @as(c_int, 83);
pub const OBJ_key_usage = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 15);
};
pub const SN_private_key_usage_period = "privateKeyUsagePeriod";
pub const LN_private_key_usage_period = "X509v3 Private Key Usage Period";
pub const NID_private_key_usage_period = @as(c_int, 84);
pub const OBJ_private_key_usage_period = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 16);
};
pub const SN_subject_alt_name = "subjectAltName";
pub const LN_subject_alt_name = "X509v3 Subject Alternative Name";
pub const NID_subject_alt_name = @as(c_int, 85);
pub const OBJ_subject_alt_name = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 17);
};
pub const SN_issuer_alt_name = "issuerAltName";
pub const LN_issuer_alt_name = "X509v3 Issuer Alternative Name";
pub const NID_issuer_alt_name = @as(c_int, 86);
pub const OBJ_issuer_alt_name = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 18);
};
pub const SN_basic_constraints = "basicConstraints";
pub const LN_basic_constraints = "X509v3 Basic Constraints";
pub const NID_basic_constraints = @as(c_int, 87);
pub const OBJ_basic_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 19);
};
pub const SN_crl_number = "crlNumber";
pub const LN_crl_number = "X509v3 CRL Number";
pub const NID_crl_number = @as(c_int, 88);
pub const OBJ_crl_number = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 20);
};
pub const SN_crl_reason = "CRLReason";
pub const LN_crl_reason = "X509v3 CRL Reason Code";
pub const NID_crl_reason = @as(c_int, 141);
pub const OBJ_crl_reason = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 21);
};
pub const SN_invalidity_date = "invalidityDate";
pub const LN_invalidity_date = "Invalidity Date";
pub const NID_invalidity_date = @as(c_int, 142);
pub const OBJ_invalidity_date = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 24);
};
pub const SN_delta_crl = "deltaCRL";
pub const LN_delta_crl = "X509v3 Delta CRL Indicator";
pub const NID_delta_crl = @as(c_int, 140);
pub const OBJ_delta_crl = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 27);
};
pub const SN_issuing_distribution_point = "issuingDistributionPoint";
pub const LN_issuing_distribution_point = "X509v3 Issuing Distribution Point";
pub const NID_issuing_distribution_point = @as(c_int, 770);
pub const OBJ_issuing_distribution_point = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 28);
};
pub const SN_certificate_issuer = "certificateIssuer";
pub const LN_certificate_issuer = "X509v3 Certificate Issuer";
pub const NID_certificate_issuer = @as(c_int, 771);
pub const OBJ_certificate_issuer = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 29);
};
pub const SN_name_constraints = "nameConstraints";
pub const LN_name_constraints = "X509v3 Name Constraints";
pub const NID_name_constraints = @as(c_int, 666);
pub const OBJ_name_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 30);
};
pub const SN_crl_distribution_points = "crlDistributionPoints";
pub const LN_crl_distribution_points = "X509v3 CRL Distribution Points";
pub const NID_crl_distribution_points = @as(c_int, 103);
pub const OBJ_crl_distribution_points = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 31);
};
pub const SN_certificate_policies = "certificatePolicies";
pub const LN_certificate_policies = "X509v3 Certificate Policies";
pub const NID_certificate_policies = @as(c_int, 89);
pub const OBJ_certificate_policies = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 32);
};
pub const SN_any_policy = "anyPolicy";
pub const LN_any_policy = "X509v3 Any Policy";
pub const NID_any_policy = @as(c_int, 746);
pub const OBJ_any_policy = blk: {
    _ = &OBJ_certificate_policies;
    break :blk @as(c_long, 0);
};
pub const SN_policy_mappings = "policyMappings";
pub const LN_policy_mappings = "X509v3 Policy Mappings";
pub const NID_policy_mappings = @as(c_int, 747);
pub const OBJ_policy_mappings = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 33);
};
pub const SN_authority_key_identifier = "authorityKeyIdentifier";
pub const LN_authority_key_identifier = "X509v3 Authority Key Identifier";
pub const NID_authority_key_identifier = @as(c_int, 90);
pub const OBJ_authority_key_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 35);
};
pub const SN_policy_constraints = "policyConstraints";
pub const LN_policy_constraints = "X509v3 Policy Constraints";
pub const NID_policy_constraints = @as(c_int, 401);
pub const OBJ_policy_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 36);
};
pub const SN_ext_key_usage = "extendedKeyUsage";
pub const LN_ext_key_usage = "X509v3 Extended Key Usage";
pub const NID_ext_key_usage = @as(c_int, 126);
pub const OBJ_ext_key_usage = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 37);
};
pub const SN_authority_attribute_identifier = "authorityAttributeIdentifier";
pub const LN_authority_attribute_identifier = "X509v3 Authority Attribute Identifier";
pub const NID_authority_attribute_identifier = @as(c_int, 1295);
pub const OBJ_authority_attribute_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 38);
};
pub const SN_role_spec_cert_identifier = "roleSpecCertIdentifier";
pub const LN_role_spec_cert_identifier = "X509v3 Role Specification Certificate Identifier";
pub const NID_role_spec_cert_identifier = @as(c_int, 1296);
pub const OBJ_role_spec_cert_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 39);
};
pub const SN_basic_att_constraints = "basicAttConstraints";
pub const LN_basic_att_constraints = "X509v3 Basic Attribute Certificate Constraints";
pub const NID_basic_att_constraints = @as(c_int, 1297);
pub const OBJ_basic_att_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 41);
};
pub const SN_delegated_name_constraints = "delegatedNameConstraints";
pub const LN_delegated_name_constraints = "X509v3 Delegated Name Constraints";
pub const NID_delegated_name_constraints = @as(c_int, 1298);
pub const OBJ_delegated_name_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 42);
};
pub const SN_time_specification = "timeSpecification";
pub const LN_time_specification = "X509v3 Time Specification";
pub const NID_time_specification = @as(c_int, 1299);
pub const OBJ_time_specification = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 43);
};
pub const SN_freshest_crl = "freshestCRL";
pub const LN_freshest_crl = "X509v3 Freshest CRL";
pub const NID_freshest_crl = @as(c_int, 857);
pub const OBJ_freshest_crl = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 46);
};
pub const SN_attribute_descriptor = "attributeDescriptor";
pub const LN_attribute_descriptor = "X509v3 Attribute Descriptor";
pub const NID_attribute_descriptor = @as(c_int, 1300);
pub const OBJ_attribute_descriptor = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 48);
};
pub const SN_user_notice = "userNotice";
pub const LN_user_notice = "X509v3 User Notice";
pub const NID_user_notice = @as(c_int, 1301);
pub const OBJ_user_notice = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 49);
};
pub const SN_soa_identifier = "sOAIdentifier";
pub const LN_soa_identifier = "X509v3 Source of Authority Identifier";
pub const NID_soa_identifier = @as(c_int, 1302);
pub const OBJ_soa_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 50);
};
pub const SN_acceptable_cert_policies = "acceptableCertPolicies";
pub const LN_acceptable_cert_policies = "X509v3 Acceptable Certification Policies";
pub const NID_acceptable_cert_policies = @as(c_int, 1303);
pub const OBJ_acceptable_cert_policies = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 52);
};
pub const SN_inhibit_any_policy = "inhibitAnyPolicy";
pub const LN_inhibit_any_policy = "X509v3 Inhibit Any Policy";
pub const NID_inhibit_any_policy = @as(c_int, 748);
pub const OBJ_inhibit_any_policy = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 54);
};
pub const SN_target_information = "targetInformation";
pub const LN_target_information = "X509v3 AC Targeting";
pub const NID_target_information = @as(c_int, 402);
pub const OBJ_target_information = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 55);
};
pub const SN_no_rev_avail = "noRevAvail";
pub const LN_no_rev_avail = "X509v3 No Revocation Available";
pub const NID_no_rev_avail = @as(c_int, 403);
pub const OBJ_no_rev_avail = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 56);
};
pub const SN_acceptable_privilege_policies = "acceptablePrivPolicies";
pub const LN_acceptable_privilege_policies = "X509v3 Acceptable Privilege Policies";
pub const NID_acceptable_privilege_policies = @as(c_int, 1304);
pub const OBJ_acceptable_privilege_policies = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 57);
};
pub const SN_indirect_issuer = "indirectIssuer";
pub const LN_indirect_issuer = "X509v3 Indirect Issuer";
pub const NID_indirect_issuer = @as(c_int, 1305);
pub const OBJ_indirect_issuer = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 61);
};
pub const SN_no_assertion = "noAssertion";
pub const LN_no_assertion = "X509v3 No Assertion";
pub const NID_no_assertion = @as(c_int, 1306);
pub const OBJ_no_assertion = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 62);
};
pub const SN_id_aa_issuing_distribution_point = "aAissuingDistributionPoint";
pub const LN_id_aa_issuing_distribution_point = "X509v3 Attribute Authority Issuing Distribution Point";
pub const NID_id_aa_issuing_distribution_point = @as(c_int, 1307);
pub const OBJ_id_aa_issuing_distribution_point = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 63);
};
pub const SN_issued_on_behalf_of = "issuedOnBehalfOf";
pub const LN_issued_on_behalf_of = "X509v3 Issued On Behalf Of";
pub const NID_issued_on_behalf_of = @as(c_int, 1308);
pub const OBJ_issued_on_behalf_of = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 64);
};
pub const SN_single_use = "singleUse";
pub const LN_single_use = "X509v3 Single Use";
pub const NID_single_use = @as(c_int, 1309);
pub const OBJ_single_use = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 65);
};
pub const SN_group_ac = "groupAC";
pub const LN_group_ac = "X509v3 Group Attribute Certificate";
pub const NID_group_ac = @as(c_int, 1310);
pub const OBJ_group_ac = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 66);
};
pub const SN_allowed_attribute_assignments = "allowedAttributeAssignments";
pub const LN_allowed_attribute_assignments = "X509v3 Allowed Attribute Assignments";
pub const NID_allowed_attribute_assignments = @as(c_int, 1311);
pub const OBJ_allowed_attribute_assignments = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 67);
};
pub const SN_attribute_mappings = "attributeMappings";
pub const LN_attribute_mappings = "X509v3 Attribute Mappings";
pub const NID_attribute_mappings = @as(c_int, 1312);
pub const OBJ_attribute_mappings = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 68);
};
pub const SN_holder_name_constraints = "holderNameConstraints";
pub const LN_holder_name_constraints = "X509v3 Holder Name Constraints";
pub const NID_holder_name_constraints = @as(c_int, 1313);
pub const OBJ_holder_name_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 69);
};
pub const SN_authorization_validation = "authorizationValidation";
pub const LN_authorization_validation = "X509v3 Authorization Validation";
pub const NID_authorization_validation = @as(c_int, 1314);
pub const OBJ_authorization_validation = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 70);
};
pub const SN_prot_restrict = "protRestrict";
pub const LN_prot_restrict = "X509v3 Protocol Restriction";
pub const NID_prot_restrict = @as(c_int, 1315);
pub const OBJ_prot_restrict = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 71);
};
pub const SN_subject_alt_public_key_info = "subjectAltPublicKeyInfo";
pub const LN_subject_alt_public_key_info = "X509v3 Subject Alternative Public Key Info";
pub const NID_subject_alt_public_key_info = @as(c_int, 1316);
pub const OBJ_subject_alt_public_key_info = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 72);
};
pub const SN_alt_signature_algorithm = "altSignatureAlgorithm";
pub const LN_alt_signature_algorithm = "X509v3 Alternative Signature Algorithm";
pub const NID_alt_signature_algorithm = @as(c_int, 1317);
pub const OBJ_alt_signature_algorithm = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 73);
};
pub const SN_alt_signature_value = "altSignatureValue";
pub const LN_alt_signature_value = "X509v3 Alternative Signature Value";
pub const NID_alt_signature_value = @as(c_int, 1318);
pub const OBJ_alt_signature_value = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 74);
};
pub const SN_associated_information = "associatedInformation";
pub const LN_associated_information = "X509v3 Associated Information";
pub const NID_associated_information = @as(c_int, 1319);
pub const OBJ_associated_information = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 75);
};
pub const SN_anyExtendedKeyUsage = "anyExtendedKeyUsage";
pub const LN_anyExtendedKeyUsage = "Any Extended Key Usage";
pub const NID_anyExtendedKeyUsage = @as(c_int, 910);
pub const OBJ_anyExtendedKeyUsage = blk: {
    _ = &OBJ_ext_key_usage;
    break :blk @as(c_long, 0);
};
pub const SN_netscape = "Netscape";
pub const LN_netscape = "Netscape Communications Corp.";
pub const NID_netscape = @as(c_int, 57);
pub const OBJ_netscape = blk: {
    _ = @as(c_long, 2);
    _ = @as(c_long, 16);
    _ = @as(c_long, 840);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 113730);
};
pub const SN_netscape_cert_extension = "nsCertExt";
pub const LN_netscape_cert_extension = "Netscape Certificate Extension";
pub const NID_netscape_cert_extension = @as(c_int, 58);
pub const OBJ_netscape_cert_extension = blk: {
    _ = &OBJ_netscape;
    break :blk @as(c_long, 1);
};
pub const SN_netscape_data_type = "nsDataType";
pub const LN_netscape_data_type = "Netscape Data Type";
pub const NID_netscape_data_type = @as(c_int, 59);
pub const OBJ_netscape_data_type = blk: {
    _ = &OBJ_netscape;
    break :blk @as(c_long, 2);
};
pub const SN_netscape_cert_type = "nsCertType";
pub const LN_netscape_cert_type = "Netscape Cert Type";
pub const NID_netscape_cert_type = @as(c_int, 71);
pub const OBJ_netscape_cert_type = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 1);
};
pub const SN_netscape_base_url = "nsBaseUrl";
pub const LN_netscape_base_url = "Netscape Base Url";
pub const NID_netscape_base_url = @as(c_int, 72);
pub const OBJ_netscape_base_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 2);
};
pub const SN_netscape_revocation_url = "nsRevocationUrl";
pub const LN_netscape_revocation_url = "Netscape Revocation Url";
pub const NID_netscape_revocation_url = @as(c_int, 73);
pub const OBJ_netscape_revocation_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 3);
};
pub const SN_netscape_ca_revocation_url = "nsCaRevocationUrl";
pub const LN_netscape_ca_revocation_url = "Netscape CA Revocation Url";
pub const NID_netscape_ca_revocation_url = @as(c_int, 74);
pub const OBJ_netscape_ca_revocation_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 4);
};
pub const SN_netscape_renewal_url = "nsRenewalUrl";
pub const LN_netscape_renewal_url = "Netscape Renewal Url";
pub const NID_netscape_renewal_url = @as(c_int, 75);
pub const OBJ_netscape_renewal_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 7);
};
pub const SN_netscape_ca_policy_url = "nsCaPolicyUrl";
pub const LN_netscape_ca_policy_url = "Netscape CA Policy Url";
pub const NID_netscape_ca_policy_url = @as(c_int, 76);
pub const OBJ_netscape_ca_policy_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 8);
};
pub const SN_netscape_ssl_server_name = "nsSslServerName";
pub const LN_netscape_ssl_server_name = "Netscape SSL Server Name";
pub const NID_netscape_ssl_server_name = @as(c_int, 77);
pub const OBJ_netscape_ssl_server_name = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 12);
};
pub const SN_netscape_comment = "nsComment";
pub const LN_netscape_comment = "Netscape Comment";
pub const NID_netscape_comment = @as(c_int, 78);
pub const OBJ_netscape_comment = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 13);
};
pub const SN_netscape_cert_sequence = "nsCertSequence";
pub const LN_netscape_cert_sequence = "Netscape Certificate Sequence";
pub const NID_netscape_cert_sequence = @as(c_int, 79);
pub const OBJ_netscape_cert_sequence = blk: {
    _ = &OBJ_netscape_data_type;
    break :blk @as(c_long, 5);
};
pub const SN_ns_sgc = "nsSGC";
pub const LN_ns_sgc = "Netscape Server Gated Crypto";
pub const NID_ns_sgc = @as(c_int, 139);
pub const OBJ_ns_sgc = blk: {
    _ = &OBJ_netscape;
    _ = @as(c_long, 4);
    break :blk @as(c_long, 1);
};
pub const SN_org = "ORG";
pub const LN_org = "org";
pub const NID_org = @as(c_int, 379);
pub const OBJ_org = blk: {
    _ = &OBJ_iso;
    break :blk @as(c_long, 3);
};
pub const SN_dod = "DOD";
pub const LN_dod = "dod";
pub const NID_dod = @as(c_int, 380);
pub const OBJ_dod = blk: {
    _ = &OBJ_org;
    break :blk @as(c_long, 6);
};
pub const SN_iana = "IANA";
pub const LN_iana = "iana";
pub const NID_iana = @as(c_int, 381);
pub const OBJ_iana = blk: {
    _ = &OBJ_dod;
    break :blk @as(c_long, 1);
};
pub const OBJ_internet = OBJ_iana;
pub const SN_Directory = "directory";
pub const LN_Directory = "Directory";
pub const NID_Directory = @as(c_int, 382);
pub const OBJ_Directory = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 1);
};
pub const SN_Management = "mgmt";
pub const LN_Management = "Management";
pub const NID_Management = @as(c_int, 383);
pub const OBJ_Management = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 2);
};
pub const SN_Experimental = "experimental";
pub const LN_Experimental = "Experimental";
pub const NID_Experimental = @as(c_int, 384);
pub const OBJ_Experimental = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 3);
};
pub const SN_Private = "private";
pub const LN_Private = "Private";
pub const NID_Private = @as(c_int, 385);
pub const OBJ_Private = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 4);
};
pub const SN_Security = "security";
pub const LN_Security = "Security";
pub const NID_Security = @as(c_int, 386);
pub const OBJ_Security = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 5);
};
pub const SN_SNMPv2 = "snmpv2";
pub const LN_SNMPv2 = "SNMPv2";
pub const NID_SNMPv2 = @as(c_int, 387);
pub const OBJ_SNMPv2 = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 6);
};
pub const LN_Mail = "Mail";
pub const NID_Mail = @as(c_int, 388);
pub const OBJ_Mail = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 7);
};
pub const SN_Enterprises = "enterprises";
pub const LN_Enterprises = "Enterprises";
pub const NID_Enterprises = @as(c_int, 389);
pub const OBJ_Enterprises = blk: {
    _ = &OBJ_Private;
    break :blk @as(c_long, 1);
};
pub const SN_dcObject = "dcobject";
pub const LN_dcObject = "dcObject";
pub const NID_dcObject = @as(c_int, 390);
pub const OBJ_dcObject = blk: {
    _ = &OBJ_Enterprises;
    _ = @as(c_long, 1466);
    break :blk @as(c_long, 344);
};
pub const SN_id_kp_wisun_fan_device = "id-kp-wisun-fan-device";
pub const LN_id_kp_wisun_fan_device = "Wi-SUN Alliance Field Area Network (FAN)";
pub const NID_id_kp_wisun_fan_device = @as(c_int, 1322);
pub const OBJ_id_kp_wisun_fan_device = blk: {
    _ = &OBJ_Enterprises;
    _ = @as(c_long, 45605);
    break :blk @as(c_long, 1);
};
pub const SN_mime_mhs = "mime-mhs";
pub const LN_mime_mhs = "MIME MHS";
pub const NID_mime_mhs = @as(c_int, 504);
pub const OBJ_mime_mhs = blk: {
    _ = &OBJ_Mail;
    break :blk @as(c_long, 1);
};
pub const SN_mime_mhs_headings = "mime-mhs-headings";
pub const LN_mime_mhs_headings = "mime-mhs-headings";
pub const NID_mime_mhs_headings = @as(c_int, 505);
pub const OBJ_mime_mhs_headings = blk: {
    _ = &OBJ_mime_mhs;
    break :blk @as(c_long, 1);
};
pub const SN_mime_mhs_bodies = "mime-mhs-bodies";
pub const LN_mime_mhs_bodies = "mime-mhs-bodies";
pub const NID_mime_mhs_bodies = @as(c_int, 506);
pub const OBJ_mime_mhs_bodies = blk: {
    _ = &OBJ_mime_mhs;
    break :blk @as(c_long, 2);
};
pub const SN_id_hex_partial_message = "id-hex-partial-message";
pub const LN_id_hex_partial_message = "id-hex-partial-message";
pub const NID_id_hex_partial_message = @as(c_int, 507);
pub const OBJ_id_hex_partial_message = blk: {
    _ = &OBJ_mime_mhs_headings;
    break :blk @as(c_long, 1);
};
pub const SN_id_hex_multipart_message = "id-hex-multipart-message";
pub const LN_id_hex_multipart_message = "id-hex-multipart-message";
pub const NID_id_hex_multipart_message = @as(c_int, 508);
pub const OBJ_id_hex_multipart_message = blk: {
    _ = &OBJ_mime_mhs_headings;
    break :blk @as(c_long, 2);
};
pub const SN_zlib_compression = "ZLIB";
pub const LN_zlib_compression = "zlib compression";
pub const NID_zlib_compression = @as(c_int, 125);
pub const OBJ_zlib_compression = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 8);
};
pub const OBJ_csor = blk: {
    _ = @as(c_long, 2);
    _ = @as(c_long, 16);
    _ = @as(c_long, 840);
    _ = @as(c_long, 1);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 3);
};
pub const OBJ_nistAlgorithms = blk: {
    _ = &OBJ_csor;
    break :blk @as(c_long, 4);
};
pub const OBJ_aes = blk: {
    _ = &OBJ_nistAlgorithms;
    break :blk @as(c_long, 1);
};
pub const SN_aes_128_ecb = "AES-128-ECB";
pub const LN_aes_128_ecb = "aes-128-ecb";
pub const NID_aes_128_ecb = @as(c_int, 418);
pub const OBJ_aes_128_ecb = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 1);
};
pub const SN_aes_128_cbc = "AES-128-CBC";
pub const LN_aes_128_cbc = "aes-128-cbc";
pub const NID_aes_128_cbc = @as(c_int, 419);
pub const OBJ_aes_128_cbc = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 2);
};
pub const SN_aes_128_ofb128 = "AES-128-OFB";
pub const LN_aes_128_ofb128 = "aes-128-ofb";
pub const NID_aes_128_ofb128 = @as(c_int, 420);
pub const OBJ_aes_128_ofb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 3);
};
pub const SN_aes_128_cfb128 = "AES-128-CFB";
pub const LN_aes_128_cfb128 = "aes-128-cfb";
pub const NID_aes_128_cfb128 = @as(c_int, 421);
pub const OBJ_aes_128_cfb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 4);
};
pub const SN_id_aes128_wrap = "id-aes128-wrap";
pub const NID_id_aes128_wrap = @as(c_int, 788);
pub const OBJ_id_aes128_wrap = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 5);
};
pub const SN_aes_128_gcm = "id-aes128-GCM";
pub const LN_aes_128_gcm = "aes-128-gcm";
pub const NID_aes_128_gcm = @as(c_int, 895);
pub const OBJ_aes_128_gcm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 6);
};
pub const SN_aes_128_ccm = "id-aes128-CCM";
pub const LN_aes_128_ccm = "aes-128-ccm";
pub const NID_aes_128_ccm = @as(c_int, 896);
pub const OBJ_aes_128_ccm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 7);
};
pub const SN_id_aes128_wrap_pad = "id-aes128-wrap-pad";
pub const NID_id_aes128_wrap_pad = @as(c_int, 897);
pub const OBJ_id_aes128_wrap_pad = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 8);
};
pub const SN_aes_192_ecb = "AES-192-ECB";
pub const LN_aes_192_ecb = "aes-192-ecb";
pub const NID_aes_192_ecb = @as(c_int, 422);
pub const OBJ_aes_192_ecb = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 21);
};
pub const SN_aes_192_cbc = "AES-192-CBC";
pub const LN_aes_192_cbc = "aes-192-cbc";
pub const NID_aes_192_cbc = @as(c_int, 423);
pub const OBJ_aes_192_cbc = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 22);
};
pub const SN_aes_192_ofb128 = "AES-192-OFB";
pub const LN_aes_192_ofb128 = "aes-192-ofb";
pub const NID_aes_192_ofb128 = @as(c_int, 424);
pub const OBJ_aes_192_ofb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 23);
};
pub const SN_aes_192_cfb128 = "AES-192-CFB";
pub const LN_aes_192_cfb128 = "aes-192-cfb";
pub const NID_aes_192_cfb128 = @as(c_int, 425);
pub const OBJ_aes_192_cfb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 24);
};
pub const SN_id_aes192_wrap = "id-aes192-wrap";
pub const NID_id_aes192_wrap = @as(c_int, 789);
pub const OBJ_id_aes192_wrap = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 25);
};
pub const SN_aes_192_gcm = "id-aes192-GCM";
pub const LN_aes_192_gcm = "aes-192-gcm";
pub const NID_aes_192_gcm = @as(c_int, 898);
pub const OBJ_aes_192_gcm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 26);
};
pub const SN_aes_192_ccm = "id-aes192-CCM";
pub const LN_aes_192_ccm = "aes-192-ccm";
pub const NID_aes_192_ccm = @as(c_int, 899);
pub const OBJ_aes_192_ccm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 27);
};
pub const SN_id_aes192_wrap_pad = "id-aes192-wrap-pad";
pub const NID_id_aes192_wrap_pad = @as(c_int, 900);
pub const OBJ_id_aes192_wrap_pad = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 28);
};
pub const SN_aes_256_ecb = "AES-256-ECB";
pub const LN_aes_256_ecb = "aes-256-ecb";
pub const NID_aes_256_ecb = @as(c_int, 426);
pub const OBJ_aes_256_ecb = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 41);
};
pub const SN_aes_256_cbc = "AES-256-CBC";
pub const LN_aes_256_cbc = "aes-256-cbc";
pub const NID_aes_256_cbc = @as(c_int, 427);
pub const OBJ_aes_256_cbc = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 42);
};
pub const SN_aes_256_ofb128 = "AES-256-OFB";
pub const LN_aes_256_ofb128 = "aes-256-ofb";
pub const NID_aes_256_ofb128 = @as(c_int, 428);
pub const OBJ_aes_256_ofb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 43);
};
pub const SN_aes_256_cfb128 = "AES-256-CFB";
pub const LN_aes_256_cfb128 = "aes-256-cfb";
pub const NID_aes_256_cfb128 = @as(c_int, 429);
pub const OBJ_aes_256_cfb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 44);
};
pub const SN_id_aes256_wrap = "id-aes256-wrap";
pub const NID_id_aes256_wrap = @as(c_int, 790);
pub const OBJ_id_aes256_wrap = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 45);
};
pub const SN_aes_256_gcm = "id-aes256-GCM";
pub const LN_aes_256_gcm = "aes-256-gcm";
pub const NID_aes_256_gcm = @as(c_int, 901);
pub const OBJ_aes_256_gcm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 46);
};
pub const SN_aes_256_ccm = "id-aes256-CCM";
pub const LN_aes_256_ccm = "aes-256-ccm";
pub const NID_aes_256_ccm = @as(c_int, 902);
pub const OBJ_aes_256_ccm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 47);
};
pub const SN_id_aes256_wrap_pad = "id-aes256-wrap-pad";
pub const NID_id_aes256_wrap_pad = @as(c_int, 903);
pub const OBJ_id_aes256_wrap_pad = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 48);
};
pub const SN_aes_128_xts = "AES-128-XTS";
pub const LN_aes_128_xts = "aes-128-xts";
pub const NID_aes_128_xts = @as(c_int, 913);
pub const OBJ_aes_128_xts = blk: {
    _ = &OBJ_ieee_siswg;
    _ = @as(c_long, 0);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_aes_256_xts = "AES-256-XTS";
pub const LN_aes_256_xts = "aes-256-xts";
pub const NID_aes_256_xts = @as(c_int, 914);
pub const OBJ_aes_256_xts = blk: {
    _ = &OBJ_ieee_siswg;
    _ = @as(c_long, 0);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_aes_128_cfb1 = "AES-128-CFB1";
pub const LN_aes_128_cfb1 = "aes-128-cfb1";
pub const NID_aes_128_cfb1 = @as(c_int, 650);
pub const SN_aes_192_cfb1 = "AES-192-CFB1";
pub const LN_aes_192_cfb1 = "aes-192-cfb1";
pub const NID_aes_192_cfb1 = @as(c_int, 651);
pub const SN_aes_256_cfb1 = "AES-256-CFB1";
pub const LN_aes_256_cfb1 = "aes-256-cfb1";
pub const NID_aes_256_cfb1 = @as(c_int, 652);
pub const SN_aes_128_cfb8 = "AES-128-CFB8";
pub const LN_aes_128_cfb8 = "aes-128-cfb8";
pub const NID_aes_128_cfb8 = @as(c_int, 653);
pub const SN_aes_192_cfb8 = "AES-192-CFB8";
pub const LN_aes_192_cfb8 = "aes-192-cfb8";
pub const NID_aes_192_cfb8 = @as(c_int, 654);
pub const SN_aes_256_cfb8 = "AES-256-CFB8";
pub const LN_aes_256_cfb8 = "aes-256-cfb8";
pub const NID_aes_256_cfb8 = @as(c_int, 655);
pub const SN_aes_128_ctr = "AES-128-CTR";
pub const LN_aes_128_ctr = "aes-128-ctr";
pub const NID_aes_128_ctr = @as(c_int, 904);
pub const SN_aes_192_ctr = "AES-192-CTR";
pub const LN_aes_192_ctr = "aes-192-ctr";
pub const NID_aes_192_ctr = @as(c_int, 905);
pub const SN_aes_256_ctr = "AES-256-CTR";
pub const LN_aes_256_ctr = "aes-256-ctr";
pub const NID_aes_256_ctr = @as(c_int, 906);
pub const SN_aes_128_ocb = "AES-128-OCB";
pub const LN_aes_128_ocb = "aes-128-ocb";
pub const NID_aes_128_ocb = @as(c_int, 958);
pub const SN_aes_192_ocb = "AES-192-OCB";
pub const LN_aes_192_ocb = "aes-192-ocb";
pub const NID_aes_192_ocb = @as(c_int, 959);
pub const SN_aes_256_ocb = "AES-256-OCB";
pub const LN_aes_256_ocb = "aes-256-ocb";
pub const NID_aes_256_ocb = @as(c_int, 960);
pub const SN_des_cfb1 = "DES-CFB1";
pub const LN_des_cfb1 = "des-cfb1";
pub const NID_des_cfb1 = @as(c_int, 656);
pub const SN_des_cfb8 = "DES-CFB8";
pub const LN_des_cfb8 = "des-cfb8";
pub const NID_des_cfb8 = @as(c_int, 657);
pub const SN_des_ede3_cfb1 = "DES-EDE3-CFB1";
pub const LN_des_ede3_cfb1 = "des-ede3-cfb1";
pub const NID_des_ede3_cfb1 = @as(c_int, 658);
pub const SN_des_ede3_cfb8 = "DES-EDE3-CFB8";
pub const LN_des_ede3_cfb8 = "des-ede3-cfb8";
pub const NID_des_ede3_cfb8 = @as(c_int, 659);
pub const OBJ_nist_hashalgs = blk: {
    _ = &OBJ_nistAlgorithms;
    break :blk @as(c_long, 2);
};
pub const SN_sha256 = "SHA256";
pub const LN_sha256 = "sha256";
pub const NID_sha256 = @as(c_int, 672);
pub const OBJ_sha256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 1);
};
pub const SN_sha384 = "SHA384";
pub const LN_sha384 = "sha384";
pub const NID_sha384 = @as(c_int, 673);
pub const OBJ_sha384 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 2);
};
pub const SN_sha512 = "SHA512";
pub const LN_sha512 = "sha512";
pub const NID_sha512 = @as(c_int, 674);
pub const OBJ_sha512 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 3);
};
pub const SN_sha224 = "SHA224";
pub const LN_sha224 = "sha224";
pub const NID_sha224 = @as(c_int, 675);
pub const OBJ_sha224 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 4);
};
pub const SN_sha512_224 = "SHA512-224";
pub const LN_sha512_224 = "sha512-224";
pub const NID_sha512_224 = @as(c_int, 1094);
pub const OBJ_sha512_224 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 5);
};
pub const SN_sha512_256 = "SHA512-256";
pub const LN_sha512_256 = "sha512-256";
pub const NID_sha512_256 = @as(c_int, 1095);
pub const OBJ_sha512_256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 6);
};
pub const SN_sha3_224 = "SHA3-224";
pub const LN_sha3_224 = "sha3-224";
pub const NID_sha3_224 = @as(c_int, 1096);
pub const OBJ_sha3_224 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 7);
};
pub const SN_sha3_256 = "SHA3-256";
pub const LN_sha3_256 = "sha3-256";
pub const NID_sha3_256 = @as(c_int, 1097);
pub const OBJ_sha3_256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 8);
};
pub const SN_sha3_384 = "SHA3-384";
pub const LN_sha3_384 = "sha3-384";
pub const NID_sha3_384 = @as(c_int, 1098);
pub const OBJ_sha3_384 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 9);
};
pub const SN_sha3_512 = "SHA3-512";
pub const LN_sha3_512 = "sha3-512";
pub const NID_sha3_512 = @as(c_int, 1099);
pub const OBJ_sha3_512 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 10);
};
pub const SN_shake128 = "SHAKE128";
pub const LN_shake128 = "shake128";
pub const NID_shake128 = @as(c_int, 1100);
pub const OBJ_shake128 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 11);
};
pub const SN_shake256 = "SHAKE256";
pub const LN_shake256 = "shake256";
pub const NID_shake256 = @as(c_int, 1101);
pub const OBJ_shake256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 12);
};
pub const SN_hmac_sha3_224 = "id-hmacWithSHA3-224";
pub const LN_hmac_sha3_224 = "hmac-sha3-224";
pub const NID_hmac_sha3_224 = @as(c_int, 1102);
pub const OBJ_hmac_sha3_224 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 13);
};
pub const SN_hmac_sha3_256 = "id-hmacWithSHA3-256";
pub const LN_hmac_sha3_256 = "hmac-sha3-256";
pub const NID_hmac_sha3_256 = @as(c_int, 1103);
pub const OBJ_hmac_sha3_256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 14);
};
pub const SN_hmac_sha3_384 = "id-hmacWithSHA3-384";
pub const LN_hmac_sha3_384 = "hmac-sha3-384";
pub const NID_hmac_sha3_384 = @as(c_int, 1104);
pub const OBJ_hmac_sha3_384 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 15);
};
pub const SN_hmac_sha3_512 = "id-hmacWithSHA3-512";
pub const LN_hmac_sha3_512 = "hmac-sha3-512";
pub const NID_hmac_sha3_512 = @as(c_int, 1105);
pub const OBJ_hmac_sha3_512 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 16);
};
pub const SN_kmac128 = "KMAC128";
pub const LN_kmac128 = "kmac128";
pub const NID_kmac128 = @as(c_int, 1196);
pub const OBJ_kmac128 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 19);
};
pub const SN_kmac256 = "KMAC256";
pub const LN_kmac256 = "kmac256";
pub const NID_kmac256 = @as(c_int, 1197);
pub const OBJ_kmac256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 20);
};
pub const OBJ_dsa_with_sha2 = blk: {
    _ = &OBJ_nistAlgorithms;
    break :blk @as(c_long, 3);
};
pub const SN_dsa_with_SHA224 = "dsa_with_SHA224";
pub const NID_dsa_with_SHA224 = @as(c_int, 802);
pub const OBJ_dsa_with_SHA224 = blk: {
    _ = &OBJ_dsa_with_sha2;
    break :blk @as(c_long, 1);
};
pub const SN_dsa_with_SHA256 = "dsa_with_SHA256";
pub const NID_dsa_with_SHA256 = @as(c_int, 803);
pub const OBJ_dsa_with_SHA256 = blk: {
    _ = &OBJ_dsa_with_sha2;
    break :blk @as(c_long, 2);
};
pub const OBJ_sigAlgs = blk: {
    _ = &OBJ_nistAlgorithms;
    break :blk @as(c_long, 3);
};
pub const SN_dsa_with_SHA384 = "id-dsa-with-sha384";
pub const LN_dsa_with_SHA384 = "dsa_with_SHA384";
pub const NID_dsa_with_SHA384 = @as(c_int, 1106);
pub const OBJ_dsa_with_SHA384 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 3);
};
pub const SN_dsa_with_SHA512 = "id-dsa-with-sha512";
pub const LN_dsa_with_SHA512 = "dsa_with_SHA512";
pub const NID_dsa_with_SHA512 = @as(c_int, 1107);
pub const OBJ_dsa_with_SHA512 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 4);
};
pub const SN_dsa_with_SHA3_224 = "id-dsa-with-sha3-224";
pub const LN_dsa_with_SHA3_224 = "dsa_with_SHA3-224";
pub const NID_dsa_with_SHA3_224 = @as(c_int, 1108);
pub const OBJ_dsa_with_SHA3_224 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 5);
};
pub const SN_dsa_with_SHA3_256 = "id-dsa-with-sha3-256";
pub const LN_dsa_with_SHA3_256 = "dsa_with_SHA3-256";
pub const NID_dsa_with_SHA3_256 = @as(c_int, 1109);
pub const OBJ_dsa_with_SHA3_256 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 6);
};
pub const SN_dsa_with_SHA3_384 = "id-dsa-with-sha3-384";
pub const LN_dsa_with_SHA3_384 = "dsa_with_SHA3-384";
pub const NID_dsa_with_SHA3_384 = @as(c_int, 1110);
pub const OBJ_dsa_with_SHA3_384 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 7);
};
pub const SN_dsa_with_SHA3_512 = "id-dsa-with-sha3-512";
pub const LN_dsa_with_SHA3_512 = "dsa_with_SHA3-512";
pub const NID_dsa_with_SHA3_512 = @as(c_int, 1111);
pub const OBJ_dsa_with_SHA3_512 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 8);
};
pub const SN_ecdsa_with_SHA3_224 = "id-ecdsa-with-sha3-224";
pub const LN_ecdsa_with_SHA3_224 = "ecdsa_with_SHA3-224";
pub const NID_ecdsa_with_SHA3_224 = @as(c_int, 1112);
pub const OBJ_ecdsa_with_SHA3_224 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 9);
};
pub const SN_ecdsa_with_SHA3_256 = "id-ecdsa-with-sha3-256";
pub const LN_ecdsa_with_SHA3_256 = "ecdsa_with_SHA3-256";
pub const NID_ecdsa_with_SHA3_256 = @as(c_int, 1113);
pub const OBJ_ecdsa_with_SHA3_256 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 10);
};
pub const SN_ecdsa_with_SHA3_384 = "id-ecdsa-with-sha3-384";
pub const LN_ecdsa_with_SHA3_384 = "ecdsa_with_SHA3-384";
pub const NID_ecdsa_with_SHA3_384 = @as(c_int, 1114);
pub const OBJ_ecdsa_with_SHA3_384 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 11);
};
pub const SN_ecdsa_with_SHA3_512 = "id-ecdsa-with-sha3-512";
pub const LN_ecdsa_with_SHA3_512 = "ecdsa_with_SHA3-512";
pub const NID_ecdsa_with_SHA3_512 = @as(c_int, 1115);
pub const OBJ_ecdsa_with_SHA3_512 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 12);
};
pub const SN_RSA_SHA3_224 = "id-rsassa-pkcs1-v1_5-with-sha3-224";
pub const LN_RSA_SHA3_224 = "RSA-SHA3-224";
pub const NID_RSA_SHA3_224 = @as(c_int, 1116);
pub const OBJ_RSA_SHA3_224 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 13);
};
pub const SN_RSA_SHA3_256 = "id-rsassa-pkcs1-v1_5-with-sha3-256";
pub const LN_RSA_SHA3_256 = "RSA-SHA3-256";
pub const NID_RSA_SHA3_256 = @as(c_int, 1117);
pub const OBJ_RSA_SHA3_256 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 14);
};
pub const SN_RSA_SHA3_384 = "id-rsassa-pkcs1-v1_5-with-sha3-384";
pub const LN_RSA_SHA3_384 = "RSA-SHA3-384";
pub const NID_RSA_SHA3_384 = @as(c_int, 1118);
pub const OBJ_RSA_SHA3_384 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 15);
};
pub const SN_RSA_SHA3_512 = "id-rsassa-pkcs1-v1_5-with-sha3-512";
pub const LN_RSA_SHA3_512 = "RSA-SHA3-512";
pub const NID_RSA_SHA3_512 = @as(c_int, 1119);
pub const OBJ_RSA_SHA3_512 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 16);
};
pub const SN_hold_instruction_code = "holdInstructionCode";
pub const LN_hold_instruction_code = "Hold Instruction Code";
pub const NID_hold_instruction_code = @as(c_int, 430);
pub const OBJ_hold_instruction_code = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 23);
};
pub const OBJ_holdInstruction = blk: {
    _ = &OBJ_X9_57;
    break :blk @as(c_long, 2);
};
pub const SN_hold_instruction_none = "holdInstructionNone";
pub const LN_hold_instruction_none = "Hold Instruction None";
pub const NID_hold_instruction_none = @as(c_int, 431);
pub const OBJ_hold_instruction_none = blk: {
    _ = &OBJ_holdInstruction;
    break :blk @as(c_long, 1);
};
pub const SN_hold_instruction_call_issuer = "holdInstructionCallIssuer";
pub const LN_hold_instruction_call_issuer = "Hold Instruction Call Issuer";
pub const NID_hold_instruction_call_issuer = @as(c_int, 432);
pub const OBJ_hold_instruction_call_issuer = blk: {
    _ = &OBJ_holdInstruction;
    break :blk @as(c_long, 2);
};
pub const SN_hold_instruction_reject = "holdInstructionReject";
pub const LN_hold_instruction_reject = "Hold Instruction Reject";
pub const NID_hold_instruction_reject = @as(c_int, 433);
pub const OBJ_hold_instruction_reject = blk: {
    _ = &OBJ_holdInstruction;
    break :blk @as(c_long, 3);
};
pub const SN_itu_t_identified_organization = "itu-t-identified-organization";
pub const NID_itu_t_identified_organization = @as(c_int, 1264);
pub const OBJ_itu_t_identified_organization = blk: {
    _ = &OBJ_itu_t;
    break :blk @as(c_long, 4);
};
pub const SN_etsi = "etsi";
pub const NID_etsi = @as(c_int, 1265);
pub const OBJ_etsi = blk: {
    _ = &OBJ_itu_t_identified_organization;
    break :blk @as(c_long, 0);
};
pub const SN_electronic_signature_standard = "electronic-signature-standard";
pub const NID_electronic_signature_standard = @as(c_int, 1266);
pub const OBJ_electronic_signature_standard = blk: {
    _ = &OBJ_etsi;
    break :blk @as(c_long, 1733);
};
pub const SN_ess_attributes = "ess-attributes";
pub const NID_ess_attributes = @as(c_int, 1267);
pub const OBJ_ess_attributes = blk: {
    _ = &OBJ_electronic_signature_standard;
    break :blk @as(c_long, 2);
};
pub const SN_id_aa_ets_mimeType = "id-aa-ets-mimeType";
pub const NID_id_aa_ets_mimeType = @as(c_int, 1268);
pub const OBJ_id_aa_ets_mimeType = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 1);
};
pub const SN_id_aa_ets_longTermValidation = "id-aa-ets-longTermValidation";
pub const NID_id_aa_ets_longTermValidation = @as(c_int, 1269);
pub const OBJ_id_aa_ets_longTermValidation = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 2);
};
pub const SN_id_aa_ets_SignaturePolicyDocument = "id-aa-ets-SignaturePolicyDocument";
pub const NID_id_aa_ets_SignaturePolicyDocument = @as(c_int, 1270);
pub const OBJ_id_aa_ets_SignaturePolicyDocument = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 3);
};
pub const SN_id_aa_ets_archiveTimestampV3 = "id-aa-ets-archiveTimestampV3";
pub const NID_id_aa_ets_archiveTimestampV3 = @as(c_int, 1271);
pub const OBJ_id_aa_ets_archiveTimestampV3 = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 4);
};
pub const SN_id_aa_ATSHashIndex = "id-aa-ATSHashIndex";
pub const NID_id_aa_ATSHashIndex = @as(c_int, 1272);
pub const OBJ_id_aa_ATSHashIndex = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 5);
};
pub const SN_cades = "cades";
pub const NID_cades = @as(c_int, 1273);
pub const OBJ_cades = blk: {
    _ = &OBJ_etsi;
    break :blk @as(c_long, 19122);
};
pub const SN_cades_attributes = "cades-attributes";
pub const NID_cades_attributes = @as(c_int, 1274);
pub const OBJ_cades_attributes = blk: {
    _ = &OBJ_cades;
    break :blk @as(c_long, 1);
};
pub const SN_id_aa_ets_signerAttrV2 = "id-aa-ets-signerAttrV2";
pub const NID_id_aa_ets_signerAttrV2 = @as(c_int, 1275);
pub const OBJ_id_aa_ets_signerAttrV2 = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 1);
};
pub const SN_id_aa_ets_sigPolicyStore = "id-aa-ets-sigPolicyStore";
pub const NID_id_aa_ets_sigPolicyStore = @as(c_int, 1276);
pub const OBJ_id_aa_ets_sigPolicyStore = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 3);
};
pub const SN_id_aa_ATSHashIndex_v2 = "id-aa-ATSHashIndex-v2";
pub const NID_id_aa_ATSHashIndex_v2 = @as(c_int, 1277);
pub const OBJ_id_aa_ATSHashIndex_v2 = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 4);
};
pub const SN_id_aa_ATSHashIndex_v3 = "id-aa-ATSHashIndex-v3";
pub const NID_id_aa_ATSHashIndex_v3 = @as(c_int, 1278);
pub const OBJ_id_aa_ATSHashIndex_v3 = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 5);
};
pub const SN_signedAssertion = "signedAssertion";
pub const NID_signedAssertion = @as(c_int, 1279);
pub const OBJ_signedAssertion = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 6);
};
pub const SN_data = "data";
pub const NID_data = @as(c_int, 434);
pub const OBJ_data = blk: {
    _ = &OBJ_itu_t;
    break :blk @as(c_long, 9);
};
pub const SN_pss = "pss";
pub const NID_pss = @as(c_int, 435);
pub const OBJ_pss = blk: {
    _ = &OBJ_data;
    break :blk @as(c_long, 2342);
};
pub const SN_ucl = "ucl";
pub const NID_ucl = @as(c_int, 436);
pub const OBJ_ucl = blk: {
    _ = &OBJ_pss;
    break :blk @as(c_long, 19200300);
};
pub const SN_pilot = "pilot";
pub const NID_pilot = @as(c_int, 437);
pub const OBJ_pilot = blk: {
    _ = &OBJ_ucl;
    break :blk @as(c_long, 100);
};
pub const LN_pilotAttributeType = "pilotAttributeType";
pub const NID_pilotAttributeType = @as(c_int, 438);
pub const OBJ_pilotAttributeType = blk: {
    _ = &OBJ_pilot;
    break :blk @as(c_long, 1);
};
pub const LN_pilotAttributeSyntax = "pilotAttributeSyntax";
pub const NID_pilotAttributeSyntax = @as(c_int, 439);
pub const OBJ_pilotAttributeSyntax = blk: {
    _ = &OBJ_pilot;
    break :blk @as(c_long, 3);
};
pub const LN_pilotObjectClass = "pilotObjectClass";
pub const NID_pilotObjectClass = @as(c_int, 440);
pub const OBJ_pilotObjectClass = blk: {
    _ = &OBJ_pilot;
    break :blk @as(c_long, 4);
};
pub const LN_pilotGroups = "pilotGroups";
pub const NID_pilotGroups = @as(c_int, 441);
pub const OBJ_pilotGroups = blk: {
    _ = &OBJ_pilot;
    break :blk @as(c_long, 10);
};
pub const LN_iA5StringSyntax = "iA5StringSyntax";
pub const NID_iA5StringSyntax = @as(c_int, 442);
pub const OBJ_iA5StringSyntax = blk: {
    _ = &OBJ_pilotAttributeSyntax;
    break :blk @as(c_long, 4);
};
pub const LN_caseIgnoreIA5StringSyntax = "caseIgnoreIA5StringSyntax";
pub const NID_caseIgnoreIA5StringSyntax = @as(c_int, 443);
pub const OBJ_caseIgnoreIA5StringSyntax = blk: {
    _ = &OBJ_pilotAttributeSyntax;
    break :blk @as(c_long, 5);
};
pub const LN_pilotObject = "pilotObject";
pub const NID_pilotObject = @as(c_int, 444);
pub const OBJ_pilotObject = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 3);
};
pub const LN_pilotPerson = "pilotPerson";
pub const NID_pilotPerson = @as(c_int, 445);
pub const OBJ_pilotPerson = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 4);
};
pub const SN_account = "account";
pub const NID_account = @as(c_int, 446);
pub const OBJ_account = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 5);
};
pub const SN_document = "document";
pub const NID_document = @as(c_int, 447);
pub const OBJ_document = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 6);
};
pub const SN_room = "room";
pub const NID_room = @as(c_int, 448);
pub const OBJ_room = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 7);
};
pub const LN_documentSeries = "documentSeries";
pub const NID_documentSeries = @as(c_int, 449);
pub const OBJ_documentSeries = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 9);
};
pub const SN_Domain = "domain";
pub const LN_Domain = "Domain";
pub const NID_Domain = @as(c_int, 392);
pub const OBJ_Domain = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 13);
};
pub const LN_rFC822localPart = "rFC822localPart";
pub const NID_rFC822localPart = @as(c_int, 450);
pub const OBJ_rFC822localPart = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 14);
};
pub const LN_dNSDomain = "dNSDomain";
pub const NID_dNSDomain = @as(c_int, 451);
pub const OBJ_dNSDomain = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 15);
};
pub const LN_domainRelatedObject = "domainRelatedObject";
pub const NID_domainRelatedObject = @as(c_int, 452);
pub const OBJ_domainRelatedObject = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 17);
};
pub const LN_friendlyCountry = "friendlyCountry";
pub const NID_friendlyCountry = @as(c_int, 453);
pub const OBJ_friendlyCountry = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 18);
};
pub const LN_simpleSecurityObject = "simpleSecurityObject";
pub const NID_simpleSecurityObject = @as(c_int, 454);
pub const OBJ_simpleSecurityObject = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 19);
};
pub const LN_pilotOrganization = "pilotOrganization";
pub const NID_pilotOrganization = @as(c_int, 455);
pub const OBJ_pilotOrganization = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 20);
};
pub const LN_pilotDSA = "pilotDSA";
pub const NID_pilotDSA = @as(c_int, 456);
pub const OBJ_pilotDSA = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 21);
};
pub const LN_qualityLabelledData = "qualityLabelledData";
pub const NID_qualityLabelledData = @as(c_int, 457);
pub const OBJ_qualityLabelledData = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 22);
};
pub const SN_userId = "UID";
pub const LN_userId = "userId";
pub const NID_userId = @as(c_int, 458);
pub const OBJ_userId = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 1);
};
pub const LN_textEncodedORAddress = "textEncodedORAddress";
pub const NID_textEncodedORAddress = @as(c_int, 459);
pub const OBJ_textEncodedORAddress = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 2);
};
pub const SN_rfc822Mailbox = "mail";
pub const LN_rfc822Mailbox = "rfc822Mailbox";
pub const NID_rfc822Mailbox = @as(c_int, 460);
pub const OBJ_rfc822Mailbox = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 3);
};
pub const SN_info = "info";
pub const NID_info = @as(c_int, 461);
pub const OBJ_info = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 4);
};
pub const LN_favouriteDrink = "favouriteDrink";
pub const NID_favouriteDrink = @as(c_int, 462);
pub const OBJ_favouriteDrink = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 5);
};
pub const LN_roomNumber = "roomNumber";
pub const NID_roomNumber = @as(c_int, 463);
pub const OBJ_roomNumber = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 6);
};
pub const SN_photo = "photo";
pub const NID_photo = @as(c_int, 464);
pub const OBJ_photo = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 7);
};
pub const LN_userClass = "userClass";
pub const NID_userClass = @as(c_int, 465);
pub const OBJ_userClass = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 8);
};
pub const SN_host = "host";
pub const NID_host = @as(c_int, 466);
pub const OBJ_host = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 9);
};
pub const SN_manager = "manager";
pub const NID_manager = @as(c_int, 467);
pub const OBJ_manager = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 10);
};
pub const LN_documentIdentifier = "documentIdentifier";
pub const NID_documentIdentifier = @as(c_int, 468);
pub const OBJ_documentIdentifier = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 11);
};
pub const LN_documentTitle = "documentTitle";
pub const NID_documentTitle = @as(c_int, 469);
pub const OBJ_documentTitle = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 12);
};
pub const LN_documentVersion = "documentVersion";
pub const NID_documentVersion = @as(c_int, 470);
pub const OBJ_documentVersion = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 13);
};
pub const LN_documentAuthor = "documentAuthor";
pub const NID_documentAuthor = @as(c_int, 471);
pub const OBJ_documentAuthor = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 14);
};
pub const LN_documentLocation = "documentLocation";
pub const NID_documentLocation = @as(c_int, 472);
pub const OBJ_documentLocation = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 15);
};
pub const LN_homeTelephoneNumber = "homeTelephoneNumber";
pub const NID_homeTelephoneNumber = @as(c_int, 473);
pub const OBJ_homeTelephoneNumber = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 20);
};
pub const SN_secretary = "secretary";
pub const NID_secretary = @as(c_int, 474);
pub const OBJ_secretary = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 21);
};
pub const LN_otherMailbox = "otherMailbox";
pub const NID_otherMailbox = @as(c_int, 475);
pub const OBJ_otherMailbox = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 22);
};
pub const LN_lastModifiedTime = "lastModifiedTime";
pub const NID_lastModifiedTime = @as(c_int, 476);
pub const OBJ_lastModifiedTime = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 23);
};
pub const LN_lastModifiedBy = "lastModifiedBy";
pub const NID_lastModifiedBy = @as(c_int, 477);
pub const OBJ_lastModifiedBy = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 24);
};
pub const SN_domainComponent = "DC";
pub const LN_domainComponent = "domainComponent";
pub const NID_domainComponent = @as(c_int, 391);
pub const OBJ_domainComponent = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 25);
};
pub const LN_aRecord = "aRecord";
pub const NID_aRecord = @as(c_int, 478);
pub const OBJ_aRecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 26);
};
pub const LN_pilotAttributeType27 = "pilotAttributeType27";
pub const NID_pilotAttributeType27 = @as(c_int, 479);
pub const OBJ_pilotAttributeType27 = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 27);
};
pub const LN_mXRecord = "mXRecord";
pub const NID_mXRecord = @as(c_int, 480);
pub const OBJ_mXRecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 28);
};
pub const LN_nSRecord = "nSRecord";
pub const NID_nSRecord = @as(c_int, 481);
pub const OBJ_nSRecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 29);
};
pub const LN_sOARecord = "sOARecord";
pub const NID_sOARecord = @as(c_int, 482);
pub const OBJ_sOARecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 30);
};
pub const LN_cNAMERecord = "cNAMERecord";
pub const NID_cNAMERecord = @as(c_int, 483);
pub const OBJ_cNAMERecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 31);
};
pub const LN_associatedDomain = "associatedDomain";
pub const NID_associatedDomain = @as(c_int, 484);
pub const OBJ_associatedDomain = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 37);
};
pub const LN_associatedName = "associatedName";
pub const NID_associatedName = @as(c_int, 485);
pub const OBJ_associatedName = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 38);
};
pub const LN_homePostalAddress = "homePostalAddress";
pub const NID_homePostalAddress = @as(c_int, 486);
pub const OBJ_homePostalAddress = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 39);
};
pub const LN_personalTitle = "personalTitle";
pub const NID_personalTitle = @as(c_int, 487);
pub const OBJ_personalTitle = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 40);
};
pub const LN_mobileTelephoneNumber = "mobileTelephoneNumber";
pub const NID_mobileTelephoneNumber = @as(c_int, 488);
pub const OBJ_mobileTelephoneNumber = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 41);
};
pub const LN_pagerTelephoneNumber = "pagerTelephoneNumber";
pub const NID_pagerTelephoneNumber = @as(c_int, 489);
pub const OBJ_pagerTelephoneNumber = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 42);
};
pub const LN_friendlyCountryName = "friendlyCountryName";
pub const NID_friendlyCountryName = @as(c_int, 490);
pub const OBJ_friendlyCountryName = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 43);
};
pub const SN_uniqueIdentifier = "uid";
pub const LN_uniqueIdentifier = "uniqueIdentifier";
pub const NID_uniqueIdentifier = @as(c_int, 102);
pub const OBJ_uniqueIdentifier = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 44);
};
pub const LN_organizationalStatus = "organizationalStatus";
pub const NID_organizationalStatus = @as(c_int, 491);
pub const OBJ_organizationalStatus = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 45);
};
pub const LN_janetMailbox = "janetMailbox";
pub const NID_janetMailbox = @as(c_int, 492);
pub const OBJ_janetMailbox = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 46);
};
pub const LN_mailPreferenceOption = "mailPreferenceOption";
pub const NID_mailPreferenceOption = @as(c_int, 493);
pub const OBJ_mailPreferenceOption = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 47);
};
pub const LN_buildingName = "buildingName";
pub const NID_buildingName = @as(c_int, 494);
pub const OBJ_buildingName = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 48);
};
pub const LN_dSAQuality = "dSAQuality";
pub const NID_dSAQuality = @as(c_int, 495);
pub const OBJ_dSAQuality = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 49);
};
pub const LN_singleLevelQuality = "singleLevelQuality";
pub const NID_singleLevelQuality = @as(c_int, 496);
pub const OBJ_singleLevelQuality = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 50);
};
pub const LN_subtreeMinimumQuality = "subtreeMinimumQuality";
pub const NID_subtreeMinimumQuality = @as(c_int, 497);
pub const OBJ_subtreeMinimumQuality = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 51);
};
pub const LN_subtreeMaximumQuality = "subtreeMaximumQuality";
pub const NID_subtreeMaximumQuality = @as(c_int, 498);
pub const OBJ_subtreeMaximumQuality = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 52);
};
pub const LN_personalSignature = "personalSignature";
pub const NID_personalSignature = @as(c_int, 499);
pub const OBJ_personalSignature = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 53);
};
pub const LN_dITRedirect = "dITRedirect";
pub const NID_dITRedirect = @as(c_int, 500);
pub const OBJ_dITRedirect = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 54);
};
pub const SN_audio = "audio";
pub const NID_audio = @as(c_int, 501);
pub const OBJ_audio = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 55);
};
pub const LN_documentPublisher = "documentPublisher";
pub const NID_documentPublisher = @as(c_int, 502);
pub const OBJ_documentPublisher = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 56);
};
pub const SN_id_set = "id-set";
pub const LN_id_set = "Secure Electronic Transactions";
pub const NID_id_set = @as(c_int, 512);
pub const OBJ_id_set = blk: {
    _ = &OBJ_international_organizations;
    break :blk @as(c_long, 42);
};
pub const SN_set_ctype = "set-ctype";
pub const LN_set_ctype = "content types";
pub const NID_set_ctype = @as(c_int, 513);
pub const OBJ_set_ctype = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 0);
};
pub const SN_set_msgExt = "set-msgExt";
pub const LN_set_msgExt = "message extensions";
pub const NID_set_msgExt = @as(c_int, 514);
pub const OBJ_set_msgExt = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 1);
};
pub const SN_set_attr = "set-attr";
pub const NID_set_attr = @as(c_int, 515);
pub const OBJ_set_attr = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 3);
};
pub const SN_set_policy = "set-policy";
pub const NID_set_policy = @as(c_int, 516);
pub const OBJ_set_policy = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 5);
};
pub const SN_set_certExt = "set-certExt";
pub const LN_set_certExt = "certificate extensions";
pub const NID_set_certExt = @as(c_int, 517);
pub const OBJ_set_certExt = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 7);
};
pub const SN_set_brand = "set-brand";
pub const NID_set_brand = @as(c_int, 518);
pub const OBJ_set_brand = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 8);
};
pub const SN_setct_PANData = "setct-PANData";
pub const NID_setct_PANData = @as(c_int, 519);
pub const OBJ_setct_PANData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 0);
};
pub const SN_setct_PANToken = "setct-PANToken";
pub const NID_setct_PANToken = @as(c_int, 520);
pub const OBJ_setct_PANToken = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 1);
};
pub const SN_setct_PANOnly = "setct-PANOnly";
pub const NID_setct_PANOnly = @as(c_int, 521);
pub const OBJ_setct_PANOnly = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 2);
};
pub const SN_setct_OIData = "setct-OIData";
pub const NID_setct_OIData = @as(c_int, 522);
pub const OBJ_setct_OIData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 3);
};
pub const SN_setct_PI = "setct-PI";
pub const NID_setct_PI = @as(c_int, 523);
pub const OBJ_setct_PI = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 4);
};
pub const SN_setct_PIData = "setct-PIData";
pub const NID_setct_PIData = @as(c_int, 524);
pub const OBJ_setct_PIData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 5);
};
pub const SN_setct_PIDataUnsigned = "setct-PIDataUnsigned";
pub const NID_setct_PIDataUnsigned = @as(c_int, 525);
pub const OBJ_setct_PIDataUnsigned = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 6);
};
pub const SN_setct_HODInput = "setct-HODInput";
pub const NID_setct_HODInput = @as(c_int, 526);
pub const OBJ_setct_HODInput = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 7);
};
pub const SN_setct_AuthResBaggage = "setct-AuthResBaggage";
pub const NID_setct_AuthResBaggage = @as(c_int, 527);
pub const OBJ_setct_AuthResBaggage = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 8);
};
pub const SN_setct_AuthRevReqBaggage = "setct-AuthRevReqBaggage";
pub const NID_setct_AuthRevReqBaggage = @as(c_int, 528);
pub const OBJ_setct_AuthRevReqBaggage = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 9);
};
pub const SN_setct_AuthRevResBaggage = "setct-AuthRevResBaggage";
pub const NID_setct_AuthRevResBaggage = @as(c_int, 529);
pub const OBJ_setct_AuthRevResBaggage = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 10);
};
pub const SN_setct_CapTokenSeq = "setct-CapTokenSeq";
pub const NID_setct_CapTokenSeq = @as(c_int, 530);
pub const OBJ_setct_CapTokenSeq = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 11);
};
pub const SN_setct_PInitResData = "setct-PInitResData";
pub const NID_setct_PInitResData = @as(c_int, 531);
pub const OBJ_setct_PInitResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 12);
};
pub const SN_setct_PI_TBS = "setct-PI-TBS";
pub const NID_setct_PI_TBS = @as(c_int, 532);
pub const OBJ_setct_PI_TBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 13);
};
pub const SN_setct_PResData = "setct-PResData";
pub const NID_setct_PResData = @as(c_int, 533);
pub const OBJ_setct_PResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 14);
};
pub const SN_setct_AuthReqTBS = "setct-AuthReqTBS";
pub const NID_setct_AuthReqTBS = @as(c_int, 534);
pub const OBJ_setct_AuthReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 16);
};
pub const SN_setct_AuthResTBS = "setct-AuthResTBS";
pub const NID_setct_AuthResTBS = @as(c_int, 535);
pub const OBJ_setct_AuthResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 17);
};
pub const SN_setct_AuthResTBSX = "setct-AuthResTBSX";
pub const NID_setct_AuthResTBSX = @as(c_int, 536);
pub const OBJ_setct_AuthResTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 18);
};
pub const SN_setct_AuthTokenTBS = "setct-AuthTokenTBS";
pub const NID_setct_AuthTokenTBS = @as(c_int, 537);
pub const OBJ_setct_AuthTokenTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 19);
};
pub const SN_setct_CapTokenData = "setct-CapTokenData";
pub const NID_setct_CapTokenData = @as(c_int, 538);
pub const OBJ_setct_CapTokenData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 20);
};
pub const SN_setct_CapTokenTBS = "setct-CapTokenTBS";
pub const NID_setct_CapTokenTBS = @as(c_int, 539);
pub const OBJ_setct_CapTokenTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 21);
};
pub const SN_setct_AcqCardCodeMsg = "setct-AcqCardCodeMsg";
pub const NID_setct_AcqCardCodeMsg = @as(c_int, 540);
pub const OBJ_setct_AcqCardCodeMsg = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 22);
};
pub const SN_setct_AuthRevReqTBS = "setct-AuthRevReqTBS";
pub const NID_setct_AuthRevReqTBS = @as(c_int, 541);
pub const OBJ_setct_AuthRevReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 23);
};
pub const SN_setct_AuthRevResData = "setct-AuthRevResData";
pub const NID_setct_AuthRevResData = @as(c_int, 542);
pub const OBJ_setct_AuthRevResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 24);
};
pub const SN_setct_AuthRevResTBS = "setct-AuthRevResTBS";
pub const NID_setct_AuthRevResTBS = @as(c_int, 543);
pub const OBJ_setct_AuthRevResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 25);
};
pub const SN_setct_CapReqTBS = "setct-CapReqTBS";
pub const NID_setct_CapReqTBS = @as(c_int, 544);
pub const OBJ_setct_CapReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 26);
};
pub const SN_setct_CapReqTBSX = "setct-CapReqTBSX";
pub const NID_setct_CapReqTBSX = @as(c_int, 545);
pub const OBJ_setct_CapReqTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 27);
};
pub const SN_setct_CapResData = "setct-CapResData";
pub const NID_setct_CapResData = @as(c_int, 546);
pub const OBJ_setct_CapResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 28);
};
pub const SN_setct_CapRevReqTBS = "setct-CapRevReqTBS";
pub const NID_setct_CapRevReqTBS = @as(c_int, 547);
pub const OBJ_setct_CapRevReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 29);
};
pub const SN_setct_CapRevReqTBSX = "setct-CapRevReqTBSX";
pub const NID_setct_CapRevReqTBSX = @as(c_int, 548);
pub const OBJ_setct_CapRevReqTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 30);
};
pub const SN_setct_CapRevResData = "setct-CapRevResData";
pub const NID_setct_CapRevResData = @as(c_int, 549);
pub const OBJ_setct_CapRevResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 31);
};
pub const SN_setct_CredReqTBS = "setct-CredReqTBS";
pub const NID_setct_CredReqTBS = @as(c_int, 550);
pub const OBJ_setct_CredReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 32);
};
pub const SN_setct_CredReqTBSX = "setct-CredReqTBSX";
pub const NID_setct_CredReqTBSX = @as(c_int, 551);
pub const OBJ_setct_CredReqTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 33);
};
pub const SN_setct_CredResData = "setct-CredResData";
pub const NID_setct_CredResData = @as(c_int, 552);
pub const OBJ_setct_CredResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 34);
};
pub const SN_setct_CredRevReqTBS = "setct-CredRevReqTBS";
pub const NID_setct_CredRevReqTBS = @as(c_int, 553);
pub const OBJ_setct_CredRevReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 35);
};
pub const SN_setct_CredRevReqTBSX = "setct-CredRevReqTBSX";
pub const NID_setct_CredRevReqTBSX = @as(c_int, 554);
pub const OBJ_setct_CredRevReqTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 36);
};
pub const SN_setct_CredRevResData = "setct-CredRevResData";
pub const NID_setct_CredRevResData = @as(c_int, 555);
pub const OBJ_setct_CredRevResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 37);
};
pub const SN_setct_PCertReqData = "setct-PCertReqData";
pub const NID_setct_PCertReqData = @as(c_int, 556);
pub const OBJ_setct_PCertReqData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 38);
};
pub const SN_setct_PCertResTBS = "setct-PCertResTBS";
pub const NID_setct_PCertResTBS = @as(c_int, 557);
pub const OBJ_setct_PCertResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 39);
};
pub const SN_setct_BatchAdminReqData = "setct-BatchAdminReqData";
pub const NID_setct_BatchAdminReqData = @as(c_int, 558);
pub const OBJ_setct_BatchAdminReqData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 40);
};
pub const SN_setct_BatchAdminResData = "setct-BatchAdminResData";
pub const NID_setct_BatchAdminResData = @as(c_int, 559);
pub const OBJ_setct_BatchAdminResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 41);
};
pub const SN_setct_CardCInitResTBS = "setct-CardCInitResTBS";
pub const NID_setct_CardCInitResTBS = @as(c_int, 560);
pub const OBJ_setct_CardCInitResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 42);
};
pub const SN_setct_MeAqCInitResTBS = "setct-MeAqCInitResTBS";
pub const NID_setct_MeAqCInitResTBS = @as(c_int, 561);
pub const OBJ_setct_MeAqCInitResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 43);
};
pub const SN_setct_RegFormResTBS = "setct-RegFormResTBS";
pub const NID_setct_RegFormResTBS = @as(c_int, 562);
pub const OBJ_setct_RegFormResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 44);
};
pub const SN_setct_CertReqData = "setct-CertReqData";
pub const NID_setct_CertReqData = @as(c_int, 563);
pub const OBJ_setct_CertReqData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 45);
};
pub const SN_setct_CertReqTBS = "setct-CertReqTBS";
pub const NID_setct_CertReqTBS = @as(c_int, 564);
pub const OBJ_setct_CertReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 46);
};
pub const SN_setct_CertResData = "setct-CertResData";
pub const NID_setct_CertResData = @as(c_int, 565);
pub const OBJ_setct_CertResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 47);
};
pub const SN_setct_CertInqReqTBS = "setct-CertInqReqTBS";
pub const NID_setct_CertInqReqTBS = @as(c_int, 566);
pub const OBJ_setct_CertInqReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 48);
};
pub const SN_setct_ErrorTBS = "setct-ErrorTBS";
pub const NID_setct_ErrorTBS = @as(c_int, 567);
pub const OBJ_setct_ErrorTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 49);
};
pub const SN_setct_PIDualSignedTBE = "setct-PIDualSignedTBE";
pub const NID_setct_PIDualSignedTBE = @as(c_int, 568);
pub const OBJ_setct_PIDualSignedTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 50);
};
pub const SN_setct_PIUnsignedTBE = "setct-PIUnsignedTBE";
pub const NID_setct_PIUnsignedTBE = @as(c_int, 569);
pub const OBJ_setct_PIUnsignedTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 51);
};
pub const SN_setct_AuthReqTBE = "setct-AuthReqTBE";
pub const NID_setct_AuthReqTBE = @as(c_int, 570);
pub const OBJ_setct_AuthReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 52);
};
pub const SN_setct_AuthResTBE = "setct-AuthResTBE";
pub const NID_setct_AuthResTBE = @as(c_int, 571);
pub const OBJ_setct_AuthResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 53);
};
pub const SN_setct_AuthResTBEX = "setct-AuthResTBEX";
pub const NID_setct_AuthResTBEX = @as(c_int, 572);
pub const OBJ_setct_AuthResTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 54);
};
pub const SN_setct_AuthTokenTBE = "setct-AuthTokenTBE";
pub const NID_setct_AuthTokenTBE = @as(c_int, 573);
pub const OBJ_setct_AuthTokenTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 55);
};
pub const SN_setct_CapTokenTBE = "setct-CapTokenTBE";
pub const NID_setct_CapTokenTBE = @as(c_int, 574);
pub const OBJ_setct_CapTokenTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 56);
};
pub const SN_setct_CapTokenTBEX = "setct-CapTokenTBEX";
pub const NID_setct_CapTokenTBEX = @as(c_int, 575);
pub const OBJ_setct_CapTokenTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 57);
};
pub const SN_setct_AcqCardCodeMsgTBE = "setct-AcqCardCodeMsgTBE";
pub const NID_setct_AcqCardCodeMsgTBE = @as(c_int, 576);
pub const OBJ_setct_AcqCardCodeMsgTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 58);
};
pub const SN_setct_AuthRevReqTBE = "setct-AuthRevReqTBE";
pub const NID_setct_AuthRevReqTBE = @as(c_int, 577);
pub const OBJ_setct_AuthRevReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 59);
};
pub const SN_setct_AuthRevResTBE = "setct-AuthRevResTBE";
pub const NID_setct_AuthRevResTBE = @as(c_int, 578);
pub const OBJ_setct_AuthRevResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 60);
};
pub const SN_setct_AuthRevResTBEB = "setct-AuthRevResTBEB";
pub const NID_setct_AuthRevResTBEB = @as(c_int, 579);
pub const OBJ_setct_AuthRevResTBEB = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 61);
};
pub const SN_setct_CapReqTBE = "setct-CapReqTBE";
pub const NID_setct_CapReqTBE = @as(c_int, 580);
pub const OBJ_setct_CapReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 62);
};
pub const SN_setct_CapReqTBEX = "setct-CapReqTBEX";
pub const NID_setct_CapReqTBEX = @as(c_int, 581);
pub const OBJ_setct_CapReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 63);
};
pub const SN_setct_CapResTBE = "setct-CapResTBE";
pub const NID_setct_CapResTBE = @as(c_int, 582);
pub const OBJ_setct_CapResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 64);
};
pub const SN_setct_CapRevReqTBE = "setct-CapRevReqTBE";
pub const NID_setct_CapRevReqTBE = @as(c_int, 583);
pub const OBJ_setct_CapRevReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 65);
};
pub const SN_setct_CapRevReqTBEX = "setct-CapRevReqTBEX";
pub const NID_setct_CapRevReqTBEX = @as(c_int, 584);
pub const OBJ_setct_CapRevReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 66);
};
pub const SN_setct_CapRevResTBE = "setct-CapRevResTBE";
pub const NID_setct_CapRevResTBE = @as(c_int, 585);
pub const OBJ_setct_CapRevResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 67);
};
pub const SN_setct_CredReqTBE = "setct-CredReqTBE";
pub const NID_setct_CredReqTBE = @as(c_int, 586);
pub const OBJ_setct_CredReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 68);
};
pub const SN_setct_CredReqTBEX = "setct-CredReqTBEX";
pub const NID_setct_CredReqTBEX = @as(c_int, 587);
pub const OBJ_setct_CredReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 69);
};
pub const SN_setct_CredResTBE = "setct-CredResTBE";
pub const NID_setct_CredResTBE = @as(c_int, 588);
pub const OBJ_setct_CredResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 70);
};
pub const SN_setct_CredRevReqTBE = "setct-CredRevReqTBE";
pub const NID_setct_CredRevReqTBE = @as(c_int, 589);
pub const OBJ_setct_CredRevReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 71);
};
pub const SN_setct_CredRevReqTBEX = "setct-CredRevReqTBEX";
pub const NID_setct_CredRevReqTBEX = @as(c_int, 590);
pub const OBJ_setct_CredRevReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 72);
};
pub const SN_setct_CredRevResTBE = "setct-CredRevResTBE";
pub const NID_setct_CredRevResTBE = @as(c_int, 591);
pub const OBJ_setct_CredRevResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 73);
};
pub const SN_setct_BatchAdminReqTBE = "setct-BatchAdminReqTBE";
pub const NID_setct_BatchAdminReqTBE = @as(c_int, 592);
pub const OBJ_setct_BatchAdminReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 74);
};
pub const SN_setct_BatchAdminResTBE = "setct-BatchAdminResTBE";
pub const NID_setct_BatchAdminResTBE = @as(c_int, 593);
pub const OBJ_setct_BatchAdminResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 75);
};
pub const SN_setct_RegFormReqTBE = "setct-RegFormReqTBE";
pub const NID_setct_RegFormReqTBE = @as(c_int, 594);
pub const OBJ_setct_RegFormReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 76);
};
pub const SN_setct_CertReqTBE = "setct-CertReqTBE";
pub const NID_setct_CertReqTBE = @as(c_int, 595);
pub const OBJ_setct_CertReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 77);
};
pub const SN_setct_CertReqTBEX = "setct-CertReqTBEX";
pub const NID_setct_CertReqTBEX = @as(c_int, 596);
pub const OBJ_setct_CertReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 78);
};
pub const SN_setct_CertResTBE = "setct-CertResTBE";
pub const NID_setct_CertResTBE = @as(c_int, 597);
pub const OBJ_setct_CertResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 79);
};
pub const SN_setct_CRLNotificationTBS = "setct-CRLNotificationTBS";
pub const NID_setct_CRLNotificationTBS = @as(c_int, 598);
pub const OBJ_setct_CRLNotificationTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 80);
};
pub const SN_setct_CRLNotificationResTBS = "setct-CRLNotificationResTBS";
pub const NID_setct_CRLNotificationResTBS = @as(c_int, 599);
pub const OBJ_setct_CRLNotificationResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 81);
};
pub const SN_setct_BCIDistributionTBS = "setct-BCIDistributionTBS";
pub const NID_setct_BCIDistributionTBS = @as(c_int, 600);
pub const OBJ_setct_BCIDistributionTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 82);
};
pub const SN_setext_genCrypt = "setext-genCrypt";
pub const LN_setext_genCrypt = "generic cryptogram";
pub const NID_setext_genCrypt = @as(c_int, 601);
pub const OBJ_setext_genCrypt = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 1);
};
pub const SN_setext_miAuth = "setext-miAuth";
pub const LN_setext_miAuth = "merchant initiated auth";
pub const NID_setext_miAuth = @as(c_int, 602);
pub const OBJ_setext_miAuth = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 3);
};
pub const SN_setext_pinSecure = "setext-pinSecure";
pub const NID_setext_pinSecure = @as(c_int, 603);
pub const OBJ_setext_pinSecure = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 4);
};
pub const SN_setext_pinAny = "setext-pinAny";
pub const NID_setext_pinAny = @as(c_int, 604);
pub const OBJ_setext_pinAny = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 5);
};
pub const SN_setext_track2 = "setext-track2";
pub const NID_setext_track2 = @as(c_int, 605);
pub const OBJ_setext_track2 = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 7);
};
pub const SN_setext_cv = "setext-cv";
pub const LN_setext_cv = "additional verification";
pub const NID_setext_cv = @as(c_int, 606);
pub const OBJ_setext_cv = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 8);
};
pub const SN_set_policy_root = "set-policy-root";
pub const NID_set_policy_root = @as(c_int, 607);
pub const OBJ_set_policy_root = blk: {
    _ = &OBJ_set_policy;
    break :blk @as(c_long, 0);
};
pub const SN_setCext_hashedRoot = "setCext-hashedRoot";
pub const NID_setCext_hashedRoot = @as(c_int, 608);
pub const OBJ_setCext_hashedRoot = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 0);
};
pub const SN_setCext_certType = "setCext-certType";
pub const NID_setCext_certType = @as(c_int, 609);
pub const OBJ_setCext_certType = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 1);
};
pub const SN_setCext_merchData = "setCext-merchData";
pub const NID_setCext_merchData = @as(c_int, 610);
pub const OBJ_setCext_merchData = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 2);
};
pub const SN_setCext_cCertRequired = "setCext-cCertRequired";
pub const NID_setCext_cCertRequired = @as(c_int, 611);
pub const OBJ_setCext_cCertRequired = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 3);
};
pub const SN_setCext_tunneling = "setCext-tunneling";
pub const NID_setCext_tunneling = @as(c_int, 612);
pub const OBJ_setCext_tunneling = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 4);
};
pub const SN_setCext_setExt = "setCext-setExt";
pub const NID_setCext_setExt = @as(c_int, 613);
pub const OBJ_setCext_setExt = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 5);
};
pub const SN_setCext_setQualf = "setCext-setQualf";
pub const NID_setCext_setQualf = @as(c_int, 614);
pub const OBJ_setCext_setQualf = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 6);
};
pub const SN_setCext_PGWYcapabilities = "setCext-PGWYcapabilities";
pub const NID_setCext_PGWYcapabilities = @as(c_int, 615);
pub const OBJ_setCext_PGWYcapabilities = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 7);
};
pub const SN_setCext_TokenIdentifier = "setCext-TokenIdentifier";
pub const NID_setCext_TokenIdentifier = @as(c_int, 616);
pub const OBJ_setCext_TokenIdentifier = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 8);
};
pub const SN_setCext_Track2Data = "setCext-Track2Data";
pub const NID_setCext_Track2Data = @as(c_int, 617);
pub const OBJ_setCext_Track2Data = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 9);
};
pub const SN_setCext_TokenType = "setCext-TokenType";
pub const NID_setCext_TokenType = @as(c_int, 618);
pub const OBJ_setCext_TokenType = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 10);
};
pub const SN_setCext_IssuerCapabilities = "setCext-IssuerCapabilities";
pub const NID_setCext_IssuerCapabilities = @as(c_int, 619);
pub const OBJ_setCext_IssuerCapabilities = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 11);
};
pub const SN_setAttr_Cert = "setAttr-Cert";
pub const NID_setAttr_Cert = @as(c_int, 620);
pub const OBJ_setAttr_Cert = blk: {
    _ = &OBJ_set_attr;
    break :blk @as(c_long, 0);
};
pub const SN_setAttr_PGWYcap = "setAttr-PGWYcap";
pub const LN_setAttr_PGWYcap = "payment gateway capabilities";
pub const NID_setAttr_PGWYcap = @as(c_int, 621);
pub const OBJ_setAttr_PGWYcap = blk: {
    _ = &OBJ_set_attr;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_TokenType = "setAttr-TokenType";
pub const NID_setAttr_TokenType = @as(c_int, 622);
pub const OBJ_setAttr_TokenType = blk: {
    _ = &OBJ_set_attr;
    break :blk @as(c_long, 2);
};
pub const SN_setAttr_IssCap = "setAttr-IssCap";
pub const LN_setAttr_IssCap = "issuer capabilities";
pub const NID_setAttr_IssCap = @as(c_int, 623);
pub const OBJ_setAttr_IssCap = blk: {
    _ = &OBJ_set_attr;
    break :blk @as(c_long, 3);
};
pub const SN_set_rootKeyThumb = "set-rootKeyThumb";
pub const NID_set_rootKeyThumb = @as(c_int, 624);
pub const OBJ_set_rootKeyThumb = blk: {
    _ = &OBJ_setAttr_Cert;
    break :blk @as(c_long, 0);
};
pub const SN_set_addPolicy = "set-addPolicy";
pub const NID_set_addPolicy = @as(c_int, 625);
pub const OBJ_set_addPolicy = blk: {
    _ = &OBJ_setAttr_Cert;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_Token_EMV = "setAttr-Token-EMV";
pub const NID_setAttr_Token_EMV = @as(c_int, 626);
pub const OBJ_setAttr_Token_EMV = blk: {
    _ = &OBJ_setAttr_TokenType;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_Token_B0Prime = "setAttr-Token-B0Prime";
pub const NID_setAttr_Token_B0Prime = @as(c_int, 627);
pub const OBJ_setAttr_Token_B0Prime = blk: {
    _ = &OBJ_setAttr_TokenType;
    break :blk @as(c_long, 2);
};
pub const SN_setAttr_IssCap_CVM = "setAttr-IssCap-CVM";
pub const NID_setAttr_IssCap_CVM = @as(c_int, 628);
pub const OBJ_setAttr_IssCap_CVM = blk: {
    _ = &OBJ_setAttr_IssCap;
    break :blk @as(c_long, 3);
};
pub const SN_setAttr_IssCap_T2 = "setAttr-IssCap-T2";
pub const NID_setAttr_IssCap_T2 = @as(c_int, 629);
pub const OBJ_setAttr_IssCap_T2 = blk: {
    _ = &OBJ_setAttr_IssCap;
    break :blk @as(c_long, 4);
};
pub const SN_setAttr_IssCap_Sig = "setAttr-IssCap-Sig";
pub const NID_setAttr_IssCap_Sig = @as(c_int, 630);
pub const OBJ_setAttr_IssCap_Sig = blk: {
    _ = &OBJ_setAttr_IssCap;
    break :blk @as(c_long, 5);
};
pub const SN_setAttr_GenCryptgrm = "setAttr-GenCryptgrm";
pub const LN_setAttr_GenCryptgrm = "generate cryptogram";
pub const NID_setAttr_GenCryptgrm = @as(c_int, 631);
pub const OBJ_setAttr_GenCryptgrm = blk: {
    _ = &OBJ_setAttr_IssCap_CVM;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_T2Enc = "setAttr-T2Enc";
pub const LN_setAttr_T2Enc = "encrypted track 2";
pub const NID_setAttr_T2Enc = @as(c_int, 632);
pub const OBJ_setAttr_T2Enc = blk: {
    _ = &OBJ_setAttr_IssCap_T2;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_T2cleartxt = "setAttr-T2cleartxt";
pub const LN_setAttr_T2cleartxt = "cleartext track 2";
pub const NID_setAttr_T2cleartxt = @as(c_int, 633);
pub const OBJ_setAttr_T2cleartxt = blk: {
    _ = &OBJ_setAttr_IssCap_T2;
    break :blk @as(c_long, 2);
};
pub const SN_setAttr_TokICCsig = "setAttr-TokICCsig";
pub const LN_setAttr_TokICCsig = "ICC or token signature";
pub const NID_setAttr_TokICCsig = @as(c_int, 634);
pub const OBJ_setAttr_TokICCsig = blk: {
    _ = &OBJ_setAttr_IssCap_Sig;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_SecDevSig = "setAttr-SecDevSig";
pub const LN_setAttr_SecDevSig = "secure device signature";
pub const NID_setAttr_SecDevSig = @as(c_int, 635);
pub const OBJ_setAttr_SecDevSig = blk: {
    _ = &OBJ_setAttr_IssCap_Sig;
    break :blk @as(c_long, 2);
};
pub const SN_set_brand_IATA_ATA = "set-brand-IATA-ATA";
pub const NID_set_brand_IATA_ATA = @as(c_int, 636);
pub const OBJ_set_brand_IATA_ATA = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 1);
};
pub const SN_set_brand_Diners = "set-brand-Diners";
pub const NID_set_brand_Diners = @as(c_int, 637);
pub const OBJ_set_brand_Diners = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 30);
};
pub const SN_set_brand_AmericanExpress = "set-brand-AmericanExpress";
pub const NID_set_brand_AmericanExpress = @as(c_int, 638);
pub const OBJ_set_brand_AmericanExpress = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 34);
};
pub const SN_set_brand_JCB = "set-brand-JCB";
pub const NID_set_brand_JCB = @as(c_int, 639);
pub const OBJ_set_brand_JCB = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 35);
};
pub const SN_set_brand_Visa = "set-brand-Visa";
pub const NID_set_brand_Visa = @as(c_int, 640);
pub const OBJ_set_brand_Visa = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 4);
};
pub const SN_set_brand_MasterCard = "set-brand-MasterCard";
pub const NID_set_brand_MasterCard = @as(c_int, 641);
pub const OBJ_set_brand_MasterCard = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 5);
};
pub const SN_set_brand_Novus = "set-brand-Novus";
pub const NID_set_brand_Novus = @as(c_int, 642);
pub const OBJ_set_brand_Novus = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 6011);
};
pub const SN_des_cdmf = "DES-CDMF";
pub const LN_des_cdmf = "des-cdmf";
pub const NID_des_cdmf = @as(c_int, 643);
pub const OBJ_des_cdmf = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 10);
};
pub const SN_rsaOAEPEncryptionSET = "rsaOAEPEncryptionSET";
pub const NID_rsaOAEPEncryptionSET = @as(c_int, 644);
pub const OBJ_rsaOAEPEncryptionSET = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 6);
};
pub const SN_ipsec3 = "Oakley-EC2N-3";
pub const LN_ipsec3 = "ipsec3";
pub const NID_ipsec3 = @as(c_int, 749);
pub const SN_ipsec4 = "Oakley-EC2N-4";
pub const LN_ipsec4 = "ipsec4";
pub const NID_ipsec4 = @as(c_int, 750);
pub const SN_whirlpool = "whirlpool";
pub const NID_whirlpool = @as(c_int, 804);
pub const OBJ_whirlpool = blk: {
    _ = &OBJ_iso;
    _ = @as(c_long, 0);
    _ = @as(c_long, 10118);
    _ = @as(c_long, 3);
    _ = @as(c_long, 0);
    break :blk @as(c_long, 55);
};
pub const SN_cryptopro = "cryptopro";
pub const NID_cryptopro = @as(c_int, 805);
pub const OBJ_cryptopro = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_cryptocom = "cryptocom";
pub const NID_cryptocom = @as(c_int, 806);
pub const OBJ_cryptocom = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 9);
};
pub const SN_id_tc26 = "id-tc26";
pub const NID_id_tc26 = @as(c_int, 974);
pub const OBJ_id_tc26 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 7);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3411_94_with_GostR3410_2001 = "id-GostR3411-94-with-GostR3410-2001";
pub const LN_id_GostR3411_94_with_GostR3410_2001 = "GOST R 34.11-94 with GOST R 34.10-2001";
pub const NID_id_GostR3411_94_with_GostR3410_2001 = @as(c_int, 807);
pub const OBJ_id_GostR3411_94_with_GostR3410_2001 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3411_94_with_GostR3410_94 = "id-GostR3411-94-with-GostR3410-94";
pub const LN_id_GostR3411_94_with_GostR3410_94 = "GOST R 34.11-94 with GOST R 34.10-94";
pub const NID_id_GostR3411_94_with_GostR3410_94 = @as(c_int, 808);
pub const OBJ_id_GostR3411_94_with_GostR3410_94 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 4);
};
pub const SN_id_GostR3411_94 = "md_gost94";
pub const LN_id_GostR3411_94 = "GOST R 34.11-94";
pub const NID_id_GostR3411_94 = @as(c_int, 809);
pub const OBJ_id_GostR3411_94 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 9);
};
pub const SN_id_HMACGostR3411_94 = "id-HMACGostR3411-94";
pub const LN_id_HMACGostR3411_94 = "HMAC GOST 34.11-94";
pub const NID_id_HMACGostR3411_94 = @as(c_int, 810);
pub const OBJ_id_HMACGostR3411_94 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 10);
};
pub const SN_id_GostR3410_2001 = "gost2001";
pub const LN_id_GostR3410_2001 = "GOST R 34.10-2001";
pub const NID_id_GostR3410_2001 = @as(c_int, 811);
pub const OBJ_id_GostR3410_2001 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 19);
};
pub const SN_id_GostR3410_94 = "gost94";
pub const LN_id_GostR3410_94 = "GOST R 34.10-94";
pub const NID_id_GostR3410_94 = @as(c_int, 812);
pub const OBJ_id_GostR3410_94 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 20);
};
pub const SN_id_Gost28147_89 = "gost89";
pub const LN_id_Gost28147_89 = "GOST 28147-89";
pub const NID_id_Gost28147_89 = @as(c_int, 813);
pub const OBJ_id_Gost28147_89 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 21);
};
pub const SN_gost89_cnt = "gost89-cnt";
pub const NID_gost89_cnt = @as(c_int, 814);
pub const SN_gost89_cnt_12 = "gost89-cnt-12";
pub const NID_gost89_cnt_12 = @as(c_int, 975);
pub const SN_gost89_cbc = "gost89-cbc";
pub const NID_gost89_cbc = @as(c_int, 1009);
pub const SN_gost89_ecb = "gost89-ecb";
pub const NID_gost89_ecb = @as(c_int, 1010);
pub const SN_gost89_ctr = "gost89-ctr";
pub const NID_gost89_ctr = @as(c_int, 1011);
pub const SN_id_Gost28147_89_MAC = "gost-mac";
pub const LN_id_Gost28147_89_MAC = "GOST 28147-89 MAC";
pub const NID_id_Gost28147_89_MAC = @as(c_int, 815);
pub const OBJ_id_Gost28147_89_MAC = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 22);
};
pub const SN_gost_mac_12 = "gost-mac-12";
pub const NID_gost_mac_12 = @as(c_int, 976);
pub const SN_id_GostR3411_94_prf = "prf-gostr3411-94";
pub const LN_id_GostR3411_94_prf = "GOST R 34.11-94 PRF";
pub const NID_id_GostR3411_94_prf = @as(c_int, 816);
pub const OBJ_id_GostR3411_94_prf = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 23);
};
pub const SN_id_GostR3410_2001DH = "id-GostR3410-2001DH";
pub const LN_id_GostR3410_2001DH = "GOST R 34.10-2001 DH";
pub const NID_id_GostR3410_2001DH = @as(c_int, 817);
pub const OBJ_id_GostR3410_2001DH = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 98);
};
pub const SN_id_GostR3410_94DH = "id-GostR3410-94DH";
pub const LN_id_GostR3410_94DH = "GOST R 34.10-94 DH";
pub const NID_id_GostR3410_94DH = @as(c_int, 818);
pub const OBJ_id_GostR3410_94DH = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 99);
};
pub const SN_id_Gost28147_89_CryptoPro_KeyMeshing = "id-Gost28147-89-CryptoPro-KeyMeshing";
pub const NID_id_Gost28147_89_CryptoPro_KeyMeshing = @as(c_int, 819);
pub const OBJ_id_Gost28147_89_CryptoPro_KeyMeshing = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 1);
};
pub const SN_id_Gost28147_89_None_KeyMeshing = "id-Gost28147-89-None-KeyMeshing";
pub const NID_id_Gost28147_89_None_KeyMeshing = @as(c_int, 820);
pub const OBJ_id_Gost28147_89_None_KeyMeshing = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3411_94_TestParamSet = "id-GostR3411-94-TestParamSet";
pub const NID_id_GostR3411_94_TestParamSet = @as(c_int, 821);
pub const OBJ_id_GostR3411_94_TestParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 30);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3411_94_CryptoProParamSet = "id-GostR3411-94-CryptoProParamSet";
pub const NID_id_GostR3411_94_CryptoProParamSet = @as(c_int, 822);
pub const OBJ_id_GostR3411_94_CryptoProParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 30);
    break :blk @as(c_long, 1);
};
pub const SN_id_Gost28147_89_TestParamSet = "id-Gost28147-89-TestParamSet";
pub const NID_id_Gost28147_89_TestParamSet = @as(c_int, 823);
pub const OBJ_id_Gost28147_89_TestParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 0);
};
pub const SN_id_Gost28147_89_CryptoPro_A_ParamSet = "id-Gost28147-89-CryptoPro-A-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_A_ParamSet = @as(c_int, 824);
pub const OBJ_id_Gost28147_89_CryptoPro_A_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 1);
};
pub const SN_id_Gost28147_89_CryptoPro_B_ParamSet = "id-Gost28147-89-CryptoPro-B-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_B_ParamSet = @as(c_int, 825);
pub const OBJ_id_Gost28147_89_CryptoPro_B_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 2);
};
pub const SN_id_Gost28147_89_CryptoPro_C_ParamSet = "id-Gost28147-89-CryptoPro-C-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_C_ParamSet = @as(c_int, 826);
pub const OBJ_id_Gost28147_89_CryptoPro_C_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 3);
};
pub const SN_id_Gost28147_89_CryptoPro_D_ParamSet = "id-Gost28147-89-CryptoPro-D-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_D_ParamSet = @as(c_int, 827);
pub const OBJ_id_Gost28147_89_CryptoPro_D_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 4);
};
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet = "id-Gost28147-89-CryptoPro-Oscar-1-1-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet = @as(c_int, 828);
pub const OBJ_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 5);
};
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet = "id-Gost28147-89-CryptoPro-Oscar-1-0-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet = @as(c_int, 829);
pub const OBJ_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 6);
};
pub const SN_id_Gost28147_89_CryptoPro_RIC_1_ParamSet = "id-Gost28147-89-CryptoPro-RIC-1-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_RIC_1_ParamSet = @as(c_int, 830);
pub const OBJ_id_Gost28147_89_CryptoPro_RIC_1_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 7);
};
pub const SN_id_GostR3410_94_TestParamSet = "id-GostR3410-94-TestParamSet";
pub const NID_id_GostR3410_94_TestParamSet = @as(c_int, 831);
pub const OBJ_id_GostR3410_94_TestParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3410_94_CryptoPro_A_ParamSet = "id-GostR3410-94-CryptoPro-A-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_A_ParamSet = @as(c_int, 832);
pub const OBJ_id_GostR3410_94_CryptoPro_A_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3410_94_CryptoPro_B_ParamSet = "id-GostR3410-94-CryptoPro-B-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_B_ParamSet = @as(c_int, 833);
pub const OBJ_id_GostR3410_94_CryptoPro_B_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_94_CryptoPro_C_ParamSet = "id-GostR3410-94-CryptoPro-C-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_C_ParamSet = @as(c_int, 834);
pub const OBJ_id_GostR3410_94_CryptoPro_C_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 4);
};
pub const SN_id_GostR3410_94_CryptoPro_D_ParamSet = "id-GostR3410-94-CryptoPro-D-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_D_ParamSet = @as(c_int, 835);
pub const OBJ_id_GostR3410_94_CryptoPro_D_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 5);
};
pub const SN_id_GostR3410_94_CryptoPro_XchA_ParamSet = "id-GostR3410-94-CryptoPro-XchA-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_XchA_ParamSet = @as(c_int, 836);
pub const OBJ_id_GostR3410_94_CryptoPro_XchA_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 33);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_94_CryptoPro_XchB_ParamSet = "id-GostR3410-94-CryptoPro-XchB-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_XchB_ParamSet = @as(c_int, 837);
pub const OBJ_id_GostR3410_94_CryptoPro_XchB_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 33);
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3410_94_CryptoPro_XchC_ParamSet = "id-GostR3410-94-CryptoPro-XchC-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_XchC_ParamSet = @as(c_int, 838);
pub const OBJ_id_GostR3410_94_CryptoPro_XchC_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 33);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_2001_TestParamSet = "id-GostR3410-2001-TestParamSet";
pub const NID_id_GostR3410_2001_TestParamSet = @as(c_int, 839);
pub const OBJ_id_GostR3410_2001_TestParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 35);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3410_2001_CryptoPro_A_ParamSet = "id-GostR3410-2001-CryptoPro-A-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_A_ParamSet = @as(c_int, 840);
pub const OBJ_id_GostR3410_2001_CryptoPro_A_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 35);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_2001_CryptoPro_B_ParamSet = "id-GostR3410-2001-CryptoPro-B-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_B_ParamSet = @as(c_int, 841);
pub const OBJ_id_GostR3410_2001_CryptoPro_B_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 35);
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3410_2001_CryptoPro_C_ParamSet = "id-GostR3410-2001-CryptoPro-C-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_C_ParamSet = @as(c_int, 842);
pub const OBJ_id_GostR3410_2001_CryptoPro_C_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 35);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_2001_CryptoPro_XchA_ParamSet = "id-GostR3410-2001-CryptoPro-XchA-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet = @as(c_int, 843);
pub const OBJ_id_GostR3410_2001_CryptoPro_XchA_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 36);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3410_2001_CryptoPro_XchB_ParamSet = "id-GostR3410-2001-CryptoPro-XchB-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet = @as(c_int, 844);
pub const OBJ_id_GostR3410_2001_CryptoPro_XchB_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 36);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_94_a = "id-GostR3410-94-a";
pub const NID_id_GostR3410_94_a = @as(c_int, 845);
pub const OBJ_id_GostR3410_94_a = blk: {
    _ = &OBJ_id_GostR3410_94;
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_94_aBis = "id-GostR3410-94-aBis";
pub const NID_id_GostR3410_94_aBis = @as(c_int, 846);
pub const OBJ_id_GostR3410_94_aBis = blk: {
    _ = &OBJ_id_GostR3410_94;
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3410_94_b = "id-GostR3410-94-b";
pub const NID_id_GostR3410_94_b = @as(c_int, 847);
pub const OBJ_id_GostR3410_94_b = blk: {
    _ = &OBJ_id_GostR3410_94;
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_94_bBis = "id-GostR3410-94-bBis";
pub const NID_id_GostR3410_94_bBis = @as(c_int, 848);
pub const OBJ_id_GostR3410_94_bBis = blk: {
    _ = &OBJ_id_GostR3410_94;
    break :blk @as(c_long, 4);
};
pub const SN_id_Gost28147_89_cc = "id-Gost28147-89-cc";
pub const LN_id_Gost28147_89_cc = "GOST 28147-89 Cryptocom ParamSet";
pub const NID_id_Gost28147_89_cc = @as(c_int, 849);
pub const OBJ_id_Gost28147_89_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 6);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_94_cc = "gost94cc";
pub const LN_id_GostR3410_94_cc = "GOST 34.10-94 Cryptocom";
pub const NID_id_GostR3410_94_cc = @as(c_int, 850);
pub const OBJ_id_GostR3410_94_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_2001_cc = "gost2001cc";
pub const LN_id_GostR3410_2001_cc = "GOST 34.10-2001 Cryptocom";
pub const NID_id_GostR3410_2001_cc = @as(c_int, 851);
pub const OBJ_id_GostR3410_2001_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    break :blk @as(c_long, 4);
};
pub const SN_id_GostR3411_94_with_GostR3410_94_cc = "id-GostR3411-94-with-GostR3410-94-cc";
pub const LN_id_GostR3411_94_with_GostR3410_94_cc = "GOST R 34.11-94 with GOST R 34.10-94 Cryptocom";
pub const NID_id_GostR3411_94_with_GostR3410_94_cc = @as(c_int, 852);
pub const OBJ_id_GostR3411_94_with_GostR3410_94_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3411_94_with_GostR3410_2001_cc = "id-GostR3411-94-with-GostR3410-2001-cc";
pub const LN_id_GostR3411_94_with_GostR3410_2001_cc = "GOST R 34.11-94 with GOST R 34.10-2001 Cryptocom";
pub const NID_id_GostR3411_94_with_GostR3410_2001_cc = @as(c_int, 853);
pub const OBJ_id_GostR3411_94_with_GostR3410_2001_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const SN_id_GostR3410_2001_ParamSet_cc = "id-GostR3410-2001-ParamSet-cc";
pub const LN_id_GostR3410_2001_ParamSet_cc = "GOST R 3410-2001 Parameter Set Cryptocom";
pub const NID_id_GostR3410_2001_ParamSet_cc = @as(c_int, 854);
pub const OBJ_id_GostR3410_2001_ParamSet_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 8);
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_algorithms = "id-tc26-algorithms";
pub const NID_id_tc26_algorithms = @as(c_int, 977);
pub const OBJ_id_tc26_algorithms = blk: {
    _ = &OBJ_id_tc26;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_sign = "id-tc26-sign";
pub const NID_id_tc26_sign = @as(c_int, 978);
pub const OBJ_id_tc26_sign = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_2012_256 = "gost2012_256";
pub const LN_id_GostR3410_2012_256 = "GOST R 34.10-2012 with 256 bit modulus";
pub const NID_id_GostR3410_2012_256 = @as(c_int, 979);
pub const OBJ_id_GostR3410_2012_256 = blk: {
    _ = &OBJ_id_tc26_sign;
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_2012_512 = "gost2012_512";
pub const LN_id_GostR3410_2012_512 = "GOST R 34.10-2012 with 512 bit modulus";
pub const NID_id_GostR3410_2012_512 = @as(c_int, 980);
pub const OBJ_id_GostR3410_2012_512 = blk: {
    _ = &OBJ_id_tc26_sign;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_digest = "id-tc26-digest";
pub const NID_id_tc26_digest = @as(c_int, 981);
pub const OBJ_id_tc26_digest = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3411_2012_256 = "md_gost12_256";
pub const LN_id_GostR3411_2012_256 = "GOST R 34.11-2012 with 256 bit hash";
pub const NID_id_GostR3411_2012_256 = @as(c_int, 982);
pub const OBJ_id_GostR3411_2012_256 = blk: {
    _ = &OBJ_id_tc26_digest;
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3411_2012_512 = "md_gost12_512";
pub const LN_id_GostR3411_2012_512 = "GOST R 34.11-2012 with 512 bit hash";
pub const NID_id_GostR3411_2012_512 = @as(c_int, 983);
pub const OBJ_id_GostR3411_2012_512 = blk: {
    _ = &OBJ_id_tc26_digest;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_signwithdigest = "id-tc26-signwithdigest";
pub const NID_id_tc26_signwithdigest = @as(c_int, 984);
pub const OBJ_id_tc26_signwithdigest = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_signwithdigest_gost3410_2012_256 = "id-tc26-signwithdigest-gost3410-2012-256";
pub const LN_id_tc26_signwithdigest_gost3410_2012_256 = "GOST R 34.10-2012 with GOST R 34.11-2012 (256 bit)";
pub const NID_id_tc26_signwithdigest_gost3410_2012_256 = @as(c_int, 985);
pub const OBJ_id_tc26_signwithdigest_gost3410_2012_256 = blk: {
    _ = &OBJ_id_tc26_signwithdigest;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_signwithdigest_gost3410_2012_512 = "id-tc26-signwithdigest-gost3410-2012-512";
pub const LN_id_tc26_signwithdigest_gost3410_2012_512 = "GOST R 34.10-2012 with GOST R 34.11-2012 (512 bit)";
pub const NID_id_tc26_signwithdigest_gost3410_2012_512 = @as(c_int, 986);
pub const OBJ_id_tc26_signwithdigest_gost3410_2012_512 = blk: {
    _ = &OBJ_id_tc26_signwithdigest;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_mac = "id-tc26-mac";
pub const NID_id_tc26_mac = @as(c_int, 987);
pub const OBJ_id_tc26_mac = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 4);
};
pub const SN_id_tc26_hmac_gost_3411_2012_256 = "id-tc26-hmac-gost-3411-2012-256";
pub const LN_id_tc26_hmac_gost_3411_2012_256 = "HMAC GOST 34.11-2012 256 bit";
pub const NID_id_tc26_hmac_gost_3411_2012_256 = @as(c_int, 988);
pub const OBJ_id_tc26_hmac_gost_3411_2012_256 = blk: {
    _ = &OBJ_id_tc26_mac;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_hmac_gost_3411_2012_512 = "id-tc26-hmac-gost-3411-2012-512";
pub const LN_id_tc26_hmac_gost_3411_2012_512 = "HMAC GOST 34.11-2012 512 bit";
pub const NID_id_tc26_hmac_gost_3411_2012_512 = @as(c_int, 989);
pub const OBJ_id_tc26_hmac_gost_3411_2012_512 = blk: {
    _ = &OBJ_id_tc26_mac;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_cipher = "id-tc26-cipher";
pub const NID_id_tc26_cipher = @as(c_int, 990);
pub const OBJ_id_tc26_cipher = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 5);
};
pub const SN_id_tc26_cipher_gostr3412_2015_magma = "id-tc26-cipher-gostr3412-2015-magma";
pub const NID_id_tc26_cipher_gostr3412_2015_magma = @as(c_int, 1173);
pub const OBJ_id_tc26_cipher_gostr3412_2015_magma = blk: {
    _ = &OBJ_id_tc26_cipher;
    break :blk @as(c_long, 1);
};
pub const SN_magma_ctr_acpkm = "magma-ctr-acpkm";
pub const NID_magma_ctr_acpkm = @as(c_int, 1174);
pub const OBJ_magma_ctr_acpkm = blk: {
    _ = &OBJ_id_tc26_cipher_gostr3412_2015_magma;
    break :blk @as(c_long, 1);
};
pub const SN_magma_ctr_acpkm_omac = "magma-ctr-acpkm-omac";
pub const NID_magma_ctr_acpkm_omac = @as(c_int, 1175);
pub const OBJ_magma_ctr_acpkm_omac = blk: {
    _ = &OBJ_id_tc26_cipher_gostr3412_2015_magma;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik = "id-tc26-cipher-gostr3412-2015-kuznyechik";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik = @as(c_int, 1176);
pub const OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik = blk: {
    _ = &OBJ_id_tc26_cipher;
    break :blk @as(c_long, 2);
};
pub const SN_kuznyechik_ctr_acpkm = "kuznyechik-ctr-acpkm";
pub const NID_kuznyechik_ctr_acpkm = @as(c_int, 1177);
pub const OBJ_kuznyechik_ctr_acpkm = blk: {
    _ = &OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik;
    break :blk @as(c_long, 1);
};
pub const SN_kuznyechik_ctr_acpkm_omac = "kuznyechik-ctr-acpkm-omac";
pub const NID_kuznyechik_ctr_acpkm_omac = @as(c_int, 1178);
pub const OBJ_kuznyechik_ctr_acpkm_omac = blk: {
    _ = &OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_agreement = "id-tc26-agreement";
pub const NID_id_tc26_agreement = @as(c_int, 991);
pub const OBJ_id_tc26_agreement = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 6);
};
pub const SN_id_tc26_agreement_gost_3410_2012_256 = "id-tc26-agreement-gost-3410-2012-256";
pub const NID_id_tc26_agreement_gost_3410_2012_256 = @as(c_int, 992);
pub const OBJ_id_tc26_agreement_gost_3410_2012_256 = blk: {
    _ = &OBJ_id_tc26_agreement;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_agreement_gost_3410_2012_512 = "id-tc26-agreement-gost-3410-2012-512";
pub const NID_id_tc26_agreement_gost_3410_2012_512 = @as(c_int, 993);
pub const OBJ_id_tc26_agreement_gost_3410_2012_512 = blk: {
    _ = &OBJ_id_tc26_agreement;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_wrap = "id-tc26-wrap";
pub const NID_id_tc26_wrap = @as(c_int, 1179);
pub const OBJ_id_tc26_wrap = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 7);
};
pub const SN_id_tc26_wrap_gostr3412_2015_magma = "id-tc26-wrap-gostr3412-2015-magma";
pub const NID_id_tc26_wrap_gostr3412_2015_magma = @as(c_int, 1180);
pub const OBJ_id_tc26_wrap_gostr3412_2015_magma = blk: {
    _ = &OBJ_id_tc26_wrap;
    break :blk @as(c_long, 1);
};
pub const SN_magma_kexp15 = "magma-kexp15";
pub const NID_magma_kexp15 = @as(c_int, 1181);
pub const OBJ_magma_kexp15 = blk: {
    _ = &OBJ_id_tc26_wrap_gostr3412_2015_magma;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik = "id-tc26-wrap-gostr3412-2015-kuznyechik";
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik = @as(c_int, 1182);
pub const OBJ_id_tc26_wrap_gostr3412_2015_kuznyechik = blk: {
    _ = &OBJ_id_tc26_wrap;
    break :blk @as(c_long, 2);
};
pub const SN_kuznyechik_kexp15 = "kuznyechik-kexp15";
pub const NID_kuznyechik_kexp15 = @as(c_int, 1183);
pub const OBJ_kuznyechik_kexp15 = blk: {
    _ = &OBJ_id_tc26_wrap_gostr3412_2015_kuznyechik;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_constants = "id-tc26-constants";
pub const NID_id_tc26_constants = @as(c_int, 994);
pub const OBJ_id_tc26_constants = blk: {
    _ = &OBJ_id_tc26;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_sign_constants = "id-tc26-sign-constants";
pub const NID_id_tc26_sign_constants = @as(c_int, 995);
pub const OBJ_id_tc26_sign_constants = blk: {
    _ = &OBJ_id_tc26_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_3410_2012_256_constants = "id-tc26-gost-3410-2012-256-constants";
pub const NID_id_tc26_gost_3410_2012_256_constants = @as(c_int, 1147);
pub const OBJ_id_tc26_gost_3410_2012_256_constants = blk: {
    _ = &OBJ_id_tc26_sign_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_3410_2012_256_paramSetA = "id-tc26-gost-3410-2012-256-paramSetA";
pub const LN_id_tc26_gost_3410_2012_256_paramSetA = "GOST R 34.10-2012 (256 bit) ParamSet A";
pub const NID_id_tc26_gost_3410_2012_256_paramSetA = @as(c_int, 1148);
pub const OBJ_id_tc26_gost_3410_2012_256_paramSetA = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_256_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_3410_2012_256_paramSetB = "id-tc26-gost-3410-2012-256-paramSetB";
pub const LN_id_tc26_gost_3410_2012_256_paramSetB = "GOST R 34.10-2012 (256 bit) ParamSet B";
pub const NID_id_tc26_gost_3410_2012_256_paramSetB = @as(c_int, 1184);
pub const OBJ_id_tc26_gost_3410_2012_256_paramSetB = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_256_constants;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_gost_3410_2012_256_paramSetC = "id-tc26-gost-3410-2012-256-paramSetC";
pub const LN_id_tc26_gost_3410_2012_256_paramSetC = "GOST R 34.10-2012 (256 bit) ParamSet C";
pub const NID_id_tc26_gost_3410_2012_256_paramSetC = @as(c_int, 1185);
pub const OBJ_id_tc26_gost_3410_2012_256_paramSetC = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_256_constants;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_gost_3410_2012_256_paramSetD = "id-tc26-gost-3410-2012-256-paramSetD";
pub const LN_id_tc26_gost_3410_2012_256_paramSetD = "GOST R 34.10-2012 (256 bit) ParamSet D";
pub const NID_id_tc26_gost_3410_2012_256_paramSetD = @as(c_int, 1186);
pub const OBJ_id_tc26_gost_3410_2012_256_paramSetD = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_256_constants;
    break :blk @as(c_long, 4);
};
pub const SN_id_tc26_gost_3410_2012_512_constants = "id-tc26-gost-3410-2012-512-constants";
pub const NID_id_tc26_gost_3410_2012_512_constants = @as(c_int, 996);
pub const OBJ_id_tc26_gost_3410_2012_512_constants = blk: {
    _ = &OBJ_id_tc26_sign_constants;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_gost_3410_2012_512_paramSetTest = "id-tc26-gost-3410-2012-512-paramSetTest";
pub const LN_id_tc26_gost_3410_2012_512_paramSetTest = "GOST R 34.10-2012 (512 bit) testing parameter set";
pub const NID_id_tc26_gost_3410_2012_512_paramSetTest = @as(c_int, 997);
pub const OBJ_id_tc26_gost_3410_2012_512_paramSetTest = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_512_constants;
    break :blk @as(c_long, 0);
};
pub const SN_id_tc26_gost_3410_2012_512_paramSetA = "id-tc26-gost-3410-2012-512-paramSetA";
pub const LN_id_tc26_gost_3410_2012_512_paramSetA = "GOST R 34.10-2012 (512 bit) ParamSet A";
pub const NID_id_tc26_gost_3410_2012_512_paramSetA = @as(c_int, 998);
pub const OBJ_id_tc26_gost_3410_2012_512_paramSetA = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_512_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_3410_2012_512_paramSetB = "id-tc26-gost-3410-2012-512-paramSetB";
pub const LN_id_tc26_gost_3410_2012_512_paramSetB = "GOST R 34.10-2012 (512 bit) ParamSet B";
pub const NID_id_tc26_gost_3410_2012_512_paramSetB = @as(c_int, 999);
pub const OBJ_id_tc26_gost_3410_2012_512_paramSetB = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_512_constants;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_gost_3410_2012_512_paramSetC = "id-tc26-gost-3410-2012-512-paramSetC";
pub const LN_id_tc26_gost_3410_2012_512_paramSetC = "GOST R 34.10-2012 (512 bit) ParamSet C";
pub const NID_id_tc26_gost_3410_2012_512_paramSetC = @as(c_int, 1149);
pub const OBJ_id_tc26_gost_3410_2012_512_paramSetC = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_512_constants;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_digest_constants = "id-tc26-digest-constants";
pub const NID_id_tc26_digest_constants = @as(c_int, 1000);
pub const OBJ_id_tc26_digest_constants = blk: {
    _ = &OBJ_id_tc26_constants;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_cipher_constants = "id-tc26-cipher-constants";
pub const NID_id_tc26_cipher_constants = @as(c_int, 1001);
pub const OBJ_id_tc26_cipher_constants = blk: {
    _ = &OBJ_id_tc26_constants;
    break :blk @as(c_long, 5);
};
pub const SN_id_tc26_gost_28147_constants = "id-tc26-gost-28147-constants";
pub const NID_id_tc26_gost_28147_constants = @as(c_int, 1002);
pub const OBJ_id_tc26_gost_28147_constants = blk: {
    _ = &OBJ_id_tc26_cipher_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_28147_param_Z = "id-tc26-gost-28147-param-Z";
pub const LN_id_tc26_gost_28147_param_Z = "GOST 28147-89 TC26 parameter set";
pub const NID_id_tc26_gost_28147_param_Z = @as(c_int, 1003);
pub const OBJ_id_tc26_gost_28147_param_Z = blk: {
    _ = &OBJ_id_tc26_gost_28147_constants;
    break :blk @as(c_long, 1);
};
pub const SN_INN = "INN";
pub const LN_INN = "INN";
pub const NID_INN = @as(c_int, 1004);
pub const OBJ_INN = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 3);
    _ = @as(c_long, 131);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_OGRN = "OGRN";
pub const LN_OGRN = "OGRN";
pub const NID_OGRN = @as(c_int, 1005);
pub const OBJ_OGRN = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 1);
};
pub const SN_SNILS = "SNILS";
pub const LN_SNILS = "SNILS";
pub const NID_SNILS = @as(c_int, 1006);
pub const OBJ_SNILS = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 3);
};
pub const SN_OGRNIP = "OGRNIP";
pub const LN_OGRNIP = "OGRNIP";
pub const NID_OGRNIP = @as(c_int, 1226);
pub const OBJ_OGRNIP = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 5);
};
pub const SN_subjectSignTool = "subjectSignTool";
pub const LN_subjectSignTool = "Signing Tool of Subject";
pub const NID_subjectSignTool = @as(c_int, 1007);
pub const OBJ_subjectSignTool = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 111);
};
pub const SN_issuerSignTool = "issuerSignTool";
pub const LN_issuerSignTool = "Signing Tool of Issuer";
pub const NID_issuerSignTool = @as(c_int, 1008);
pub const OBJ_issuerSignTool = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 112);
};
pub const SN_classSignTool = "classSignTool";
pub const LN_classSignTool = "Class of Signing Tool";
pub const NID_classSignTool = @as(c_int, 1227);
pub const OBJ_classSignTool = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 113);
};
pub const SN_classSignToolKC1 = "classSignToolKC1";
pub const LN_classSignToolKC1 = "Class of Signing Tool KC1";
pub const NID_classSignToolKC1 = @as(c_int, 1228);
pub const OBJ_classSignToolKC1 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 1);
};
pub const SN_classSignToolKC2 = "classSignToolKC2";
pub const LN_classSignToolKC2 = "Class of Signing Tool KC2";
pub const NID_classSignToolKC2 = @as(c_int, 1229);
pub const OBJ_classSignToolKC2 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 2);
};
pub const SN_classSignToolKC3 = "classSignToolKC3";
pub const LN_classSignToolKC3 = "Class of Signing Tool KC3";
pub const NID_classSignToolKC3 = @as(c_int, 1230);
pub const OBJ_classSignToolKC3 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 3);
};
pub const SN_classSignToolKB1 = "classSignToolKB1";
pub const LN_classSignToolKB1 = "Class of Signing Tool KB1";
pub const NID_classSignToolKB1 = @as(c_int, 1231);
pub const OBJ_classSignToolKB1 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 4);
};
pub const SN_classSignToolKB2 = "classSignToolKB2";
pub const LN_classSignToolKB2 = "Class of Signing Tool KB2";
pub const NID_classSignToolKB2 = @as(c_int, 1232);
pub const OBJ_classSignToolKB2 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 5);
};
pub const SN_classSignToolKA1 = "classSignToolKA1";
pub const LN_classSignToolKA1 = "Class of Signing Tool KA1";
pub const NID_classSignToolKA1 = @as(c_int, 1233);
pub const OBJ_classSignToolKA1 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 6);
};
pub const SN_kuznyechik_ecb = "kuznyechik-ecb";
pub const NID_kuznyechik_ecb = @as(c_int, 1012);
pub const SN_kuznyechik_ctr = "kuznyechik-ctr";
pub const NID_kuznyechik_ctr = @as(c_int, 1013);
pub const SN_kuznyechik_ofb = "kuznyechik-ofb";
pub const NID_kuznyechik_ofb = @as(c_int, 1014);
pub const SN_kuznyechik_cbc = "kuznyechik-cbc";
pub const NID_kuznyechik_cbc = @as(c_int, 1015);
pub const SN_kuznyechik_cfb = "kuznyechik-cfb";
pub const NID_kuznyechik_cfb = @as(c_int, 1016);
pub const SN_kuznyechik_mac = "kuznyechik-mac";
pub const NID_kuznyechik_mac = @as(c_int, 1017);
pub const SN_magma_ecb = "magma-ecb";
pub const NID_magma_ecb = @as(c_int, 1187);
pub const SN_magma_ctr = "magma-ctr";
pub const NID_magma_ctr = @as(c_int, 1188);
pub const SN_magma_ofb = "magma-ofb";
pub const NID_magma_ofb = @as(c_int, 1189);
pub const SN_magma_cbc = "magma-cbc";
pub const NID_magma_cbc = @as(c_int, 1190);
pub const SN_magma_cfb = "magma-cfb";
pub const NID_magma_cfb = @as(c_int, 1191);
pub const SN_magma_mac = "magma-mac";
pub const NID_magma_mac = @as(c_int, 1192);
pub const SN_camellia_128_cbc = "CAMELLIA-128-CBC";
pub const LN_camellia_128_cbc = "camellia-128-cbc";
pub const NID_camellia_128_cbc = @as(c_int, 751);
pub const OBJ_camellia_128_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_camellia_192_cbc = "CAMELLIA-192-CBC";
pub const LN_camellia_192_cbc = "camellia-192-cbc";
pub const NID_camellia_192_cbc = @as(c_int, 752);
pub const OBJ_camellia_192_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 3);
};
pub const SN_camellia_256_cbc = "CAMELLIA-256-CBC";
pub const LN_camellia_256_cbc = "camellia-256-cbc";
pub const NID_camellia_256_cbc = @as(c_int, 753);
pub const OBJ_camellia_256_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 4);
};
pub const SN_id_camellia128_wrap = "id-camellia128-wrap";
pub const NID_id_camellia128_wrap = @as(c_int, 907);
pub const OBJ_id_camellia128_wrap = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 2);
};
pub const SN_id_camellia192_wrap = "id-camellia192-wrap";
pub const NID_id_camellia192_wrap = @as(c_int, 908);
pub const OBJ_id_camellia192_wrap = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 3);
};
pub const SN_id_camellia256_wrap = "id-camellia256-wrap";
pub const NID_id_camellia256_wrap = @as(c_int, 909);
pub const OBJ_id_camellia256_wrap = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const OBJ_ntt_ds = blk: {
    _ = @as(c_long, 0);
    _ = @as(c_long, 3);
    _ = @as(c_long, 4401);
    break :blk @as(c_long, 5);
};
pub const OBJ_camellia = blk: {
    _ = &OBJ_ntt_ds;
    _ = @as(c_long, 3);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 9);
};
pub const SN_camellia_128_ecb = "CAMELLIA-128-ECB";
pub const LN_camellia_128_ecb = "camellia-128-ecb";
pub const NID_camellia_128_ecb = @as(c_int, 754);
pub const OBJ_camellia_128_ecb = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 1);
};
pub const SN_camellia_128_ofb128 = "CAMELLIA-128-OFB";
pub const LN_camellia_128_ofb128 = "camellia-128-ofb";
pub const NID_camellia_128_ofb128 = @as(c_int, 766);
pub const OBJ_camellia_128_ofb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 3);
};
pub const SN_camellia_128_cfb128 = "CAMELLIA-128-CFB";
pub const LN_camellia_128_cfb128 = "camellia-128-cfb";
pub const NID_camellia_128_cfb128 = @as(c_int, 757);
pub const OBJ_camellia_128_cfb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 4);
};
pub const SN_camellia_128_gcm = "CAMELLIA-128-GCM";
pub const LN_camellia_128_gcm = "camellia-128-gcm";
pub const NID_camellia_128_gcm = @as(c_int, 961);
pub const OBJ_camellia_128_gcm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 6);
};
pub const SN_camellia_128_ccm = "CAMELLIA-128-CCM";
pub const LN_camellia_128_ccm = "camellia-128-ccm";
pub const NID_camellia_128_ccm = @as(c_int, 962);
pub const OBJ_camellia_128_ccm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 7);
};
pub const SN_camellia_128_ctr = "CAMELLIA-128-CTR";
pub const LN_camellia_128_ctr = "camellia-128-ctr";
pub const NID_camellia_128_ctr = @as(c_int, 963);
pub const OBJ_camellia_128_ctr = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 9);
};
pub const SN_camellia_128_cmac = "CAMELLIA-128-CMAC";
pub const LN_camellia_128_cmac = "camellia-128-cmac";
pub const NID_camellia_128_cmac = @as(c_int, 964);
pub const OBJ_camellia_128_cmac = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 10);
};
pub const SN_camellia_192_ecb = "CAMELLIA-192-ECB";
pub const LN_camellia_192_ecb = "camellia-192-ecb";
pub const NID_camellia_192_ecb = @as(c_int, 755);
pub const OBJ_camellia_192_ecb = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 21);
};
pub const SN_camellia_192_ofb128 = "CAMELLIA-192-OFB";
pub const LN_camellia_192_ofb128 = "camellia-192-ofb";
pub const NID_camellia_192_ofb128 = @as(c_int, 767);
pub const OBJ_camellia_192_ofb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 23);
};
pub const SN_camellia_192_cfb128 = "CAMELLIA-192-CFB";
pub const LN_camellia_192_cfb128 = "camellia-192-cfb";
pub const NID_camellia_192_cfb128 = @as(c_int, 758);
pub const OBJ_camellia_192_cfb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 24);
};
pub const SN_camellia_192_gcm = "CAMELLIA-192-GCM";
pub const LN_camellia_192_gcm = "camellia-192-gcm";
pub const NID_camellia_192_gcm = @as(c_int, 965);
pub const OBJ_camellia_192_gcm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 26);
};
pub const SN_camellia_192_ccm = "CAMELLIA-192-CCM";
pub const LN_camellia_192_ccm = "camellia-192-ccm";
pub const NID_camellia_192_ccm = @as(c_int, 966);
pub const OBJ_camellia_192_ccm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 27);
};
pub const SN_camellia_192_ctr = "CAMELLIA-192-CTR";
pub const LN_camellia_192_ctr = "camellia-192-ctr";
pub const NID_camellia_192_ctr = @as(c_int, 967);
pub const OBJ_camellia_192_ctr = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 29);
};
pub const SN_camellia_192_cmac = "CAMELLIA-192-CMAC";
pub const LN_camellia_192_cmac = "camellia-192-cmac";
pub const NID_camellia_192_cmac = @as(c_int, 968);
pub const OBJ_camellia_192_cmac = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 30);
};
pub const SN_camellia_256_ecb = "CAMELLIA-256-ECB";
pub const LN_camellia_256_ecb = "camellia-256-ecb";
pub const NID_camellia_256_ecb = @as(c_int, 756);
pub const OBJ_camellia_256_ecb = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 41);
};
pub const SN_camellia_256_ofb128 = "CAMELLIA-256-OFB";
pub const LN_camellia_256_ofb128 = "camellia-256-ofb";
pub const NID_camellia_256_ofb128 = @as(c_int, 768);
pub const OBJ_camellia_256_ofb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 43);
};
pub const SN_camellia_256_cfb128 = "CAMELLIA-256-CFB";
pub const LN_camellia_256_cfb128 = "camellia-256-cfb";
pub const NID_camellia_256_cfb128 = @as(c_int, 759);
pub const OBJ_camellia_256_cfb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 44);
};
pub const SN_camellia_256_gcm = "CAMELLIA-256-GCM";
pub const LN_camellia_256_gcm = "camellia-256-gcm";
pub const NID_camellia_256_gcm = @as(c_int, 969);
pub const OBJ_camellia_256_gcm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 46);
};
pub const SN_camellia_256_ccm = "CAMELLIA-256-CCM";
pub const LN_camellia_256_ccm = "camellia-256-ccm";
pub const NID_camellia_256_ccm = @as(c_int, 970);
pub const OBJ_camellia_256_ccm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 47);
};
pub const SN_camellia_256_ctr = "CAMELLIA-256-CTR";
pub const LN_camellia_256_ctr = "camellia-256-ctr";
pub const NID_camellia_256_ctr = @as(c_int, 971);
pub const OBJ_camellia_256_ctr = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 49);
};
pub const SN_camellia_256_cmac = "CAMELLIA-256-CMAC";
pub const LN_camellia_256_cmac = "camellia-256-cmac";
pub const NID_camellia_256_cmac = @as(c_int, 972);
pub const OBJ_camellia_256_cmac = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 50);
};
pub const SN_camellia_128_cfb1 = "CAMELLIA-128-CFB1";
pub const LN_camellia_128_cfb1 = "camellia-128-cfb1";
pub const NID_camellia_128_cfb1 = @as(c_int, 760);
pub const SN_camellia_192_cfb1 = "CAMELLIA-192-CFB1";
pub const LN_camellia_192_cfb1 = "camellia-192-cfb1";
pub const NID_camellia_192_cfb1 = @as(c_int, 761);
pub const SN_camellia_256_cfb1 = "CAMELLIA-256-CFB1";
pub const LN_camellia_256_cfb1 = "camellia-256-cfb1";
pub const NID_camellia_256_cfb1 = @as(c_int, 762);
pub const SN_camellia_128_cfb8 = "CAMELLIA-128-CFB8";
pub const LN_camellia_128_cfb8 = "camellia-128-cfb8";
pub const NID_camellia_128_cfb8 = @as(c_int, 763);
pub const SN_camellia_192_cfb8 = "CAMELLIA-192-CFB8";
pub const LN_camellia_192_cfb8 = "camellia-192-cfb8";
pub const NID_camellia_192_cfb8 = @as(c_int, 764);
pub const SN_camellia_256_cfb8 = "CAMELLIA-256-CFB8";
pub const LN_camellia_256_cfb8 = "camellia-256-cfb8";
pub const NID_camellia_256_cfb8 = @as(c_int, 765);
pub const OBJ_aria = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 410);
    _ = @as(c_long, 200046);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_aria_128_ecb = "ARIA-128-ECB";
pub const LN_aria_128_ecb = "aria-128-ecb";
pub const NID_aria_128_ecb = @as(c_int, 1065);
pub const OBJ_aria_128_ecb = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 1);
};
pub const SN_aria_128_cbc = "ARIA-128-CBC";
pub const LN_aria_128_cbc = "aria-128-cbc";
pub const NID_aria_128_cbc = @as(c_int, 1066);
pub const OBJ_aria_128_cbc = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 2);
};
pub const SN_aria_128_cfb128 = "ARIA-128-CFB";
pub const LN_aria_128_cfb128 = "aria-128-cfb";
pub const NID_aria_128_cfb128 = @as(c_int, 1067);
pub const OBJ_aria_128_cfb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 3);
};
pub const SN_aria_128_ofb128 = "ARIA-128-OFB";
pub const LN_aria_128_ofb128 = "aria-128-ofb";
pub const NID_aria_128_ofb128 = @as(c_int, 1068);
pub const OBJ_aria_128_ofb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 4);
};
pub const SN_aria_128_ctr = "ARIA-128-CTR";
pub const LN_aria_128_ctr = "aria-128-ctr";
pub const NID_aria_128_ctr = @as(c_int, 1069);
pub const OBJ_aria_128_ctr = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 5);
};
pub const SN_aria_192_ecb = "ARIA-192-ECB";
pub const LN_aria_192_ecb = "aria-192-ecb";
pub const NID_aria_192_ecb = @as(c_int, 1070);
pub const OBJ_aria_192_ecb = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 6);
};
pub const SN_aria_192_cbc = "ARIA-192-CBC";
pub const LN_aria_192_cbc = "aria-192-cbc";
pub const NID_aria_192_cbc = @as(c_int, 1071);
pub const OBJ_aria_192_cbc = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 7);
};
pub const SN_aria_192_cfb128 = "ARIA-192-CFB";
pub const LN_aria_192_cfb128 = "aria-192-cfb";
pub const NID_aria_192_cfb128 = @as(c_int, 1072);
pub const OBJ_aria_192_cfb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 8);
};
pub const SN_aria_192_ofb128 = "ARIA-192-OFB";
pub const LN_aria_192_ofb128 = "aria-192-ofb";
pub const NID_aria_192_ofb128 = @as(c_int, 1073);
pub const OBJ_aria_192_ofb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 9);
};
pub const SN_aria_192_ctr = "ARIA-192-CTR";
pub const LN_aria_192_ctr = "aria-192-ctr";
pub const NID_aria_192_ctr = @as(c_int, 1074);
pub const OBJ_aria_192_ctr = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 10);
};
pub const SN_aria_256_ecb = "ARIA-256-ECB";
pub const LN_aria_256_ecb = "aria-256-ecb";
pub const NID_aria_256_ecb = @as(c_int, 1075);
pub const OBJ_aria_256_ecb = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 11);
};
pub const SN_aria_256_cbc = "ARIA-256-CBC";
pub const LN_aria_256_cbc = "aria-256-cbc";
pub const NID_aria_256_cbc = @as(c_int, 1076);
pub const OBJ_aria_256_cbc = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 12);
};
pub const SN_aria_256_cfb128 = "ARIA-256-CFB";
pub const LN_aria_256_cfb128 = "aria-256-cfb";
pub const NID_aria_256_cfb128 = @as(c_int, 1077);
pub const OBJ_aria_256_cfb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 13);
};
pub const SN_aria_256_ofb128 = "ARIA-256-OFB";
pub const LN_aria_256_ofb128 = "aria-256-ofb";
pub const NID_aria_256_ofb128 = @as(c_int, 1078);
pub const OBJ_aria_256_ofb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 14);
};
pub const SN_aria_256_ctr = "ARIA-256-CTR";
pub const LN_aria_256_ctr = "aria-256-ctr";
pub const NID_aria_256_ctr = @as(c_int, 1079);
pub const OBJ_aria_256_ctr = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 15);
};
pub const SN_aria_128_cfb1 = "ARIA-128-CFB1";
pub const LN_aria_128_cfb1 = "aria-128-cfb1";
pub const NID_aria_128_cfb1 = @as(c_int, 1080);
pub const SN_aria_192_cfb1 = "ARIA-192-CFB1";
pub const LN_aria_192_cfb1 = "aria-192-cfb1";
pub const NID_aria_192_cfb1 = @as(c_int, 1081);
pub const SN_aria_256_cfb1 = "ARIA-256-CFB1";
pub const LN_aria_256_cfb1 = "aria-256-cfb1";
pub const NID_aria_256_cfb1 = @as(c_int, 1082);
pub const SN_aria_128_cfb8 = "ARIA-128-CFB8";
pub const LN_aria_128_cfb8 = "aria-128-cfb8";
pub const NID_aria_128_cfb8 = @as(c_int, 1083);
pub const SN_aria_192_cfb8 = "ARIA-192-CFB8";
pub const LN_aria_192_cfb8 = "aria-192-cfb8";
pub const NID_aria_192_cfb8 = @as(c_int, 1084);
pub const SN_aria_256_cfb8 = "ARIA-256-CFB8";
pub const LN_aria_256_cfb8 = "aria-256-cfb8";
pub const NID_aria_256_cfb8 = @as(c_int, 1085);
pub const SN_aria_128_ccm = "ARIA-128-CCM";
pub const LN_aria_128_ccm = "aria-128-ccm";
pub const NID_aria_128_ccm = @as(c_int, 1120);
pub const OBJ_aria_128_ccm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 37);
};
pub const SN_aria_192_ccm = "ARIA-192-CCM";
pub const LN_aria_192_ccm = "aria-192-ccm";
pub const NID_aria_192_ccm = @as(c_int, 1121);
pub const OBJ_aria_192_ccm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 38);
};
pub const SN_aria_256_ccm = "ARIA-256-CCM";
pub const LN_aria_256_ccm = "aria-256-ccm";
pub const NID_aria_256_ccm = @as(c_int, 1122);
pub const OBJ_aria_256_ccm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 39);
};
pub const SN_aria_128_gcm = "ARIA-128-GCM";
pub const LN_aria_128_gcm = "aria-128-gcm";
pub const NID_aria_128_gcm = @as(c_int, 1123);
pub const OBJ_aria_128_gcm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 34);
};
pub const SN_aria_192_gcm = "ARIA-192-GCM";
pub const LN_aria_192_gcm = "aria-192-gcm";
pub const NID_aria_192_gcm = @as(c_int, 1124);
pub const OBJ_aria_192_gcm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 35);
};
pub const SN_aria_256_gcm = "ARIA-256-GCM";
pub const LN_aria_256_gcm = "aria-256-gcm";
pub const NID_aria_256_gcm = @as(c_int, 1125);
pub const OBJ_aria_256_gcm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 36);
};
pub const SN_kisa = "KISA";
pub const LN_kisa = "kisa";
pub const NID_kisa = @as(c_int, 773);
pub const OBJ_kisa = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 410);
    break :blk @as(c_long, 200004);
};
pub const SN_seed_ecb = "SEED-ECB";
pub const LN_seed_ecb = "seed-ecb";
pub const NID_seed_ecb = @as(c_int, 776);
pub const OBJ_seed_ecb = blk: {
    _ = &OBJ_kisa;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 3);
};
pub const SN_seed_cbc = "SEED-CBC";
pub const LN_seed_cbc = "seed-cbc";
pub const NID_seed_cbc = @as(c_int, 777);
pub const OBJ_seed_cbc = blk: {
    _ = &OBJ_kisa;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 4);
};
pub const SN_seed_cfb128 = "SEED-CFB";
pub const LN_seed_cfb128 = "seed-cfb";
pub const NID_seed_cfb128 = @as(c_int, 779);
pub const OBJ_seed_cfb128 = blk: {
    _ = &OBJ_kisa;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 5);
};
pub const SN_seed_ofb128 = "SEED-OFB";
pub const LN_seed_ofb128 = "seed-ofb";
pub const NID_seed_ofb128 = @as(c_int, 778);
pub const OBJ_seed_ofb128 = blk: {
    _ = &OBJ_kisa;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 6);
};
pub const SN_sm4_ecb = "SM4-ECB";
pub const LN_sm4_ecb = "sm4-ecb";
pub const NID_sm4_ecb = @as(c_int, 1133);
pub const OBJ_sm4_ecb = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 1);
};
pub const SN_sm4_cbc = "SM4-CBC";
pub const LN_sm4_cbc = "sm4-cbc";
pub const NID_sm4_cbc = @as(c_int, 1134);
pub const OBJ_sm4_cbc = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 2);
};
pub const SN_sm4_ofb128 = "SM4-OFB";
pub const LN_sm4_ofb128 = "sm4-ofb";
pub const NID_sm4_ofb128 = @as(c_int, 1135);
pub const OBJ_sm4_ofb128 = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 3);
};
pub const SN_sm4_cfb128 = "SM4-CFB";
pub const LN_sm4_cfb128 = "sm4-cfb";
pub const NID_sm4_cfb128 = @as(c_int, 1137);
pub const OBJ_sm4_cfb128 = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 4);
};
pub const SN_sm4_cfb1 = "SM4-CFB1";
pub const LN_sm4_cfb1 = "sm4-cfb1";
pub const NID_sm4_cfb1 = @as(c_int, 1136);
pub const OBJ_sm4_cfb1 = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 5);
};
pub const SN_sm4_cfb8 = "SM4-CFB8";
pub const LN_sm4_cfb8 = "sm4-cfb8";
pub const NID_sm4_cfb8 = @as(c_int, 1138);
pub const OBJ_sm4_cfb8 = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 6);
};
pub const SN_sm4_ctr = "SM4-CTR";
pub const LN_sm4_ctr = "sm4-ctr";
pub const NID_sm4_ctr = @as(c_int, 1139);
pub const OBJ_sm4_ctr = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 7);
};
pub const SN_sm4_gcm = "SM4-GCM";
pub const LN_sm4_gcm = "sm4-gcm";
pub const NID_sm4_gcm = @as(c_int, 1248);
pub const OBJ_sm4_gcm = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 8);
};
pub const SN_sm4_ccm = "SM4-CCM";
pub const LN_sm4_ccm = "sm4-ccm";
pub const NID_sm4_ccm = @as(c_int, 1249);
pub const OBJ_sm4_ccm = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 9);
};
pub const SN_sm4_xts = "SM4-XTS";
pub const LN_sm4_xts = "sm4-xts";
pub const NID_sm4_xts = @as(c_int, 1290);
pub const OBJ_sm4_xts = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 10);
};
pub const SN_hmac = "HMAC";
pub const LN_hmac = "hmac";
pub const NID_hmac = @as(c_int, 855);
pub const SN_cmac = "CMAC";
pub const LN_cmac = "cmac";
pub const NID_cmac = @as(c_int, 894);
pub const SN_rc4_hmac_md5 = "RC4-HMAC-MD5";
pub const LN_rc4_hmac_md5 = "rc4-hmac-md5";
pub const NID_rc4_hmac_md5 = @as(c_int, 915);
pub const SN_aes_128_cbc_hmac_sha1 = "AES-128-CBC-HMAC-SHA1";
pub const LN_aes_128_cbc_hmac_sha1 = "aes-128-cbc-hmac-sha1";
pub const NID_aes_128_cbc_hmac_sha1 = @as(c_int, 916);
pub const SN_aes_192_cbc_hmac_sha1 = "AES-192-CBC-HMAC-SHA1";
pub const LN_aes_192_cbc_hmac_sha1 = "aes-192-cbc-hmac-sha1";
pub const NID_aes_192_cbc_hmac_sha1 = @as(c_int, 917);
pub const SN_aes_256_cbc_hmac_sha1 = "AES-256-CBC-HMAC-SHA1";
pub const LN_aes_256_cbc_hmac_sha1 = "aes-256-cbc-hmac-sha1";
pub const NID_aes_256_cbc_hmac_sha1 = @as(c_int, 918);
pub const SN_aes_128_cbc_hmac_sha256 = "AES-128-CBC-HMAC-SHA256";
pub const LN_aes_128_cbc_hmac_sha256 = "aes-128-cbc-hmac-sha256";
pub const NID_aes_128_cbc_hmac_sha256 = @as(c_int, 948);
pub const SN_aes_192_cbc_hmac_sha256 = "AES-192-CBC-HMAC-SHA256";
pub const LN_aes_192_cbc_hmac_sha256 = "aes-192-cbc-hmac-sha256";
pub const NID_aes_192_cbc_hmac_sha256 = @as(c_int, 949);
pub const SN_aes_256_cbc_hmac_sha256 = "AES-256-CBC-HMAC-SHA256";
pub const LN_aes_256_cbc_hmac_sha256 = "aes-256-cbc-hmac-sha256";
pub const NID_aes_256_cbc_hmac_sha256 = @as(c_int, 950);
pub const SN_chacha20_poly1305 = "ChaCha20-Poly1305";
pub const LN_chacha20_poly1305 = "chacha20-poly1305";
pub const NID_chacha20_poly1305 = @as(c_int, 1018);
pub const SN_chacha20 = "ChaCha20";
pub const LN_chacha20 = "chacha20";
pub const NID_chacha20 = @as(c_int, 1019);
pub const SN_dhpublicnumber = "dhpublicnumber";
pub const LN_dhpublicnumber = "X9.42 DH";
pub const NID_dhpublicnumber = @as(c_int, 920);
pub const OBJ_dhpublicnumber = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 10046);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_brainpoolP160r1 = "brainpoolP160r1";
pub const NID_brainpoolP160r1 = @as(c_int, 921);
pub const OBJ_brainpoolP160r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_brainpoolP160t1 = "brainpoolP160t1";
pub const NID_brainpoolP160t1 = @as(c_int, 922);
pub const OBJ_brainpoolP160t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_brainpoolP192r1 = "brainpoolP192r1";
pub const NID_brainpoolP192r1 = @as(c_int, 923);
pub const OBJ_brainpoolP192r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 3);
};
pub const SN_brainpoolP192t1 = "brainpoolP192t1";
pub const NID_brainpoolP192t1 = @as(c_int, 924);
pub const OBJ_brainpoolP192t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 4);
};
pub const SN_brainpoolP224r1 = "brainpoolP224r1";
pub const NID_brainpoolP224r1 = @as(c_int, 925);
pub const OBJ_brainpoolP224r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 5);
};
pub const SN_brainpoolP224t1 = "brainpoolP224t1";
pub const NID_brainpoolP224t1 = @as(c_int, 926);
pub const OBJ_brainpoolP224t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 6);
};
pub const SN_brainpoolP256r1 = "brainpoolP256r1";
pub const NID_brainpoolP256r1 = @as(c_int, 927);
pub const OBJ_brainpoolP256r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 7);
};
pub const SN_brainpoolP256r1tls13 = "brainpoolP256r1tls13";
pub const NID_brainpoolP256r1tls13 = @as(c_int, 1285);
pub const SN_brainpoolP256t1 = "brainpoolP256t1";
pub const NID_brainpoolP256t1 = @as(c_int, 928);
pub const OBJ_brainpoolP256t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 8);
};
pub const SN_brainpoolP320r1 = "brainpoolP320r1";
pub const NID_brainpoolP320r1 = @as(c_int, 929);
pub const OBJ_brainpoolP320r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 9);
};
pub const SN_brainpoolP320t1 = "brainpoolP320t1";
pub const NID_brainpoolP320t1 = @as(c_int, 930);
pub const OBJ_brainpoolP320t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 10);
};
pub const SN_brainpoolP384r1 = "brainpoolP384r1";
pub const NID_brainpoolP384r1 = @as(c_int, 931);
pub const OBJ_brainpoolP384r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 11);
};
pub const SN_brainpoolP384r1tls13 = "brainpoolP384r1tls13";
pub const NID_brainpoolP384r1tls13 = @as(c_int, 1286);
pub const SN_brainpoolP384t1 = "brainpoolP384t1";
pub const NID_brainpoolP384t1 = @as(c_int, 932);
pub const OBJ_brainpoolP384t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 12);
};
pub const SN_brainpoolP512r1 = "brainpoolP512r1";
pub const NID_brainpoolP512r1 = @as(c_int, 933);
pub const OBJ_brainpoolP512r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 13);
};
pub const SN_brainpoolP512r1tls13 = "brainpoolP512r1tls13";
pub const NID_brainpoolP512r1tls13 = @as(c_int, 1287);
pub const SN_brainpoolP512t1 = "brainpoolP512t1";
pub const NID_brainpoolP512t1 = @as(c_int, 934);
pub const OBJ_brainpoolP512t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 14);
};
pub const OBJ_x9_63_scheme = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 133);
    _ = @as(c_long, 16);
    _ = @as(c_long, 840);
    _ = @as(c_long, 63);
    break :blk @as(c_long, 0);
};
pub const OBJ_secg_scheme = blk: {
    _ = &OBJ_certicom_arc;
    break :blk @as(c_long, 1);
};
pub const SN_dhSinglePass_stdDH_sha1kdf_scheme = "dhSinglePass-stdDH-sha1kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha1kdf_scheme = @as(c_int, 936);
pub const OBJ_dhSinglePass_stdDH_sha1kdf_scheme = blk: {
    _ = &OBJ_x9_63_scheme;
    break :blk @as(c_long, 2);
};
pub const SN_dhSinglePass_stdDH_sha224kdf_scheme = "dhSinglePass-stdDH-sha224kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha224kdf_scheme = @as(c_int, 937);
pub const OBJ_dhSinglePass_stdDH_sha224kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 11);
    break :blk @as(c_long, 0);
};
pub const SN_dhSinglePass_stdDH_sha256kdf_scheme = "dhSinglePass-stdDH-sha256kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha256kdf_scheme = @as(c_int, 938);
pub const OBJ_dhSinglePass_stdDH_sha256kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 11);
    break :blk @as(c_long, 1);
};
pub const SN_dhSinglePass_stdDH_sha384kdf_scheme = "dhSinglePass-stdDH-sha384kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha384kdf_scheme = @as(c_int, 939);
pub const OBJ_dhSinglePass_stdDH_sha384kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 11);
    break :blk @as(c_long, 2);
};
pub const SN_dhSinglePass_stdDH_sha512kdf_scheme = "dhSinglePass-stdDH-sha512kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha512kdf_scheme = @as(c_int, 940);
pub const OBJ_dhSinglePass_stdDH_sha512kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 11);
    break :blk @as(c_long, 3);
};
pub const SN_dhSinglePass_cofactorDH_sha1kdf_scheme = "dhSinglePass-cofactorDH-sha1kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha1kdf_scheme = @as(c_int, 941);
pub const OBJ_dhSinglePass_cofactorDH_sha1kdf_scheme = blk: {
    _ = &OBJ_x9_63_scheme;
    break :blk @as(c_long, 3);
};
pub const SN_dhSinglePass_cofactorDH_sha224kdf_scheme = "dhSinglePass-cofactorDH-sha224kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha224kdf_scheme = @as(c_int, 942);
pub const OBJ_dhSinglePass_cofactorDH_sha224kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 0);
};
pub const SN_dhSinglePass_cofactorDH_sha256kdf_scheme = "dhSinglePass-cofactorDH-sha256kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha256kdf_scheme = @as(c_int, 943);
pub const OBJ_dhSinglePass_cofactorDH_sha256kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 1);
};
pub const SN_dhSinglePass_cofactorDH_sha384kdf_scheme = "dhSinglePass-cofactorDH-sha384kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha384kdf_scheme = @as(c_int, 944);
pub const OBJ_dhSinglePass_cofactorDH_sha384kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 2);
};
pub const SN_dhSinglePass_cofactorDH_sha512kdf_scheme = "dhSinglePass-cofactorDH-sha512kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha512kdf_scheme = @as(c_int, 945);
pub const OBJ_dhSinglePass_cofactorDH_sha512kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 3);
};
pub const SN_dh_std_kdf = "dh-std-kdf";
pub const NID_dh_std_kdf = @as(c_int, 946);
pub const SN_dh_cofactor_kdf = "dh-cofactor-kdf";
pub const NID_dh_cofactor_kdf = @as(c_int, 947);
pub const SN_ct_precert_scts = "ct_precert_scts";
pub const LN_ct_precert_scts = "CT Precertificate SCTs";
pub const NID_ct_precert_scts = @as(c_int, 951);
pub const OBJ_ct_precert_scts = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11129);
    _ = @as(c_long, 2);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 2);
};
pub const SN_ct_precert_poison = "ct_precert_poison";
pub const LN_ct_precert_poison = "CT Precertificate Poison";
pub const NID_ct_precert_poison = @as(c_int, 952);
pub const OBJ_ct_precert_poison = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11129);
    _ = @as(c_long, 2);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 3);
};
pub const SN_ct_precert_signer = "ct_precert_signer";
pub const LN_ct_precert_signer = "CT Precertificate Signer";
pub const NID_ct_precert_signer = @as(c_int, 953);
pub const OBJ_ct_precert_signer = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11129);
    _ = @as(c_long, 2);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 4);
};
pub const SN_ct_cert_scts = "ct_cert_scts";
pub const LN_ct_cert_scts = "CT Certificate SCTs";
pub const NID_ct_cert_scts = @as(c_int, 954);
pub const OBJ_ct_cert_scts = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11129);
    _ = @as(c_long, 2);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 5);
};
pub const SN_jurisdictionLocalityName = "jurisdictionL";
pub const LN_jurisdictionLocalityName = "jurisdictionLocalityName";
pub const NID_jurisdictionLocalityName = @as(c_int, 955);
pub const OBJ_jurisdictionLocalityName = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 60);
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_jurisdictionStateOrProvinceName = "jurisdictionST";
pub const LN_jurisdictionStateOrProvinceName = "jurisdictionStateOrProvinceName";
pub const NID_jurisdictionStateOrProvinceName = @as(c_int, 956);
pub const OBJ_jurisdictionStateOrProvinceName = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 60);
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_jurisdictionCountryName = "jurisdictionC";
pub const LN_jurisdictionCountryName = "jurisdictionCountryName";
pub const NID_jurisdictionCountryName = @as(c_int, 957);
pub const OBJ_jurisdictionCountryName = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 60);
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 3);
};
pub const SN_id_scrypt = "id-scrypt";
pub const LN_id_scrypt = "scrypt";
pub const NID_id_scrypt = @as(c_int, 973);
pub const OBJ_id_scrypt = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11591);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 11);
};
pub const SN_tls1_prf = "TLS1-PRF";
pub const LN_tls1_prf = "tls1-prf";
pub const NID_tls1_prf = @as(c_int, 1021);
pub const SN_hkdf = "HKDF";
pub const LN_hkdf = "hkdf";
pub const NID_hkdf = @as(c_int, 1036);
pub const SN_sshkdf = "SSHKDF";
pub const LN_sshkdf = "sshkdf";
pub const NID_sshkdf = @as(c_int, 1203);
pub const SN_sskdf = "SSKDF";
pub const LN_sskdf = "sskdf";
pub const NID_sskdf = @as(c_int, 1205);
pub const SN_x942kdf = "X942KDF";
pub const LN_x942kdf = "x942kdf";
pub const NID_x942kdf = @as(c_int, 1207);
pub const SN_x963kdf = "X963KDF";
pub const LN_x963kdf = "x963kdf";
pub const NID_x963kdf = @as(c_int, 1206);
pub const SN_id_pkinit = "id-pkinit";
pub const NID_id_pkinit = @as(c_int, 1031);
pub const OBJ_id_pkinit = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 3);
};
pub const SN_pkInitClientAuth = "pkInitClientAuth";
pub const LN_pkInitClientAuth = "PKINIT Client Auth";
pub const NID_pkInitClientAuth = @as(c_int, 1032);
pub const OBJ_pkInitClientAuth = blk: {
    _ = &OBJ_id_pkinit;
    break :blk @as(c_long, 4);
};
pub const SN_pkInitKDC = "pkInitKDC";
pub const LN_pkInitKDC = "Signing KDC Response";
pub const NID_pkInitKDC = @as(c_int, 1033);
pub const OBJ_pkInitKDC = blk: {
    _ = &OBJ_id_pkinit;
    break :blk @as(c_long, 5);
};
pub const SN_X25519 = "X25519";
pub const NID_X25519 = @as(c_int, 1034);
pub const OBJ_X25519 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 110);
};
pub const SN_X448 = "X448";
pub const NID_X448 = @as(c_int, 1035);
pub const OBJ_X448 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 111);
};
pub const SN_ED25519 = "ED25519";
pub const NID_ED25519 = @as(c_int, 1087);
pub const OBJ_ED25519 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 112);
};
pub const SN_ED448 = "ED448";
pub const NID_ED448 = @as(c_int, 1088);
pub const OBJ_ED448 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 113);
};
pub const SN_kx_rsa = "KxRSA";
pub const LN_kx_rsa = "kx-rsa";
pub const NID_kx_rsa = @as(c_int, 1037);
pub const SN_kx_ecdhe = "KxECDHE";
pub const LN_kx_ecdhe = "kx-ecdhe";
pub const NID_kx_ecdhe = @as(c_int, 1038);
pub const SN_kx_dhe = "KxDHE";
pub const LN_kx_dhe = "kx-dhe";
pub const NID_kx_dhe = @as(c_int, 1039);
pub const SN_kx_ecdhe_psk = "KxECDHE-PSK";
pub const LN_kx_ecdhe_psk = "kx-ecdhe-psk";
pub const NID_kx_ecdhe_psk = @as(c_int, 1040);
pub const SN_kx_dhe_psk = "KxDHE-PSK";
pub const LN_kx_dhe_psk = "kx-dhe-psk";
pub const NID_kx_dhe_psk = @as(c_int, 1041);
pub const SN_kx_rsa_psk = "KxRSA_PSK";
pub const LN_kx_rsa_psk = "kx-rsa-psk";
pub const NID_kx_rsa_psk = @as(c_int, 1042);
pub const SN_kx_psk = "KxPSK";
pub const LN_kx_psk = "kx-psk";
pub const NID_kx_psk = @as(c_int, 1043);
pub const SN_kx_srp = "KxSRP";
pub const LN_kx_srp = "kx-srp";
pub const NID_kx_srp = @as(c_int, 1044);
pub const SN_kx_gost = "KxGOST";
pub const LN_kx_gost = "kx-gost";
pub const NID_kx_gost = @as(c_int, 1045);
pub const SN_kx_gost18 = "KxGOST18";
pub const LN_kx_gost18 = "kx-gost18";
pub const NID_kx_gost18 = @as(c_int, 1218);
pub const SN_kx_any = "KxANY";
pub const LN_kx_any = "kx-any";
pub const NID_kx_any = @as(c_int, 1063);
pub const SN_auth_rsa = "AuthRSA";
pub const LN_auth_rsa = "auth-rsa";
pub const NID_auth_rsa = @as(c_int, 1046);
pub const SN_auth_ecdsa = "AuthECDSA";
pub const LN_auth_ecdsa = "auth-ecdsa";
pub const NID_auth_ecdsa = @as(c_int, 1047);
pub const SN_auth_psk = "AuthPSK";
pub const LN_auth_psk = "auth-psk";
pub const NID_auth_psk = @as(c_int, 1048);
pub const SN_auth_dss = "AuthDSS";
pub const LN_auth_dss = "auth-dss";
pub const NID_auth_dss = @as(c_int, 1049);
pub const SN_auth_gost01 = "AuthGOST01";
pub const LN_auth_gost01 = "auth-gost01";
pub const NID_auth_gost01 = @as(c_int, 1050);
pub const SN_auth_gost12 = "AuthGOST12";
pub const LN_auth_gost12 = "auth-gost12";
pub const NID_auth_gost12 = @as(c_int, 1051);
pub const SN_auth_srp = "AuthSRP";
pub const LN_auth_srp = "auth-srp";
pub const NID_auth_srp = @as(c_int, 1052);
pub const SN_auth_null = "AuthNULL";
pub const LN_auth_null = "auth-null";
pub const NID_auth_null = @as(c_int, 1053);
pub const SN_auth_any = "AuthANY";
pub const LN_auth_any = "auth-any";
pub const NID_auth_any = @as(c_int, 1064);
pub const SN_poly1305 = "Poly1305";
pub const LN_poly1305 = "poly1305";
pub const NID_poly1305 = @as(c_int, 1061);
pub const SN_siphash = "SipHash";
pub const LN_siphash = "siphash";
pub const NID_siphash = @as(c_int, 1062);
pub const SN_ffdhe2048 = "ffdhe2048";
pub const NID_ffdhe2048 = @as(c_int, 1126);
pub const SN_ffdhe3072 = "ffdhe3072";
pub const NID_ffdhe3072 = @as(c_int, 1127);
pub const SN_ffdhe4096 = "ffdhe4096";
pub const NID_ffdhe4096 = @as(c_int, 1128);
pub const SN_ffdhe6144 = "ffdhe6144";
pub const NID_ffdhe6144 = @as(c_int, 1129);
pub const SN_ffdhe8192 = "ffdhe8192";
pub const NID_ffdhe8192 = @as(c_int, 1130);
pub const SN_modp_1536 = "modp_1536";
pub const NID_modp_1536 = @as(c_int, 1212);
pub const SN_modp_2048 = "modp_2048";
pub const NID_modp_2048 = @as(c_int, 1213);
pub const SN_modp_3072 = "modp_3072";
pub const NID_modp_3072 = @as(c_int, 1214);
pub const SN_modp_4096 = "modp_4096";
pub const NID_modp_4096 = @as(c_int, 1215);
pub const SN_modp_6144 = "modp_6144";
pub const NID_modp_6144 = @as(c_int, 1216);
pub const SN_modp_8192 = "modp_8192";
pub const NID_modp_8192 = @as(c_int, 1217);
pub const SN_ISO_UA = "ISO-UA";
pub const NID_ISO_UA = @as(c_int, 1150);
pub const OBJ_ISO_UA = blk: {
    _ = &OBJ_member_body;
    break :blk @as(c_long, 804);
};
pub const SN_ua_pki = "ua-pki";
pub const NID_ua_pki = @as(c_int, 1151);
pub const OBJ_ua_pki = blk: {
    _ = &OBJ_ISO_UA;
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_dstu28147 = "dstu28147";
pub const LN_dstu28147 = "DSTU Gost 28147-2009";
pub const NID_dstu28147 = @as(c_int, 1152);
pub const OBJ_dstu28147 = blk: {
    _ = &OBJ_ua_pki;
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_dstu28147_ofb = "dstu28147-ofb";
pub const LN_dstu28147_ofb = "DSTU Gost 28147-2009 OFB mode";
pub const NID_dstu28147_ofb = @as(c_int, 1153);
pub const OBJ_dstu28147_ofb = blk: {
    _ = &OBJ_dstu28147;
    break :blk @as(c_long, 2);
};
pub const SN_dstu28147_cfb = "dstu28147-cfb";
pub const LN_dstu28147_cfb = "DSTU Gost 28147-2009 CFB mode";
pub const NID_dstu28147_cfb = @as(c_int, 1154);
pub const OBJ_dstu28147_cfb = blk: {
    _ = &OBJ_dstu28147;
    break :blk @as(c_long, 3);
};
pub const SN_dstu28147_wrap = "dstu28147-wrap";
pub const LN_dstu28147_wrap = "DSTU Gost 28147-2009 key wrap";
pub const NID_dstu28147_wrap = @as(c_int, 1155);
pub const OBJ_dstu28147_wrap = blk: {
    _ = &OBJ_dstu28147;
    break :blk @as(c_long, 5);
};
pub const SN_hmacWithDstu34311 = "hmacWithDstu34311";
pub const LN_hmacWithDstu34311 = "HMAC DSTU Gost 34311-95";
pub const NID_hmacWithDstu34311 = @as(c_int, 1156);
pub const OBJ_hmacWithDstu34311 = blk: {
    _ = &OBJ_ua_pki;
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_dstu34311 = "dstu34311";
pub const LN_dstu34311 = "DSTU Gost 34311-95";
pub const NID_dstu34311 = @as(c_int, 1157);
pub const OBJ_dstu34311 = blk: {
    _ = &OBJ_ua_pki;
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_dstu4145le = "dstu4145le";
pub const LN_dstu4145le = "DSTU 4145-2002 little endian";
pub const NID_dstu4145le = @as(c_int, 1158);
pub const OBJ_dstu4145le = blk: {
    _ = &OBJ_ua_pki;
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_dstu4145be = "dstu4145be";
pub const LN_dstu4145be = "DSTU 4145-2002 big endian";
pub const NID_dstu4145be = @as(c_int, 1159);
pub const OBJ_dstu4145be = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_uacurve0 = "uacurve0";
pub const LN_uacurve0 = "DSTU curve 0";
pub const NID_uacurve0 = @as(c_int, 1160);
pub const OBJ_uacurve0 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 0);
};
pub const SN_uacurve1 = "uacurve1";
pub const LN_uacurve1 = "DSTU curve 1";
pub const NID_uacurve1 = @as(c_int, 1161);
pub const OBJ_uacurve1 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_uacurve2 = "uacurve2";
pub const LN_uacurve2 = "DSTU curve 2";
pub const NID_uacurve2 = @as(c_int, 1162);
pub const OBJ_uacurve2 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_uacurve3 = "uacurve3";
pub const LN_uacurve3 = "DSTU curve 3";
pub const NID_uacurve3 = @as(c_int, 1163);
pub const OBJ_uacurve3 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 3);
};
pub const SN_uacurve4 = "uacurve4";
pub const LN_uacurve4 = "DSTU curve 4";
pub const NID_uacurve4 = @as(c_int, 1164);
pub const OBJ_uacurve4 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 4);
};
pub const SN_uacurve5 = "uacurve5";
pub const LN_uacurve5 = "DSTU curve 5";
pub const NID_uacurve5 = @as(c_int, 1165);
pub const OBJ_uacurve5 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 5);
};
pub const SN_uacurve6 = "uacurve6";
pub const LN_uacurve6 = "DSTU curve 6";
pub const NID_uacurve6 = @as(c_int, 1166);
pub const OBJ_uacurve6 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 6);
};
pub const SN_uacurve7 = "uacurve7";
pub const LN_uacurve7 = "DSTU curve 7";
pub const NID_uacurve7 = @as(c_int, 1167);
pub const OBJ_uacurve7 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 7);
};
pub const SN_uacurve8 = "uacurve8";
pub const LN_uacurve8 = "DSTU curve 8";
pub const NID_uacurve8 = @as(c_int, 1168);
pub const OBJ_uacurve8 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 8);
};
pub const SN_uacurve9 = "uacurve9";
pub const LN_uacurve9 = "DSTU curve 9";
pub const NID_uacurve9 = @as(c_int, 1169);
pub const OBJ_uacurve9 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 9);
};
pub const SN_aes_128_siv = "AES-128-SIV";
pub const LN_aes_128_siv = "aes-128-siv";
pub const NID_aes_128_siv = @as(c_int, 1198);
pub const SN_aes_192_siv = "AES-192-SIV";
pub const LN_aes_192_siv = "aes-192-siv";
pub const NID_aes_192_siv = @as(c_int, 1199);
pub const SN_aes_256_siv = "AES-256-SIV";
pub const LN_aes_256_siv = "aes-256-siv";
pub const NID_aes_256_siv = @as(c_int, 1200);
pub const SN_oracle = "oracle-organization";
pub const LN_oracle = "Oracle organization";
pub const NID_oracle = @as(c_int, 1282);
pub const OBJ_oracle = blk: {
    _ = &OBJ_joint_iso_itu_t;
    _ = @as(c_long, 16);
    _ = @as(c_long, 840);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 113894);
};
pub const SN_oracle_jdk_trustedkeyusage = "oracle-jdk-trustedkeyusage";
pub const LN_oracle_jdk_trustedkeyusage = "Trusted key usage (Oracle)";
pub const NID_oracle_jdk_trustedkeyusage = @as(c_int, 1283);
pub const OBJ_oracle_jdk_trustedkeyusage = blk: {
    _ = &OBJ_oracle;
    _ = @as(c_long, 746875);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_brotli = "brotli";
pub const LN_brotli = "Brotli compression";
pub const NID_brotli = @as(c_int, 1288);
pub const SN_zstd = "zstd";
pub const LN_zstd = "Zstandard compression";
pub const NID_zstd = @as(c_int, 1289);
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm = SN_magma_ctr_acpkm;
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm = NID_magma_ctr_acpkm;
pub const OBJ_id_tc26_cipher_gostr3412_2015_magma_ctracpkm = OBJ_magma_ctr_acpkm;
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac = SN_magma_ctr_acpkm_omac;
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac = NID_magma_ctr_acpkm_omac;
pub const OBJ_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac = OBJ_magma_ctr_acpkm_omac;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm = SN_kuznyechik_ctr_acpkm;
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm = NID_kuznyechik_ctr_acpkm;
pub const OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm = OBJ_kuznyechik_ctr_acpkm;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac = SN_kuznyechik_ctr_acpkm_omac;
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac = NID_kuznyechik_ctr_acpkm_omac;
pub const OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac = OBJ_kuznyechik_ctr_acpkm_omac;
pub const SN_id_tc26_wrap_gostr3412_2015_magma_kexp15 = SN_magma_kexp15;
pub const NID_id_tc26_wrap_gostr3412_2015_magma_kexp15 = NID_magma_kexp15;
pub const OBJ_id_tc26_wrap_gostr3412_2015_magma_kexp15 = OBJ_magma_kexp15;
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15 = SN_kuznyechik_kexp15;
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15 = NID_kuznyechik_kexp15;
pub const OBJ_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15 = OBJ_kuznyechik_kexp15;
pub const SN_grasshopper_ecb = SN_kuznyechik_ecb;
pub const NID_grasshopper_ecb = NID_kuznyechik_ecb;
pub const SN_grasshopper_ctr = SN_kuznyechik_ctr;
pub const NID_grasshopper_ctr = NID_kuznyechik_ctr;
pub const SN_grasshopper_ofb = SN_kuznyechik_ofb;
pub const NID_grasshopper_ofb = NID_kuznyechik_ofb;
pub const SN_grasshopper_cbc = SN_kuznyechik_cbc;
pub const NID_grasshopper_cbc = NID_kuznyechik_cbc;
pub const SN_grasshopper_cfb = SN_kuznyechik_cfb;
pub const NID_grasshopper_cfb = NID_kuznyechik_cfb;
pub const SN_grasshopper_mac = SN_kuznyechik_mac;
pub const NID_grasshopper_mac = NID_kuznyechik_mac;
pub const OPENSSL_ASN1_H = "";
pub const HEADER_ASN1_H = "";
pub const OPENSSL_ASN1ERR_H = "";
pub const ASN1_R_ADDING_OBJECT = @as(c_int, 171);
pub const ASN1_R_ASN1_PARSE_ERROR = @as(c_int, 203);
pub const ASN1_R_ASN1_SIG_PARSE_ERROR = @as(c_int, 204);
pub const ASN1_R_AUX_ERROR = @as(c_int, 100);
pub const ASN1_R_BAD_OBJECT_HEADER = @as(c_int, 102);
pub const ASN1_R_BAD_TEMPLATE = @as(c_int, 230);
pub const ASN1_R_BMPSTRING_IS_WRONG_LENGTH = @as(c_int, 214);
pub const ASN1_R_BN_LIB = @as(c_int, 105);
pub const ASN1_R_BOOLEAN_IS_WRONG_LENGTH = @as(c_int, 106);
pub const ASN1_R_BUFFER_TOO_SMALL = @as(c_int, 107);
pub const ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER = @as(c_int, 108);
pub const ASN1_R_CONTEXT_NOT_INITIALISED = @as(c_int, 217);
pub const ASN1_R_DATA_IS_WRONG = @as(c_int, 109);
pub const ASN1_R_DECODE_ERROR = @as(c_int, 110);
pub const ASN1_R_DEPTH_EXCEEDED = @as(c_int, 174);
pub const ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED = @as(c_int, 198);
pub const ASN1_R_ENCODE_ERROR = @as(c_int, 112);
pub const ASN1_R_ERROR_GETTING_TIME = @as(c_int, 173);
pub const ASN1_R_ERROR_LOADING_SECTION = @as(c_int, 172);
pub const ASN1_R_ERROR_SETTING_CIPHER_PARAMS = @as(c_int, 114);
pub const ASN1_R_EXPECTING_AN_INTEGER = @as(c_int, 115);
pub const ASN1_R_EXPECTING_AN_OBJECT = @as(c_int, 116);
pub const ASN1_R_EXPLICIT_LENGTH_MISMATCH = @as(c_int, 119);
pub const ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED = @as(c_int, 120);
pub const ASN1_R_FIELD_MISSING = @as(c_int, 121);
pub const ASN1_R_FIRST_NUM_TOO_LARGE = @as(c_int, 122);
pub const ASN1_R_GENERALIZEDTIME_IS_TOO_SHORT = @as(c_int, 232);
pub const ASN1_R_HEADER_TOO_LONG = @as(c_int, 123);
pub const ASN1_R_ILLEGAL_BITSTRING_FORMAT = @as(c_int, 175);
pub const ASN1_R_ILLEGAL_BOOLEAN = @as(c_int, 176);
pub const ASN1_R_ILLEGAL_CHARACTERS = @as(c_int, 124);
pub const ASN1_R_ILLEGAL_FORMAT = @as(c_int, 177);
pub const ASN1_R_ILLEGAL_HEX = @as(c_int, 178);
pub const ASN1_R_ILLEGAL_IMPLICIT_TAG = @as(c_int, 179);
pub const ASN1_R_ILLEGAL_INTEGER = @as(c_int, 180);
pub const ASN1_R_ILLEGAL_NEGATIVE_VALUE = @as(c_int, 226);
pub const ASN1_R_ILLEGAL_NESTED_TAGGING = @as(c_int, 181);
pub const ASN1_R_ILLEGAL_NULL = @as(c_int, 125);
pub const ASN1_R_ILLEGAL_NULL_VALUE = @as(c_int, 182);
pub const ASN1_R_ILLEGAL_OBJECT = @as(c_int, 183);
pub const ASN1_R_ILLEGAL_OPTIONAL_ANY = @as(c_int, 126);
pub const ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE = @as(c_int, 170);
pub const ASN1_R_ILLEGAL_PADDING = @as(c_int, 221);
pub const ASN1_R_ILLEGAL_TAGGED_ANY = @as(c_int, 127);
pub const ASN1_R_ILLEGAL_TIME_VALUE = @as(c_int, 184);
pub const ASN1_R_ILLEGAL_ZERO_CONTENT = @as(c_int, 222);
pub const ASN1_R_INTEGER_NOT_ASCII_FORMAT = @as(c_int, 185);
pub const ASN1_R_INTEGER_TOO_LARGE_FOR_LONG = @as(c_int, 128);
pub const ASN1_R_INVALID_BIT_STRING_BITS_LEFT = @as(c_int, 220);
pub const ASN1_R_INVALID_BMPSTRING_LENGTH = @as(c_int, 129);
pub const ASN1_R_INVALID_DIGIT = @as(c_int, 130);
pub const ASN1_R_INVALID_MIME_TYPE = @as(c_int, 205);
pub const ASN1_R_INVALID_MODIFIER = @as(c_int, 186);
pub const ASN1_R_INVALID_NUMBER = @as(c_int, 187);
pub const ASN1_R_INVALID_OBJECT_ENCODING = @as(c_int, 216);
pub const ASN1_R_INVALID_SCRYPT_PARAMETERS = @as(c_int, 227);
pub const ASN1_R_INVALID_SEPARATOR = @as(c_int, 131);
pub const ASN1_R_INVALID_STRING_TABLE_VALUE = @as(c_int, 218);
pub const ASN1_R_INVALID_UNIVERSALSTRING_LENGTH = @as(c_int, 133);
pub const ASN1_R_INVALID_UTF8STRING = @as(c_int, 134);
pub const ASN1_R_INVALID_VALUE = @as(c_int, 219);
pub const ASN1_R_LENGTH_TOO_LONG = @as(c_int, 231);
pub const ASN1_R_LIST_ERROR = @as(c_int, 188);
pub const ASN1_R_MIME_NO_CONTENT_TYPE = @as(c_int, 206);
pub const ASN1_R_MIME_PARSE_ERROR = @as(c_int, 207);
pub const ASN1_R_MIME_SIG_PARSE_ERROR = @as(c_int, 208);
pub const ASN1_R_MISSING_EOC = @as(c_int, 137);
pub const ASN1_R_MISSING_SECOND_NUMBER = @as(c_int, 138);
pub const ASN1_R_MISSING_VALUE = @as(c_int, 189);
pub const ASN1_R_MSTRING_NOT_UNIVERSAL = @as(c_int, 139);
pub const ASN1_R_MSTRING_WRONG_TAG = @as(c_int, 140);
pub const ASN1_R_NESTED_ASN1_STRING = @as(c_int, 197);
pub const ASN1_R_NESTED_TOO_DEEP = @as(c_int, 201);
pub const ASN1_R_NON_HEX_CHARACTERS = @as(c_int, 141);
pub const ASN1_R_NOT_ASCII_FORMAT = @as(c_int, 190);
pub const ASN1_R_NOT_ENOUGH_DATA = @as(c_int, 142);
pub const ASN1_R_NO_CONTENT_TYPE = @as(c_int, 209);
pub const ASN1_R_NO_MATCHING_CHOICE_TYPE = @as(c_int, 143);
pub const ASN1_R_NO_MULTIPART_BODY_FAILURE = @as(c_int, 210);
pub const ASN1_R_NO_MULTIPART_BOUNDARY = @as(c_int, 211);
pub const ASN1_R_NO_SIG_CONTENT_TYPE = @as(c_int, 212);
pub const ASN1_R_NULL_IS_WRONG_LENGTH = @as(c_int, 144);
pub const ASN1_R_OBJECT_NOT_ASCII_FORMAT = @as(c_int, 191);
pub const ASN1_R_ODD_NUMBER_OF_CHARS = @as(c_int, 145);
pub const ASN1_R_SECOND_NUMBER_TOO_LARGE = @as(c_int, 147);
pub const ASN1_R_SEQUENCE_LENGTH_MISMATCH = @as(c_int, 148);
pub const ASN1_R_SEQUENCE_NOT_CONSTRUCTED = @as(c_int, 149);
pub const ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG = @as(c_int, 192);
pub const ASN1_R_SHORT_LINE = @as(c_int, 150);
pub const ASN1_R_SIG_INVALID_MIME_TYPE = @as(c_int, 213);
pub const ASN1_R_STREAMING_NOT_SUPPORTED = @as(c_int, 202);
pub const ASN1_R_STRING_TOO_LONG = @as(c_int, 151);
pub const ASN1_R_STRING_TOO_SHORT = @as(c_int, 152);
pub const ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD = @as(c_int, 154);
pub const ASN1_R_TIME_NOT_ASCII_FORMAT = @as(c_int, 193);
pub const ASN1_R_TOO_LARGE = @as(c_int, 223);
pub const ASN1_R_TOO_LONG = @as(c_int, 155);
pub const ASN1_R_TOO_SMALL = @as(c_int, 224);
pub const ASN1_R_TYPE_NOT_CONSTRUCTED = @as(c_int, 156);
pub const ASN1_R_TYPE_NOT_PRIMITIVE = @as(c_int, 195);
pub const ASN1_R_UNEXPECTED_EOC = @as(c_int, 159);
pub const ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH = @as(c_int, 215);
pub const ASN1_R_UNKNOWN_DIGEST = @as(c_int, 229);
pub const ASN1_R_UNKNOWN_FORMAT = @as(c_int, 160);
pub const ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM = @as(c_int, 161);
pub const ASN1_R_UNKNOWN_OBJECT_TYPE = @as(c_int, 162);
pub const ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE = @as(c_int, 163);
pub const ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM = @as(c_int, 199);
pub const ASN1_R_UNKNOWN_TAG = @as(c_int, 194);
pub const ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE = @as(c_int, 164);
pub const ASN1_R_UNSUPPORTED_CIPHER = @as(c_int, 228);
pub const ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE = @as(c_int, 167);
pub const ASN1_R_UNSUPPORTED_TYPE = @as(c_int, 196);
pub const ASN1_R_UTCTIME_IS_TOO_SHORT = @as(c_int, 233);
pub const ASN1_R_WRONG_INTEGER_TYPE = @as(c_int, 225);
pub const ASN1_R_WRONG_PUBLIC_KEY_TYPE = @as(c_int, 200);
pub const ASN1_R_WRONG_TAG = @as(c_int, 168);
pub const V_ASN1_UNIVERSAL = @as(c_int, 0x00);
pub const V_ASN1_APPLICATION = @as(c_int, 0x40);
pub const V_ASN1_CONTEXT_SPECIFIC = @as(c_int, 0x80);
pub const V_ASN1_PRIVATE = @as(c_int, 0xc0);
pub const V_ASN1_CONSTRUCTED = @as(c_int, 0x20);
pub const V_ASN1_PRIMITIVE_TAG = @as(c_int, 0x1f);
pub const V_ASN1_PRIMATIVE_TAG = V_ASN1_PRIMITIVE_TAG;
pub const V_ASN1_APP_CHOOSE = -@as(c_int, 2);
pub const V_ASN1_OTHER = -@as(c_int, 3);
pub const V_ASN1_ANY = -@as(c_int, 4);
pub const V_ASN1_UNDEF = -@as(c_int, 1);
pub const V_ASN1_EOC = @as(c_int, 0);
pub const V_ASN1_BOOLEAN = @as(c_int, 1);
pub const V_ASN1_INTEGER = @as(c_int, 2);
pub const V_ASN1_BIT_STRING = @as(c_int, 3);
pub const V_ASN1_OCTET_STRING = @as(c_int, 4);
pub const V_ASN1_NULL = @as(c_int, 5);
pub const V_ASN1_OBJECT = @as(c_int, 6);
pub const V_ASN1_OBJECT_DESCRIPTOR = @as(c_int, 7);
pub const V_ASN1_EXTERNAL = @as(c_int, 8);
pub const V_ASN1_REAL = @as(c_int, 9);
pub const V_ASN1_ENUMERATED = @as(c_int, 10);
pub const V_ASN1_UTF8STRING = @as(c_int, 12);
pub const V_ASN1_SEQUENCE = @as(c_int, 16);
pub const V_ASN1_SET = @as(c_int, 17);
pub const V_ASN1_NUMERICSTRING = @as(c_int, 18);
pub const V_ASN1_PRINTABLESTRING = @as(c_int, 19);
pub const V_ASN1_T61STRING = @as(c_int, 20);
pub const V_ASN1_TELETEXSTRING = @as(c_int, 20);
pub const V_ASN1_VIDEOTEXSTRING = @as(c_int, 21);
pub const V_ASN1_IA5STRING = @as(c_int, 22);
pub const V_ASN1_UTCTIME = @as(c_int, 23);
pub const V_ASN1_GENERALIZEDTIME = @as(c_int, 24);
pub const V_ASN1_GRAPHICSTRING = @as(c_int, 25);
pub const V_ASN1_ISO64STRING = @as(c_int, 26);
pub const V_ASN1_VISIBLESTRING = @as(c_int, 26);
pub const V_ASN1_GENERALSTRING = @as(c_int, 27);
pub const V_ASN1_UNIVERSALSTRING = @as(c_int, 28);
pub const V_ASN1_BMPSTRING = @as(c_int, 30);
pub const V_ASN1_NEG = @as(c_int, 0x100);
pub const V_ASN1_NEG_INTEGER = @as(c_int, 2) | V_ASN1_NEG;
pub const V_ASN1_NEG_ENUMERATED = @as(c_int, 10) | V_ASN1_NEG;
pub const B_ASN1_NUMERICSTRING = @as(c_int, 0x0001);
pub const B_ASN1_PRINTABLESTRING = @as(c_int, 0x0002);
pub const B_ASN1_T61STRING = @as(c_int, 0x0004);
pub const B_ASN1_TELETEXSTRING = @as(c_int, 0x0004);
pub const B_ASN1_VIDEOTEXSTRING = @as(c_int, 0x0008);
pub const B_ASN1_IA5STRING = @as(c_int, 0x0010);
pub const B_ASN1_GRAPHICSTRING = @as(c_int, 0x0020);
pub const B_ASN1_ISO64STRING = @as(c_int, 0x0040);
pub const B_ASN1_VISIBLESTRING = @as(c_int, 0x0040);
pub const B_ASN1_GENERALSTRING = @as(c_int, 0x0080);
pub const B_ASN1_UNIVERSALSTRING = @as(c_int, 0x0100);
pub const B_ASN1_OCTET_STRING = @as(c_int, 0x0200);
pub const B_ASN1_BIT_STRING = @as(c_int, 0x0400);
pub const B_ASN1_BMPSTRING = @as(c_int, 0x0800);
pub const B_ASN1_UNKNOWN = @as(c_int, 0x1000);
pub const B_ASN1_UTF8STRING = @as(c_int, 0x2000);
pub const B_ASN1_UTCTIME = @as(c_int, 0x4000);
pub const B_ASN1_GENERALIZEDTIME = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const B_ASN1_SEQUENCE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const MBSTRING_FLAG = @as(c_int, 0x1000);
pub const MBSTRING_UTF8 = MBSTRING_FLAG;
pub const MBSTRING_ASC = MBSTRING_FLAG | @as(c_int, 1);
pub const MBSTRING_BMP = MBSTRING_FLAG | @as(c_int, 2);
pub const MBSTRING_UNIV = MBSTRING_FLAG | @as(c_int, 4);
pub const SMIME_OLDMIME = @as(c_int, 0x400);
pub const SMIME_CRLFEOL = @as(c_int, 0x800);
pub const SMIME_STREAM = @as(c_int, 0x1000);
pub inline fn sk_X509_ALGOR_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_ALGOR_sk_type(sk));
}
pub inline fn sk_X509_ALGOR_value(sk: anytype, idx: anytype) [*c]X509_ALGOR {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_value(ossl_check_const_X509_ALGOR_sk_type(sk), idx));
}
pub const sk_X509_ALGOR_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:135:9
pub const sk_X509_ALGOR_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:136:9
pub const sk_X509_ALGOR_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:137:9
pub inline fn sk_X509_ALGOR_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_ALGOR_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_ALGOR_sk_type(sk), n);
}
pub inline fn sk_X509_ALGOR_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_ALGOR_sk_type(sk));
}
pub inline fn sk_X509_ALGOR_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_ALGOR_sk_type(sk));
}
pub inline fn sk_X509_ALGOR_delete(sk: anytype, i: anytype) [*c]X509_ALGOR {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_delete(ossl_check_X509_ALGOR_sk_type(sk), i));
}
pub inline fn sk_X509_ALGOR_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_ALGOR {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_delete_ptr(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr)));
}
pub inline fn sk_X509_ALGOR_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr));
}
pub inline fn sk_X509_ALGOR_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr));
}
pub inline fn sk_X509_ALGOR_pop(sk: anytype) [*c]X509_ALGOR {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_pop(ossl_check_X509_ALGOR_sk_type(sk)));
}
pub inline fn sk_X509_ALGOR_shift(sk: anytype) [*c]X509_ALGOR {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_shift(ossl_check_X509_ALGOR_sk_type(sk)));
}
pub inline fn sk_X509_ALGOR_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_freefunc_type(freefunc));
}
pub inline fn sk_X509_ALGOR_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr), idx);
}
pub inline fn sk_X509_ALGOR_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_ALGOR {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_set(ossl_check_X509_ALGOR_sk_type(sk), idx, ossl_check_X509_ALGOR_type(ptr)));
}
pub inline fn sk_X509_ALGOR_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr));
}
pub inline fn sk_X509_ALGOR_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr));
}
pub inline fn sk_X509_ALGOR_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr), pnum);
}
pub inline fn sk_X509_ALGOR_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_ALGOR_sk_type(sk));
}
pub inline fn sk_X509_ALGOR_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_ALGOR_sk_type(sk));
}
pub const sk_X509_ALGOR_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:155:9
pub const sk_X509_ALGOR_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:156:9
pub inline fn sk_X509_ALGOR_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_ALGOR_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_ALGOR_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_compfunc_type(cmp)));
}
pub const ASN1_STRING_FLAG_BITS_LEFT = @as(c_int, 0x08);
pub const ASN1_STRING_FLAG_NDEF = @as(c_int, 0x010);
pub const ASN1_STRING_FLAG_CONT = @as(c_int, 0x020);
pub const ASN1_STRING_FLAG_MSTRING = @as(c_int, 0x040);
pub const ASN1_STRING_FLAG_EMBED = @as(c_int, 0x080);
pub const ASN1_STRING_FLAG_X509_TIME = @as(c_int, 0x100);
pub const ASN1_LONG_UNDEF = @as(c_long, 0x7fffffff);
pub const STABLE_FLAGS_MALLOC = @as(c_int, 0x01);
pub const STABLE_FLAGS_CLEAR = STABLE_FLAGS_MALLOC;
pub const STABLE_NO_MASK = @as(c_int, 0x02);
pub const DIRSTRING_TYPE = ((B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING) | B_ASN1_BMPSTRING) | B_ASN1_UTF8STRING;
pub const PKCS9STRING_TYPE = DIRSTRING_TYPE | B_ASN1_IA5STRING;
pub inline fn sk_ASN1_STRING_TABLE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_TABLE_value(sk: anytype, idx: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_value(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk), idx));
}
pub const sk_ASN1_STRING_TABLE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:237:9
pub const sk_ASN1_STRING_TABLE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:238:9
pub const sk_ASN1_STRING_TABLE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:239:9
pub inline fn sk_ASN1_STRING_TABLE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_STRING_TABLE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_STRING_TABLE_sk_type(sk), n);
}
pub inline fn sk_ASN1_STRING_TABLE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_STRING_TABLE_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_TABLE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_STRING_TABLE_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_TABLE_delete(sk: anytype, i: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_delete(ossl_check_ASN1_STRING_TABLE_sk_type(sk), i));
}
pub inline fn sk_ASN1_STRING_TABLE_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_delete_ptr(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr)));
}
pub inline fn sk_ASN1_STRING_TABLE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr));
}
pub inline fn sk_ASN1_STRING_TABLE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr));
}
pub inline fn sk_ASN1_STRING_TABLE_pop(sk: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_pop(ossl_check_ASN1_STRING_TABLE_sk_type(sk)));
}
pub inline fn sk_ASN1_STRING_TABLE_shift(sk: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_shift(ossl_check_ASN1_STRING_TABLE_sk_type(sk)));
}
pub inline fn sk_ASN1_STRING_TABLE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_STRING_TABLE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr), idx);
}
pub inline fn sk_ASN1_STRING_TABLE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_set(ossl_check_ASN1_STRING_TABLE_sk_type(sk), idx, ossl_check_ASN1_STRING_TABLE_type(ptr)));
}
pub inline fn sk_ASN1_STRING_TABLE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr));
}
pub inline fn sk_ASN1_STRING_TABLE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr));
}
pub inline fn sk_ASN1_STRING_TABLE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr), pnum);
}
pub inline fn sk_ASN1_STRING_TABLE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_STRING_TABLE_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_TABLE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk));
}
pub const sk_ASN1_STRING_TABLE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:257:9
pub const sk_ASN1_STRING_TABLE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:258:9
pub inline fn sk_ASN1_STRING_TABLE_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_STRING_TABLE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_STRING_TABLE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_compfunc_type(cmp)));
}
pub const ub_name = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const ub_common_name = @as(c_int, 64);
pub const ub_locality_name = @as(c_int, 128);
pub const ub_state_name = @as(c_int, 128);
pub const ub_organization_name = @as(c_int, 64);
pub const ub_organization_unit_name = @as(c_int, 64);
pub const ub_title = @as(c_int, 64);
pub const ub_email_address = @as(c_int, 128);
pub inline fn DECLARE_ASN1_FUNCTIONS_attr(attr: anytype, @"type": anytype) @TypeOf(DECLARE_ASN1_FUNCTIONS_name_attr(attr, @"type", @"type")) {
    _ = &attr;
    _ = &@"type";
    return DECLARE_ASN1_FUNCTIONS_name_attr(attr, @"type", @"type");
}
pub const DECLARE_ASN1_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:291:10
pub inline fn DECLARE_ASN1_ALLOC_FUNCTIONS_attr(attr: anytype, @"type": anytype) @TypeOf(DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr(attr, @"type", @"type")) {
    _ = &attr;
    _ = &@"type";
    return DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr(attr, @"type", @"type");
}
pub const DECLARE_ASN1_ALLOC_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:296:10
pub inline fn DECLARE_ASN1_FUNCTIONS_name_attr(attr: anytype, @"type": anytype, name: anytype) @TypeOf(DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr(attr, @"type", name) ++ DECLARE_ASN1_ENCODE_FUNCTIONS_name_attr(attr, @"type", name)) {
    _ = &attr;
    _ = &@"type";
    _ = &name;
    return DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr(attr, @"type", name) ++ DECLARE_ASN1_ENCODE_FUNCTIONS_name_attr(attr, @"type", name);
}
pub const DECLARE_ASN1_FUNCTIONS_name = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:302:10
pub inline fn DECLARE_ASN1_ENCODE_FUNCTIONS_attr(attr: anytype, @"type": anytype, itname: anytype, name: anytype) @TypeOf(DECLARE_ASN1_ENCODE_FUNCTIONS_only_attr(attr, @"type", name) ++ DECLARE_ASN1_ITEM_attr(attr, itname)) {
    _ = &attr;
    _ = &@"type";
    _ = &itname;
    _ = &name;
    return DECLARE_ASN1_ENCODE_FUNCTIONS_only_attr(attr, @"type", name) ++ DECLARE_ASN1_ITEM_attr(attr, itname);
}
pub const DECLARE_ASN1_ENCODE_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:308:10
pub inline fn DECLARE_ASN1_ENCODE_FUNCTIONS_name_attr(attr: anytype, @"type": anytype, name: anytype) @TypeOf(DECLARE_ASN1_ENCODE_FUNCTIONS_attr(attr, @"type", name, name)) {
    _ = &attr;
    _ = &@"type";
    _ = &name;
    return DECLARE_ASN1_ENCODE_FUNCTIONS_attr(attr, @"type", name, name);
}
pub const DECLARE_ASN1_ENCODE_FUNCTIONS_name = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:313:10
pub const DECLARE_ASN1_ENCODE_FUNCTIONS_only_attr = @compileError("unable to translate macro: undefined identifier `d2i_`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:316:10
pub const DECLARE_ASN1_ENCODE_FUNCTIONS_only = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:319:10
pub const DECLARE_ASN1_NDEF_FUNCTION_attr = @compileError("unable to translate macro: undefined identifier `i2d_`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:322:10
pub const DECLARE_ASN1_NDEF_FUNCTION = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:324:10
pub const DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr = @compileError("unable to translate macro: undefined identifier `_new`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:327:10
pub const DECLARE_ASN1_ALLOC_FUNCTIONS_name = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:330:10
pub inline fn DECLARE_ASN1_DUP_FUNCTION_attr(attr: anytype, @"type": anytype) @TypeOf(DECLARE_ASN1_DUP_FUNCTION_name_attr(attr, @"type", @"type")) {
    _ = &attr;
    _ = &@"type";
    return DECLARE_ASN1_DUP_FUNCTION_name_attr(attr, @"type", @"type");
}
pub const DECLARE_ASN1_DUP_FUNCTION = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:335:10
pub const DECLARE_ASN1_DUP_FUNCTION_name_attr = @compileError("unable to translate macro: undefined identifier `_dup`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:338:10
pub const DECLARE_ASN1_DUP_FUNCTION_name = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:340:10
pub inline fn DECLARE_ASN1_PRINT_FUNCTION_attr(attr: anytype, stname: anytype) @TypeOf(DECLARE_ASN1_PRINT_FUNCTION_fname_attr(attr, stname, stname)) {
    _ = &attr;
    _ = &stname;
    return DECLARE_ASN1_PRINT_FUNCTION_fname_attr(attr, stname, stname);
}
pub const DECLARE_ASN1_PRINT_FUNCTION = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:345:10
pub const DECLARE_ASN1_PRINT_FUNCTION_fname_attr = @compileError("unable to translate macro: undefined identifier `_print_ctx`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:348:10
pub const DECLARE_ASN1_PRINT_FUNCTION_fname = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:351:10
pub const D2I_OF = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:354:10
pub const I2D_OF = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:355:10
pub const CHECKED_D2I_OF = @compileError("unable to translate C expr: expected ')' instead got 'A number'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:357:10
pub const CHECKED_I2D_OF = @compileError("unable to translate C expr: expected ')' instead got 'A number'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:359:10
pub const CHECKED_NEW_OF = @compileError("unable to translate C expr: expected ')' instead got '('");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:361:10
pub const CHECKED_PTR_OF = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:363:10
pub const CHECKED_PPTR_OF = @compileError("unable to translate C expr: expected ')' instead got '*'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:365:10
pub const TYPEDEF_D2I_OF = @compileError("unable to translate macro: undefined identifier `d2i_of_`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:368:10
pub const TYPEDEF_I2D_OF = @compileError("unable to translate macro: undefined identifier `i2d_of_`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:369:10
pub const TYPEDEF_D2I2D_OF = @compileError("unable to translate C expr: unexpected token ';'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:370:10
pub inline fn ASN1_ITEM_ptr(iptr: anytype) @TypeOf(iptr()) {
    _ = &iptr;
    return iptr();
}
pub const ASN1_ITEM_ref = @compileError("unable to translate macro: undefined identifier `_it`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:424:10
pub const ASN1_ITEM_rptr = @compileError("unable to translate macro: undefined identifier `_it`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:426:10
pub const DECLARE_ASN1_ITEM_attr = @compileError("unable to translate macro: undefined identifier `_it`");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:428:10
pub const DECLARE_ASN1_ITEM = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:430:10
pub const ASN1_STRFLGS_ESC_2253 = @as(c_int, 1);
pub const ASN1_STRFLGS_ESC_CTRL = @as(c_int, 2);
pub const ASN1_STRFLGS_ESC_MSB = @as(c_int, 4);
pub const ASN1_DTFLGS_TYPE_MASK = @as(c_ulong, 0x0F);
pub const ASN1_DTFLGS_RFC822 = @as(c_ulong, 0x00);
pub const ASN1_DTFLGS_ISO8601 = @as(c_ulong, 0x01);
pub const ASN1_STRFLGS_ESC_QUOTE = @as(c_int, 8);
pub const CHARTYPE_PRINTABLESTRING = @as(c_int, 0x10);
pub const CHARTYPE_FIRST_ESC_2253 = @as(c_int, 0x20);
pub const CHARTYPE_LAST_ESC_2253 = @as(c_int, 0x40);
pub const ASN1_STRFLGS_UTF8_CONVERT = @as(c_int, 0x10);
pub const ASN1_STRFLGS_IGNORE_TYPE = @as(c_int, 0x20);
pub const ASN1_STRFLGS_SHOW_TYPE = @as(c_int, 0x40);
pub const ASN1_STRFLGS_DUMP_ALL = @as(c_int, 0x80);
pub const ASN1_STRFLGS_DUMP_UNKNOWN = @as(c_int, 0x100);
pub const ASN1_STRFLGS_DUMP_DER = @as(c_int, 0x200);
pub const ASN1_STRFLGS_ESC_2254 = @as(c_int, 0x400);
pub const ASN1_STRFLGS_RFC2253 = ((((ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL) | ASN1_STRFLGS_ESC_MSB) | ASN1_STRFLGS_UTF8_CONVERT) | ASN1_STRFLGS_DUMP_UNKNOWN) | ASN1_STRFLGS_DUMP_DER;
pub inline fn sk_ASN1_TYPE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_TYPE_sk_type(sk));
}
pub inline fn sk_ASN1_TYPE_value(sk: anytype, idx: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_value(ossl_check_const_ASN1_TYPE_sk_type(sk), idx));
}
pub const sk_ASN1_TYPE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:557:9
pub const sk_ASN1_TYPE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:558:9
pub const sk_ASN1_TYPE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:559:9
pub inline fn sk_ASN1_TYPE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_TYPE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_TYPE_sk_type(sk), n);
}
pub inline fn sk_ASN1_TYPE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_TYPE_sk_type(sk));
}
pub inline fn sk_ASN1_TYPE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_TYPE_sk_type(sk));
}
pub inline fn sk_ASN1_TYPE_delete(sk: anytype, i: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_delete(ossl_check_ASN1_TYPE_sk_type(sk), i));
}
pub inline fn sk_ASN1_TYPE_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_delete_ptr(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr)));
}
pub inline fn sk_ASN1_TYPE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr));
}
pub inline fn sk_ASN1_TYPE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr));
}
pub inline fn sk_ASN1_TYPE_pop(sk: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_pop(ossl_check_ASN1_TYPE_sk_type(sk)));
}
pub inline fn sk_ASN1_TYPE_shift(sk: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_shift(ossl_check_ASN1_TYPE_sk_type(sk)));
}
pub inline fn sk_ASN1_TYPE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_TYPE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr), idx);
}
pub inline fn sk_ASN1_TYPE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_set(ossl_check_ASN1_TYPE_sk_type(sk), idx, ossl_check_ASN1_TYPE_type(ptr)));
}
pub inline fn sk_ASN1_TYPE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr));
}
pub inline fn sk_ASN1_TYPE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr));
}
pub inline fn sk_ASN1_TYPE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr), pnum);
}
pub inline fn sk_ASN1_TYPE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_TYPE_sk_type(sk));
}
pub inline fn sk_ASN1_TYPE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_TYPE_sk_type(sk));
}
pub const sk_ASN1_TYPE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:577:9
pub const sk_ASN1_TYPE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:578:9
pub inline fn sk_ASN1_TYPE_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_TYPE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_TYPE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_compfunc_type(cmp)));
}
pub const B_ASN1_TIME = B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME;
pub const B_ASN1_PRINTABLE = ((((((((B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING) | B_ASN1_T61STRING) | B_ASN1_IA5STRING) | B_ASN1_BIT_STRING) | B_ASN1_UNIVERSALSTRING) | B_ASN1_BMPSTRING) | B_ASN1_UTF8STRING) | B_ASN1_SEQUENCE) | B_ASN1_UNKNOWN;
pub const B_ASN1_DIRECTORYSTRING = (((B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING) | B_ASN1_BMPSTRING) | B_ASN1_UNIVERSALSTRING) | B_ASN1_UTF8STRING;
pub const B_ASN1_DISPLAYTEXT = ((B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING) | B_ASN1_BMPSTRING) | B_ASN1_UTF8STRING;
pub inline fn sk_ASN1_OBJECT_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_OBJECT_sk_type(sk));
}
pub inline fn sk_ASN1_OBJECT_value(sk: anytype, idx: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_value(ossl_check_const_ASN1_OBJECT_sk_type(sk), idx));
}
pub const sk_ASN1_OBJECT_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:637:9
pub const sk_ASN1_OBJECT_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:638:9
pub const sk_ASN1_OBJECT_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:639:9
pub inline fn sk_ASN1_OBJECT_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_OBJECT_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_OBJECT_sk_type(sk), n);
}
pub inline fn sk_ASN1_OBJECT_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_OBJECT_sk_type(sk));
}
pub inline fn sk_ASN1_OBJECT_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_OBJECT_sk_type(sk));
}
pub inline fn sk_ASN1_OBJECT_delete(sk: anytype, i: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_delete(ossl_check_ASN1_OBJECT_sk_type(sk), i));
}
pub inline fn sk_ASN1_OBJECT_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_delete_ptr(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr)));
}
pub inline fn sk_ASN1_OBJECT_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr));
}
pub inline fn sk_ASN1_OBJECT_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr));
}
pub inline fn sk_ASN1_OBJECT_pop(sk: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_pop(ossl_check_ASN1_OBJECT_sk_type(sk)));
}
pub inline fn sk_ASN1_OBJECT_shift(sk: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_shift(ossl_check_ASN1_OBJECT_sk_type(sk)));
}
pub inline fn sk_ASN1_OBJECT_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_OBJECT_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr), idx);
}
pub inline fn sk_ASN1_OBJECT_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_set(ossl_check_ASN1_OBJECT_sk_type(sk), idx, ossl_check_ASN1_OBJECT_type(ptr)));
}
pub inline fn sk_ASN1_OBJECT_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr));
}
pub inline fn sk_ASN1_OBJECT_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr));
}
pub inline fn sk_ASN1_OBJECT_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr), pnum);
}
pub inline fn sk_ASN1_OBJECT_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_OBJECT_sk_type(sk));
}
pub inline fn sk_ASN1_OBJECT_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_OBJECT_sk_type(sk));
}
pub const sk_ASN1_OBJECT_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:657:9
pub const sk_ASN1_OBJECT_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:658:9
pub inline fn sk_ASN1_OBJECT_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_OBJECT_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_OBJECT_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_compfunc_type(cmp)));
}
pub inline fn sk_ASN1_INTEGER_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_INTEGER_sk_type(sk));
}
pub inline fn sk_ASN1_INTEGER_value(sk: anytype, idx: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_value(ossl_check_const_ASN1_INTEGER_sk_type(sk), idx));
}
pub const sk_ASN1_INTEGER_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:703:9
pub const sk_ASN1_INTEGER_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:704:9
pub const sk_ASN1_INTEGER_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:705:9
pub inline fn sk_ASN1_INTEGER_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_INTEGER_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_INTEGER_sk_type(sk), n);
}
pub inline fn sk_ASN1_INTEGER_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_INTEGER_sk_type(sk));
}
pub inline fn sk_ASN1_INTEGER_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_INTEGER_sk_type(sk));
}
pub inline fn sk_ASN1_INTEGER_delete(sk: anytype, i: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_delete(ossl_check_ASN1_INTEGER_sk_type(sk), i));
}
pub inline fn sk_ASN1_INTEGER_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_delete_ptr(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr)));
}
pub inline fn sk_ASN1_INTEGER_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr));
}
pub inline fn sk_ASN1_INTEGER_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr));
}
pub inline fn sk_ASN1_INTEGER_pop(sk: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_pop(ossl_check_ASN1_INTEGER_sk_type(sk)));
}
pub inline fn sk_ASN1_INTEGER_shift(sk: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_shift(ossl_check_ASN1_INTEGER_sk_type(sk)));
}
pub inline fn sk_ASN1_INTEGER_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_INTEGER_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr), idx);
}
pub inline fn sk_ASN1_INTEGER_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_set(ossl_check_ASN1_INTEGER_sk_type(sk), idx, ossl_check_ASN1_INTEGER_type(ptr)));
}
pub inline fn sk_ASN1_INTEGER_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr));
}
pub inline fn sk_ASN1_INTEGER_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr));
}
pub inline fn sk_ASN1_INTEGER_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr), pnum);
}
pub inline fn sk_ASN1_INTEGER_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_INTEGER_sk_type(sk));
}
pub inline fn sk_ASN1_INTEGER_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_INTEGER_sk_type(sk));
}
pub const sk_ASN1_INTEGER_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:723:9
pub const sk_ASN1_INTEGER_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:724:9
pub inline fn sk_ASN1_INTEGER_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_INTEGER_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_INTEGER_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_compfunc_type(cmp)));
}
pub inline fn sk_ASN1_UTF8STRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_UTF8STRING_sk_type(sk));
}
pub inline fn sk_ASN1_UTF8STRING_value(sk: anytype, idx: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_value(ossl_check_const_ASN1_UTF8STRING_sk_type(sk), idx));
}
pub const sk_ASN1_UTF8STRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:765:9
pub const sk_ASN1_UTF8STRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:766:9
pub const sk_ASN1_UTF8STRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:767:9
pub inline fn sk_ASN1_UTF8STRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_UTF8STRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_UTF8STRING_sk_type(sk), n);
}
pub inline fn sk_ASN1_UTF8STRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_UTF8STRING_sk_type(sk));
}
pub inline fn sk_ASN1_UTF8STRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_UTF8STRING_sk_type(sk));
}
pub inline fn sk_ASN1_UTF8STRING_delete(sk: anytype, i: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_delete(ossl_check_ASN1_UTF8STRING_sk_type(sk), i));
}
pub inline fn sk_ASN1_UTF8STRING_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_delete_ptr(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr)));
}
pub inline fn sk_ASN1_UTF8STRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr));
}
pub inline fn sk_ASN1_UTF8STRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr));
}
pub inline fn sk_ASN1_UTF8STRING_pop(sk: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_pop(ossl_check_ASN1_UTF8STRING_sk_type(sk)));
}
pub inline fn sk_ASN1_UTF8STRING_shift(sk: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_shift(ossl_check_ASN1_UTF8STRING_sk_type(sk)));
}
pub inline fn sk_ASN1_UTF8STRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_UTF8STRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr), idx);
}
pub inline fn sk_ASN1_UTF8STRING_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_set(ossl_check_ASN1_UTF8STRING_sk_type(sk), idx, ossl_check_ASN1_UTF8STRING_type(ptr)));
}
pub inline fn sk_ASN1_UTF8STRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr));
}
pub inline fn sk_ASN1_UTF8STRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr));
}
pub inline fn sk_ASN1_UTF8STRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr), pnum);
}
pub inline fn sk_ASN1_UTF8STRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_UTF8STRING_sk_type(sk));
}
pub inline fn sk_ASN1_UTF8STRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_UTF8STRING_sk_type(sk));
}
pub const sk_ASN1_UTF8STRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:785:9
pub const sk_ASN1_UTF8STRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:786:9
pub inline fn sk_ASN1_UTF8STRING_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_UTF8STRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_UTF8STRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_compfunc_type(cmp)));
}
pub inline fn sk_ASN1_GENERALSTRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk));
}
pub inline fn sk_ASN1_GENERALSTRING_value(sk: anytype, idx: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_value(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk), idx));
}
pub const sk_ASN1_GENERALSTRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:802:9
pub const sk_ASN1_GENERALSTRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:803:9
pub const sk_ASN1_GENERALSTRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:804:9
pub inline fn sk_ASN1_GENERALSTRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_GENERALSTRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_GENERALSTRING_sk_type(sk), n);
}
pub inline fn sk_ASN1_GENERALSTRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_GENERALSTRING_sk_type(sk));
}
pub inline fn sk_ASN1_GENERALSTRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_GENERALSTRING_sk_type(sk));
}
pub inline fn sk_ASN1_GENERALSTRING_delete(sk: anytype, i: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_delete(ossl_check_ASN1_GENERALSTRING_sk_type(sk), i));
}
pub inline fn sk_ASN1_GENERALSTRING_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_delete_ptr(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr)));
}
pub inline fn sk_ASN1_GENERALSTRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr));
}
pub inline fn sk_ASN1_GENERALSTRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr));
}
pub inline fn sk_ASN1_GENERALSTRING_pop(sk: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_pop(ossl_check_ASN1_GENERALSTRING_sk_type(sk)));
}
pub inline fn sk_ASN1_GENERALSTRING_shift(sk: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_shift(ossl_check_ASN1_GENERALSTRING_sk_type(sk)));
}
pub inline fn sk_ASN1_GENERALSTRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_GENERALSTRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr), idx);
}
pub inline fn sk_ASN1_GENERALSTRING_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_set(ossl_check_ASN1_GENERALSTRING_sk_type(sk), idx, ossl_check_ASN1_GENERALSTRING_type(ptr)));
}
pub inline fn sk_ASN1_GENERALSTRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr));
}
pub inline fn sk_ASN1_GENERALSTRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr));
}
pub inline fn sk_ASN1_GENERALSTRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr), pnum);
}
pub inline fn sk_ASN1_GENERALSTRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_GENERALSTRING_sk_type(sk));
}
pub inline fn sk_ASN1_GENERALSTRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk));
}
pub const sk_ASN1_GENERALSTRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:822:9
pub const sk_ASN1_GENERALSTRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:823:9
pub inline fn sk_ASN1_GENERALSTRING_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_GENERALSTRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_GENERALSTRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_compfunc_type(cmp)));
}
pub const ASN1_dup_of = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:909:10
pub const M_ASN1_new_of = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:927:10
pub inline fn M_ASN1_free_of(x: anytype, @"type": anytype) @TypeOf(ASN1_item_free(CHECKED_PTR_OF(@"type", x), ASN1_ITEM_rptr(@"type"))) {
    _ = &x;
    _ = &@"type";
    return ASN1_item_free(CHECKED_PTR_OF(@"type", x), ASN1_ITEM_rptr(@"type"));
}
pub const ASN1_d2i_fp_of = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:934:11
pub const ASN1_i2d_fp_of = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:945:11
pub const ASN1_d2i_bio_of = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:958:11
pub const ASN1_i2d_bio_of = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/asn1.h:969:11
pub const ASN1_PCTX_FLAGS_SHOW_ABSENT = @as(c_int, 0x001);
pub const ASN1_PCTX_FLAGS_SHOW_SEQUENCE = @as(c_int, 0x002);
pub const ASN1_PCTX_FLAGS_SHOW_SSOF = @as(c_int, 0x004);
pub const ASN1_PCTX_FLAGS_SHOW_TYPE = @as(c_int, 0x008);
pub const ASN1_PCTX_FLAGS_NO_ANY_TYPE = @as(c_int, 0x010);
pub const ASN1_PCTX_FLAGS_NO_MSTRING_TYPE = @as(c_int, 0x020);
pub const ASN1_PCTX_FLAGS_NO_FIELD_NAME = @as(c_int, 0x040);
pub const ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME = @as(c_int, 0x080);
pub const ASN1_PCTX_FLAGS_NO_STRUCT_NAME = @as(c_int, 0x100);
pub inline fn DECLARE_ASN1_FUNCTIONS_fname(@"type": anytype, itname: anytype, name: anytype) @TypeOf(DECLARE_ASN1_ALLOC_FUNCTIONS_name(@"type", name) ++ DECLARE_ASN1_ENCODE_FUNCTIONS(@"type", itname, name)) {
    _ = &@"type";
    _ = &itname;
    _ = &name;
    return DECLARE_ASN1_ALLOC_FUNCTIONS_name(@"type", name) ++ DECLARE_ASN1_ENCODE_FUNCTIONS(@"type", itname, name);
}
pub inline fn DECLARE_ASN1_FUNCTIONS_const(@"type": anytype) @TypeOf(DECLARE_ASN1_FUNCTIONS(@"type")) {
    _ = &@"type";
    return DECLARE_ASN1_FUNCTIONS(@"type");
}
pub inline fn DECLARE_ASN1_ENCODE_FUNCTIONS_const(@"type": anytype, name: anytype) @TypeOf(DECLARE_ASN1_ENCODE_FUNCTIONS(@"type", name)) {
    _ = &@"type";
    _ = &name;
    return DECLARE_ASN1_ENCODE_FUNCTIONS(@"type", name);
}
pub inline fn I2D_OF_const(@"type": anytype) @TypeOf(I2D_OF(@"type")) {
    _ = &@"type";
    return I2D_OF(@"type");
}
pub inline fn ASN1_dup_of_const(@"type": anytype, i2d: anytype, d2i: anytype, x: anytype) @TypeOf(ASN1_dup_of(@"type", i2d, d2i, x)) {
    _ = &@"type";
    _ = &i2d;
    _ = &d2i;
    _ = &x;
    return ASN1_dup_of(@"type", i2d, d2i, x);
}
pub inline fn ASN1_i2d_fp_of_const(@"type": anytype, i2d: anytype, out: anytype, x: anytype) @TypeOf(ASN1_i2d_fp_of(@"type", i2d, out, x)) {
    _ = &@"type";
    _ = &i2d;
    _ = &out;
    _ = &x;
    return ASN1_i2d_fp_of(@"type", i2d, out, x);
}
pub inline fn ASN1_i2d_bio_of_const(@"type": anytype, i2d: anytype, out: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(@"type", i2d, out, x)) {
    _ = &@"type";
    _ = &i2d;
    _ = &out;
    _ = &x;
    return ASN1_i2d_bio_of(@"type", i2d, out, x);
}
pub const OPENSSL_OBJECTSERR_H = "";
pub const OBJ_R_OID_EXISTS = @as(c_int, 102);
pub const OBJ_R_UNKNOWN_NID = @as(c_int, 101);
pub const OBJ_R_UNKNOWN_OBJECT_NAME = @as(c_int, 103);
pub const OBJ_NAME_TYPE_UNDEF = @as(c_int, 0x00);
pub const OBJ_NAME_TYPE_MD_METH = @as(c_int, 0x01);
pub const OBJ_NAME_TYPE_CIPHER_METH = @as(c_int, 0x02);
pub const OBJ_NAME_TYPE_PKEY_METH = @as(c_int, 0x03);
pub const OBJ_NAME_TYPE_COMP_METH = @as(c_int, 0x04);
pub const OBJ_NAME_TYPE_MAC_METH = @as(c_int, 0x05);
pub const OBJ_NAME_TYPE_KDF_METH = @as(c_int, 0x06);
pub const OBJ_NAME_TYPE_NUM = @as(c_int, 0x07);
pub const OBJ_NAME_ALIAS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const OBJ_BSEARCH_VALUE_ON_NOMATCH = @as(c_int, 0x01);
pub const OBJ_BSEARCH_FIRST_VALUE_ON_MATCH = @as(c_int, 0x02);
pub inline fn OBJ_create_and_add_object(a: anytype, b: anytype, c: anytype) @TypeOf(OBJ_create(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return OBJ_create(a, b, c);
}
pub const _DECLARE_OBJ_BSEARCH_CMP_FN = @compileError("unable to translate macro: undefined identifier `_cmp_BSEARCH_CMP_FN`");
// /opt/homebrew/opt/openssl@3/include/openssl/objects.h:84:10
pub const DECLARE_OBJ_BSEARCH_CMP_FN = @compileError("unable to translate C expr: unexpected token 'static'");
// /opt/homebrew/opt/openssl@3/include/openssl/objects.h:89:10
pub const DECLARE_OBJ_BSEARCH_GLOBAL_CMP_FN = @compileError("unable to translate macro: undefined identifier `key`");
// /opt/homebrew/opt/openssl@3/include/openssl/objects.h:91:10
pub const IMPLEMENT_OBJ_BSEARCH_CMP_FN = @compileError("unable to translate macro: undefined identifier `_cmp_BSEARCH_CMP_FN`");
// /opt/homebrew/opt/openssl@3/include/openssl/objects.h:121:10
pub const IMPLEMENT_OBJ_BSEARCH_GLOBAL_CMP_FN = @compileError("unable to translate macro: undefined identifier `_cmp_BSEARCH_CMP_FN`");
// /opt/homebrew/opt/openssl@3/include/openssl/objects.h:135:10
pub const OBJ_bsearch = @compileError("unable to translate macro: undefined identifier `_type_1`");
// /opt/homebrew/opt/openssl@3/include/openssl/objects.h:149:10
pub const OBJ_bsearch_ex = @compileError("unable to translate macro: undefined identifier `_type_1`");
// /opt/homebrew/opt/openssl@3/include/openssl/objects.h:156:10
pub const OBJ_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/objects.h:167:10
pub const SN_ac_auditEntity = SN_ac_auditIdentity;
pub const EVP_PK_RSA = @as(c_int, 0x0001);
pub const EVP_PK_DSA = @as(c_int, 0x0002);
pub const EVP_PK_DH = @as(c_int, 0x0004);
pub const EVP_PK_EC = @as(c_int, 0x0008);
pub const EVP_PKT_SIGN = @as(c_int, 0x0010);
pub const EVP_PKT_ENC = @as(c_int, 0x0020);
pub const EVP_PKT_EXCH = @as(c_int, 0x0040);
pub const EVP_PKS_RSA = @as(c_int, 0x0100);
pub const EVP_PKS_DSA = @as(c_int, 0x0200);
pub const EVP_PKS_EC = @as(c_int, 0x0400);
pub const EVP_PKEY_NONE = NID_undef;
pub const EVP_PKEY_RSA = NID_rsaEncryption;
pub const EVP_PKEY_RSA2 = NID_rsa;
pub const EVP_PKEY_RSA_PSS = NID_rsassaPss;
pub const EVP_PKEY_DSA = NID_dsa;
pub const EVP_PKEY_DSA1 = NID_dsa_2;
pub const EVP_PKEY_DSA2 = NID_dsaWithSHA;
pub const EVP_PKEY_DSA3 = NID_dsaWithSHA1;
pub const EVP_PKEY_DSA4 = NID_dsaWithSHA1_2;
pub const EVP_PKEY_DH = NID_dhKeyAgreement;
pub const EVP_PKEY_DHX = NID_dhpublicnumber;
pub const EVP_PKEY_EC = NID_X9_62_id_ecPublicKey;
pub const EVP_PKEY_SM2 = NID_sm2;
pub const EVP_PKEY_HMAC = NID_hmac;
pub const EVP_PKEY_CMAC = NID_cmac;
pub const EVP_PKEY_SCRYPT = NID_id_scrypt;
pub const EVP_PKEY_TLS1_PRF = NID_tls1_prf;
pub const EVP_PKEY_HKDF = NID_hkdf;
pub const EVP_PKEY_POLY1305 = NID_poly1305;
pub const EVP_PKEY_SIPHASH = NID_siphash;
pub const EVP_PKEY_X25519 = NID_X25519;
pub const EVP_PKEY_ED25519 = NID_ED25519;
pub const EVP_PKEY_X448 = NID_X448;
pub const EVP_PKEY_ED448 = NID_ED448;
pub const EVP_PKEY_KEYMGMT = -@as(c_int, 1);
pub const EVP_PKEY_KEY_PARAMETERS = OSSL_KEYMGMT_SELECT_ALL_PARAMETERS;
pub const EVP_PKEY_PRIVATE_KEY = EVP_PKEY_KEY_PARAMETERS | OSSL_KEYMGMT_SELECT_PRIVATE_KEY;
pub const EVP_PKEY_PUBLIC_KEY = EVP_PKEY_KEY_PARAMETERS | OSSL_KEYMGMT_SELECT_PUBLIC_KEY;
pub const EVP_PKEY_KEYPAIR = EVP_PKEY_PUBLIC_KEY | OSSL_KEYMGMT_SELECT_PRIVATE_KEY;
pub const EVP_PKEY_MO_SIGN = @as(c_int, 0x0001);
pub const EVP_PKEY_MO_VERIFY = @as(c_int, 0x0002);
pub const EVP_PKEY_MO_ENCRYPT = @as(c_int, 0x0004);
pub const EVP_PKEY_MO_DECRYPT = @as(c_int, 0x0008);
pub const EVP_MD_FLAG_ONESHOT = @as(c_int, 0x0001);
pub const EVP_MD_FLAG_XOF = @as(c_int, 0x0002);
pub const EVP_MD_FLAG_DIGALGID_MASK = @as(c_int, 0x0018);
pub const EVP_MD_FLAG_DIGALGID_NULL = @as(c_int, 0x0000);
pub const EVP_MD_FLAG_DIGALGID_ABSENT = @as(c_int, 0x0008);
pub const EVP_MD_FLAG_DIGALGID_CUSTOM = @as(c_int, 0x0018);
pub const EVP_MD_FLAG_FIPS = @as(c_int, 0x0400);
pub const EVP_MD_CTRL_DIGALGID = @as(c_int, 0x1);
pub const EVP_MD_CTRL_MICALG = @as(c_int, 0x2);
pub const EVP_MD_CTRL_XOF_LEN = @as(c_int, 0x3);
pub const EVP_MD_CTRL_TLSTREE = @as(c_int, 0x4);
pub const EVP_MD_CTRL_ALG_CTRL = @as(c_int, 0x1000);
pub const EVP_MD_CTX_FLAG_ONESHOT = @as(c_int, 0x0001);
pub const EVP_MD_CTX_FLAG_CLEANED = @as(c_int, 0x0002);
pub const EVP_MD_CTX_FLAG_REUSE = @as(c_int, 0x0004);
pub const EVP_MD_CTX_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0008);
pub const EVP_MD_CTX_FLAG_PAD_MASK = @as(c_int, 0xF0);
pub const EVP_MD_CTX_FLAG_PAD_PKCS1 = @as(c_int, 0x00);
pub const EVP_MD_CTX_FLAG_PAD_X931 = @as(c_int, 0x10);
pub const EVP_MD_CTX_FLAG_PAD_PSS = @as(c_int, 0x20);
pub const EVP_MD_CTX_FLAG_NO_INIT = @as(c_int, 0x0100);
pub const EVP_MD_CTX_FLAG_FINALISE = @as(c_int, 0x0200);
pub const EVP_CIPH_STREAM_CIPHER = @as(c_int, 0x0);
pub const EVP_CIPH_ECB_MODE = @as(c_int, 0x1);
pub const EVP_CIPH_CBC_MODE = @as(c_int, 0x2);
pub const EVP_CIPH_CFB_MODE = @as(c_int, 0x3);
pub const EVP_CIPH_OFB_MODE = @as(c_int, 0x4);
pub const EVP_CIPH_CTR_MODE = @as(c_int, 0x5);
pub const EVP_CIPH_GCM_MODE = @as(c_int, 0x6);
pub const EVP_CIPH_CCM_MODE = @as(c_int, 0x7);
pub const EVP_CIPH_XTS_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001, .hex);
pub const EVP_CIPH_WRAP_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10002, .hex);
pub const EVP_CIPH_OCB_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10003, .hex);
pub const EVP_CIPH_SIV_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004, .hex);
pub const EVP_CIPH_GCM_SIV_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10005, .hex);
pub const EVP_CIPH_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF0007, .hex);
pub const EVP_CIPH_VARIABLE_LENGTH = @as(c_int, 0x8);
pub const EVP_CIPH_CUSTOM_IV = @as(c_int, 0x10);
pub const EVP_CIPH_ALWAYS_CALL_INIT = @as(c_int, 0x20);
pub const EVP_CIPH_CTRL_INIT = @as(c_int, 0x40);
pub const EVP_CIPH_CUSTOM_KEY_LENGTH = @as(c_int, 0x80);
pub const EVP_CIPH_NO_PADDING = @as(c_int, 0x100);
pub const EVP_CIPH_RAND_KEY = @as(c_int, 0x200);
pub const EVP_CIPH_CUSTOM_COPY = @as(c_int, 0x400);
pub const EVP_CIPH_CUSTOM_IV_LENGTH = @as(c_int, 0x800);
pub const EVP_CIPH_FLAG_DEFAULT_ASN1 = @as(c_int, 0);
pub const EVP_CIPH_FLAG_LENGTH_BITS = @as(c_int, 0x2000);
pub const EVP_CIPH_FLAG_FIPS = @as(c_int, 0);
pub const EVP_CIPH_FLAG_NON_FIPS_ALLOW = @as(c_int, 0);
pub const EVP_CIPH_FLAG_CTS = @as(c_int, 0x4000);
pub const EVP_CIPH_FLAG_CUSTOM_CIPHER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100000, .hex);
pub const EVP_CIPH_FLAG_AEAD_CIPHER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x200000, .hex);
pub const EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x400000, .hex);
pub const EVP_CIPH_FLAG_PIPELINE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x800000, .hex);
pub const EVP_CIPH_FLAG_CUSTOM_ASN1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000000, .hex);
pub const EVP_CIPH_FLAG_CIPHER_WITH_MAC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x2000000, .hex);
pub const EVP_CIPH_FLAG_GET_WRAP_CIPHER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x4000000, .hex);
pub const EVP_CIPH_FLAG_INVERSE_CIPHER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000000, .hex);
pub const EVP_CIPHER_CTX_FLAG_WRAP_ALLOW = @as(c_int, 0x1);
pub const EVP_CTRL_INIT = @as(c_int, 0x0);
pub const EVP_CTRL_SET_KEY_LENGTH = @as(c_int, 0x1);
pub const EVP_CTRL_GET_RC2_KEY_BITS = @as(c_int, 0x2);
pub const EVP_CTRL_SET_RC2_KEY_BITS = @as(c_int, 0x3);
pub const EVP_CTRL_GET_RC5_ROUNDS = @as(c_int, 0x4);
pub const EVP_CTRL_SET_RC5_ROUNDS = @as(c_int, 0x5);
pub const EVP_CTRL_RAND_KEY = @as(c_int, 0x6);
pub const EVP_CTRL_PBE_PRF_NID = @as(c_int, 0x7);
pub const EVP_CTRL_COPY = @as(c_int, 0x8);
pub const EVP_CTRL_AEAD_SET_IVLEN = @as(c_int, 0x9);
pub const EVP_CTRL_AEAD_GET_TAG = @as(c_int, 0x10);
pub const EVP_CTRL_AEAD_SET_TAG = @as(c_int, 0x11);
pub const EVP_CTRL_AEAD_SET_IV_FIXED = @as(c_int, 0x12);
pub const EVP_CTRL_GCM_SET_IVLEN = EVP_CTRL_AEAD_SET_IVLEN;
pub const EVP_CTRL_GCM_GET_TAG = EVP_CTRL_AEAD_GET_TAG;
pub const EVP_CTRL_GCM_SET_TAG = EVP_CTRL_AEAD_SET_TAG;
pub const EVP_CTRL_GCM_SET_IV_FIXED = EVP_CTRL_AEAD_SET_IV_FIXED;
pub const EVP_CTRL_GCM_IV_GEN = @as(c_int, 0x13);
pub const EVP_CTRL_CCM_SET_IVLEN = EVP_CTRL_AEAD_SET_IVLEN;
pub const EVP_CTRL_CCM_GET_TAG = EVP_CTRL_AEAD_GET_TAG;
pub const EVP_CTRL_CCM_SET_TAG = EVP_CTRL_AEAD_SET_TAG;
pub const EVP_CTRL_CCM_SET_IV_FIXED = EVP_CTRL_AEAD_SET_IV_FIXED;
pub const EVP_CTRL_CCM_SET_L = @as(c_int, 0x14);
pub const EVP_CTRL_CCM_SET_MSGLEN = @as(c_int, 0x15);
pub const EVP_CTRL_AEAD_TLS1_AAD = @as(c_int, 0x16);
pub const EVP_CTRL_AEAD_SET_MAC_KEY = @as(c_int, 0x17);
pub const EVP_CTRL_GCM_SET_IV_INV = @as(c_int, 0x18);
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_AAD = @as(c_int, 0x19);
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT = @as(c_int, 0x1a);
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT = @as(c_int, 0x1b);
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE = @as(c_int, 0x1c);
pub const EVP_CTRL_SSL3_MASTER_SECRET = @as(c_int, 0x1d);
pub const EVP_CTRL_SET_SBOX = @as(c_int, 0x1e);
pub const EVP_CTRL_SBOX_USED = @as(c_int, 0x1f);
pub const EVP_CTRL_KEY_MESH = @as(c_int, 0x20);
pub const EVP_CTRL_BLOCK_PADDING_MODE = @as(c_int, 0x21);
pub const EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS = @as(c_int, 0x22);
pub const EVP_CTRL_SET_PIPELINE_INPUT_BUFS = @as(c_int, 0x23);
pub const EVP_CTRL_SET_PIPELINE_INPUT_LENS = @as(c_int, 0x24);
pub const EVP_CTRL_GET_IVLEN = @as(c_int, 0x25);
pub const EVP_CTRL_SET_SPEED = @as(c_int, 0x27);
pub const EVP_CTRL_PROCESS_UNPROTECTED = @as(c_int, 0x28);
pub const EVP_CTRL_GET_WRAP_CIPHER = @as(c_int, 0x29);
pub const EVP_CTRL_TLSTREE = @as(c_int, 0x2A);
pub const EVP_PADDING_PKCS7 = @as(c_int, 1);
pub const EVP_PADDING_ISO7816_4 = @as(c_int, 2);
pub const EVP_PADDING_ANSI923 = @as(c_int, 3);
pub const EVP_PADDING_ISO10126 = @as(c_int, 4);
pub const EVP_PADDING_ZERO = @as(c_int, 5);
pub const EVP_AEAD_TLS1_AAD_LEN = @as(c_int, 13);
pub const EVP_GCM_TLS_FIXED_IV_LEN = @as(c_int, 4);
pub const EVP_GCM_TLS_EXPLICIT_IV_LEN = @as(c_int, 8);
pub const EVP_GCM_TLS_TAG_LEN = @as(c_int, 16);
pub const EVP_CCM_TLS_FIXED_IV_LEN = @as(c_int, 4);
pub const EVP_CCM_TLS_EXPLICIT_IV_LEN = @as(c_int, 8);
pub const EVP_CCM_TLS_IV_LEN = @as(c_int, 12);
pub const EVP_CCM_TLS_TAG_LEN = @as(c_int, 16);
pub const EVP_CCM8_TLS_TAG_LEN = @as(c_int, 8);
pub const EVP_CHACHAPOLY_TLS_TAG_LEN = @as(c_int, 16);
pub inline fn EVP_PKEY_assign_RSA(pkey: anytype, rsa: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_RSA, rsa)) {
    _ = &pkey;
    _ = &rsa;
    return EVP_PKEY_assign(pkey, EVP_PKEY_RSA, rsa);
}
pub inline fn EVP_PKEY_assign_DSA(pkey: anytype, dsa: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_DSA, dsa)) {
    _ = &pkey;
    _ = &dsa;
    return EVP_PKEY_assign(pkey, EVP_PKEY_DSA, dsa);
}
pub inline fn EVP_PKEY_assign_DH(pkey: anytype, dh: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_DH, dh)) {
    _ = &pkey;
    _ = &dh;
    return EVP_PKEY_assign(pkey, EVP_PKEY_DH, dh);
}
pub inline fn EVP_PKEY_assign_EC_KEY(pkey: anytype, eckey: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_EC, eckey)) {
    _ = &pkey;
    _ = &eckey;
    return EVP_PKEY_assign(pkey, EVP_PKEY_EC, eckey);
}
pub inline fn EVP_PKEY_assign_SIPHASH(pkey: anytype, shkey: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_SIPHASH, shkey)) {
    _ = &pkey;
    _ = &shkey;
    return EVP_PKEY_assign(pkey, EVP_PKEY_SIPHASH, shkey);
}
pub inline fn EVP_PKEY_assign_POLY1305(pkey: anytype, polykey: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_POLY1305, polykey)) {
    _ = &pkey;
    _ = &polykey;
    return EVP_PKEY_assign(pkey, EVP_PKEY_POLY1305, polykey);
}
pub inline fn EVP_get_digestbynid(a: anytype) @TypeOf(EVP_get_digestbyname(OBJ_nid2sn(a))) {
    _ = &a;
    return EVP_get_digestbyname(OBJ_nid2sn(a));
}
pub inline fn EVP_get_digestbyobj(a: anytype) @TypeOf(EVP_get_digestbynid(OBJ_obj2nid(a))) {
    _ = &a;
    return EVP_get_digestbynid(OBJ_obj2nid(a));
}
pub inline fn EVP_get_cipherbynid(a: anytype) @TypeOf(EVP_get_cipherbyname(OBJ_nid2sn(a))) {
    _ = &a;
    return EVP_get_cipherbyname(OBJ_nid2sn(a));
}
pub inline fn EVP_get_cipherbyobj(a: anytype) @TypeOf(EVP_get_cipherbynid(OBJ_obj2nid(a))) {
    _ = &a;
    return EVP_get_cipherbynid(OBJ_obj2nid(a));
}
pub const EVP_MD_type = EVP_MD_get_type;
pub const EVP_MD_nid = EVP_MD_get_type;
pub const EVP_MD_name = EVP_MD_get0_name;
pub const EVP_MD_pkey_type = EVP_MD_get_pkey_type;
pub const EVP_MD_size = EVP_MD_get_size;
pub const EVP_MD_block_size = EVP_MD_get_block_size;
pub const EVP_MD_flags = EVP_MD_get_flags;
pub inline fn EVP_MD_CTX_get0_name(e: anytype) @TypeOf(EVP_MD_get0_name(EVP_MD_CTX_get0_md(e))) {
    _ = &e;
    return EVP_MD_get0_name(EVP_MD_CTX_get0_md(e));
}
pub inline fn EVP_MD_CTX_get_size(e: anytype) @TypeOf(EVP_MD_CTX_get_size_ex(e)) {
    _ = &e;
    return EVP_MD_CTX_get_size_ex(e);
}
pub const EVP_MD_CTX_size = EVP_MD_CTX_get_size_ex;
pub inline fn EVP_MD_CTX_get_block_size(e: anytype) @TypeOf(EVP_MD_get_block_size(EVP_MD_CTX_get0_md(e))) {
    _ = &e;
    return EVP_MD_get_block_size(EVP_MD_CTX_get0_md(e));
}
pub const EVP_MD_CTX_block_size = EVP_MD_CTX_get_block_size;
pub inline fn EVP_MD_CTX_get_type(e: anytype) @TypeOf(EVP_MD_get_type(EVP_MD_CTX_get0_md(e))) {
    _ = &e;
    return EVP_MD_get_type(EVP_MD_CTX_get0_md(e));
}
pub const EVP_MD_CTX_type = EVP_MD_CTX_get_type;
pub const EVP_MD_CTX_pkey_ctx = EVP_MD_CTX_get_pkey_ctx;
pub const EVP_MD_CTX_md_data = EVP_MD_CTX_get0_md_data;
pub const EVP_CIPHER_nid = EVP_CIPHER_get_nid;
pub const EVP_CIPHER_name = EVP_CIPHER_get0_name;
pub const EVP_CIPHER_block_size = EVP_CIPHER_get_block_size;
pub const EVP_CIPHER_key_length = EVP_CIPHER_get_key_length;
pub const EVP_CIPHER_iv_length = EVP_CIPHER_get_iv_length;
pub const EVP_CIPHER_flags = EVP_CIPHER_get_flags;
pub const EVP_CIPHER_mode = EVP_CIPHER_get_mode;
pub const EVP_CIPHER_type = EVP_CIPHER_get_type;
pub const EVP_CIPHER_CTX_encrypting = EVP_CIPHER_CTX_is_encrypting;
pub const EVP_CIPHER_CTX_nid = EVP_CIPHER_CTX_get_nid;
pub const EVP_CIPHER_CTX_block_size = EVP_CIPHER_CTX_get_block_size;
pub const EVP_CIPHER_CTX_key_length = EVP_CIPHER_CTX_get_key_length;
pub const EVP_CIPHER_CTX_iv_length = EVP_CIPHER_CTX_get_iv_length;
pub const EVP_CIPHER_CTX_tag_length = EVP_CIPHER_CTX_get_tag_length;
pub const EVP_CIPHER_CTX_num = EVP_CIPHER_CTX_get_num;
pub inline fn EVP_CIPHER_CTX_get0_name(c: anytype) @TypeOf(EVP_CIPHER_get0_name(EVP_CIPHER_CTX_get0_cipher(c))) {
    _ = &c;
    return EVP_CIPHER_get0_name(EVP_CIPHER_CTX_get0_cipher(c));
}
pub inline fn EVP_CIPHER_CTX_get_type(c: anytype) @TypeOf(EVP_CIPHER_get_type(EVP_CIPHER_CTX_get0_cipher(c))) {
    _ = &c;
    return EVP_CIPHER_get_type(EVP_CIPHER_CTX_get0_cipher(c));
}
pub const EVP_CIPHER_CTX_type = EVP_CIPHER_CTX_get_type;
pub inline fn EVP_CIPHER_CTX_flags(c: anytype) @TypeOf(EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(c))) {
    _ = &c;
    return EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(c));
}
pub inline fn EVP_CIPHER_CTX_get_mode(c: anytype) @TypeOf(EVP_CIPHER_get_mode(EVP_CIPHER_CTX_get0_cipher(c))) {
    _ = &c;
    return EVP_CIPHER_get_mode(EVP_CIPHER_CTX_get0_cipher(c));
}
pub const EVP_CIPHER_CTX_mode = EVP_CIPHER_CTX_get_mode;
pub inline fn EVP_ENCODE_LENGTH(l: anytype) @TypeOf(((@import("std").zig.c_translation.MacroArithmetic.div(l + @as(c_int, 2), @as(c_int, 3)) * @as(c_int, 4)) + ((@import("std").zig.c_translation.MacroArithmetic.div(l, @as(c_int, 48)) + @as(c_int, 1)) * @as(c_int, 2))) + @as(c_int, 80)) {
    _ = &l;
    return ((@import("std").zig.c_translation.MacroArithmetic.div(l + @as(c_int, 2), @as(c_int, 3)) * @as(c_int, 4)) + ((@import("std").zig.c_translation.MacroArithmetic.div(l, @as(c_int, 48)) + @as(c_int, 1)) * @as(c_int, 2))) + @as(c_int, 80);
}
pub inline fn EVP_DECODE_LENGTH(l: anytype) @TypeOf((@import("std").zig.c_translation.MacroArithmetic.div(l + @as(c_int, 3), @as(c_int, 4)) * @as(c_int, 3)) + @as(c_int, 80)) {
    _ = &l;
    return (@import("std").zig.c_translation.MacroArithmetic.div(l + @as(c_int, 3), @as(c_int, 4)) * @as(c_int, 3)) + @as(c_int, 80);
}
pub inline fn EVP_SignInit_ex(a: anytype, b: anytype, c: anytype) @TypeOf(EVP_DigestInit_ex(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return EVP_DigestInit_ex(a, b, c);
}
pub inline fn EVP_SignInit(a: anytype, b: anytype) @TypeOf(EVP_DigestInit(a, b)) {
    _ = &a;
    _ = &b;
    return EVP_DigestInit(a, b);
}
pub inline fn EVP_SignUpdate(a: anytype, b: anytype, c: anytype) @TypeOf(EVP_DigestUpdate(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return EVP_DigestUpdate(a, b, c);
}
pub inline fn EVP_VerifyInit_ex(a: anytype, b: anytype, c: anytype) @TypeOf(EVP_DigestInit_ex(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return EVP_DigestInit_ex(a, b, c);
}
pub inline fn EVP_VerifyInit(a: anytype, b: anytype) @TypeOf(EVP_DigestInit(a, b)) {
    _ = &a;
    _ = &b;
    return EVP_DigestInit(a, b);
}
pub inline fn EVP_VerifyUpdate(a: anytype, b: anytype, c: anytype) @TypeOf(EVP_DigestUpdate(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return EVP_DigestUpdate(a, b, c);
}
pub inline fn EVP_OpenUpdate(a: anytype, b: anytype, c: anytype, d: anytype, e: anytype) @TypeOf(EVP_DecryptUpdate(a, b, c, d, e)) {
    _ = &a;
    _ = &b;
    _ = &c;
    _ = &d;
    _ = &e;
    return EVP_DecryptUpdate(a, b, c, d, e);
}
pub inline fn EVP_SealUpdate(a: anytype, b: anytype, c: anytype, d: anytype, e: anytype) @TypeOf(EVP_EncryptUpdate(a, b, c, d, e)) {
    _ = &a;
    _ = &b;
    _ = &c;
    _ = &d;
    _ = &e;
    return EVP_EncryptUpdate(a, b, c, d, e);
}
pub inline fn BIO_set_md(b: anytype, md: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_MD, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, md))) {
    _ = &b;
    _ = &md;
    return BIO_ctrl(b, BIO_C_SET_MD, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, md));
}
pub inline fn BIO_get_md(b: anytype, mdp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_MD, @as(c_int, 0), mdp)) {
    _ = &b;
    _ = &mdp;
    return BIO_ctrl(b, BIO_C_GET_MD, @as(c_int, 0), mdp);
}
pub inline fn BIO_get_md_ctx(b: anytype, mdcp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_MD_CTX, @as(c_int, 0), mdcp)) {
    _ = &b;
    _ = &mdcp;
    return BIO_ctrl(b, BIO_C_GET_MD_CTX, @as(c_int, 0), mdcp);
}
pub inline fn BIO_set_md_ctx(b: anytype, mdcp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_MD_CTX, @as(c_int, 0), mdcp)) {
    _ = &b;
    _ = &mdcp;
    return BIO_ctrl(b, BIO_C_SET_MD_CTX, @as(c_int, 0), mdcp);
}
pub inline fn BIO_get_cipher_status(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_CIPHER_STATUS, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_CIPHER_STATUS, @as(c_int, 0), NULL);
}
pub inline fn BIO_get_cipher_ctx(b: anytype, c_pp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_CIPHER_CTX, @as(c_int, 0), c_pp)) {
    _ = &b;
    _ = &c_pp;
    return BIO_ctrl(b, BIO_C_GET_CIPHER_CTX, @as(c_int, 0), c_pp);
}
pub inline fn EVP_add_cipher_alias(n: anytype, alias: anytype) @TypeOf(OBJ_NAME_add(alias, OBJ_NAME_TYPE_CIPHER_METH | OBJ_NAME_ALIAS, n)) {
    _ = &n;
    _ = &alias;
    return OBJ_NAME_add(alias, OBJ_NAME_TYPE_CIPHER_METH | OBJ_NAME_ALIAS, n);
}
pub inline fn EVP_add_digest_alias(n: anytype, alias: anytype) @TypeOf(OBJ_NAME_add(alias, OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, n)) {
    _ = &n;
    _ = &alias;
    return OBJ_NAME_add(alias, OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, n);
}
pub const EVP_delete_cipher_alias = @compileError("unable to translate C expr: unexpected token ';'");
// /opt/homebrew/opt/openssl@3/include/openssl/evp.h:691:10
pub const EVP_delete_digest_alias = @compileError("unable to translate C expr: unexpected token ';'");
// /opt/homebrew/opt/openssl@3/include/openssl/evp.h:693:10
pub inline fn EVP_MD_CTX_create() @TypeOf(EVP_MD_CTX_new()) {
    return EVP_MD_CTX_new();
}
pub inline fn EVP_MD_CTX_init(ctx: anytype) @TypeOf(EVP_MD_CTX_reset(ctx)) {
    _ = &ctx;
    return EVP_MD_CTX_reset(ctx);
}
pub inline fn EVP_MD_CTX_destroy(ctx: anytype) @TypeOf(EVP_MD_CTX_free(ctx)) {
    _ = &ctx;
    return EVP_MD_CTX_free(ctx);
}
pub inline fn EVP_CIPHER_CTX_init(c: anytype) @TypeOf(EVP_CIPHER_CTX_reset(c)) {
    _ = &c;
    return EVP_CIPHER_CTX_reset(c);
}
pub inline fn EVP_CIPHER_CTX_cleanup(c: anytype) @TypeOf(EVP_CIPHER_CTX_reset(c)) {
    _ = &c;
    return EVP_CIPHER_CTX_reset(c);
}
pub const EVP_des_cfb = EVP_des_cfb64;
pub const EVP_des_ede_cfb = EVP_des_ede_cfb64;
pub const EVP_des_ede3_cfb = EVP_des_ede3_cfb64;
pub const EVP_idea_cfb = EVP_idea_cfb64;
pub const EVP_rc2_cfb = EVP_rc2_cfb64;
pub const EVP_bf_cfb = EVP_bf_cfb64;
pub const EVP_cast5_cfb = EVP_cast5_cfb64;
pub const EVP_aes_128_cfb = EVP_aes_128_cfb128;
pub const EVP_aes_192_cfb = EVP_aes_192_cfb128;
pub const EVP_aes_256_cfb = EVP_aes_256_cfb128;
pub const EVP_aria_128_cfb = EVP_aria_128_cfb128;
pub const EVP_aria_192_cfb = EVP_aria_192_cfb128;
pub const EVP_aria_256_cfb = EVP_aria_256_cfb128;
pub const EVP_camellia_128_cfb = EVP_camellia_128_cfb128;
pub const EVP_camellia_192_cfb = EVP_camellia_192_cfb128;
pub const EVP_camellia_256_cfb = EVP_camellia_256_cfb128;
pub const EVP_seed_cfb = EVP_seed_cfb128;
pub const EVP_sm4_cfb = EVP_sm4_cfb128;
pub inline fn OPENSSL_add_all_algorithms_conf() @TypeOf(OPENSSL_init_crypto((OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS) | OPENSSL_INIT_LOAD_CONFIG, NULL)) {
    return OPENSSL_init_crypto((OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS) | OPENSSL_INIT_LOAD_CONFIG, NULL);
}
pub inline fn OPENSSL_add_all_algorithms_noconf() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);
}
pub inline fn OpenSSL_add_all_algorithms() @TypeOf(OPENSSL_add_all_algorithms_noconf()) {
    return OPENSSL_add_all_algorithms_noconf();
}
pub inline fn OpenSSL_add_all_ciphers() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS, NULL);
}
pub inline fn OpenSSL_add_all_digests() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_DIGESTS, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);
}
pub const EVP_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/evp.h:1181:11
pub const EVP_RAND_STATE_UNINITIALISED = @as(c_int, 0);
pub const EVP_RAND_STATE_READY = @as(c_int, 1);
pub const EVP_RAND_STATE_ERROR = @as(c_int, 2);
pub const EVP_PKEY_id = EVP_PKEY_get_id;
pub const EVP_PKEY_base_id = EVP_PKEY_get_base_id;
pub const EVP_PKEY_bits = EVP_PKEY_get_bits;
pub const EVP_PKEY_security_bits = EVP_PKEY_get_security_bits;
pub const EVP_PKEY_size = EVP_PKEY_get_size;
pub inline fn EVP_PKEY_set1_tls_encodedpoint(pkey: anytype, pt: anytype, ptlen: anytype) @TypeOf(EVP_PKEY_set1_encoded_public_key(pkey, pt, ptlen)) {
    _ = &pkey;
    _ = &pt;
    _ = &ptlen;
    return EVP_PKEY_set1_encoded_public_key(pkey, pt, ptlen);
}
pub inline fn EVP_PKEY_get1_tls_encodedpoint(pkey: anytype, ppt: anytype) @TypeOf(EVP_PKEY_get1_encoded_public_key(pkey, ppt)) {
    _ = &pkey;
    _ = &ppt;
    return EVP_PKEY_get1_encoded_public_key(pkey, ppt);
}
pub const EVP_PBE_TYPE_OUTER = @as(c_int, 0x0);
pub const EVP_PBE_TYPE_PRF = @as(c_int, 0x1);
pub const EVP_PBE_TYPE_KDF = @as(c_int, 0x2);
pub const ASN1_PKEY_ALIAS = @as(c_int, 0x1);
pub const ASN1_PKEY_DYNAMIC = @as(c_int, 0x2);
pub const ASN1_PKEY_SIGPARAM_NULL = @as(c_int, 0x4);
pub const ASN1_PKEY_CTRL_PKCS7_SIGN = @as(c_int, 0x1);
pub const ASN1_PKEY_CTRL_PKCS7_ENCRYPT = @as(c_int, 0x2);
pub const ASN1_PKEY_CTRL_DEFAULT_MD_NID = @as(c_int, 0x3);
pub const ASN1_PKEY_CTRL_CMS_SIGN = @as(c_int, 0x5);
pub const ASN1_PKEY_CTRL_CMS_ENVELOPE = @as(c_int, 0x7);
pub const ASN1_PKEY_CTRL_CMS_RI_TYPE = @as(c_int, 0x8);
pub const ASN1_PKEY_CTRL_SET1_TLS_ENCPT = @as(c_int, 0x9);
pub const ASN1_PKEY_CTRL_GET1_TLS_ENCPT = @as(c_int, 0xa);
pub const ASN1_PKEY_CTRL_CMS_IS_RI_TYPE_SUPPORTED = @as(c_int, 0xb);
pub const EVP_PKEY_OP_UNDEFINED = @as(c_int, 0);
pub const EVP_PKEY_OP_PARAMGEN = @as(c_int, 1) << @as(c_int, 1);
pub const EVP_PKEY_OP_KEYGEN = @as(c_int, 1) << @as(c_int, 2);
pub const EVP_PKEY_OP_FROMDATA = @as(c_int, 1) << @as(c_int, 3);
pub const EVP_PKEY_OP_SIGN = @as(c_int, 1) << @as(c_int, 4);
pub const EVP_PKEY_OP_VERIFY = @as(c_int, 1) << @as(c_int, 5);
pub const EVP_PKEY_OP_VERIFYRECOVER = @as(c_int, 1) << @as(c_int, 6);
pub const EVP_PKEY_OP_SIGNCTX = @as(c_int, 1) << @as(c_int, 7);
pub const EVP_PKEY_OP_VERIFYCTX = @as(c_int, 1) << @as(c_int, 8);
pub const EVP_PKEY_OP_ENCRYPT = @as(c_int, 1) << @as(c_int, 9);
pub const EVP_PKEY_OP_DECRYPT = @as(c_int, 1) << @as(c_int, 10);
pub const EVP_PKEY_OP_DERIVE = @as(c_int, 1) << @as(c_int, 11);
pub const EVP_PKEY_OP_ENCAPSULATE = @as(c_int, 1) << @as(c_int, 12);
pub const EVP_PKEY_OP_DECAPSULATE = @as(c_int, 1) << @as(c_int, 13);
pub const EVP_PKEY_OP_SIGNMSG = @as(c_int, 1) << @as(c_int, 14);
pub const EVP_PKEY_OP_VERIFYMSG = @as(c_int, 1) << @as(c_int, 15);
pub const EVP_PKEY_OP_ALL = (@as(c_int, 1) << @as(c_int, 16)) - @as(c_int, 1);
pub const EVP_PKEY_OP_TYPE_SIG = (((((EVP_PKEY_OP_SIGN | EVP_PKEY_OP_SIGNMSG) | EVP_PKEY_OP_VERIFY) | EVP_PKEY_OP_VERIFYMSG) | EVP_PKEY_OP_VERIFYRECOVER) | EVP_PKEY_OP_SIGNCTX) | EVP_PKEY_OP_VERIFYCTX;
pub const EVP_PKEY_OP_TYPE_CRYPT = EVP_PKEY_OP_ENCRYPT | EVP_PKEY_OP_DECRYPT;
pub const EVP_PKEY_OP_TYPE_DERIVE = EVP_PKEY_OP_DERIVE;
pub const EVP_PKEY_OP_TYPE_DATA = EVP_PKEY_OP_FROMDATA;
pub const EVP_PKEY_OP_TYPE_KEM = EVP_PKEY_OP_ENCAPSULATE | EVP_PKEY_OP_DECAPSULATE;
pub const EVP_PKEY_OP_TYPE_GEN = EVP_PKEY_OP_PARAMGEN | EVP_PKEY_OP_KEYGEN;
pub const EVP_PKEY_OP_TYPE_NOGEN = EVP_PKEY_OP_ALL & ~EVP_PKEY_OP_TYPE_GEN;
pub const EVP_PKEY_CTRL_MD = @as(c_int, 1);
pub const EVP_PKEY_CTRL_PEER_KEY = @as(c_int, 2);
pub const EVP_PKEY_CTRL_SET_MAC_KEY = @as(c_int, 6);
pub const EVP_PKEY_CTRL_DIGESTINIT = @as(c_int, 7);
pub const EVP_PKEY_CTRL_SET_IV = @as(c_int, 8);
pub const EVP_PKEY_CTRL_PKCS7_ENCRYPT = @as(c_int, 3);
pub const EVP_PKEY_CTRL_PKCS7_DECRYPT = @as(c_int, 4);
pub const EVP_PKEY_CTRL_PKCS7_SIGN = @as(c_int, 5);
pub const EVP_PKEY_CTRL_CMS_ENCRYPT = @as(c_int, 9);
pub const EVP_PKEY_CTRL_CMS_DECRYPT = @as(c_int, 10);
pub const EVP_PKEY_CTRL_CMS_SIGN = @as(c_int, 11);
pub const EVP_PKEY_CTRL_CIPHER = @as(c_int, 12);
pub const EVP_PKEY_CTRL_GET_MD = @as(c_int, 13);
pub const EVP_PKEY_CTRL_SET_DIGEST_SIZE = @as(c_int, 14);
pub const EVP_PKEY_CTRL_SET1_ID = @as(c_int, 15);
pub const EVP_PKEY_CTRL_GET1_ID = @as(c_int, 16);
pub const EVP_PKEY_CTRL_GET1_ID_LEN = @as(c_int, 17);
pub const EVP_PKEY_ALG_CTRL = @as(c_int, 0x1000);
pub const EVP_PKEY_FLAG_AUTOARGLEN = @as(c_int, 2);
pub const EVP_PKEY_FLAG_SIGCTX_CUSTOM = @as(c_int, 4);
pub inline fn EVP_PKEY_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_EVP_PKEY, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_EVP_PKEY, l, p, newf, dupf, freef);
}
pub const OPENSSL_EC_H = "";
pub const HEADER_EC_H = "";
pub const _STRING_H_ = "";
pub const _STRINGS_H_ = "";
pub const _SECURE__STRINGS_H_ = "";
pub const _SECURE__STRING_H_ = "";
pub const __HAS_FIXED_CHK_PROTOTYPES = @as(c_int, 1);
pub const OPENSSL_EC_EXPLICIT_CURVE = @as(c_int, 0x000);
pub const OPENSSL_EC_NAMED_CURVE = @as(c_int, 0x001);
pub const EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID = EVP_PKEY_ALG_CTRL + @as(c_int, 1);
pub const EVP_PKEY_CTRL_EC_PARAM_ENC = EVP_PKEY_ALG_CTRL + @as(c_int, 2);
pub const EVP_PKEY_CTRL_EC_ECDH_COFACTOR = EVP_PKEY_ALG_CTRL + @as(c_int, 3);
pub const EVP_PKEY_CTRL_EC_KDF_TYPE = EVP_PKEY_ALG_CTRL + @as(c_int, 4);
pub const EVP_PKEY_CTRL_EC_KDF_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 5);
pub const EVP_PKEY_CTRL_GET_EC_KDF_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 6);
pub const EVP_PKEY_CTRL_EC_KDF_OUTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 7);
pub const EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 8);
pub const EVP_PKEY_CTRL_EC_KDF_UKM = EVP_PKEY_ALG_CTRL + @as(c_int, 9);
pub const EVP_PKEY_CTRL_GET_EC_KDF_UKM = EVP_PKEY_ALG_CTRL + @as(c_int, 10);
pub const EVP_PKEY_ECDH_KDF_NONE = @as(c_int, 1);
pub const EVP_PKEY_ECDH_KDF_X9_63 = @as(c_int, 2);
pub const EVP_PKEY_ECDH_KDF_X9_62 = EVP_PKEY_ECDH_KDF_X9_63;
pub const OPENSSL_ECERR_H = "";
pub const EC_R_ASN1_ERROR = @as(c_int, 115);
pub const EC_R_BAD_SIGNATURE = @as(c_int, 156);
pub const EC_R_BIGNUM_OUT_OF_RANGE = @as(c_int, 144);
pub const EC_R_BUFFER_TOO_SMALL = @as(c_int, 100);
pub const EC_R_CANNOT_INVERT = @as(c_int, 165);
pub const EC_R_COORDINATES_OUT_OF_RANGE = @as(c_int, 146);
pub const EC_R_CURVE_DOES_NOT_SUPPORT_ECDH = @as(c_int, 160);
pub const EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA = @as(c_int, 170);
pub const EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING = @as(c_int, 159);
pub const EC_R_DECODE_ERROR = @as(c_int, 142);
pub const EC_R_DISCRIMINANT_IS_ZERO = @as(c_int, 118);
pub const EC_R_EC_GROUP_NEW_BY_NAME_FAILURE = @as(c_int, 119);
pub const EC_R_EXPLICIT_PARAMS_NOT_SUPPORTED = @as(c_int, 127);
pub const EC_R_FAILED_MAKING_PUBLIC_KEY = @as(c_int, 166);
pub const EC_R_FIELD_TOO_LARGE = @as(c_int, 143);
pub const EC_R_GF2M_NOT_SUPPORTED = @as(c_int, 147);
pub const EC_R_GROUP2PKPARAMETERS_FAILURE = @as(c_int, 120);
pub const EC_R_I2D_ECPKPARAMETERS_FAILURE = @as(c_int, 121);
pub const EC_R_INCOMPATIBLE_OBJECTS = @as(c_int, 101);
pub const EC_R_INVALID_A = @as(c_int, 168);
pub const EC_R_INVALID_ARGUMENT = @as(c_int, 112);
pub const EC_R_INVALID_B = @as(c_int, 169);
pub const EC_R_INVALID_COFACTOR = @as(c_int, 171);
pub const EC_R_INVALID_COMPRESSED_POINT = @as(c_int, 110);
pub const EC_R_INVALID_COMPRESSION_BIT = @as(c_int, 109);
pub const EC_R_INVALID_CURVE = @as(c_int, 141);
pub const EC_R_INVALID_DIGEST = @as(c_int, 151);
pub const EC_R_INVALID_DIGEST_TYPE = @as(c_int, 138);
pub const EC_R_INVALID_ENCODING = @as(c_int, 102);
pub const EC_R_INVALID_FIELD = @as(c_int, 103);
pub const EC_R_INVALID_FORM = @as(c_int, 104);
pub const EC_R_INVALID_GENERATOR = @as(c_int, 173);
pub const EC_R_INVALID_GROUP_ORDER = @as(c_int, 122);
pub const EC_R_INVALID_KEY = @as(c_int, 116);
pub const EC_R_INVALID_LENGTH = @as(c_int, 117);
pub const EC_R_INVALID_NAMED_GROUP_CONVERSION = @as(c_int, 174);
pub const EC_R_INVALID_OUTPUT_LENGTH = @as(c_int, 161);
pub const EC_R_INVALID_P = @as(c_int, 172);
pub const EC_R_INVALID_PEER_KEY = @as(c_int, 133);
pub const EC_R_INVALID_PENTANOMIAL_BASIS = @as(c_int, 132);
pub const EC_R_INVALID_PRIVATE_KEY = @as(c_int, 123);
pub const EC_R_INVALID_SEED = @as(c_int, 175);
pub const EC_R_INVALID_TRINOMIAL_BASIS = @as(c_int, 137);
pub const EC_R_KDF_PARAMETER_ERROR = @as(c_int, 148);
pub const EC_R_KEYS_NOT_SET = @as(c_int, 140);
pub const EC_R_LADDER_POST_FAILURE = @as(c_int, 136);
pub const EC_R_LADDER_PRE_FAILURE = @as(c_int, 153);
pub const EC_R_LADDER_STEP_FAILURE = @as(c_int, 162);
pub const EC_R_MISSING_OID = @as(c_int, 167);
pub const EC_R_MISSING_PARAMETERS = @as(c_int, 124);
pub const EC_R_MISSING_PRIVATE_KEY = @as(c_int, 125);
pub const EC_R_NEED_NEW_SETUP_VALUES = @as(c_int, 157);
pub const EC_R_NOT_A_NIST_PRIME = @as(c_int, 135);
pub const EC_R_NOT_IMPLEMENTED = @as(c_int, 126);
pub const EC_R_NOT_INITIALIZED = @as(c_int, 111);
pub const EC_R_NO_PARAMETERS_SET = @as(c_int, 139);
pub const EC_R_NO_PRIVATE_VALUE = @as(c_int, 154);
pub const EC_R_OPERATION_NOT_SUPPORTED = @as(c_int, 152);
pub const EC_R_PASSED_NULL_PARAMETER = @as(c_int, 134);
pub const EC_R_PEER_KEY_ERROR = @as(c_int, 149);
pub const EC_R_POINT_ARITHMETIC_FAILURE = @as(c_int, 155);
pub const EC_R_POINT_AT_INFINITY = @as(c_int, 106);
pub const EC_R_POINT_COORDINATES_BLIND_FAILURE = @as(c_int, 163);
pub const EC_R_POINT_IS_NOT_ON_CURVE = @as(c_int, 107);
pub const EC_R_RANDOM_NUMBER_GENERATION_FAILED = @as(c_int, 158);
pub const EC_R_SHARED_INFO_ERROR = @as(c_int, 150);
pub const EC_R_SLOT_FULL = @as(c_int, 108);
pub const EC_R_TOO_MANY_RETRIES = @as(c_int, 176);
pub const EC_R_UNDEFINED_GENERATOR = @as(c_int, 113);
pub const EC_R_UNDEFINED_ORDER = @as(c_int, 128);
pub const EC_R_UNKNOWN_COFACTOR = @as(c_int, 164);
pub const EC_R_UNKNOWN_GROUP = @as(c_int, 129);
pub const EC_R_UNKNOWN_ORDER = @as(c_int, 114);
pub const EC_R_UNSUPPORTED_FIELD = @as(c_int, 131);
pub const EC_R_WRONG_CURVE_PARAMETERS = @as(c_int, 145);
pub const EC_R_WRONG_ORDER = @as(c_int, 130);
pub const OPENSSL_ECC_MAX_FIELD_BITS = @as(c_int, 661);
pub inline fn d2i_ECPKParameters_bio(bp: anytype, x: anytype) @TypeOf(ASN1_d2i_bio_of(EC_GROUP, NULL, d2i_ECPKParameters, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_d2i_bio_of(EC_GROUP, NULL, d2i_ECPKParameters, bp, x);
}
pub inline fn i2d_ECPKParameters_bio(bp: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(EC_GROUP, i2d_ECPKParameters, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_i2d_bio_of(EC_GROUP, i2d_ECPKParameters, bp, x);
}
pub const d2i_ECPKParameters_fp = @compileError("unable to translate C expr: expected ')' instead got '*'");
// /opt/homebrew/opt/openssl@3/include/openssl/ec.h:938:11
pub inline fn i2d_ECPKParameters_fp(fp: anytype, x: anytype) @TypeOf(ASN1_i2d_fp(@import("std").zig.c_translation.cast([*c]i2d_of_void, i2d_ECPKParameters), fp, @import("std").zig.c_translation.cast(?*anyopaque, x))) {
    _ = &fp;
    _ = &x;
    return ASN1_i2d_fp(@import("std").zig.c_translation.cast([*c]i2d_of_void, i2d_ECPKParameters), fp, @import("std").zig.c_translation.cast(?*anyopaque, x));
}
pub const EC_PKEY_NO_PARAMETERS = @as(c_int, 0x001);
pub const EC_PKEY_NO_PUBKEY = @as(c_int, 0x002);
pub const EC_FLAG_SM2_RANGE = @as(c_int, 0x0004);
pub const EC_FLAG_COFACTOR_ECDH = @as(c_int, 0x1000);
pub const EC_FLAG_CHECK_NAMED_GROUP = @as(c_int, 0x2000);
pub const EC_FLAG_CHECK_NAMED_GROUP_NIST = @as(c_int, 0x4000);
pub const EC_FLAG_CHECK_NAMED_GROUP_MASK = EC_FLAG_CHECK_NAMED_GROUP | EC_FLAG_CHECK_NAMED_GROUP_NIST;
pub const EC_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0000);
pub const EC_FLAG_FIPS_CHECKED = @as(c_int, 0x0000);
pub inline fn EC_KEY_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_EC_KEY, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_EC_KEY, l, p, newf, dupf, freef);
}
pub inline fn EVP_EC_gen(curve: anytype) @TypeOf(EVP_PKEY_Q_keygen(NULL, NULL, "EC", @import("std").zig.c_translation.cast([*c]u8, strstr(curve, "")))) {
    _ = &curve;
    return EVP_PKEY_Q_keygen(NULL, NULL, "EC", @import("std").zig.c_translation.cast([*c]u8, strstr(curve, "")));
}
pub inline fn ECParameters_dup(x: anytype) @TypeOf(ASN1_dup_of(EC_KEY, i2d_ECParameters, d2i_ECParameters, x)) {
    _ = &x;
    return ASN1_dup_of(EC_KEY, i2d_ECParameters, d2i_ECParameters, x);
}
pub const OPENSSL_RSA_H = "";
pub const HEADER_RSA_H = "";
pub const OPENSSL_RSAERR_H = "";
pub const RSA_R_ALGORITHM_MISMATCH = @as(c_int, 100);
pub const RSA_R_BAD_E_VALUE = @as(c_int, 101);
pub const RSA_R_BAD_FIXED_HEADER_DECRYPT = @as(c_int, 102);
pub const RSA_R_BAD_PAD_BYTE_COUNT = @as(c_int, 103);
pub const RSA_R_BAD_SIGNATURE = @as(c_int, 104);
pub const RSA_R_BLOCK_TYPE_IS_NOT_01 = @as(c_int, 106);
pub const RSA_R_BLOCK_TYPE_IS_NOT_02 = @as(c_int, 107);
pub const RSA_R_DATA_GREATER_THAN_MOD_LEN = @as(c_int, 108);
pub const RSA_R_DATA_TOO_LARGE = @as(c_int, 109);
pub const RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE = @as(c_int, 110);
pub const RSA_R_DATA_TOO_LARGE_FOR_MODULUS = @as(c_int, 132);
pub const RSA_R_DATA_TOO_SMALL = @as(c_int, 111);
pub const RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE = @as(c_int, 122);
pub const RSA_R_DIGEST_DOES_NOT_MATCH = @as(c_int, 158);
pub const RSA_R_DIGEST_NOT_ALLOWED = @as(c_int, 145);
pub const RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY = @as(c_int, 112);
pub const RSA_R_DMP1_NOT_CONGRUENT_TO_D = @as(c_int, 124);
pub const RSA_R_DMQ1_NOT_CONGRUENT_TO_D = @as(c_int, 125);
pub const RSA_R_D_E_NOT_CONGRUENT_TO_1 = @as(c_int, 123);
pub const RSA_R_FIRST_OCTET_INVALID = @as(c_int, 133);
pub const RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE = @as(c_int, 144);
pub const RSA_R_INVALID_DIGEST = @as(c_int, 157);
pub const RSA_R_INVALID_DIGEST_LENGTH = @as(c_int, 143);
pub const RSA_R_INVALID_HEADER = @as(c_int, 137);
pub const RSA_R_INVALID_KEYPAIR = @as(c_int, 171);
pub const RSA_R_INVALID_KEY_LENGTH = @as(c_int, 173);
pub const RSA_R_INVALID_LABEL = @as(c_int, 160);
pub const RSA_R_INVALID_LENGTH = @as(c_int, 181);
pub const RSA_R_INVALID_MESSAGE_LENGTH = @as(c_int, 131);
pub const RSA_R_INVALID_MGF1_MD = @as(c_int, 156);
pub const RSA_R_INVALID_MODULUS = @as(c_int, 174);
pub const RSA_R_INVALID_MULTI_PRIME_KEY = @as(c_int, 167);
pub const RSA_R_INVALID_OAEP_PARAMETERS = @as(c_int, 161);
pub const RSA_R_INVALID_PADDING = @as(c_int, 138);
pub const RSA_R_INVALID_PADDING_MODE = @as(c_int, 141);
pub const RSA_R_INVALID_PSS_PARAMETERS = @as(c_int, 149);
pub const RSA_R_INVALID_PSS_SALTLEN = @as(c_int, 146);
pub const RSA_R_INVALID_REQUEST = @as(c_int, 175);
pub const RSA_R_INVALID_SALT_LENGTH = @as(c_int, 150);
pub const RSA_R_INVALID_STRENGTH = @as(c_int, 176);
pub const RSA_R_INVALID_TRAILER = @as(c_int, 139);
pub const RSA_R_INVALID_X931_DIGEST = @as(c_int, 142);
pub const RSA_R_IQMP_NOT_INVERSE_OF_Q = @as(c_int, 126);
pub const RSA_R_KEY_PRIME_NUM_INVALID = @as(c_int, 165);
pub const RSA_R_KEY_SIZE_TOO_SMALL = @as(c_int, 120);
pub const RSA_R_LAST_OCTET_INVALID = @as(c_int, 134);
pub const RSA_R_MGF1_DIGEST_NOT_ALLOWED = @as(c_int, 152);
pub const RSA_R_MISSING_PRIVATE_KEY = @as(c_int, 179);
pub const RSA_R_MODULUS_TOO_LARGE = @as(c_int, 105);
pub const RSA_R_MP_COEFFICIENT_NOT_INVERSE_OF_R = @as(c_int, 168);
pub const RSA_R_MP_EXPONENT_NOT_CONGRUENT_TO_D = @as(c_int, 169);
pub const RSA_R_MP_R_NOT_PRIME = @as(c_int, 170);
pub const RSA_R_NO_PUBLIC_EXPONENT = @as(c_int, 140);
pub const RSA_R_NULL_BEFORE_BLOCK_MISSING = @as(c_int, 113);
pub const RSA_R_N_DOES_NOT_EQUAL_PRODUCT_OF_PRIMES = @as(c_int, 172);
pub const RSA_R_N_DOES_NOT_EQUAL_P_Q = @as(c_int, 127);
pub const RSA_R_OAEP_DECODING_ERROR = @as(c_int, 121);
pub const RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE = @as(c_int, 148);
pub const RSA_R_PADDING_CHECK_FAILED = @as(c_int, 114);
pub const RSA_R_PAIRWISE_TEST_FAILURE = @as(c_int, 177);
pub const RSA_R_PKCS_DECODING_ERROR = @as(c_int, 159);
pub const RSA_R_PSS_SALTLEN_TOO_SMALL = @as(c_int, 164);
pub const RSA_R_PUB_EXPONENT_OUT_OF_RANGE = @as(c_int, 178);
pub const RSA_R_P_NOT_PRIME = @as(c_int, 128);
pub const RSA_R_Q_NOT_PRIME = @as(c_int, 129);
pub const RSA_R_RANDOMNESS_SOURCE_STRENGTH_INSUFFICIENT = @as(c_int, 180);
pub const RSA_R_RSA_OPERATIONS_NOT_SUPPORTED = @as(c_int, 130);
pub const RSA_R_SLEN_CHECK_FAILED = @as(c_int, 136);
pub const RSA_R_SLEN_RECOVERY_FAILED = @as(c_int, 135);
pub const RSA_R_SSLV3_ROLLBACK_ATTACK = @as(c_int, 115);
pub const RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD = @as(c_int, 116);
pub const RSA_R_UNKNOWN_ALGORITHM_TYPE = @as(c_int, 117);
pub const RSA_R_UNKNOWN_DIGEST = @as(c_int, 166);
pub const RSA_R_UNKNOWN_MASK_DIGEST = @as(c_int, 151);
pub const RSA_R_UNKNOWN_PADDING_TYPE = @as(c_int, 118);
pub const RSA_R_UNSUPPORTED_ENCRYPTION_TYPE = @as(c_int, 162);
pub const RSA_R_UNSUPPORTED_LABEL_SOURCE = @as(c_int, 163);
pub const RSA_R_UNSUPPORTED_MASK_ALGORITHM = @as(c_int, 153);
pub const RSA_R_UNSUPPORTED_MASK_PARAMETER = @as(c_int, 154);
pub const RSA_R_UNSUPPORTED_SIGNATURE_TYPE = @as(c_int, 155);
pub const RSA_R_VALUE_MISSING = @as(c_int, 147);
pub const RSA_R_WRONG_SIGNATURE_LENGTH = @as(c_int, 119);
pub const OPENSSL_RSA_MAX_MODULUS_BITS = @as(c_int, 16384);
pub const RSA_3 = @as(c_long, 0x3);
pub const RSA_F4 = @as(c_long, 0x10001);
pub const OPENSSL_RSA_FIPS_MIN_MODULUS_BITS = @as(c_int, 2048);
pub const OPENSSL_RSA_SMALL_MODULUS_BITS = @as(c_int, 3072);
pub const OPENSSL_RSA_MAX_PUBEXP_BITS = @as(c_int, 64);
pub const RSA_ASN1_VERSION_DEFAULT = @as(c_int, 0);
pub const RSA_ASN1_VERSION_MULTI = @as(c_int, 1);
pub const RSA_DEFAULT_PRIME_NUM = @as(c_int, 2);
pub const RSA_METHOD_FLAG_NO_CHECK = @as(c_int, 0x0001);
pub const RSA_FLAG_CACHE_PUBLIC = @as(c_int, 0x0002);
pub const RSA_FLAG_CACHE_PRIVATE = @as(c_int, 0x0004);
pub const RSA_FLAG_BLINDING = @as(c_int, 0x0008);
pub const RSA_FLAG_THREAD_SAFE = @as(c_int, 0x0010);
pub const RSA_FLAG_EXT_PKEY = @as(c_int, 0x0020);
pub const RSA_FLAG_NO_BLINDING = @as(c_int, 0x0080);
pub const RSA_FLAG_NO_CONSTTIME = @as(c_int, 0x0000);
pub const RSA_FLAG_NO_EXP_CONSTTIME = RSA_FLAG_NO_CONSTTIME;
pub const RSA_FLAG_TYPE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF000, .hex);
pub const RSA_FLAG_TYPE_RSA = @as(c_int, 0x0000);
pub const RSA_FLAG_TYPE_RSASSAPSS = @as(c_int, 0x1000);
pub const RSA_FLAG_TYPE_RSAESOAEP = @as(c_int, 0x2000);
pub const RSA_PSS_SALTLEN_DIGEST = -@as(c_int, 1);
pub const RSA_PSS_SALTLEN_AUTO = -@as(c_int, 2);
pub const RSA_PSS_SALTLEN_MAX = -@as(c_int, 3);
pub const RSA_PSS_SALTLEN_AUTO_DIGEST_MAX = -@as(c_int, 4);
pub const RSA_PSS_SALTLEN_MAX_SIGN = -@as(c_int, 2);
pub const EVP_PKEY_CTRL_RSA_PADDING = EVP_PKEY_ALG_CTRL + @as(c_int, 1);
pub const EVP_PKEY_CTRL_RSA_PSS_SALTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 2);
pub const EVP_PKEY_CTRL_RSA_KEYGEN_BITS = EVP_PKEY_ALG_CTRL + @as(c_int, 3);
pub const EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP = EVP_PKEY_ALG_CTRL + @as(c_int, 4);
pub const EVP_PKEY_CTRL_RSA_MGF1_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 5);
pub const EVP_PKEY_CTRL_GET_RSA_PADDING = EVP_PKEY_ALG_CTRL + @as(c_int, 6);
pub const EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 7);
pub const EVP_PKEY_CTRL_GET_RSA_MGF1_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 8);
pub const EVP_PKEY_CTRL_RSA_OAEP_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 9);
pub const EVP_PKEY_CTRL_RSA_OAEP_LABEL = EVP_PKEY_ALG_CTRL + @as(c_int, 10);
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 11);
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_LABEL = EVP_PKEY_ALG_CTRL + @as(c_int, 12);
pub const EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES = EVP_PKEY_ALG_CTRL + @as(c_int, 13);
pub const EVP_PKEY_CTRL_RSA_IMPLICIT_REJECTION = EVP_PKEY_ALG_CTRL + @as(c_int, 14);
pub const RSA_PKCS1_PADDING = @as(c_int, 1);
pub const RSA_NO_PADDING = @as(c_int, 3);
pub const RSA_PKCS1_OAEP_PADDING = @as(c_int, 4);
pub const RSA_X931_PADDING = @as(c_int, 5);
pub const RSA_PKCS1_PSS_PADDING = @as(c_int, 6);
pub const RSA_PKCS1_WITH_TLS_PADDING = @as(c_int, 7);
pub const RSA_PKCS1_NO_IMPLICIT_REJECT_PADDING = @as(c_int, 8);
pub const RSA_PKCS1_PADDING_SIZE = @as(c_int, 11);
pub inline fn RSA_set_app_data(s: anytype, arg: anytype) @TypeOf(RSA_set_ex_data(s, @as(c_int, 0), arg)) {
    _ = &s;
    _ = &arg;
    return RSA_set_ex_data(s, @as(c_int, 0), arg);
}
pub inline fn RSA_get_app_data(s: anytype) @TypeOf(RSA_get_ex_data(s, @as(c_int, 0))) {
    _ = &s;
    return RSA_get_ex_data(s, @as(c_int, 0));
}
pub inline fn EVP_RSA_gen(bits: anytype) @TypeOf(EVP_PKEY_Q_keygen(NULL, NULL, "RSA", @import("std").zig.c_translation.cast(usize, @as(c_int, 0) + bits))) {
    _ = &bits;
    return EVP_PKEY_Q_keygen(NULL, NULL, "RSA", @import("std").zig.c_translation.cast(usize, @as(c_int, 0) + bits));
}
pub inline fn RSA_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_RSA, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_RSA, l, p, newf, dupf, freef);
}
pub const RSA_FLAG_FIPS_METHOD = @as(c_int, 0x0400);
pub const RSA_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0400);
pub const RSA_FLAG_CHECKED = @as(c_int, 0x0800);
pub const OPENSSL_DSA_H = "";
pub const HEADER_DSA_H = "";
pub const OPENSSL_DH_H = "";
pub const HEADER_DH_H = "";
pub const DH_PARAMGEN_TYPE_GENERATOR = @as(c_int, 0);
pub const DH_PARAMGEN_TYPE_FIPS_186_2 = @as(c_int, 1);
pub const DH_PARAMGEN_TYPE_FIPS_186_4 = @as(c_int, 2);
pub const DH_PARAMGEN_TYPE_GROUP = @as(c_int, 3);
pub const EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN = EVP_PKEY_ALG_CTRL + @as(c_int, 1);
pub const EVP_PKEY_CTRL_DH_PARAMGEN_GENERATOR = EVP_PKEY_ALG_CTRL + @as(c_int, 2);
pub const EVP_PKEY_CTRL_DH_RFC5114 = EVP_PKEY_ALG_CTRL + @as(c_int, 3);
pub const EVP_PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN = EVP_PKEY_ALG_CTRL + @as(c_int, 4);
pub const EVP_PKEY_CTRL_DH_PARAMGEN_TYPE = EVP_PKEY_ALG_CTRL + @as(c_int, 5);
pub const EVP_PKEY_CTRL_DH_KDF_TYPE = EVP_PKEY_ALG_CTRL + @as(c_int, 6);
pub const EVP_PKEY_CTRL_DH_KDF_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 7);
pub const EVP_PKEY_CTRL_GET_DH_KDF_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 8);
pub const EVP_PKEY_CTRL_DH_KDF_OUTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 9);
pub const EVP_PKEY_CTRL_GET_DH_KDF_OUTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 10);
pub const EVP_PKEY_CTRL_DH_KDF_UKM = EVP_PKEY_ALG_CTRL + @as(c_int, 11);
pub const EVP_PKEY_CTRL_GET_DH_KDF_UKM = EVP_PKEY_ALG_CTRL + @as(c_int, 12);
pub const EVP_PKEY_CTRL_DH_KDF_OID = EVP_PKEY_ALG_CTRL + @as(c_int, 13);
pub const EVP_PKEY_CTRL_GET_DH_KDF_OID = EVP_PKEY_ALG_CTRL + @as(c_int, 14);
pub const EVP_PKEY_CTRL_DH_NID = EVP_PKEY_ALG_CTRL + @as(c_int, 15);
pub const EVP_PKEY_CTRL_DH_PAD = EVP_PKEY_ALG_CTRL + @as(c_int, 16);
pub const EVP_PKEY_DH_KDF_NONE = @as(c_int, 1);
pub const EVP_PKEY_DH_KDF_X9_42 = @as(c_int, 2);
pub const OPENSSL_DHERR_H = "";
pub const DH_R_BAD_FFC_PARAMETERS = @as(c_int, 127);
pub const DH_R_BAD_GENERATOR = @as(c_int, 101);
pub const DH_R_BN_DECODE_ERROR = @as(c_int, 109);
pub const DH_R_BN_ERROR = @as(c_int, 106);
pub const DH_R_CHECK_INVALID_J_VALUE = @as(c_int, 115);
pub const DH_R_CHECK_INVALID_Q_VALUE = @as(c_int, 116);
pub const DH_R_CHECK_PUBKEY_INVALID = @as(c_int, 122);
pub const DH_R_CHECK_PUBKEY_TOO_LARGE = @as(c_int, 123);
pub const DH_R_CHECK_PUBKEY_TOO_SMALL = @as(c_int, 124);
pub const DH_R_CHECK_P_NOT_PRIME = @as(c_int, 117);
pub const DH_R_CHECK_P_NOT_SAFE_PRIME = @as(c_int, 118);
pub const DH_R_CHECK_Q_NOT_PRIME = @as(c_int, 119);
pub const DH_R_DECODE_ERROR = @as(c_int, 104);
pub const DH_R_INVALID_PARAMETER_NAME = @as(c_int, 110);
pub const DH_R_INVALID_PARAMETER_NID = @as(c_int, 114);
pub const DH_R_INVALID_PUBKEY = @as(c_int, 102);
pub const DH_R_INVALID_SECRET = @as(c_int, 128);
pub const DH_R_INVALID_SIZE = @as(c_int, 129);
pub const DH_R_KDF_PARAMETER_ERROR = @as(c_int, 112);
pub const DH_R_KEYS_NOT_SET = @as(c_int, 108);
pub const DH_R_MISSING_PUBKEY = @as(c_int, 125);
pub const DH_R_MODULUS_TOO_LARGE = @as(c_int, 103);
pub const DH_R_MODULUS_TOO_SMALL = @as(c_int, 126);
pub const DH_R_NOT_SUITABLE_GENERATOR = @as(c_int, 120);
pub const DH_R_NO_PARAMETERS_SET = @as(c_int, 107);
pub const DH_R_NO_PRIVATE_VALUE = @as(c_int, 100);
pub const DH_R_PARAMETER_ENCODING_ERROR = @as(c_int, 105);
pub const DH_R_PEER_KEY_ERROR = @as(c_int, 111);
pub const DH_R_Q_TOO_LARGE = @as(c_int, 130);
pub const DH_R_SHARED_INFO_ERROR = @as(c_int, 113);
pub const DH_R_UNABLE_TO_CHECK_GENERATOR = @as(c_int, 121);
pub const OPENSSL_DH_MAX_MODULUS_BITS = @as(c_int, 10000);
pub const OPENSSL_DH_CHECK_MAX_MODULUS_BITS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const OPENSSL_DH_FIPS_MIN_MODULUS_BITS = @as(c_int, 1024);
pub const DH_FLAG_CACHE_MONT_P = @as(c_int, 0x01);
pub const DH_FLAG_TYPE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF000, .hex);
pub const DH_FLAG_TYPE_DH = @as(c_int, 0x0000);
pub const DH_FLAG_TYPE_DHX = @as(c_int, 0x1000);
pub const DH_FLAG_NO_EXP_CONSTTIME = @as(c_int, 0x00);
pub const DH_FLAG_FIPS_METHOD = @as(c_int, 0x0400);
pub const DH_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0400);
pub const DH_GENERATOR_2 = @as(c_int, 2);
pub const DH_GENERATOR_3 = @as(c_int, 3);
pub const DH_GENERATOR_5 = @as(c_int, 5);
pub const DH_CHECK_P_NOT_PRIME = @as(c_int, 0x01);
pub const DH_CHECK_P_NOT_SAFE_PRIME = @as(c_int, 0x02);
pub const DH_UNABLE_TO_CHECK_GENERATOR = @as(c_int, 0x04);
pub const DH_NOT_SUITABLE_GENERATOR = @as(c_int, 0x08);
pub const DH_CHECK_Q_NOT_PRIME = @as(c_int, 0x10);
pub const DH_CHECK_INVALID_Q_VALUE = @as(c_int, 0x20);
pub const DH_CHECK_INVALID_J_VALUE = @as(c_int, 0x40);
pub const DH_MODULUS_TOO_SMALL = @as(c_int, 0x80);
pub const DH_MODULUS_TOO_LARGE = @as(c_int, 0x100);
pub const DH_CHECK_PUBKEY_TOO_SMALL = @as(c_int, 0x01);
pub const DH_CHECK_PUBKEY_TOO_LARGE = @as(c_int, 0x02);
pub const DH_CHECK_PUBKEY_INVALID = @as(c_int, 0x04);
pub const DH_CHECK_P_NOT_STRONG_PRIME = DH_CHECK_P_NOT_SAFE_PRIME;
pub const d2i_DHparams_fp = @compileError("unable to translate C expr: expected ')' instead got '('");
// /opt/homebrew/opt/openssl@3/include/openssl/dh.h:177:12
pub inline fn i2d_DHparams_fp(fp: anytype, x: anytype) @TypeOf(ASN1_i2d_fp(i2d_DHparams, fp, @import("std").zig.c_translation.cast([*c]u8, x))) {
    _ = &fp;
    _ = &x;
    return ASN1_i2d_fp(i2d_DHparams, fp, @import("std").zig.c_translation.cast([*c]u8, x));
}
pub inline fn d2i_DHparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_d2i_bio_of(DH, DH_new, d2i_DHparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_d2i_bio_of(DH, DH_new, d2i_DHparams, bp, x);
}
pub inline fn i2d_DHparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(DH, i2d_DHparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_i2d_bio_of(DH, i2d_DHparams, bp, x);
}
pub const d2i_DHxparams_fp = @compileError("unable to translate C expr: expected ')' instead got '('");
// /opt/homebrew/opt/openssl@3/include/openssl/dh.h:189:12
pub inline fn i2d_DHxparams_fp(fp: anytype, x: anytype) @TypeOf(ASN1_i2d_fp(i2d_DHxparams, fp, @import("std").zig.c_translation.cast([*c]u8, x))) {
    _ = &fp;
    _ = &x;
    return ASN1_i2d_fp(i2d_DHxparams, fp, @import("std").zig.c_translation.cast([*c]u8, x));
}
pub inline fn d2i_DHxparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_d2i_bio_of(DH, DH_new, d2i_DHxparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_d2i_bio_of(DH, DH_new, d2i_DHxparams, bp, x);
}
pub inline fn i2d_DHxparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(DH, i2d_DHxparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_i2d_bio_of(DH, i2d_DHxparams, bp, x);
}
pub inline fn DH_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DH, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DH, l, p, newf, dupf, freef);
}
pub const OPENSSL_DSAERR_H = "";
pub const DSA_R_BAD_FFC_PARAMETERS = @as(c_int, 114);
pub const DSA_R_BAD_Q_VALUE = @as(c_int, 102);
pub const DSA_R_BN_DECODE_ERROR = @as(c_int, 108);
pub const DSA_R_BN_ERROR = @as(c_int, 109);
pub const DSA_R_DECODE_ERROR = @as(c_int, 104);
pub const DSA_R_INVALID_DIGEST_TYPE = @as(c_int, 106);
pub const DSA_R_INVALID_PARAMETERS = @as(c_int, 112);
pub const DSA_R_MISSING_PARAMETERS = @as(c_int, 101);
pub const DSA_R_MISSING_PRIVATE_KEY = @as(c_int, 111);
pub const DSA_R_MODULUS_TOO_LARGE = @as(c_int, 103);
pub const DSA_R_NO_PARAMETERS_SET = @as(c_int, 107);
pub const DSA_R_PARAMETER_ENCODING_ERROR = @as(c_int, 105);
pub const DSA_R_P_NOT_PRIME = @as(c_int, 115);
pub const DSA_R_Q_NOT_PRIME = @as(c_int, 113);
pub const DSA_R_SEED_LEN_SMALL = @as(c_int, 110);
pub const DSA_R_TOO_MANY_RETRIES = @as(c_int, 116);
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_BITS = EVP_PKEY_ALG_CTRL + @as(c_int, 1);
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS = EVP_PKEY_ALG_CTRL + @as(c_int, 2);
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 3);
pub const OPENSSL_DSA_MAX_MODULUS_BITS = @as(c_int, 10000);
pub const OPENSSL_DSA_FIPS_MIN_MODULUS_BITS = @as(c_int, 1024);
pub const DSA_FLAG_NO_EXP_CONSTTIME = @as(c_int, 0x00);
pub const DSA_FLAG_CACHE_MONT_P = @as(c_int, 0x01);
pub const DSA_FLAG_FIPS_METHOD = @as(c_int, 0x0400);
pub const DSA_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0400);
pub const DSA_FLAG_FIPS_CHECKED = @as(c_int, 0x0800);
pub const d2i_DSAparams_fp = @compileError("unable to translate C expr: expected ')' instead got '('");
// /opt/homebrew/opt/openssl@3/include/openssl/dsa.h:106:12
pub inline fn i2d_DSAparams_fp(fp: anytype, x: anytype) @TypeOf(ASN1_i2d_fp(i2d_DSAparams, fp, @import("std").zig.c_translation.cast([*c]u8, x))) {
    _ = &fp;
    _ = &x;
    return ASN1_i2d_fp(i2d_DSAparams, fp, @import("std").zig.c_translation.cast([*c]u8, x));
}
pub inline fn d2i_DSAparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_d2i_bio_of(DSA, DSA_new, d2i_DSAparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_d2i_bio_of(DSA, DSA_new, d2i_DSAparams, bp, x);
}
pub inline fn i2d_DSAparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(DSA, i2d_DSAparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_i2d_bio_of(DSA, i2d_DSAparams, bp, x);
}
pub inline fn DSA_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DSA, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DSA, l, p, newf, dupf, freef);
}
pub const DSS_prime_checks = @as(c_int, 64);
pub inline fn DSA_is_prime(n: anytype, callback: anytype, cb_arg: anytype) @TypeOf(BN_is_prime(n, DSS_prime_checks, callback, NULL, cb_arg)) {
    _ = &n;
    _ = &callback;
    _ = &cb_arg;
    return BN_is_prime(n, DSS_prime_checks, callback, NULL, cb_arg);
}
pub const OPENSSL_SHA_H = "";
pub const HEADER_SHA_H = "";
pub const SHA_DIGEST_LENGTH = @as(c_int, 20);
pub const SHA_LONG = c_uint;
pub const SHA_LBLOCK = @as(c_int, 16);
pub const SHA_CBLOCK = SHA_LBLOCK * @as(c_int, 4);
pub const SHA_LAST_BLOCK = SHA_CBLOCK - @as(c_int, 8);
pub const SHA256_CBLOCK = SHA_LBLOCK * @as(c_int, 4);
pub const SHA256_192_DIGEST_LENGTH = @as(c_int, 24);
pub const SHA224_DIGEST_LENGTH = @as(c_int, 28);
pub const SHA256_DIGEST_LENGTH = @as(c_int, 32);
pub const SHA384_DIGEST_LENGTH = @as(c_int, 48);
pub const SHA512_DIGEST_LENGTH = @as(c_int, 64);
pub const SHA512_CBLOCK = SHA_LBLOCK * @as(c_int, 8);
pub const SHA_LONG64 = c_ulonglong;
pub const OPENSSL_X509ERR_H = "";
pub const X509_R_AKID_MISMATCH = @as(c_int, 110);
pub const X509_R_BAD_SELECTOR = @as(c_int, 133);
pub const X509_R_BAD_X509_FILETYPE = @as(c_int, 100);
pub const X509_R_BASE64_DECODE_ERROR = @as(c_int, 118);
pub const X509_R_CANT_CHECK_DH_KEY = @as(c_int, 114);
pub const X509_R_CERTIFICATE_VERIFICATION_FAILED = @as(c_int, 139);
pub const X509_R_CERT_ALREADY_IN_HASH_TABLE = @as(c_int, 101);
pub const X509_R_CRL_ALREADY_DELTA = @as(c_int, 127);
pub const X509_R_CRL_VERIFY_FAILURE = @as(c_int, 131);
pub const X509_R_DUPLICATE_ATTRIBUTE = @as(c_int, 140);
pub const X509_R_ERROR_GETTING_MD_BY_NID = @as(c_int, 141);
pub const X509_R_ERROR_USING_SIGINF_SET = @as(c_int, 142);
pub const X509_R_IDP_MISMATCH = @as(c_int, 128);
pub const X509_R_INVALID_ATTRIBUTES = @as(c_int, 138);
pub const X509_R_INVALID_DIRECTORY = @as(c_int, 113);
pub const X509_R_INVALID_DISTPOINT = @as(c_int, 143);
pub const X509_R_INVALID_FIELD_NAME = @as(c_int, 119);
pub const X509_R_INVALID_TRUST = @as(c_int, 123);
pub const X509_R_ISSUER_MISMATCH = @as(c_int, 129);
pub const X509_R_KEY_TYPE_MISMATCH = @as(c_int, 115);
pub const X509_R_KEY_VALUES_MISMATCH = @as(c_int, 116);
pub const X509_R_LOADING_CERT_DIR = @as(c_int, 103);
pub const X509_R_LOADING_DEFAULTS = @as(c_int, 104);
pub const X509_R_METHOD_NOT_SUPPORTED = @as(c_int, 124);
pub const X509_R_NAME_TOO_LONG = @as(c_int, 134);
pub const X509_R_NEWER_CRL_NOT_NEWER = @as(c_int, 132);
pub const X509_R_NO_CERTIFICATE_FOUND = @as(c_int, 135);
pub const X509_R_NO_CERTIFICATE_OR_CRL_FOUND = @as(c_int, 136);
pub const X509_R_NO_CERT_SET_FOR_US_TO_VERIFY = @as(c_int, 105);
pub const X509_R_NO_CRL_FOUND = @as(c_int, 137);
pub const X509_R_NO_CRL_NUMBER = @as(c_int, 130);
pub const X509_R_PUBLIC_KEY_DECODE_ERROR = @as(c_int, 125);
pub const X509_R_PUBLIC_KEY_ENCODE_ERROR = @as(c_int, 126);
pub const X509_R_SHOULD_RETRY = @as(c_int, 106);
pub const X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN = @as(c_int, 107);
pub const X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY = @as(c_int, 108);
pub const X509_R_UNKNOWN_KEY_TYPE = @as(c_int, 117);
pub const X509_R_UNKNOWN_NID = @as(c_int, 109);
pub const X509_R_UNKNOWN_PURPOSE_ID = @as(c_int, 121);
pub const X509_R_UNKNOWN_SIGID_ALGS = @as(c_int, 144);
pub const X509_R_UNKNOWN_TRUST_ID = @as(c_int, 120);
pub const X509_R_UNSUPPORTED_ALGORITHM = @as(c_int, 111);
pub const X509_R_UNSUPPORTED_VERSION = @as(c_int, 145);
pub const X509_R_WRONG_LOOKUP_TYPE = @as(c_int, 112);
pub const X509_R_WRONG_TYPE = @as(c_int, 122);
pub inline fn sk_X509_NAME_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_NAME_sk_type(sk));
}
pub inline fn sk_X509_NAME_value(sk: anytype, idx: anytype) [*c]X509_NAME {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_value(ossl_check_const_X509_NAME_sk_type(sk), idx));
}
pub const sk_X509_NAME_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:55:9
pub const sk_X509_NAME_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:56:9
pub const sk_X509_NAME_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:57:9
pub inline fn sk_X509_NAME_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_NAME_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_NAME_sk_type(sk), n);
}
pub inline fn sk_X509_NAME_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_NAME_sk_type(sk));
}
pub inline fn sk_X509_NAME_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_NAME_sk_type(sk));
}
pub inline fn sk_X509_NAME_delete(sk: anytype, i: anytype) [*c]X509_NAME {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_delete(ossl_check_X509_NAME_sk_type(sk), i));
}
pub inline fn sk_X509_NAME_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_NAME {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_delete_ptr(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr)));
}
pub inline fn sk_X509_NAME_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr));
}
pub inline fn sk_X509_NAME_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr));
}
pub inline fn sk_X509_NAME_pop(sk: anytype) [*c]X509_NAME {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_pop(ossl_check_X509_NAME_sk_type(sk)));
}
pub inline fn sk_X509_NAME_shift(sk: anytype) [*c]X509_NAME {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_shift(ossl_check_X509_NAME_sk_type(sk)));
}
pub inline fn sk_X509_NAME_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_freefunc_type(freefunc));
}
pub inline fn sk_X509_NAME_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr), idx);
}
pub inline fn sk_X509_NAME_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_NAME {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_set(ossl_check_X509_NAME_sk_type(sk), idx, ossl_check_X509_NAME_type(ptr)));
}
pub inline fn sk_X509_NAME_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr));
}
pub inline fn sk_X509_NAME_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr));
}
pub inline fn sk_X509_NAME_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr), pnum);
}
pub inline fn sk_X509_NAME_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_NAME_sk_type(sk));
}
pub inline fn sk_X509_NAME_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_NAME_sk_type(sk));
}
pub const sk_X509_NAME_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:75:9
pub const sk_X509_NAME_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:76:9
pub inline fn sk_X509_NAME_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_NAME_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_NAME_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_compfunc_type(cmp)));
}
pub inline fn sk_X509_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_sk_type(sk));
}
pub inline fn sk_X509_value(sk: anytype, idx: anytype) [*c]X509 {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_value(ossl_check_const_X509_sk_type(sk), idx));
}
pub const sk_X509_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:81:9
pub const sk_X509_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:82:9
pub const sk_X509_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:83:9
pub inline fn sk_X509_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_sk_type(sk), n);
}
pub inline fn sk_X509_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_sk_type(sk));
}
pub inline fn sk_X509_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_sk_type(sk));
}
pub inline fn sk_X509_delete(sk: anytype, i: anytype) [*c]X509 {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_delete(ossl_check_X509_sk_type(sk), i));
}
pub inline fn sk_X509_delete_ptr(sk: anytype, ptr: anytype) [*c]X509 {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_delete_ptr(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr)));
}
pub inline fn sk_X509_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr));
}
pub inline fn sk_X509_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr));
}
pub inline fn sk_X509_pop(sk: anytype) [*c]X509 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_pop(ossl_check_X509_sk_type(sk)));
}
pub inline fn sk_X509_shift(sk: anytype) [*c]X509 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_shift(ossl_check_X509_sk_type(sk)));
}
pub inline fn sk_X509_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_sk_type(sk), ossl_check_X509_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_sk_type(sk), ossl_check_X509_freefunc_type(freefunc));
}
pub inline fn sk_X509_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr), idx);
}
pub inline fn sk_X509_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509 {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_set(ossl_check_X509_sk_type(sk), idx, ossl_check_X509_type(ptr)));
}
pub inline fn sk_X509_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr));
}
pub inline fn sk_X509_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr));
}
pub inline fn sk_X509_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr), pnum);
}
pub inline fn sk_X509_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_sk_type(sk));
}
pub inline fn sk_X509_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_sk_type(sk));
}
pub const sk_X509_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:101:9
pub const sk_X509_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:102:9
pub inline fn sk_X509_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_sk_type(sk), ossl_check_X509_compfunc_type(cmp)));
}
pub inline fn sk_X509_REVOKED_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_REVOKED_sk_type(sk));
}
pub inline fn sk_X509_REVOKED_value(sk: anytype, idx: anytype) [*c]X509_REVOKED {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_value(ossl_check_const_X509_REVOKED_sk_type(sk), idx));
}
pub const sk_X509_REVOKED_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:107:9
pub const sk_X509_REVOKED_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:108:9
pub const sk_X509_REVOKED_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:109:9
pub inline fn sk_X509_REVOKED_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_REVOKED_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_REVOKED_sk_type(sk), n);
}
pub inline fn sk_X509_REVOKED_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_REVOKED_sk_type(sk));
}
pub inline fn sk_X509_REVOKED_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_REVOKED_sk_type(sk));
}
pub inline fn sk_X509_REVOKED_delete(sk: anytype, i: anytype) [*c]X509_REVOKED {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_delete(ossl_check_X509_REVOKED_sk_type(sk), i));
}
pub inline fn sk_X509_REVOKED_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_REVOKED {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_delete_ptr(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr)));
}
pub inline fn sk_X509_REVOKED_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr));
}
pub inline fn sk_X509_REVOKED_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr));
}
pub inline fn sk_X509_REVOKED_pop(sk: anytype) [*c]X509_REVOKED {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_pop(ossl_check_X509_REVOKED_sk_type(sk)));
}
pub inline fn sk_X509_REVOKED_shift(sk: anytype) [*c]X509_REVOKED {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_shift(ossl_check_X509_REVOKED_sk_type(sk)));
}
pub inline fn sk_X509_REVOKED_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_freefunc_type(freefunc));
}
pub inline fn sk_X509_REVOKED_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr), idx);
}
pub inline fn sk_X509_REVOKED_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_REVOKED {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_set(ossl_check_X509_REVOKED_sk_type(sk), idx, ossl_check_X509_REVOKED_type(ptr)));
}
pub inline fn sk_X509_REVOKED_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr));
}
pub inline fn sk_X509_REVOKED_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr));
}
pub inline fn sk_X509_REVOKED_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr), pnum);
}
pub inline fn sk_X509_REVOKED_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_REVOKED_sk_type(sk));
}
pub inline fn sk_X509_REVOKED_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_REVOKED_sk_type(sk));
}
pub const sk_X509_REVOKED_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:127:9
pub const sk_X509_REVOKED_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:128:9
pub inline fn sk_X509_REVOKED_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_REVOKED_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_REVOKED_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_compfunc_type(cmp)));
}
pub inline fn sk_X509_CRL_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_CRL_sk_type(sk));
}
pub inline fn sk_X509_CRL_value(sk: anytype, idx: anytype) [*c]X509_CRL {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_value(ossl_check_const_X509_CRL_sk_type(sk), idx));
}
pub const sk_X509_CRL_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:133:9
pub const sk_X509_CRL_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:134:9
pub const sk_X509_CRL_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:135:9
pub inline fn sk_X509_CRL_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_CRL_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_CRL_sk_type(sk), n);
}
pub inline fn sk_X509_CRL_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_CRL_sk_type(sk));
}
pub inline fn sk_X509_CRL_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_CRL_sk_type(sk));
}
pub inline fn sk_X509_CRL_delete(sk: anytype, i: anytype) [*c]X509_CRL {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_delete(ossl_check_X509_CRL_sk_type(sk), i));
}
pub inline fn sk_X509_CRL_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_CRL {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_delete_ptr(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr)));
}
pub inline fn sk_X509_CRL_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr));
}
pub inline fn sk_X509_CRL_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr));
}
pub inline fn sk_X509_CRL_pop(sk: anytype) [*c]X509_CRL {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_pop(ossl_check_X509_CRL_sk_type(sk)));
}
pub inline fn sk_X509_CRL_shift(sk: anytype) [*c]X509_CRL {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_shift(ossl_check_X509_CRL_sk_type(sk)));
}
pub inline fn sk_X509_CRL_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_freefunc_type(freefunc));
}
pub inline fn sk_X509_CRL_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr), idx);
}
pub inline fn sk_X509_CRL_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_CRL {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_set(ossl_check_X509_CRL_sk_type(sk), idx, ossl_check_X509_CRL_type(ptr)));
}
pub inline fn sk_X509_CRL_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr));
}
pub inline fn sk_X509_CRL_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr));
}
pub inline fn sk_X509_CRL_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr), pnum);
}
pub inline fn sk_X509_CRL_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_CRL_sk_type(sk));
}
pub inline fn sk_X509_CRL_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_CRL_sk_type(sk));
}
pub const sk_X509_CRL_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:153:9
pub const sk_X509_CRL_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:154:9
pub inline fn sk_X509_CRL_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_CRL_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_CRL_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_compfunc_type(cmp)));
}
pub const X509_SIG_INFO_VALID = @as(c_int, 0x1);
pub const X509_SIG_INFO_TLS = @as(c_int, 0x2);
pub const X509_FILETYPE_PEM = @as(c_int, 1);
pub const X509_FILETYPE_ASN1 = @as(c_int, 2);
pub const X509_FILETYPE_DEFAULT = @as(c_int, 3);
pub const X509v3_KU_DIGITAL_SIGNATURE = @as(c_int, 0x0080);
pub const X509v3_KU_NON_REPUDIATION = @as(c_int, 0x0040);
pub const X509v3_KU_KEY_ENCIPHERMENT = @as(c_int, 0x0020);
pub const X509v3_KU_DATA_ENCIPHERMENT = @as(c_int, 0x0010);
pub const X509v3_KU_KEY_AGREEMENT = @as(c_int, 0x0008);
pub const X509v3_KU_KEY_CERT_SIGN = @as(c_int, 0x0004);
pub const X509v3_KU_CRL_SIGN = @as(c_int, 0x0002);
pub const X509v3_KU_ENCIPHER_ONLY = @as(c_int, 0x0001);
pub const X509v3_KU_DECIPHER_ONLY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const X509v3_KU_UNDEF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hex);
pub inline fn sk_X509_NAME_ENTRY_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_NAME_ENTRY_sk_type(sk));
}
pub inline fn sk_X509_NAME_ENTRY_value(sk: anytype, idx: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_value(ossl_check_const_X509_NAME_ENTRY_sk_type(sk), idx));
}
pub const sk_X509_NAME_ENTRY_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:206:9
pub const sk_X509_NAME_ENTRY_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:207:9
pub const sk_X509_NAME_ENTRY_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:208:9
pub inline fn sk_X509_NAME_ENTRY_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_NAME_ENTRY_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_NAME_ENTRY_sk_type(sk), n);
}
pub inline fn sk_X509_NAME_ENTRY_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_NAME_ENTRY_sk_type(sk));
}
pub inline fn sk_X509_NAME_ENTRY_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_NAME_ENTRY_sk_type(sk));
}
pub inline fn sk_X509_NAME_ENTRY_delete(sk: anytype, i: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_delete(ossl_check_X509_NAME_ENTRY_sk_type(sk), i));
}
pub inline fn sk_X509_NAME_ENTRY_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_delete_ptr(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr)));
}
pub inline fn sk_X509_NAME_ENTRY_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr));
}
pub inline fn sk_X509_NAME_ENTRY_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr));
}
pub inline fn sk_X509_NAME_ENTRY_pop(sk: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_pop(ossl_check_X509_NAME_ENTRY_sk_type(sk)));
}
pub inline fn sk_X509_NAME_ENTRY_shift(sk: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_shift(ossl_check_X509_NAME_ENTRY_sk_type(sk)));
}
pub inline fn sk_X509_NAME_ENTRY_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_freefunc_type(freefunc));
}
pub inline fn sk_X509_NAME_ENTRY_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr), idx);
}
pub inline fn sk_X509_NAME_ENTRY_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_set(ossl_check_X509_NAME_ENTRY_sk_type(sk), idx, ossl_check_X509_NAME_ENTRY_type(ptr)));
}
pub inline fn sk_X509_NAME_ENTRY_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr));
}
pub inline fn sk_X509_NAME_ENTRY_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr));
}
pub inline fn sk_X509_NAME_ENTRY_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr), pnum);
}
pub inline fn sk_X509_NAME_ENTRY_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_NAME_ENTRY_sk_type(sk));
}
pub inline fn sk_X509_NAME_ENTRY_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_NAME_ENTRY_sk_type(sk));
}
pub const sk_X509_NAME_ENTRY_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:226:9
pub const sk_X509_NAME_ENTRY_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:227:9
pub inline fn sk_X509_NAME_ENTRY_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_NAME_ENTRY_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_NAME_ENTRY_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_compfunc_type(cmp)));
}
pub const X509_EX_V_NETSCAPE_HACK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const X509_EX_V_INIT = @as(c_int, 0x0001);
pub inline fn sk_X509_EXTENSION_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_EXTENSION_sk_type(sk));
}
pub inline fn sk_X509_EXTENSION_value(sk: anytype, idx: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_value(ossl_check_const_X509_EXTENSION_sk_type(sk), idx));
}
pub const sk_X509_EXTENSION_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:237:9
pub const sk_X509_EXTENSION_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:238:9
pub const sk_X509_EXTENSION_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:239:9
pub inline fn sk_X509_EXTENSION_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_EXTENSION_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_EXTENSION_sk_type(sk), n);
}
pub inline fn sk_X509_EXTENSION_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_EXTENSION_sk_type(sk));
}
pub inline fn sk_X509_EXTENSION_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_EXTENSION_sk_type(sk));
}
pub inline fn sk_X509_EXTENSION_delete(sk: anytype, i: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_delete(ossl_check_X509_EXTENSION_sk_type(sk), i));
}
pub inline fn sk_X509_EXTENSION_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_delete_ptr(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr)));
}
pub inline fn sk_X509_EXTENSION_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr));
}
pub inline fn sk_X509_EXTENSION_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr));
}
pub inline fn sk_X509_EXTENSION_pop(sk: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_pop(ossl_check_X509_EXTENSION_sk_type(sk)));
}
pub inline fn sk_X509_EXTENSION_shift(sk: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_shift(ossl_check_X509_EXTENSION_sk_type(sk)));
}
pub inline fn sk_X509_EXTENSION_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_freefunc_type(freefunc));
}
pub inline fn sk_X509_EXTENSION_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr), idx);
}
pub inline fn sk_X509_EXTENSION_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_set(ossl_check_X509_EXTENSION_sk_type(sk), idx, ossl_check_X509_EXTENSION_type(ptr)));
}
pub inline fn sk_X509_EXTENSION_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr));
}
pub inline fn sk_X509_EXTENSION_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr));
}
pub inline fn sk_X509_EXTENSION_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr), pnum);
}
pub inline fn sk_X509_EXTENSION_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_EXTENSION_sk_type(sk));
}
pub inline fn sk_X509_EXTENSION_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_EXTENSION_sk_type(sk));
}
pub const sk_X509_EXTENSION_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:257:9
pub const sk_X509_EXTENSION_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:258:9
pub inline fn sk_X509_EXTENSION_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_EXTENSION_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_EXTENSION_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_compfunc_type(cmp)));
}
pub inline fn sk_X509_ATTRIBUTE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_ATTRIBUTE_sk_type(sk));
}
pub inline fn sk_X509_ATTRIBUTE_value(sk: anytype, idx: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_value(ossl_check_const_X509_ATTRIBUTE_sk_type(sk), idx));
}
pub const sk_X509_ATTRIBUTE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:266:9
pub const sk_X509_ATTRIBUTE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:267:9
pub const sk_X509_ATTRIBUTE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:268:9
pub inline fn sk_X509_ATTRIBUTE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_ATTRIBUTE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_ATTRIBUTE_sk_type(sk), n);
}
pub inline fn sk_X509_ATTRIBUTE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_ATTRIBUTE_sk_type(sk));
}
pub inline fn sk_X509_ATTRIBUTE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_ATTRIBUTE_sk_type(sk));
}
pub inline fn sk_X509_ATTRIBUTE_delete(sk: anytype, i: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_delete(ossl_check_X509_ATTRIBUTE_sk_type(sk), i));
}
pub inline fn sk_X509_ATTRIBUTE_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_delete_ptr(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr)));
}
pub inline fn sk_X509_ATTRIBUTE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr));
}
pub inline fn sk_X509_ATTRIBUTE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr));
}
pub inline fn sk_X509_ATTRIBUTE_pop(sk: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_pop(ossl_check_X509_ATTRIBUTE_sk_type(sk)));
}
pub inline fn sk_X509_ATTRIBUTE_shift(sk: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_shift(ossl_check_X509_ATTRIBUTE_sk_type(sk)));
}
pub inline fn sk_X509_ATTRIBUTE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_freefunc_type(freefunc));
}
pub inline fn sk_X509_ATTRIBUTE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr), idx);
}
pub inline fn sk_X509_ATTRIBUTE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_set(ossl_check_X509_ATTRIBUTE_sk_type(sk), idx, ossl_check_X509_ATTRIBUTE_type(ptr)));
}
pub inline fn sk_X509_ATTRIBUTE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr));
}
pub inline fn sk_X509_ATTRIBUTE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr));
}
pub inline fn sk_X509_ATTRIBUTE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr), pnum);
}
pub inline fn sk_X509_ATTRIBUTE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_ATTRIBUTE_sk_type(sk));
}
pub inline fn sk_X509_ATTRIBUTE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_ATTRIBUTE_sk_type(sk));
}
pub const sk_X509_ATTRIBUTE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:286:9
pub const sk_X509_ATTRIBUTE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:287:9
pub inline fn sk_X509_ATTRIBUTE_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_ATTRIBUTE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_ATTRIBUTE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_compfunc_type(cmp)));
}
pub const X509_FLAG_COMPAT = @as(c_int, 0);
pub const X509_FLAG_NO_HEADER = @as(c_long, 1);
pub const X509_FLAG_NO_VERSION = @as(c_long, 1) << @as(c_int, 1);
pub const X509_FLAG_NO_SERIAL = @as(c_long, 1) << @as(c_int, 2);
pub const X509_FLAG_NO_SIGNAME = @as(c_long, 1) << @as(c_int, 3);
pub const X509_FLAG_NO_ISSUER = @as(c_long, 1) << @as(c_int, 4);
pub const X509_FLAG_NO_VALIDITY = @as(c_long, 1) << @as(c_int, 5);
pub const X509_FLAG_NO_SUBJECT = @as(c_long, 1) << @as(c_int, 6);
pub const X509_FLAG_NO_PUBKEY = @as(c_long, 1) << @as(c_int, 7);
pub const X509_FLAG_NO_EXTENSIONS = @as(c_long, 1) << @as(c_int, 8);
pub const X509_FLAG_NO_SIGDUMP = @as(c_long, 1) << @as(c_int, 9);
pub const X509_FLAG_NO_AUX = @as(c_long, 1) << @as(c_int, 10);
pub const X509_FLAG_NO_ATTRIBUTES = @as(c_long, 1) << @as(c_int, 11);
pub const X509_FLAG_NO_IDS = @as(c_long, 1) << @as(c_int, 12);
pub const X509_FLAG_EXTENSIONS_ONLY_KID = @as(c_long, 1) << @as(c_int, 13);
pub const XN_FLAG_SEP_MASK = @as(c_int, 0xf) << @as(c_int, 16);
pub const XN_FLAG_COMPAT = @as(c_int, 0);
pub const XN_FLAG_SEP_COMMA_PLUS = @as(c_int, 1) << @as(c_int, 16);
pub const XN_FLAG_SEP_CPLUS_SPC = @as(c_int, 2) << @as(c_int, 16);
pub const XN_FLAG_SEP_SPLUS_SPC = @as(c_int, 3) << @as(c_int, 16);
pub const XN_FLAG_SEP_MULTILINE = @as(c_int, 4) << @as(c_int, 16);
pub const XN_FLAG_DN_REV = @as(c_int, 1) << @as(c_int, 20);
pub const XN_FLAG_FN_MASK = @as(c_int, 0x3) << @as(c_int, 21);
pub const XN_FLAG_FN_SN = @as(c_int, 0);
pub const XN_FLAG_FN_LN = @as(c_int, 1) << @as(c_int, 21);
pub const XN_FLAG_FN_OID = @as(c_int, 2) << @as(c_int, 21);
pub const XN_FLAG_FN_NONE = @as(c_int, 3) << @as(c_int, 21);
pub const XN_FLAG_SPC_EQ = @as(c_int, 1) << @as(c_int, 23);
pub const XN_FLAG_DUMP_UNKNOWN_FIELDS = @as(c_int, 1) << @as(c_int, 24);
pub const XN_FLAG_FN_ALIGN = @as(c_int, 1) << @as(c_int, 25);
pub const XN_FLAG_RFC2253 = (((ASN1_STRFLGS_RFC2253 | XN_FLAG_SEP_COMMA_PLUS) | XN_FLAG_DN_REV) | XN_FLAG_FN_SN) | XN_FLAG_DUMP_UNKNOWN_FIELDS;
pub const XN_FLAG_ONELINE = (((ASN1_STRFLGS_RFC2253 | ASN1_STRFLGS_ESC_QUOTE) | XN_FLAG_SEP_CPLUS_SPC) | XN_FLAG_SPC_EQ) | XN_FLAG_FN_SN;
pub const XN_FLAG_MULTILINE = ((((ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB) | XN_FLAG_SEP_MULTILINE) | XN_FLAG_SPC_EQ) | XN_FLAG_FN_LN) | XN_FLAG_FN_ALIGN;
pub inline fn sk_X509_INFO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_INFO_sk_type(sk));
}
pub inline fn sk_X509_INFO_value(sk: anytype, idx: anytype) [*c]X509_INFO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_value(ossl_check_const_X509_INFO_sk_type(sk), idx));
}
pub const sk_X509_INFO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:401:9
pub const sk_X509_INFO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:402:9
pub const sk_X509_INFO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:403:9
pub inline fn sk_X509_INFO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_INFO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_INFO_sk_type(sk), n);
}
pub inline fn sk_X509_INFO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_INFO_sk_type(sk));
}
pub inline fn sk_X509_INFO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_INFO_sk_type(sk));
}
pub inline fn sk_X509_INFO_delete(sk: anytype, i: anytype) [*c]X509_INFO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_delete(ossl_check_X509_INFO_sk_type(sk), i));
}
pub inline fn sk_X509_INFO_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_INFO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_delete_ptr(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr)));
}
pub inline fn sk_X509_INFO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr));
}
pub inline fn sk_X509_INFO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr));
}
pub inline fn sk_X509_INFO_pop(sk: anytype) [*c]X509_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_pop(ossl_check_X509_INFO_sk_type(sk)));
}
pub inline fn sk_X509_INFO_shift(sk: anytype) [*c]X509_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_shift(ossl_check_X509_INFO_sk_type(sk)));
}
pub inline fn sk_X509_INFO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_freefunc_type(freefunc));
}
pub inline fn sk_X509_INFO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr), idx);
}
pub inline fn sk_X509_INFO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_INFO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_set(ossl_check_X509_INFO_sk_type(sk), idx, ossl_check_X509_INFO_type(ptr)));
}
pub inline fn sk_X509_INFO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr));
}
pub inline fn sk_X509_INFO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr));
}
pub inline fn sk_X509_INFO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr), pnum);
}
pub inline fn sk_X509_INFO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_INFO_sk_type(sk));
}
pub inline fn sk_X509_INFO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_INFO_sk_type(sk));
}
pub const sk_X509_INFO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:421:9
pub const sk_X509_INFO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509.h:422:9
pub inline fn sk_X509_INFO_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_INFO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_INFO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_compfunc_type(cmp)));
}
pub const OPENSSL_X509_VFY_H = "";
pub const HEADER_X509_VFY_H = "";
pub const OPENSSL_LHASH_H = "";
pub const HEADER_LHASH_H = "";
pub const DECLARE_LHASH_HASH_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_HASH`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:56:10
pub const IMPLEMENT_LHASH_HASH_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_HASH`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:58:10
pub const LHASH_HASH_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_HASH`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:62:10
pub const DECLARE_LHASH_COMP_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_COMP`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:65:10
pub const IMPLEMENT_LHASH_COMP_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_COMP`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:67:10
pub const LHASH_COMP_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_COMP`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:72:10
pub const DECLARE_LHASH_DOALL_ARG_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_DOALL_ARG`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:75:10
pub const IMPLEMENT_LHASH_DOALL_ARG_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_DOALL_ARG`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:77:10
pub const LHASH_DOALL_ARG_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_DOALL_ARG`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:82:10
pub const LH_LOAD_MULT = @as(c_int, 256);
pub const _LHASH = OPENSSL_LHASH;
pub const LHASH_NODE = OPENSSL_LH_NODE;
pub const lh_error = OPENSSL_LH_error;
pub const lh_new = OPENSSL_LH_new;
pub const lh_free = OPENSSL_LH_free;
pub const lh_insert = OPENSSL_LH_insert;
pub const lh_delete = OPENSSL_LH_delete;
pub const lh_retrieve = OPENSSL_LH_retrieve;
pub const lh_doall = OPENSSL_LH_doall;
pub const lh_doall_arg = OPENSSL_LH_doall_arg;
pub const lh_strhash = OPENSSL_LH_strhash;
pub const lh_num_items = OPENSSL_LH_num_items;
pub const lh_stats = OPENSSL_LH_stats;
pub const lh_node_stats = OPENSSL_LH_node_stats;
pub const lh_node_usage_stats = OPENSSL_LH_node_usage_stats;
pub const lh_stats_bio = OPENSSL_LH_stats_bio;
pub const lh_node_stats_bio = OPENSSL_LH_node_stats_bio;
pub const lh_node_usage_stats_bio = OPENSSL_LH_node_usage_stats_bio;
pub const LHASH_OF = @compileError("unable to translate macro: undefined identifier `lhash_st_`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:149:10
pub const DEFINE_LHASH_OF_INTERNAL = @compileError("unable to translate macro: undefined identifier `lh_`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:152:10
pub const DEFINE_LHASH_OF_DEPRECATED = @compileError("unable to translate macro: undefined identifier `lh_`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:217:11
pub const DEFINE_LHASH_OF_EX = @compileError("unable to translate macro: undefined identifier `lh_`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:237:10
pub const DEFINE_LHASH_OF = @compileError("unable to translate C expr: unexpected token ';'");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:332:10
pub const IMPLEMENT_LHASH_DOALL_ARG_CONST = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:337:9
pub inline fn IMPLEMENT_LHASH_DOALL_ARG(@"type": anytype, argtype: anytype) @TypeOf(int_implement_lhash_doall(@"type", argtype, @"type")) {
    _ = &@"type";
    _ = &argtype;
    return int_implement_lhash_doall(@"type", argtype, @"type");
}
pub const int_implement_lhash_doall = @compileError("unable to translate macro: undefined identifier `lh_`");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:343:9
pub const lh_OPENSSL_STRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:363:9
pub inline fn lh_OPENSSL_STRING_free(lh: anytype) @TypeOf(OPENSSL_LH_free(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_free(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_flush(lh: anytype) @TypeOf(OPENSSL_LH_flush(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_flush(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_insert(lh: anytype, ptr: anytype) [*c]OPENSSL_STRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_STRING, OPENSSL_LH_insert(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_OPENSSL_STRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_STRING_delete(lh: anytype, ptr: anytype) [*c]OPENSSL_STRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_STRING, OPENSSL_LH_delete(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_const_OPENSSL_STRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_STRING_retrieve(lh: anytype, ptr: anytype) [*c]OPENSSL_STRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_STRING, OPENSSL_LH_retrieve(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_const_OPENSSL_STRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_STRING_error(lh: anytype) @TypeOf(OPENSSL_LH_error(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_error(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_num_items(lh: anytype) @TypeOf(OPENSSL_LH_num_items(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_num_items(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_node_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_STRING_node_usage_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_usage_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_usage_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_STRING_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_STRING_get_down_load(lh: anytype) @TypeOf(OPENSSL_LH_get_down_load(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_get_down_load(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_set_down_load(lh: anytype, dl: anytype) @TypeOf(OPENSSL_LH_set_down_load(ossl_check_OPENSSL_STRING_lh_type(lh), dl)) {
    _ = &lh;
    _ = &dl;
    return OPENSSL_LH_set_down_load(ossl_check_OPENSSL_STRING_lh_type(lh), dl);
}
pub inline fn lh_OPENSSL_STRING_doall(lh: anytype, dfn: anytype) @TypeOf(OPENSSL_LH_doall(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_OPENSSL_STRING_lh_doallfunc_type(dfn))) {
    _ = &lh;
    _ = &dfn;
    return OPENSSL_LH_doall(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_OPENSSL_STRING_lh_doallfunc_type(dfn));
}
pub const lh_OPENSSL_CSTRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/lhash.h:378:9
pub inline fn lh_OPENSSL_CSTRING_free(lh: anytype) @TypeOf(OPENSSL_LH_free(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_free(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_flush(lh: anytype) @TypeOf(OPENSSL_LH_flush(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_flush(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_insert(lh: anytype, ptr: anytype) [*c]OPENSSL_CSTRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_CSTRING, OPENSSL_LH_insert(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_OPENSSL_CSTRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_CSTRING_delete(lh: anytype, ptr: anytype) [*c]OPENSSL_CSTRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_CSTRING, OPENSSL_LH_delete(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_const_OPENSSL_CSTRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_CSTRING_retrieve(lh: anytype, ptr: anytype) [*c]OPENSSL_CSTRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_CSTRING, OPENSSL_LH_retrieve(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_const_OPENSSL_CSTRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_CSTRING_error(lh: anytype) @TypeOf(OPENSSL_LH_error(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_error(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_num_items(lh: anytype) @TypeOf(OPENSSL_LH_num_items(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_num_items(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_node_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_CSTRING_node_usage_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_usage_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_usage_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_CSTRING_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_CSTRING_get_down_load(lh: anytype) @TypeOf(OPENSSL_LH_get_down_load(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_get_down_load(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_set_down_load(lh: anytype, dl: anytype) @TypeOf(OPENSSL_LH_set_down_load(ossl_check_OPENSSL_CSTRING_lh_type(lh), dl)) {
    _ = &lh;
    _ = &dl;
    return OPENSSL_LH_set_down_load(ossl_check_OPENSSL_CSTRING_lh_type(lh), dl);
}
pub inline fn lh_OPENSSL_CSTRING_doall(lh: anytype, dfn: anytype) @TypeOf(OPENSSL_LH_doall(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_OPENSSL_CSTRING_lh_doallfunc_type(dfn))) {
    _ = &lh;
    _ = &dfn;
    return OPENSSL_LH_doall(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_OPENSSL_CSTRING_lh_doallfunc_type(dfn));
}
pub const X509_LU_RETRY = -@as(c_int, 1);
pub const X509_LU_FAIL = @as(c_int, 0);
pub inline fn sk_X509_LOOKUP_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_LOOKUP_sk_type(sk));
}
pub inline fn sk_X509_LOOKUP_value(sk: anytype, idx: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_value(ossl_check_const_X509_LOOKUP_sk_type(sk), idx));
}
pub const sk_X509_LOOKUP_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:71:9
pub const sk_X509_LOOKUP_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:72:9
pub const sk_X509_LOOKUP_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:73:9
pub inline fn sk_X509_LOOKUP_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_LOOKUP_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_LOOKUP_sk_type(sk), n);
}
pub inline fn sk_X509_LOOKUP_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_LOOKUP_sk_type(sk));
}
pub inline fn sk_X509_LOOKUP_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_LOOKUP_sk_type(sk));
}
pub inline fn sk_X509_LOOKUP_delete(sk: anytype, i: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_delete(ossl_check_X509_LOOKUP_sk_type(sk), i));
}
pub inline fn sk_X509_LOOKUP_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_delete_ptr(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr)));
}
pub inline fn sk_X509_LOOKUP_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr));
}
pub inline fn sk_X509_LOOKUP_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr));
}
pub inline fn sk_X509_LOOKUP_pop(sk: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_pop(ossl_check_X509_LOOKUP_sk_type(sk)));
}
pub inline fn sk_X509_LOOKUP_shift(sk: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_shift(ossl_check_X509_LOOKUP_sk_type(sk)));
}
pub inline fn sk_X509_LOOKUP_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_freefunc_type(freefunc));
}
pub inline fn sk_X509_LOOKUP_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr), idx);
}
pub inline fn sk_X509_LOOKUP_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_set(ossl_check_X509_LOOKUP_sk_type(sk), idx, ossl_check_X509_LOOKUP_type(ptr)));
}
pub inline fn sk_X509_LOOKUP_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr));
}
pub inline fn sk_X509_LOOKUP_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr));
}
pub inline fn sk_X509_LOOKUP_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr), pnum);
}
pub inline fn sk_X509_LOOKUP_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_LOOKUP_sk_type(sk));
}
pub inline fn sk_X509_LOOKUP_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_LOOKUP_sk_type(sk));
}
pub const sk_X509_LOOKUP_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:91:9
pub const sk_X509_LOOKUP_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:92:9
pub inline fn sk_X509_LOOKUP_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_LOOKUP_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_LOOKUP_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_compfunc_type(cmp)));
}
pub inline fn sk_X509_OBJECT_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_OBJECT_sk_type(sk));
}
pub inline fn sk_X509_OBJECT_value(sk: anytype, idx: anytype) [*c]X509_OBJECT {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_value(ossl_check_const_X509_OBJECT_sk_type(sk), idx));
}
pub const sk_X509_OBJECT_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:97:9
pub const sk_X509_OBJECT_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:98:9
pub const sk_X509_OBJECT_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:99:9
pub inline fn sk_X509_OBJECT_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_OBJECT_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_OBJECT_sk_type(sk), n);
}
pub inline fn sk_X509_OBJECT_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_OBJECT_sk_type(sk));
}
pub inline fn sk_X509_OBJECT_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_OBJECT_sk_type(sk));
}
pub inline fn sk_X509_OBJECT_delete(sk: anytype, i: anytype) [*c]X509_OBJECT {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_delete(ossl_check_X509_OBJECT_sk_type(sk), i));
}
pub inline fn sk_X509_OBJECT_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_OBJECT {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_delete_ptr(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr)));
}
pub inline fn sk_X509_OBJECT_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr));
}
pub inline fn sk_X509_OBJECT_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr));
}
pub inline fn sk_X509_OBJECT_pop(sk: anytype) [*c]X509_OBJECT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_pop(ossl_check_X509_OBJECT_sk_type(sk)));
}
pub inline fn sk_X509_OBJECT_shift(sk: anytype) [*c]X509_OBJECT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_shift(ossl_check_X509_OBJECT_sk_type(sk)));
}
pub inline fn sk_X509_OBJECT_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_freefunc_type(freefunc));
}
pub inline fn sk_X509_OBJECT_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr), idx);
}
pub inline fn sk_X509_OBJECT_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_OBJECT {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_set(ossl_check_X509_OBJECT_sk_type(sk), idx, ossl_check_X509_OBJECT_type(ptr)));
}
pub inline fn sk_X509_OBJECT_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr));
}
pub inline fn sk_X509_OBJECT_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr));
}
pub inline fn sk_X509_OBJECT_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr), pnum);
}
pub inline fn sk_X509_OBJECT_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_OBJECT_sk_type(sk));
}
pub inline fn sk_X509_OBJECT_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_OBJECT_sk_type(sk));
}
pub const sk_X509_OBJECT_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:117:9
pub const sk_X509_OBJECT_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:118:9
pub inline fn sk_X509_OBJECT_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_OBJECT_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_OBJECT_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_compfunc_type(cmp)));
}
pub inline fn sk_X509_VERIFY_PARAM_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk));
}
pub inline fn sk_X509_VERIFY_PARAM_value(sk: anytype, idx: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_value(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk), idx));
}
pub const sk_X509_VERIFY_PARAM_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:123:9
pub const sk_X509_VERIFY_PARAM_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:124:9
pub const sk_X509_VERIFY_PARAM_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:125:9
pub inline fn sk_X509_VERIFY_PARAM_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_VERIFY_PARAM_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_VERIFY_PARAM_sk_type(sk), n);
}
pub inline fn sk_X509_VERIFY_PARAM_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_VERIFY_PARAM_sk_type(sk));
}
pub inline fn sk_X509_VERIFY_PARAM_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_VERIFY_PARAM_sk_type(sk));
}
pub inline fn sk_X509_VERIFY_PARAM_delete(sk: anytype, i: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_delete(ossl_check_X509_VERIFY_PARAM_sk_type(sk), i));
}
pub inline fn sk_X509_VERIFY_PARAM_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_delete_ptr(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr)));
}
pub inline fn sk_X509_VERIFY_PARAM_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr));
}
pub inline fn sk_X509_VERIFY_PARAM_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr));
}
pub inline fn sk_X509_VERIFY_PARAM_pop(sk: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_pop(ossl_check_X509_VERIFY_PARAM_sk_type(sk)));
}
pub inline fn sk_X509_VERIFY_PARAM_shift(sk: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_shift(ossl_check_X509_VERIFY_PARAM_sk_type(sk)));
}
pub inline fn sk_X509_VERIFY_PARAM_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_freefunc_type(freefunc));
}
pub inline fn sk_X509_VERIFY_PARAM_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr), idx);
}
pub inline fn sk_X509_VERIFY_PARAM_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_set(ossl_check_X509_VERIFY_PARAM_sk_type(sk), idx, ossl_check_X509_VERIFY_PARAM_type(ptr)));
}
pub inline fn sk_X509_VERIFY_PARAM_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr));
}
pub inline fn sk_X509_VERIFY_PARAM_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr));
}
pub inline fn sk_X509_VERIFY_PARAM_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr), pnum);
}
pub inline fn sk_X509_VERIFY_PARAM_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_VERIFY_PARAM_sk_type(sk));
}
pub inline fn sk_X509_VERIFY_PARAM_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk));
}
pub const sk_X509_VERIFY_PARAM_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:143:9
pub const sk_X509_VERIFY_PARAM_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:144:9
pub inline fn sk_X509_VERIFY_PARAM_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_VERIFY_PARAM_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_VERIFY_PARAM_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_compfunc_type(cmp)));
}
pub inline fn sk_X509_TRUST_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_TRUST_sk_type(sk));
}
pub inline fn sk_X509_TRUST_value(sk: anytype, idx: anytype) [*c]X509_TRUST {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_value(ossl_check_const_X509_TRUST_sk_type(sk), idx));
}
pub const sk_X509_TRUST_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:160:9
pub const sk_X509_TRUST_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:161:9
pub const sk_X509_TRUST_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:162:9
pub inline fn sk_X509_TRUST_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_TRUST_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_TRUST_sk_type(sk), n);
}
pub inline fn sk_X509_TRUST_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_TRUST_sk_type(sk));
}
pub inline fn sk_X509_TRUST_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_TRUST_sk_type(sk));
}
pub inline fn sk_X509_TRUST_delete(sk: anytype, i: anytype) [*c]X509_TRUST {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_delete(ossl_check_X509_TRUST_sk_type(sk), i));
}
pub inline fn sk_X509_TRUST_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_TRUST {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_delete_ptr(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr)));
}
pub inline fn sk_X509_TRUST_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr));
}
pub inline fn sk_X509_TRUST_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr));
}
pub inline fn sk_X509_TRUST_pop(sk: anytype) [*c]X509_TRUST {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_pop(ossl_check_X509_TRUST_sk_type(sk)));
}
pub inline fn sk_X509_TRUST_shift(sk: anytype) [*c]X509_TRUST {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_shift(ossl_check_X509_TRUST_sk_type(sk)));
}
pub inline fn sk_X509_TRUST_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_freefunc_type(freefunc));
}
pub inline fn sk_X509_TRUST_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr), idx);
}
pub inline fn sk_X509_TRUST_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_TRUST {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_set(ossl_check_X509_TRUST_sk_type(sk), idx, ossl_check_X509_TRUST_type(ptr)));
}
pub inline fn sk_X509_TRUST_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr));
}
pub inline fn sk_X509_TRUST_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr));
}
pub inline fn sk_X509_TRUST_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr), pnum);
}
pub inline fn sk_X509_TRUST_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_TRUST_sk_type(sk));
}
pub inline fn sk_X509_TRUST_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_TRUST_sk_type(sk));
}
pub const sk_X509_TRUST_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:180:9
pub const sk_X509_TRUST_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/x509_vfy.h:181:9
pub inline fn sk_X509_TRUST_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_TRUST_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_TRUST_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_compfunc_type(cmp)));
}
pub const X509_TRUST_DEFAULT = @as(c_int, 0);
pub const X509_TRUST_COMPAT = @as(c_int, 1);
pub const X509_TRUST_SSL_CLIENT = @as(c_int, 2);
pub const X509_TRUST_SSL_SERVER = @as(c_int, 3);
pub const X509_TRUST_EMAIL = @as(c_int, 4);
pub const X509_TRUST_OBJECT_SIGN = @as(c_int, 5);
pub const X509_TRUST_OCSP_SIGN = @as(c_int, 6);
pub const X509_TRUST_OCSP_REQUEST = @as(c_int, 7);
pub const X509_TRUST_TSA = @as(c_int, 8);
pub const X509_TRUST_MIN = @as(c_int, 1);
pub const X509_TRUST_MAX = @as(c_int, 8);
pub const X509_TRUST_DYNAMIC = @as(c_uint, 1) << @as(c_int, 0);
pub const X509_TRUST_DYNAMIC_NAME = @as(c_uint, 1) << @as(c_int, 1);
pub const X509_TRUST_NO_SS_COMPAT = @as(c_uint, 1) << @as(c_int, 2);
pub const X509_TRUST_DO_SS_COMPAT = @as(c_uint, 1) << @as(c_int, 3);
pub const X509_TRUST_OK_ANY_EKU = @as(c_uint, 1) << @as(c_int, 4);
pub const X509_TRUST_TRUSTED = @as(c_int, 1);
pub const X509_TRUST_REJECTED = @as(c_int, 2);
pub const X509_TRUST_UNTRUSTED = @as(c_int, 3);
pub inline fn X509_STORE_CTX_set_app_data(ctx: anytype, data: anytype) @TypeOf(X509_STORE_CTX_set_ex_data(ctx, @as(c_int, 0), data)) {
    _ = &ctx;
    _ = &data;
    return X509_STORE_CTX_set_ex_data(ctx, @as(c_int, 0), data);
}
pub inline fn X509_STORE_CTX_get_app_data(ctx: anytype) @TypeOf(X509_STORE_CTX_get_ex_data(ctx, @as(c_int, 0))) {
    _ = &ctx;
    return X509_STORE_CTX_get_ex_data(ctx, @as(c_int, 0));
}
pub const X509_L_FILE_LOAD = @as(c_int, 1);
pub const X509_L_ADD_DIR = @as(c_int, 2);
pub const X509_L_ADD_STORE = @as(c_int, 3);
pub const X509_L_LOAD_STORE = @as(c_int, 4);
pub inline fn X509_LOOKUP_load_file(x: anytype, name: anytype, @"type": anytype) @TypeOf(X509_LOOKUP_ctrl(x, X509_L_FILE_LOAD, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL)) {
    _ = &x;
    _ = &name;
    _ = &@"type";
    return X509_LOOKUP_ctrl(x, X509_L_FILE_LOAD, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL);
}
pub inline fn X509_LOOKUP_add_dir(x: anytype, name: anytype, @"type": anytype) @TypeOf(X509_LOOKUP_ctrl(x, X509_L_ADD_DIR, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL)) {
    _ = &x;
    _ = &name;
    _ = &@"type";
    return X509_LOOKUP_ctrl(x, X509_L_ADD_DIR, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL);
}
pub inline fn X509_LOOKUP_add_store(x: anytype, name: anytype) @TypeOf(X509_LOOKUP_ctrl(x, X509_L_ADD_STORE, name, @as(c_int, 0), NULL)) {
    _ = &x;
    _ = &name;
    return X509_LOOKUP_ctrl(x, X509_L_ADD_STORE, name, @as(c_int, 0), NULL);
}
pub inline fn X509_LOOKUP_load_store(x: anytype, name: anytype) @TypeOf(X509_LOOKUP_ctrl(x, X509_L_LOAD_STORE, name, @as(c_int, 0), NULL)) {
    _ = &x;
    _ = &name;
    return X509_LOOKUP_ctrl(x, X509_L_LOAD_STORE, name, @as(c_int, 0), NULL);
}
pub inline fn X509_LOOKUP_load_file_ex(x: anytype, name: anytype, @"type": anytype, libctx: anytype, propq: anytype) @TypeOf(X509_LOOKUP_ctrl_ex(x, X509_L_FILE_LOAD, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL, libctx, propq)) {
    _ = &x;
    _ = &name;
    _ = &@"type";
    _ = &libctx;
    _ = &propq;
    return X509_LOOKUP_ctrl_ex(x, X509_L_FILE_LOAD, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL, libctx, propq);
}
pub inline fn X509_LOOKUP_load_store_ex(x: anytype, name: anytype, libctx: anytype, propq: anytype) @TypeOf(X509_LOOKUP_ctrl_ex(x, X509_L_LOAD_STORE, name, @as(c_int, 0), NULL, libctx, propq)) {
    _ = &x;
    _ = &name;
    _ = &libctx;
    _ = &propq;
    return X509_LOOKUP_ctrl_ex(x, X509_L_LOAD_STORE, name, @as(c_int, 0), NULL, libctx, propq);
}
pub inline fn X509_LOOKUP_add_store_ex(x: anytype, name: anytype, libctx: anytype, propq: anytype) @TypeOf(X509_LOOKUP_ctrl_ex(x, X509_L_ADD_STORE, name, @as(c_int, 0), NULL, libctx, propq)) {
    _ = &x;
    _ = &name;
    _ = &libctx;
    _ = &propq;
    return X509_LOOKUP_ctrl_ex(x, X509_L_ADD_STORE, name, @as(c_int, 0), NULL, libctx, propq);
}
pub const X509_V_OK = @as(c_int, 0);
pub const X509_V_ERR_UNSPECIFIED = @as(c_int, 1);
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT = @as(c_int, 2);
pub const X509_V_ERR_UNABLE_TO_GET_CRL = @as(c_int, 3);
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE = @as(c_int, 4);
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE = @as(c_int, 5);
pub const X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY = @as(c_int, 6);
pub const X509_V_ERR_CERT_SIGNATURE_FAILURE = @as(c_int, 7);
pub const X509_V_ERR_CRL_SIGNATURE_FAILURE = @as(c_int, 8);
pub const X509_V_ERR_CERT_NOT_YET_VALID = @as(c_int, 9);
pub const X509_V_ERR_CERT_HAS_EXPIRED = @as(c_int, 10);
pub const X509_V_ERR_CRL_NOT_YET_VALID = @as(c_int, 11);
pub const X509_V_ERR_CRL_HAS_EXPIRED = @as(c_int, 12);
pub const X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD = @as(c_int, 13);
pub const X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD = @as(c_int, 14);
pub const X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD = @as(c_int, 15);
pub const X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD = @as(c_int, 16);
pub const X509_V_ERR_OUT_OF_MEM = @as(c_int, 17);
pub const X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT = @as(c_int, 18);
pub const X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN = @as(c_int, 19);
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY = @as(c_int, 20);
pub const X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE = @as(c_int, 21);
pub const X509_V_ERR_CERT_CHAIN_TOO_LONG = @as(c_int, 22);
pub const X509_V_ERR_CERT_REVOKED = @as(c_int, 23);
pub const X509_V_ERR_NO_ISSUER_PUBLIC_KEY = @as(c_int, 24);
pub const X509_V_ERR_PATH_LENGTH_EXCEEDED = @as(c_int, 25);
pub const X509_V_ERR_INVALID_PURPOSE = @as(c_int, 26);
pub const X509_V_ERR_CERT_UNTRUSTED = @as(c_int, 27);
pub const X509_V_ERR_CERT_REJECTED = @as(c_int, 28);
pub const X509_V_ERR_SUBJECT_ISSUER_MISMATCH = @as(c_int, 29);
pub const X509_V_ERR_AKID_SKID_MISMATCH = @as(c_int, 30);
pub const X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH = @as(c_int, 31);
pub const X509_V_ERR_KEYUSAGE_NO_CERTSIGN = @as(c_int, 32);
pub const X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER = @as(c_int, 33);
pub const X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION = @as(c_int, 34);
pub const X509_V_ERR_KEYUSAGE_NO_CRL_SIGN = @as(c_int, 35);
pub const X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = @as(c_int, 36);
pub const X509_V_ERR_INVALID_NON_CA = @as(c_int, 37);
pub const X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED = @as(c_int, 38);
pub const X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = @as(c_int, 39);
pub const X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = @as(c_int, 40);
pub const X509_V_ERR_INVALID_EXTENSION = @as(c_int, 41);
pub const X509_V_ERR_INVALID_POLICY_EXTENSION = @as(c_int, 42);
pub const X509_V_ERR_NO_EXPLICIT_POLICY = @as(c_int, 43);
pub const X509_V_ERR_DIFFERENT_CRL_SCOPE = @as(c_int, 44);
pub const X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE = @as(c_int, 45);
pub const X509_V_ERR_UNNESTED_RESOURCE = @as(c_int, 46);
pub const X509_V_ERR_PERMITTED_VIOLATION = @as(c_int, 47);
pub const X509_V_ERR_EXCLUDED_VIOLATION = @as(c_int, 48);
pub const X509_V_ERR_SUBTREE_MINMAX = @as(c_int, 49);
pub const X509_V_ERR_APPLICATION_VERIFICATION = @as(c_int, 50);
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = @as(c_int, 51);
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = @as(c_int, 52);
pub const X509_V_ERR_UNSUPPORTED_NAME_SYNTAX = @as(c_int, 53);
pub const X509_V_ERR_CRL_PATH_VALIDATION_ERROR = @as(c_int, 54);
pub const X509_V_ERR_PATH_LOOP = @as(c_int, 55);
pub const X509_V_ERR_SUITE_B_INVALID_VERSION = @as(c_int, 56);
pub const X509_V_ERR_SUITE_B_INVALID_ALGORITHM = @as(c_int, 57);
pub const X509_V_ERR_SUITE_B_INVALID_CURVE = @as(c_int, 58);
pub const X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = @as(c_int, 59);
pub const X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED = @as(c_int, 60);
pub const X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = @as(c_int, 61);
pub const X509_V_ERR_HOSTNAME_MISMATCH = @as(c_int, 62);
pub const X509_V_ERR_EMAIL_MISMATCH = @as(c_int, 63);
pub const X509_V_ERR_IP_ADDRESS_MISMATCH = @as(c_int, 64);
pub const X509_V_ERR_DANE_NO_MATCH = @as(c_int, 65);
pub const X509_V_ERR_EE_KEY_TOO_SMALL = @as(c_int, 66);
pub const X509_V_ERR_CA_KEY_TOO_SMALL = @as(c_int, 67);
pub const X509_V_ERR_CA_MD_TOO_WEAK = @as(c_int, 68);
pub const X509_V_ERR_INVALID_CALL = @as(c_int, 69);
pub const X509_V_ERR_STORE_LOOKUP = @as(c_int, 70);
pub const X509_V_ERR_NO_VALID_SCTS = @as(c_int, 71);
pub const X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION = @as(c_int, 72);
pub const X509_V_ERR_OCSP_VERIFY_NEEDED = @as(c_int, 73);
pub const X509_V_ERR_OCSP_VERIFY_FAILED = @as(c_int, 74);
pub const X509_V_ERR_OCSP_CERT_UNKNOWN = @as(c_int, 75);
pub const X509_V_ERR_UNSUPPORTED_SIGNATURE_ALGORITHM = @as(c_int, 76);
pub const X509_V_ERR_SIGNATURE_ALGORITHM_MISMATCH = @as(c_int, 77);
pub const X509_V_ERR_SIGNATURE_ALGORITHM_INCONSISTENCY = @as(c_int, 78);
pub const X509_V_ERR_INVALID_CA = @as(c_int, 79);
pub const X509_V_ERR_PATHLEN_INVALID_FOR_NON_CA = @as(c_int, 80);
pub const X509_V_ERR_PATHLEN_WITHOUT_KU_KEY_CERT_SIGN = @as(c_int, 81);
pub const X509_V_ERR_KU_KEY_CERT_SIGN_INVALID_FOR_NON_CA = @as(c_int, 82);
pub const X509_V_ERR_ISSUER_NAME_EMPTY = @as(c_int, 83);
pub const X509_V_ERR_SUBJECT_NAME_EMPTY = @as(c_int, 84);
pub const X509_V_ERR_MISSING_AUTHORITY_KEY_IDENTIFIER = @as(c_int, 85);
pub const X509_V_ERR_MISSING_SUBJECT_KEY_IDENTIFIER = @as(c_int, 86);
pub const X509_V_ERR_EMPTY_SUBJECT_ALT_NAME = @as(c_int, 87);
pub const X509_V_ERR_EMPTY_SUBJECT_SAN_NOT_CRITICAL = @as(c_int, 88);
pub const X509_V_ERR_CA_BCONS_NOT_CRITICAL = @as(c_int, 89);
pub const X509_V_ERR_AUTHORITY_KEY_IDENTIFIER_CRITICAL = @as(c_int, 90);
pub const X509_V_ERR_SUBJECT_KEY_IDENTIFIER_CRITICAL = @as(c_int, 91);
pub const X509_V_ERR_CA_CERT_MISSING_KEY_USAGE = @as(c_int, 92);
pub const X509_V_ERR_EXTENSIONS_REQUIRE_VERSION_3 = @as(c_int, 93);
pub const X509_V_ERR_EC_KEY_EXPLICIT_PARAMS = @as(c_int, 94);
pub const X509_V_ERR_RPK_UNTRUSTED = @as(c_int, 95);
pub const X509_V_FLAG_CB_ISSUER_CHECK = @as(c_int, 0x0);
pub const X509_V_FLAG_USE_CHECK_TIME = @as(c_int, 0x2);
pub const X509_V_FLAG_CRL_CHECK = @as(c_int, 0x4);
pub const X509_V_FLAG_CRL_CHECK_ALL = @as(c_int, 0x8);
pub const X509_V_FLAG_IGNORE_CRITICAL = @as(c_int, 0x10);
pub const X509_V_FLAG_X509_STRICT = @as(c_int, 0x20);
pub const X509_V_FLAG_ALLOW_PROXY_CERTS = @as(c_int, 0x40);
pub const X509_V_FLAG_POLICY_CHECK = @as(c_int, 0x80);
pub const X509_V_FLAG_EXPLICIT_POLICY = @as(c_int, 0x100);
pub const X509_V_FLAG_INHIBIT_ANY = @as(c_int, 0x200);
pub const X509_V_FLAG_INHIBIT_MAP = @as(c_int, 0x400);
pub const X509_V_FLAG_NOTIFY_POLICY = @as(c_int, 0x800);
pub const X509_V_FLAG_EXTENDED_CRL_SUPPORT = @as(c_int, 0x1000);
pub const X509_V_FLAG_USE_DELTAS = @as(c_int, 0x2000);
pub const X509_V_FLAG_CHECK_SS_SIGNATURE = @as(c_int, 0x4000);
pub const X509_V_FLAG_TRUSTED_FIRST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const X509_V_FLAG_SUITEB_128_LOS_ONLY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const X509_V_FLAG_SUITEB_192_LOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000, .hex);
pub const X509_V_FLAG_SUITEB_128_LOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x30000, .hex);
pub const X509_V_FLAG_PARTIAL_CHAIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000, .hex);
pub const X509_V_FLAG_NO_ALT_CHAINS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100000, .hex);
pub const X509_V_FLAG_NO_CHECK_TIME = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x200000, .hex);
pub const X509_VP_FLAG_DEFAULT = @as(c_int, 0x1);
pub const X509_VP_FLAG_OVERWRITE = @as(c_int, 0x2);
pub const X509_VP_FLAG_RESET_FLAGS = @as(c_int, 0x4);
pub const X509_VP_FLAG_LOCKED = @as(c_int, 0x8);
pub const X509_VP_FLAG_ONCE = @as(c_int, 0x10);
pub const X509_V_FLAG_POLICY_MASK = ((X509_V_FLAG_POLICY_CHECK | X509_V_FLAG_EXPLICIT_POLICY) | X509_V_FLAG_INHIBIT_ANY) | X509_V_FLAG_INHIBIT_MAP;
pub inline fn X509_STORE_set_verify_func(ctx: anytype, func: anytype) @TypeOf(X509_STORE_set_verify(ctx, func)) {
    _ = &ctx;
    _ = &func;
    return X509_STORE_set_verify(ctx, func);
}
pub inline fn X509_STORE_set_verify_cb_func(ctx: anytype, func: anytype) @TypeOf(X509_STORE_set_verify_cb(ctx, func)) {
    _ = &ctx;
    _ = &func;
    return X509_STORE_set_verify_cb(ctx, func);
}
pub inline fn X509_STORE_set_lookup_crls_cb(ctx: anytype, func: anytype) @TypeOf(X509_STORE_set_lookup_crls(ctx, func)) {
    _ = &ctx;
    _ = &func;
    return X509_STORE_set_lookup_crls(ctx, func);
}
pub inline fn X509_STORE_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE, l, p, newf, dupf, freef);
}
pub const X509_STORE_CTX_get_chain = X509_STORE_CTX_get0_chain;
pub const X509_STORE_CTX_set_chain = X509_STORE_CTX_set0_untrusted;
pub const X509_STORE_CTX_trusted_stack = X509_STORE_CTX_set0_trusted_stack;
pub const X509_STORE_get_by_subject = X509_STORE_CTX_get_by_subject;
pub const X509_STORE_get1_certs = X509_STORE_CTX_get1_certs;
pub const X509_STORE_get1_crls = X509_STORE_CTX_get1_crls;
pub const X509_STORE_get1_cert = X509_STORE_CTX_get1_certs;
pub const X509_STORE_get1_crl = X509_STORE_CTX_get1_crls;
pub inline fn X509_STORE_CTX_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, l, p, newf, dupf, freef);
}
pub const DANE_FLAG_NO_DANE_EE_NAMECHECKS = @as(c_long, 1) << @as(c_int, 0);
pub const X509_PCY_TREE_FAILURE = -@as(c_int, 2);
pub const X509_PCY_TREE_INVALID = -@as(c_int, 1);
pub const X509_PCY_TREE_INTERNAL = @as(c_int, 0);
pub const X509_PCY_TREE_VALID = @as(c_int, 1);
pub const X509_PCY_TREE_EMPTY = @as(c_int, 2);
pub const X509_PCY_TREE_EXPLICIT = @as(c_int, 4);
pub const OPENSSL_PKCS7_H = "";
pub const HEADER_PKCS7_H = "";
pub const OPENSSL_PKCS7ERR_H = "";
pub const PKCS7_R_CERTIFICATE_VERIFY_ERROR = @as(c_int, 117);
pub const PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER = @as(c_int, 144);
pub const PKCS7_R_CIPHER_NOT_INITIALIZED = @as(c_int, 116);
pub const PKCS7_R_CONTENT_AND_DATA_PRESENT = @as(c_int, 118);
pub const PKCS7_R_CTRL_ERROR = @as(c_int, 152);
pub const PKCS7_R_DECRYPT_ERROR = @as(c_int, 119);
pub const PKCS7_R_DIGEST_FAILURE = @as(c_int, 101);
pub const PKCS7_R_ENCRYPTION_CTRL_FAILURE = @as(c_int, 149);
pub const PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE = @as(c_int, 150);
pub const PKCS7_R_ERROR_ADDING_RECIPIENT = @as(c_int, 120);
pub const PKCS7_R_ERROR_SETTING_CIPHER = @as(c_int, 121);
pub const PKCS7_R_INVALID_NULL_POINTER = @as(c_int, 143);
pub const PKCS7_R_INVALID_SIGNED_DATA_TYPE = @as(c_int, 155);
pub const PKCS7_R_NO_CONTENT = @as(c_int, 122);
pub const PKCS7_R_NO_DEFAULT_DIGEST = @as(c_int, 151);
pub const PKCS7_R_NO_MATCHING_DIGEST_TYPE_FOUND = @as(c_int, 154);
pub const PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE = @as(c_int, 115);
pub const PKCS7_R_NO_SIGNATURES_ON_DATA = @as(c_int, 123);
pub const PKCS7_R_NO_SIGNERS = @as(c_int, 142);
pub const PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE = @as(c_int, 104);
pub const PKCS7_R_PKCS7_ADD_SIGNATURE_ERROR = @as(c_int, 124);
pub const PKCS7_R_PKCS7_ADD_SIGNER_ERROR = @as(c_int, 153);
pub const PKCS7_R_PKCS7_DATASIGN = @as(c_int, 145);
pub const PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE = @as(c_int, 127);
pub const PKCS7_R_SIGNATURE_FAILURE = @as(c_int, 105);
pub const PKCS7_R_SIGNER_CERTIFICATE_NOT_FOUND = @as(c_int, 128);
pub const PKCS7_R_SIGNING_CTRL_FAILURE = @as(c_int, 147);
pub const PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE = @as(c_int, 148);
pub const PKCS7_R_SMIME_TEXT_ERROR = @as(c_int, 129);
pub const PKCS7_R_UNABLE_TO_FIND_CERTIFICATE = @as(c_int, 106);
pub const PKCS7_R_UNABLE_TO_FIND_MEM_BIO = @as(c_int, 107);
pub const PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST = @as(c_int, 108);
pub const PKCS7_R_UNKNOWN_DIGEST_TYPE = @as(c_int, 109);
pub const PKCS7_R_UNKNOWN_OPERATION = @as(c_int, 110);
pub const PKCS7_R_UNSUPPORTED_CIPHER_TYPE = @as(c_int, 111);
pub const PKCS7_R_UNSUPPORTED_CONTENT_TYPE = @as(c_int, 112);
pub const PKCS7_R_WRONG_CONTENT_TYPE = @as(c_int, 113);
pub const PKCS7_R_WRONG_PKCS7_TYPE = @as(c_int, 114);
pub inline fn sk_PKCS7_SIGNER_INFO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_SIGNER_INFO_value(sk: anytype, idx: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_value(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk), idx));
}
pub const sk_PKCS7_SIGNER_INFO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:72:9
pub const sk_PKCS7_SIGNER_INFO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:73:9
pub const sk_PKCS7_SIGNER_INFO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:74:9
pub inline fn sk_PKCS7_SIGNER_INFO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), n);
}
pub inline fn sk_PKCS7_SIGNER_INFO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_SIGNER_INFO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_SIGNER_INFO_delete(sk: anytype, i: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_delete(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), i));
}
pub inline fn sk_PKCS7_SIGNER_INFO_delete_ptr(sk: anytype, ptr: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_delete_ptr(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr)));
}
pub inline fn sk_PKCS7_SIGNER_INFO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr));
}
pub inline fn sk_PKCS7_SIGNER_INFO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr));
}
pub inline fn sk_PKCS7_SIGNER_INFO_pop(sk: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_pop(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk)));
}
pub inline fn sk_PKCS7_SIGNER_INFO_shift(sk: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_shift(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk)));
}
pub inline fn sk_PKCS7_SIGNER_INFO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_freefunc_type(freefunc));
}
pub inline fn sk_PKCS7_SIGNER_INFO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr), idx);
}
pub inline fn sk_PKCS7_SIGNER_INFO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_set(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), idx, ossl_check_PKCS7_SIGNER_INFO_type(ptr)));
}
pub inline fn sk_PKCS7_SIGNER_INFO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr));
}
pub inline fn sk_PKCS7_SIGNER_INFO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr));
}
pub inline fn sk_PKCS7_SIGNER_INFO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr), pnum);
}
pub inline fn sk_PKCS7_SIGNER_INFO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_SIGNER_INFO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub const sk_PKCS7_SIGNER_INFO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:92:9
pub const sk_PKCS7_SIGNER_INFO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:93:9
pub inline fn sk_PKCS7_SIGNER_INFO_set_cmp_func(sk: anytype, cmp: anytype) sk_PKCS7_SIGNER_INFO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_PKCS7_SIGNER_INFO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_compfunc_type(cmp)));
}
pub inline fn sk_PKCS7_RECIP_INFO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_RECIP_INFO_value(sk: anytype, idx: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_value(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk), idx));
}
pub const sk_PKCS7_RECIP_INFO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:108:9
pub const sk_PKCS7_RECIP_INFO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:109:9
pub const sk_PKCS7_RECIP_INFO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:110:9
pub inline fn sk_PKCS7_RECIP_INFO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), n);
}
pub inline fn sk_PKCS7_RECIP_INFO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_PKCS7_RECIP_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_RECIP_INFO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_PKCS7_RECIP_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_RECIP_INFO_delete(sk: anytype, i: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_delete(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), i));
}
pub inline fn sk_PKCS7_RECIP_INFO_delete_ptr(sk: anytype, ptr: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_delete_ptr(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr)));
}
pub inline fn sk_PKCS7_RECIP_INFO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr));
}
pub inline fn sk_PKCS7_RECIP_INFO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr));
}
pub inline fn sk_PKCS7_RECIP_INFO_pop(sk: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_pop(ossl_check_PKCS7_RECIP_INFO_sk_type(sk)));
}
pub inline fn sk_PKCS7_RECIP_INFO_shift(sk: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_shift(ossl_check_PKCS7_RECIP_INFO_sk_type(sk)));
}
pub inline fn sk_PKCS7_RECIP_INFO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_freefunc_type(freefunc));
}
pub inline fn sk_PKCS7_RECIP_INFO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr), idx);
}
pub inline fn sk_PKCS7_RECIP_INFO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_set(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), idx, ossl_check_PKCS7_RECIP_INFO_type(ptr)));
}
pub inline fn sk_PKCS7_RECIP_INFO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr));
}
pub inline fn sk_PKCS7_RECIP_INFO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr));
}
pub inline fn sk_PKCS7_RECIP_INFO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr), pnum);
}
pub inline fn sk_PKCS7_RECIP_INFO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_PKCS7_RECIP_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_RECIP_INFO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk));
}
pub const sk_PKCS7_RECIP_INFO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:128:9
pub const sk_PKCS7_RECIP_INFO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:129:9
pub inline fn sk_PKCS7_RECIP_INFO_set_cmp_func(sk: anytype, cmp: anytype) sk_PKCS7_RECIP_INFO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_PKCS7_RECIP_INFO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_compfunc_type(cmp)));
}
pub const PKCS7_S_HEADER = @as(c_int, 0);
pub const PKCS7_S_BODY = @as(c_int, 1);
pub const PKCS7_S_TAIL = @as(c_int, 2);
pub inline fn sk_PKCS7_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_PKCS7_sk_type(sk));
}
pub inline fn sk_PKCS7_value(sk: anytype, idx: anytype) [*c]PKCS7 {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_value(ossl_check_const_PKCS7_sk_type(sk), idx));
}
pub const sk_PKCS7_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:223:9
pub const sk_PKCS7_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:224:9
pub const sk_PKCS7_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:225:9
pub inline fn sk_PKCS7_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_PKCS7_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_PKCS7_sk_type(sk), n);
}
pub inline fn sk_PKCS7_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_PKCS7_sk_type(sk));
}
pub inline fn sk_PKCS7_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_PKCS7_sk_type(sk));
}
pub inline fn sk_PKCS7_delete(sk: anytype, i: anytype) [*c]PKCS7 {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_delete(ossl_check_PKCS7_sk_type(sk), i));
}
pub inline fn sk_PKCS7_delete_ptr(sk: anytype, ptr: anytype) [*c]PKCS7 {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_delete_ptr(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr)));
}
pub inline fn sk_PKCS7_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr));
}
pub inline fn sk_PKCS7_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr));
}
pub inline fn sk_PKCS7_pop(sk: anytype) [*c]PKCS7 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_pop(ossl_check_PKCS7_sk_type(sk)));
}
pub inline fn sk_PKCS7_shift(sk: anytype) [*c]PKCS7 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_shift(ossl_check_PKCS7_sk_type(sk)));
}
pub inline fn sk_PKCS7_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_freefunc_type(freefunc));
}
pub inline fn sk_PKCS7_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr), idx);
}
pub inline fn sk_PKCS7_set(sk: anytype, idx: anytype, ptr: anytype) [*c]PKCS7 {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_set(ossl_check_PKCS7_sk_type(sk), idx, ossl_check_PKCS7_type(ptr)));
}
pub inline fn sk_PKCS7_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr));
}
pub inline fn sk_PKCS7_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr));
}
pub inline fn sk_PKCS7_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr), pnum);
}
pub inline fn sk_PKCS7_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_PKCS7_sk_type(sk));
}
pub inline fn sk_PKCS7_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_sk_type(sk));
}
pub const sk_PKCS7_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:243:9
pub const sk_PKCS7_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/pkcs7.h:244:9
pub inline fn sk_PKCS7_set_cmp_func(sk: anytype, cmp: anytype) sk_PKCS7_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_PKCS7_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_compfunc_type(cmp)));
}
pub const PKCS7_OP_SET_DETACHED_SIGNATURE = @as(c_int, 1);
pub const PKCS7_OP_GET_DETACHED_SIGNATURE = @as(c_int, 2);
pub inline fn PKCS7_get_signed_attributes(si: anytype) @TypeOf(si.*.auth_attr) {
    _ = &si;
    return si.*.auth_attr;
}
pub inline fn PKCS7_get_attributes(si: anytype) @TypeOf(si.*.unauth_attr) {
    _ = &si;
    return si.*.unauth_attr;
}
pub inline fn PKCS7_type_is_signed(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_signed) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_signed;
}
pub inline fn PKCS7_type_is_encrypted(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_encrypted) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_encrypted;
}
pub inline fn PKCS7_type_is_enveloped(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_enveloped) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_enveloped;
}
pub inline fn PKCS7_type_is_signedAndEnveloped(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_signedAndEnveloped) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_signedAndEnveloped;
}
pub inline fn PKCS7_type_is_data(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_data) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_data;
}
pub inline fn PKCS7_type_is_digest(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_digest) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_digest;
}
pub inline fn PKCS7_set_detached(p: anytype, v: anytype) @TypeOf(PKCS7_ctrl(p, PKCS7_OP_SET_DETACHED_SIGNATURE, v, NULL)) {
    _ = &p;
    _ = &v;
    return PKCS7_ctrl(p, PKCS7_OP_SET_DETACHED_SIGNATURE, v, NULL);
}
pub inline fn PKCS7_get_detached(p: anytype) @TypeOf(PKCS7_ctrl(p, PKCS7_OP_GET_DETACHED_SIGNATURE, @as(c_int, 0), NULL)) {
    _ = &p;
    return PKCS7_ctrl(p, PKCS7_OP_GET_DETACHED_SIGNATURE, @as(c_int, 0), NULL);
}
pub inline fn PKCS7_is_detached(p7: anytype) @TypeOf((PKCS7_type_is_signed(p7) != 0) and (PKCS7_get_detached(p7) != 0)) {
    _ = &p7;
    return (PKCS7_type_is_signed(p7) != 0) and (PKCS7_get_detached(p7) != 0);
}
pub const PKCS7_TEXT = @as(c_int, 0x1);
pub const PKCS7_NOCERTS = @as(c_int, 0x2);
pub const PKCS7_NOSIGS = @as(c_int, 0x4);
pub const PKCS7_NOCHAIN = @as(c_int, 0x8);
pub const PKCS7_NOINTERN = @as(c_int, 0x10);
pub const PKCS7_NOVERIFY = @as(c_int, 0x20);
pub const PKCS7_DETACHED = @as(c_int, 0x40);
pub const PKCS7_BINARY = @as(c_int, 0x80);
pub const PKCS7_NOATTR = @as(c_int, 0x100);
pub const PKCS7_NOSMIMECAP = @as(c_int, 0x200);
pub const PKCS7_NOOLDMIMETYPE = @as(c_int, 0x400);
pub const PKCS7_CRLFEOL = @as(c_int, 0x800);
pub const PKCS7_STREAM = @as(c_int, 0x1000);
pub const PKCS7_NOCRL = @as(c_int, 0x2000);
pub const PKCS7_PARTIAL = @as(c_int, 0x4000);
pub const PKCS7_REUSE_DIGEST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const PKCS7_NO_DUAL_CONTENT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const SMIME_TEXT = PKCS7_TEXT;
pub const SMIME_NOCERTS = PKCS7_NOCERTS;
pub const SMIME_NOSIGS = PKCS7_NOSIGS;
pub const SMIME_NOCHAIN = PKCS7_NOCHAIN;
pub const SMIME_NOINTERN = PKCS7_NOINTERN;
pub const SMIME_NOVERIFY = PKCS7_NOVERIFY;
pub const SMIME_DETACHED = PKCS7_DETACHED;
pub const SMIME_BINARY = PKCS7_BINARY;
pub const SMIME_NOATTR = PKCS7_NOATTR;
pub const SMIME_ASCIICRLF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000, .hex);
pub const X509_EXT_PACK_UNKNOWN = @as(c_int, 1);
pub const X509_EXT_PACK_STRING = @as(c_int, 2);
pub inline fn X509_extract_key(x: anytype) @TypeOf(X509_get_pubkey(x)) {
    _ = &x;
    return X509_get_pubkey(x);
}
pub inline fn X509_REQ_extract_key(a: anytype) @TypeOf(X509_REQ_get_pubkey(a)) {
    _ = &a;
    return X509_REQ_get_pubkey(a);
}
pub inline fn X509_name_cmp(a: anytype, b: anytype) @TypeOf(X509_NAME_cmp(a, b)) {
    _ = &a;
    _ = &b;
    return X509_NAME_cmp(a, b);
}
pub const OPENSSL_HTTP_H = "";
pub const OPENSSL_CONF_H = "";
pub const HEADER_CONF_H = "";
pub const OPENSSL_CONFERR_H = "";
pub const CONF_R_ERROR_LOADING_DSO = @as(c_int, 110);
pub const CONF_R_INVALID_PRAGMA = @as(c_int, 122);
pub const CONF_R_LIST_CANNOT_BE_NULL = @as(c_int, 115);
pub const CONF_R_MANDATORY_BRACES_IN_VARIABLE_EXPANSION = @as(c_int, 123);
pub const CONF_R_MISSING_CLOSE_SQUARE_BRACKET = @as(c_int, 100);
pub const CONF_R_MISSING_EQUAL_SIGN = @as(c_int, 101);
pub const CONF_R_MISSING_INIT_FUNCTION = @as(c_int, 112);
pub const CONF_R_MODULE_INITIALIZATION_ERROR = @as(c_int, 109);
pub const CONF_R_NO_CLOSE_BRACE = @as(c_int, 102);
pub const CONF_R_NO_CONF = @as(c_int, 105);
pub const CONF_R_NO_CONF_OR_ENVIRONMENT_VARIABLE = @as(c_int, 106);
pub const CONF_R_NO_SECTION = @as(c_int, 107);
pub const CONF_R_NO_SUCH_FILE = @as(c_int, 114);
pub const CONF_R_NO_VALUE = @as(c_int, 108);
pub const CONF_R_NUMBER_TOO_LARGE = @as(c_int, 121);
pub const CONF_R_OPENSSL_CONF_REFERENCES_MISSING_SECTION = @as(c_int, 124);
pub const CONF_R_RECURSIVE_DIRECTORY_INCLUDE = @as(c_int, 111);
pub const CONF_R_RECURSIVE_SECTION_REFERENCE = @as(c_int, 126);
pub const CONF_R_RELATIVE_PATH = @as(c_int, 125);
pub const CONF_R_SSL_COMMAND_SECTION_EMPTY = @as(c_int, 117);
pub const CONF_R_SSL_COMMAND_SECTION_NOT_FOUND = @as(c_int, 118);
pub const CONF_R_SSL_SECTION_EMPTY = @as(c_int, 119);
pub const CONF_R_SSL_SECTION_NOT_FOUND = @as(c_int, 120);
pub const CONF_R_UNABLE_TO_CREATE_NEW_SECTION = @as(c_int, 103);
pub const CONF_R_UNKNOWN_MODULE_NAME = @as(c_int, 113);
pub const CONF_R_VARIABLE_EXPANSION_TOO_LONG = @as(c_int, 116);
pub const CONF_R_VARIABLE_HAS_NO_VALUE = @as(c_int, 104);
pub inline fn sk_CONF_VALUE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_CONF_VALUE_sk_type(sk));
}
pub inline fn sk_CONF_VALUE_value(sk: anytype, idx: anytype) [*c]CONF_VALUE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_value(ossl_check_const_CONF_VALUE_sk_type(sk), idx));
}
pub const sk_CONF_VALUE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/conf.h:47:9
pub const sk_CONF_VALUE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/conf.h:48:9
pub const sk_CONF_VALUE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/conf.h:49:9
pub inline fn sk_CONF_VALUE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_CONF_VALUE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_CONF_VALUE_sk_type(sk), n);
}
pub inline fn sk_CONF_VALUE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_CONF_VALUE_sk_type(sk));
}
pub inline fn sk_CONF_VALUE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_CONF_VALUE_sk_type(sk));
}
pub inline fn sk_CONF_VALUE_delete(sk: anytype, i: anytype) [*c]CONF_VALUE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_delete(ossl_check_CONF_VALUE_sk_type(sk), i));
}
pub inline fn sk_CONF_VALUE_delete_ptr(sk: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_delete_ptr(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr)));
}
pub inline fn sk_CONF_VALUE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr));
}
pub inline fn sk_CONF_VALUE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr));
}
pub inline fn sk_CONF_VALUE_pop(sk: anytype) [*c]CONF_VALUE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_pop(ossl_check_CONF_VALUE_sk_type(sk)));
}
pub inline fn sk_CONF_VALUE_shift(sk: anytype) [*c]CONF_VALUE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_shift(ossl_check_CONF_VALUE_sk_type(sk)));
}
pub inline fn sk_CONF_VALUE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_freefunc_type(freefunc));
}
pub inline fn sk_CONF_VALUE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr), idx);
}
pub inline fn sk_CONF_VALUE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_set(ossl_check_CONF_VALUE_sk_type(sk), idx, ossl_check_CONF_VALUE_type(ptr)));
}
pub inline fn sk_CONF_VALUE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr));
}
pub inline fn sk_CONF_VALUE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr));
}
pub inline fn sk_CONF_VALUE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr), pnum);
}
pub inline fn sk_CONF_VALUE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_CONF_VALUE_sk_type(sk));
}
pub inline fn sk_CONF_VALUE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_CONF_VALUE_sk_type(sk));
}
pub const sk_CONF_VALUE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/conf.h:67:9
pub const sk_CONF_VALUE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/conf.h:68:9
pub inline fn sk_CONF_VALUE_set_cmp_func(sk: anytype, cmp: anytype) sk_CONF_VALUE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_CONF_VALUE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_compfunc_type(cmp)));
}
pub const lh_CONF_VALUE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/conf.h:71:9
pub inline fn lh_CONF_VALUE_free(lh: anytype) @TypeOf(OPENSSL_LH_free(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_free(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_flush(lh: anytype) @TypeOf(OPENSSL_LH_flush(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_flush(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_insert(lh: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_LH_insert(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_CONF_VALUE_lh_plain_type(ptr)));
}
pub inline fn lh_CONF_VALUE_delete(lh: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_LH_delete(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_const_CONF_VALUE_lh_plain_type(ptr)));
}
pub inline fn lh_CONF_VALUE_retrieve(lh: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_LH_retrieve(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_const_CONF_VALUE_lh_plain_type(ptr)));
}
pub inline fn lh_CONF_VALUE_error(lh: anytype) @TypeOf(OPENSSL_LH_error(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_error(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_num_items(lh: anytype) @TypeOf(OPENSSL_LH_num_items(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_num_items(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_node_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out);
}
pub inline fn lh_CONF_VALUE_node_usage_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_usage_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_usage_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out);
}
pub inline fn lh_CONF_VALUE_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out);
}
pub inline fn lh_CONF_VALUE_get_down_load(lh: anytype) @TypeOf(OPENSSL_LH_get_down_load(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_get_down_load(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_set_down_load(lh: anytype, dl: anytype) @TypeOf(OPENSSL_LH_set_down_load(ossl_check_CONF_VALUE_lh_type(lh), dl)) {
    _ = &lh;
    _ = &dl;
    return OPENSSL_LH_set_down_load(ossl_check_CONF_VALUE_lh_type(lh), dl);
}
pub inline fn lh_CONF_VALUE_doall(lh: anytype, dfn: anytype) @TypeOf(OPENSSL_LH_doall(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_CONF_VALUE_lh_doallfunc_type(dfn))) {
    _ = &lh;
    _ = &dfn;
    return OPENSSL_LH_doall(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_CONF_VALUE_lh_doallfunc_type(dfn));
}
pub const OPENSSL_CONFTYPES_H = "";
pub const CONF_MFLAGS_IGNORE_ERRORS = @as(c_int, 0x1);
pub const CONF_MFLAGS_IGNORE_RETURN_CODES = @as(c_int, 0x2);
pub const CONF_MFLAGS_SILENT = @as(c_int, 0x4);
pub const CONF_MFLAGS_NO_DSO = @as(c_int, 0x8);
pub const CONF_MFLAGS_IGNORE_MISSING_FILE = @as(c_int, 0x10);
pub const CONF_MFLAGS_DEFAULT_SECTION = @as(c_int, 0x20);
pub inline fn OPENSSL_no_config() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_NO_LOAD_CONFIG, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_NO_LOAD_CONFIG, NULL);
}
pub inline fn NCONF_get_number(c: anytype, g: anytype, n: anytype, r: anytype) @TypeOf(NCONF_get_number_e(c, g, n, r)) {
    _ = &c;
    _ = &g;
    _ = &n;
    _ = &r;
    return NCONF_get_number_e(c, g, n, r);
}
pub const CONF_modules_free = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/conf.h:187:10
pub const OSSL_HTTP_NAME = "http";
pub const OSSL_HTTPS_NAME = "https";
pub const OSSL_HTTP_PREFIX = OSSL_HTTP_NAME ++ "://";
pub const OSSL_HTTPS_PREFIX = OSSL_HTTPS_NAME ++ "://";
pub const OSSL_HTTP_PORT = "80";
pub const OSSL_HTTPS_PORT = "443";
pub const OPENSSL_NO_PROXY = "NO_PROXY";
pub const OPENSSL_HTTP_PROXY = "HTTP_PROXY";
pub const OPENSSL_HTTPS_PROXY = "HTTPS_PROXY";
pub const OSSL_HTTP_DEFAULT_MAX_LINE_LEN = @as(c_int, 4) * @as(c_int, 1024);
pub const OSSL_HTTP_DEFAULT_MAX_RESP_LEN = @as(c_int, 100) * @as(c_int, 1024);
pub const OSSL_HTTP_DEFAULT_MAX_CRL_LEN = (@as(c_int, 32) * @as(c_int, 1024)) * @as(c_int, 1024);
pub const OSSL_HTTP_DEFAULT_MAX_RESP_HDR_LINES = @as(c_int, 256);
pub inline fn X509_http_nbio(rctx: anytype, pcert: anytype) @TypeOf(OSSL_HTTP_REQ_CTX_nbio_d2i(rctx, pcert, ASN1_ITEM_rptr(X509))) {
    _ = &rctx;
    _ = &pcert;
    return OSSL_HTTP_REQ_CTX_nbio_d2i(rctx, pcert, ASN1_ITEM_rptr(X509));
}
pub inline fn X509_CRL_http_nbio(rctx: anytype, pcrl: anytype) @TypeOf(OSSL_HTTP_REQ_CTX_nbio_d2i(rctx, pcrl, ASN1_ITEM_rptr(X509_CRL))) {
    _ = &rctx;
    _ = &pcrl;
    return OSSL_HTTP_REQ_CTX_nbio_d2i(rctx, pcrl, ASN1_ITEM_rptr(X509_CRL));
}
pub inline fn X509_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509, l, p, newf, dupf, freef);
}
pub const X509_VERSION_1 = @as(c_int, 0);
pub const X509_VERSION_2 = @as(c_int, 1);
pub const X509_VERSION_3 = @as(c_int, 2);
pub const X509_get_notBefore = X509_getm_notBefore;
pub const X509_get_notAfter = X509_getm_notAfter;
pub const X509_set_notBefore = X509_set1_notBefore;
pub const X509_set_notAfter = X509_set1_notAfter;
pub const X509_REQ_VERSION_1 = @as(c_int, 0);
pub const X509_CRL_VERSION_1 = @as(c_int, 0);
pub const X509_CRL_VERSION_2 = @as(c_int, 1);
pub const X509_CRL_set_lastUpdate = X509_CRL_set1_lastUpdate;
pub const X509_CRL_set_nextUpdate = X509_CRL_set1_nextUpdate;
pub const X509_ADD_FLAG_DEFAULT = @as(c_int, 0);
pub const X509_ADD_FLAG_UP_REF = @as(c_int, 0x1);
pub const X509_ADD_FLAG_PREPEND = @as(c_int, 0x2);
pub const X509_ADD_FLAG_NO_DUP = @as(c_int, 0x4);
pub const X509_ADD_FLAG_NO_SS = @as(c_int, 0x8);
pub inline fn X509_NAME_hash(x: anytype) @TypeOf(X509_NAME_hash_ex(x, NULL, NULL, NULL)) {
    _ = &x;
    return X509_NAME_hash_ex(x, NULL, NULL, NULL);
}
pub const OPENSSL_PEM_H = "";
pub const HEADER_PEM_H = "";
pub const OPENSSL_PEMERR_H = "";
pub const PEM_R_BAD_BASE64_DECODE = @as(c_int, 100);
pub const PEM_R_BAD_DECRYPT = @as(c_int, 101);
pub const PEM_R_BAD_END_LINE = @as(c_int, 102);
pub const PEM_R_BAD_IV_CHARS = @as(c_int, 103);
pub const PEM_R_BAD_MAGIC_NUMBER = @as(c_int, 116);
pub const PEM_R_BAD_PASSWORD_READ = @as(c_int, 104);
pub const PEM_R_BAD_VERSION_NUMBER = @as(c_int, 117);
pub const PEM_R_BIO_WRITE_FAILURE = @as(c_int, 118);
pub const PEM_R_CIPHER_IS_NULL = @as(c_int, 127);
pub const PEM_R_ERROR_CONVERTING_PRIVATE_KEY = @as(c_int, 115);
pub const PEM_R_EXPECTING_DSS_KEY_BLOB = @as(c_int, 131);
pub const PEM_R_EXPECTING_PRIVATE_KEY_BLOB = @as(c_int, 119);
pub const PEM_R_EXPECTING_PUBLIC_KEY_BLOB = @as(c_int, 120);
pub const PEM_R_EXPECTING_RSA_KEY_BLOB = @as(c_int, 132);
pub const PEM_R_HEADER_TOO_LONG = @as(c_int, 128);
pub const PEM_R_INCONSISTENT_HEADER = @as(c_int, 121);
pub const PEM_R_KEYBLOB_HEADER_PARSE_ERROR = @as(c_int, 122);
pub const PEM_R_KEYBLOB_TOO_SHORT = @as(c_int, 123);
pub const PEM_R_MISSING_DEK_IV = @as(c_int, 129);
pub const PEM_R_NOT_DEK_INFO = @as(c_int, 105);
pub const PEM_R_NOT_ENCRYPTED = @as(c_int, 106);
pub const PEM_R_NOT_PROC_TYPE = @as(c_int, 107);
pub const PEM_R_NO_START_LINE = @as(c_int, 108);
pub const PEM_R_PROBLEMS_GETTING_PASSWORD = @as(c_int, 109);
pub const PEM_R_PVK_DATA_TOO_SHORT = @as(c_int, 124);
pub const PEM_R_PVK_TOO_SHORT = @as(c_int, 125);
pub const PEM_R_READ_KEY = @as(c_int, 111);
pub const PEM_R_SHORT_HEADER = @as(c_int, 112);
pub const PEM_R_UNEXPECTED_DEK_IV = @as(c_int, 130);
pub const PEM_R_UNSUPPORTED_CIPHER = @as(c_int, 113);
pub const PEM_R_UNSUPPORTED_ENCRYPTION = @as(c_int, 114);
pub const PEM_R_UNSUPPORTED_KEY_COMPONENTS = @as(c_int, 126);
pub const PEM_R_UNSUPPORTED_PUBLIC_KEY_TYPE = @as(c_int, 110);
pub const PEM_BUFSIZE = @as(c_int, 1024);
pub const PEM_STRING_X509_OLD = "X509 CERTIFICATE";
pub const PEM_STRING_X509 = "CERTIFICATE";
pub const PEM_STRING_X509_TRUSTED = "TRUSTED CERTIFICATE";
pub const PEM_STRING_X509_REQ_OLD = "NEW CERTIFICATE REQUEST";
pub const PEM_STRING_X509_REQ = "CERTIFICATE REQUEST";
pub const PEM_STRING_X509_CRL = "X509 CRL";
pub const PEM_STRING_EVP_PKEY = "ANY PRIVATE KEY";
pub const PEM_STRING_PUBLIC = "PUBLIC KEY";
pub const PEM_STRING_RSA = "RSA PRIVATE KEY";
pub const PEM_STRING_RSA_PUBLIC = "RSA PUBLIC KEY";
pub const PEM_STRING_DSA = "DSA PRIVATE KEY";
pub const PEM_STRING_DSA_PUBLIC = "DSA PUBLIC KEY";
pub const PEM_STRING_PKCS7 = "PKCS7";
pub const PEM_STRING_PKCS7_SIGNED = "PKCS #7 SIGNED DATA";
pub const PEM_STRING_PKCS8 = "ENCRYPTED PRIVATE KEY";
pub const PEM_STRING_PKCS8INF = "PRIVATE KEY";
pub const PEM_STRING_DHPARAMS = "DH PARAMETERS";
pub const PEM_STRING_DHXPARAMS = "X9.42 DH PARAMETERS";
pub const PEM_STRING_SSL_SESSION = "SSL SESSION PARAMETERS";
pub const PEM_STRING_DSAPARAMS = "DSA PARAMETERS";
pub const PEM_STRING_ECDSA_PUBLIC = "ECDSA PUBLIC KEY";
pub const PEM_STRING_ECPARAMETERS = "EC PARAMETERS";
pub const PEM_STRING_ECPRIVATEKEY = "EC PRIVATE KEY";
pub const PEM_STRING_PARAMETERS = "PARAMETERS";
pub const PEM_STRING_CMS = "CMS";
pub const PEM_STRING_SM2PARAMETERS = "SM2 PARAMETERS";
pub const PEM_STRING_ACERT = "ATTRIBUTE CERTIFICATE";
pub const PEM_TYPE_ENCRYPTED = @as(c_int, 10);
pub const PEM_TYPE_MIC_ONLY = @as(c_int, 20);
pub const PEM_TYPE_MIC_CLEAR = @as(c_int, 30);
pub const PEM_TYPE_CLEAR = @as(c_int, 40);
pub const PEM_read_cb_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:74:10
pub const PEM_read_cb_ex_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:77:10
pub const PEM_write_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:83:10
pub const PEM_write_cb_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:85:10
pub const PEM_write_ex_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:90:10
pub const PEM_write_cb_ex_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:94:10
pub const IMPLEMENT_PEM_read_fp = @compileError("unable to translate macro: undefined identifier `PEM_read_`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:115:11
pub const IMPLEMENT_PEM_write_fp = @compileError("unable to translate macro: undefined identifier `write`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:122:11
pub inline fn IMPLEMENT_PEM_write_fp_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_fp(name, @"type", str, asn1);
}
pub const IMPLEMENT_PEM_write_cb_fp = @compileError("unable to translate macro: undefined identifier `write`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:134:11
pub inline fn IMPLEMENT_PEM_write_cb_fp_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_cb_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_cb_fp(name, @"type", str, asn1);
}
pub const IMPLEMENT_PEM_read_bio = @compileError("unable to translate macro: undefined identifier `PEM_read_bio_`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:147:10
pub const IMPLEMENT_PEM_write_bio = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:155:10
pub inline fn IMPLEMENT_PEM_write_bio_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_bio(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_bio(name, @"type", str, asn1);
}
pub const IMPLEMENT_PEM_write_cb_bio = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:167:10
pub inline fn IMPLEMENT_PEM_write_cb_bio_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_cb_bio(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_cb_bio(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_write(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_fp(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_write_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_bio_const(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_fp_const(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_bio_const(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_fp_const(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_write_cb(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_cb_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_cb_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb_fp(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_write_cb_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_cb_bio_const(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb_fp_const(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_cb_bio_const(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb_fp_const(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_read(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_read_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_read_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_read_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_read_fp(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_rw(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_rw_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_const(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_const(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_rw_cb(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb(name, @"type", str, asn1);
}
pub const DECLARE_PEM_read_fp_attr = @compileError("unable to translate macro: undefined identifier `read`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:238:11
pub const DECLARE_PEM_read_fp_ex_attr = @compileError("unable to translate macro: undefined identifier `read`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:240:11
pub const DECLARE_PEM_write_fp_attr = @compileError("unable to translate macro: undefined identifier `write`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:244:11
pub const DECLARE_PEM_write_fp_ex_attr = @compileError("unable to translate macro: undefined identifier `write`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:246:11
pub const DECLARE_PEM_write_fp_const_attr = @compileError("unable to translate macro: undefined identifier `write`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:250:12
pub const DECLARE_PEM_write_cb_fp_attr = @compileError("unable to translate macro: undefined identifier `write`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:253:11
pub const DECLARE_PEM_write_cb_fp_ex_attr = @compileError("unable to translate macro: undefined identifier `write`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:255:11
pub const DECLARE_PEM_read_fp = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:261:10
pub const DECLARE_PEM_write_fp = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:263:10
pub const DECLARE_PEM_write_fp_const = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:266:12
pub const DECLARE_PEM_write_cb_fp = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:269:10
pub const DECLARE_PEM_read_bio_attr = @compileError("unable to translate macro: undefined identifier `read_bio`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:272:11
pub const DECLARE_PEM_read_bio_ex_attr = @compileError("unable to translate macro: undefined identifier `read_bio`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:274:11
pub const DECLARE_PEM_read_bio = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:277:10
pub const DECLARE_PEM_read_bio_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:279:10
pub const DECLARE_PEM_write_bio_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:282:10
pub const DECLARE_PEM_write_bio_ex_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:284:10
pub const DECLARE_PEM_write_bio = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:287:10
pub const DECLARE_PEM_write_bio_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:289:10
pub const DECLARE_PEM_write_bio_const_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:293:11
pub const DECLARE_PEM_write_bio_const = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:295:11
pub const DECLARE_PEM_write_cb_bio_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:299:10
pub const DECLARE_PEM_write_cb_bio_ex_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:301:10
pub const DECLARE_PEM_write_cb_bio = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:304:10
pub const DECLARE_PEM_write_cb_ex_bio = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:306:10
pub inline fn DECLARE_PEM_write_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_bio_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_bio_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_write_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_write = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:315:10
pub const DECLARE_PEM_write_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:317:10
pub inline fn DECLARE_PEM_write_const_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_bio_const_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_const_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_bio_const_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_const_attr(attr, name, @"type");
}
pub const DECLARE_PEM_write_const = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:323:11
pub inline fn DECLARE_PEM_write_cb_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_cb_bio_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_fp_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_cb_bio_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_fp_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_write_cb_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_cb_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_fp_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_cb_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_fp_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_write_cb = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:332:10
pub const DECLARE_PEM_write_cb_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:334:10
pub inline fn DECLARE_PEM_read_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_bio_attr(attr, name, @"type") ++ DECLARE_PEM_read_fp_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_bio_attr(attr, name, @"type") ++ DECLARE_PEM_read_fp_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_read_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_read_fp_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_read_fp_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_read = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:342:10
pub const DECLARE_PEM_read_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:344:10
pub inline fn DECLARE_PEM_rw_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_rw_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_rw = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:352:10
pub const DECLARE_PEM_rw_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:354:10
pub inline fn DECLARE_PEM_rw_const_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_const_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_const_attr(attr, name, @"type");
}
pub const DECLARE_PEM_rw_const = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:360:11
pub inline fn DECLARE_PEM_rw_cb_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_rw_cb_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_rw_cb = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:369:10
pub const DECLARE_PEM_rw_cb_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /opt/homebrew/opt/openssl@3/include/openssl/pem.h:371:10
pub const PEM_FLAG_SECURE = @as(c_int, 0x1);
pub const PEM_FLAG_EAY_COMPATIBLE = @as(c_int, 0x2);
pub const PEM_FLAG_ONLY_B64 = @as(c_int, 0x4);
pub const OPENSSL_HMAC_H = "";
pub const HEADER_HMAC_H = "";
pub const HMAC_MAX_MD_CBLOCK = @as(c_int, 200);
pub const OPENSSL_ASYNC_H = "";
pub const HEADER_ASYNC_H = "";
pub const OSSL_ASYNC_FD = c_int;
pub const OSSL_BAD_ASYNC_FD = -@as(c_int, 1);
pub const OPENSSL_ASYNCERR_H = "";
pub const ASYNC_R_FAILED_TO_SET_POOL = @as(c_int, 101);
pub const ASYNC_R_FAILED_TO_SWAP_CONTEXT = @as(c_int, 102);
pub const ASYNC_R_INIT_FAILED = @as(c_int, 105);
pub const ASYNC_R_INVALID_POOL_SIZE = @as(c_int, 103);
pub const ASYNC_ERR = @as(c_int, 0);
pub const ASYNC_NO_JOBS = @as(c_int, 1);
pub const ASYNC_PAUSE = @as(c_int, 2);
pub const ASYNC_FINISH = @as(c_int, 3);
pub const ASYNC_STATUS_UNSUPPORTED = @as(c_int, 0);
pub const ASYNC_STATUS_ERR = @as(c_int, 1);
pub const ASYNC_STATUS_OK = @as(c_int, 2);
pub const ASYNC_STATUS_EAGAIN = @as(c_int, 3);
pub const OPENSSL_CT_H = "";
pub const HEADER_CT_H = "";
pub const OPENSSL_CTERR_H = "";
pub const CT_R_BASE64_DECODE_ERROR = @as(c_int, 108);
pub const CT_R_INVALID_LOG_ID_LENGTH = @as(c_int, 100);
pub const CT_R_LOG_CONF_INVALID = @as(c_int, 109);
pub const CT_R_LOG_CONF_INVALID_KEY = @as(c_int, 110);
pub const CT_R_LOG_CONF_MISSING_DESCRIPTION = @as(c_int, 111);
pub const CT_R_LOG_CONF_MISSING_KEY = @as(c_int, 112);
pub const CT_R_LOG_KEY_INVALID = @as(c_int, 113);
pub const CT_R_SCT_FUTURE_TIMESTAMP = @as(c_int, 116);
pub const CT_R_SCT_INVALID = @as(c_int, 104);
pub const CT_R_SCT_INVALID_SIGNATURE = @as(c_int, 107);
pub const CT_R_SCT_LIST_INVALID = @as(c_int, 105);
pub const CT_R_SCT_LOG_ID_MISMATCH = @as(c_int, 114);
pub const CT_R_SCT_NOT_SET = @as(c_int, 106);
pub const CT_R_SCT_UNSUPPORTED_VERSION = @as(c_int, 115);
pub const CT_R_UNRECOGNIZED_SIGNATURE_NID = @as(c_int, 101);
pub const CT_R_UNSUPPORTED_ENTRY_TYPE = @as(c_int, 102);
pub const CT_R_UNSUPPORTED_VERSION = @as(c_int, 103);
pub const SCT_MIN_RSA_BITS = @as(c_int, 2048);
pub const CT_V1_HASHLEN = SHA256_DIGEST_LENGTH;
pub inline fn sk_SCT_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_SCT_sk_type(sk));
}
pub inline fn sk_SCT_value(sk: anytype, idx: anytype) [*c]SCT {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_value(ossl_check_const_SCT_sk_type(sk), idx));
}
pub const sk_SCT_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:45:9
pub const sk_SCT_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:46:9
pub const sk_SCT_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:47:9
pub inline fn sk_SCT_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_SCT_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_SCT_sk_type(sk), n);
}
pub inline fn sk_SCT_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_SCT_sk_type(sk));
}
pub inline fn sk_SCT_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_SCT_sk_type(sk));
}
pub inline fn sk_SCT_delete(sk: anytype, i: anytype) [*c]SCT {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_delete(ossl_check_SCT_sk_type(sk), i));
}
pub inline fn sk_SCT_delete_ptr(sk: anytype, ptr: anytype) [*c]SCT {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_delete_ptr(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr)));
}
pub inline fn sk_SCT_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr));
}
pub inline fn sk_SCT_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr));
}
pub inline fn sk_SCT_pop(sk: anytype) [*c]SCT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_pop(ossl_check_SCT_sk_type(sk)));
}
pub inline fn sk_SCT_shift(sk: anytype) [*c]SCT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_shift(ossl_check_SCT_sk_type(sk)));
}
pub inline fn sk_SCT_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_SCT_sk_type(sk), ossl_check_SCT_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_SCT_sk_type(sk), ossl_check_SCT_freefunc_type(freefunc));
}
pub inline fn sk_SCT_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr), idx);
}
pub inline fn sk_SCT_set(sk: anytype, idx: anytype, ptr: anytype) [*c]SCT {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_set(ossl_check_SCT_sk_type(sk), idx, ossl_check_SCT_type(ptr)));
}
pub inline fn sk_SCT_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr));
}
pub inline fn sk_SCT_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr));
}
pub inline fn sk_SCT_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr), pnum);
}
pub inline fn sk_SCT_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_SCT_sk_type(sk));
}
pub inline fn sk_SCT_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_SCT_sk_type(sk));
}
pub const sk_SCT_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:65:9
pub const sk_SCT_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:66:9
pub inline fn sk_SCT_set_cmp_func(sk: anytype, cmp: anytype) sk_SCT_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_SCT_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_SCT_sk_type(sk), ossl_check_SCT_compfunc_type(cmp)));
}
pub inline fn sk_CTLOG_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_CTLOG_sk_type(sk));
}
pub inline fn sk_CTLOG_value(sk: anytype, idx: anytype) [*c]CTLOG {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_value(ossl_check_const_CTLOG_sk_type(sk), idx));
}
pub const sk_CTLOG_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:71:9
pub const sk_CTLOG_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:72:9
pub const sk_CTLOG_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:73:9
pub inline fn sk_CTLOG_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_CTLOG_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_CTLOG_sk_type(sk), n);
}
pub inline fn sk_CTLOG_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_CTLOG_sk_type(sk));
}
pub inline fn sk_CTLOG_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_CTLOG_sk_type(sk));
}
pub inline fn sk_CTLOG_delete(sk: anytype, i: anytype) [*c]CTLOG {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_delete(ossl_check_CTLOG_sk_type(sk), i));
}
pub inline fn sk_CTLOG_delete_ptr(sk: anytype, ptr: anytype) [*c]CTLOG {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_delete_ptr(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr)));
}
pub inline fn sk_CTLOG_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr));
}
pub inline fn sk_CTLOG_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr));
}
pub inline fn sk_CTLOG_pop(sk: anytype) [*c]CTLOG {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_pop(ossl_check_CTLOG_sk_type(sk)));
}
pub inline fn sk_CTLOG_shift(sk: anytype) [*c]CTLOG {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_shift(ossl_check_CTLOG_sk_type(sk)));
}
pub inline fn sk_CTLOG_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_freefunc_type(freefunc));
}
pub inline fn sk_CTLOG_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr), idx);
}
pub inline fn sk_CTLOG_set(sk: anytype, idx: anytype, ptr: anytype) [*c]CTLOG {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_set(ossl_check_CTLOG_sk_type(sk), idx, ossl_check_CTLOG_type(ptr)));
}
pub inline fn sk_CTLOG_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr));
}
pub inline fn sk_CTLOG_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr));
}
pub inline fn sk_CTLOG_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr), pnum);
}
pub inline fn sk_CTLOG_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_CTLOG_sk_type(sk));
}
pub inline fn sk_CTLOG_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_CTLOG_sk_type(sk));
}
pub const sk_CTLOG_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:91:9
pub const sk_CTLOG_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ct.h:92:9
pub inline fn sk_CTLOG_set_cmp_func(sk: anytype, cmp: anytype) sk_CTLOG_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_CTLOG_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_compfunc_type(cmp)));
}
pub const OPENSSL_SSLERR_H = "";
pub const OPENSSL_SSLERR_LEGACY_H = "";
pub const SSL_F_ADD_CLIENT_KEY_SHARE_EXT = @as(c_int, 0);
pub const SSL_F_ADD_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_BYTES_TO_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_CHECK_SUITEB_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_CIPHERSUITE_CB = @as(c_int, 0);
pub const SSL_F_CONSTRUCT_CA_NAMES = @as(c_int, 0);
pub const SSL_F_CONSTRUCT_KEY_EXCHANGE_TBS = @as(c_int, 0);
pub const SSL_F_CONSTRUCT_STATEFUL_TICKET = @as(c_int, 0);
pub const SSL_F_CONSTRUCT_STATELESS_TICKET = @as(c_int, 0);
pub const SSL_F_CREATE_SYNTHETIC_MESSAGE_HASH = @as(c_int, 0);
pub const SSL_F_CREATE_TICKET_PREQUEL = @as(c_int, 0);
pub const SSL_F_CT_MOVE_SCTS = @as(c_int, 0);
pub const SSL_F_CT_STRICT = @as(c_int, 0);
pub const SSL_F_CUSTOM_EXT_ADD = @as(c_int, 0);
pub const SSL_F_CUSTOM_EXT_PARSE = @as(c_int, 0);
pub const SSL_F_D2I_SSL_SESSION = @as(c_int, 0);
pub const SSL_F_DANE_CTX_ENABLE = @as(c_int, 0);
pub const SSL_F_DANE_MTYPE_SET = @as(c_int, 0);
pub const SSL_F_DANE_TLSA_ADD = @as(c_int, 0);
pub const SSL_F_DERIVE_SECRET_KEY_AND_IV = @as(c_int, 0);
pub const SSL_F_DO_DTLS1_WRITE = @as(c_int, 0);
pub const SSL_F_DO_SSL3_WRITE = @as(c_int, 0);
pub const SSL_F_DTLS1_BUFFER_RECORD = @as(c_int, 0);
pub const SSL_F_DTLS1_CHECK_TIMEOUT_NUM = @as(c_int, 0);
pub const SSL_F_DTLS1_HEARTBEAT = @as(c_int, 0);
pub const SSL_F_DTLS1_HM_FRAGMENT_NEW = @as(c_int, 0);
pub const SSL_F_DTLS1_PREPROCESS_FRAGMENT = @as(c_int, 0);
pub const SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS = @as(c_int, 0);
pub const SSL_F_DTLS1_PROCESS_RECORD = @as(c_int, 0);
pub const SSL_F_DTLS1_READ_BYTES = @as(c_int, 0);
pub const SSL_F_DTLS1_READ_FAILED = @as(c_int, 0);
pub const SSL_F_DTLS1_RETRANSMIT_MESSAGE = @as(c_int, 0);
pub const SSL_F_DTLS1_WRITE_APP_DATA_BYTES = @as(c_int, 0);
pub const SSL_F_DTLS1_WRITE_BYTES = @as(c_int, 0);
pub const SSL_F_DTLSV1_LISTEN = @as(c_int, 0);
pub const SSL_F_DTLS_CONSTRUCT_CHANGE_CIPHER_SPEC = @as(c_int, 0);
pub const SSL_F_DTLS_CONSTRUCT_HELLO_VERIFY_REQUEST = @as(c_int, 0);
pub const SSL_F_DTLS_GET_REASSEMBLED_MESSAGE = @as(c_int, 0);
pub const SSL_F_DTLS_PROCESS_HELLO_VERIFY = @as(c_int, 0);
pub const SSL_F_DTLS_RECORD_LAYER_NEW = @as(c_int, 0);
pub const SSL_F_DTLS_WAIT_FOR_DRY = @as(c_int, 0);
pub const SSL_F_EARLY_DATA_COUNT_OK = @as(c_int, 0);
pub const SSL_F_FINAL_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_FINAL_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_FINAL_EMS = @as(c_int, 0);
pub const SSL_F_FINAL_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_FINAL_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_FINAL_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_FINAL_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_FINAL_SIG_ALGS = @as(c_int, 0);
pub const SSL_F_GET_CERT_VERIFY_TBS_DATA = @as(c_int, 0);
pub const SSL_F_NSS_KEYLOG_INT = @as(c_int, 0);
pub const SSL_F_OPENSSL_INIT_SSL = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT13_READ_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT13_WRITE_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_CONSTRUCT_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_POST_PROCESS_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_PROCESS_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_READ_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_WRITE_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER13_READ_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER13_WRITE_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_CONSTRUCT_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_POST_PROCESS_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_POST_WORK = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_PRE_WORK = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_PROCESS_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_READ_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_WRITE_TRANSITION = @as(c_int, 0);
pub const SSL_F_PARSE_CA_NAMES = @as(c_int, 0);
pub const SSL_F_PITEM_NEW = @as(c_int, 0);
pub const SSL_F_PQUEUE_NEW = @as(c_int, 0);
pub const SSL_F_PROCESS_KEY_SHARE_EXT = @as(c_int, 0);
pub const SSL_F_READ_STATE_MACHINE = @as(c_int, 0);
pub const SSL_F_SET_CLIENT_CIPHERSUITE = @as(c_int, 0);
pub const SSL_F_SRP_GENERATE_CLIENT_MASTER_SECRET = @as(c_int, 0);
pub const SSL_F_SRP_GENERATE_SERVER_MASTER_SECRET = @as(c_int, 0);
pub const SSL_F_SRP_VERIFY_SERVER_PARAM = @as(c_int, 0);
pub const SSL_F_SSL3_CHANGE_CIPHER_STATE = @as(c_int, 0);
pub const SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM = @as(c_int, 0);
pub const SSL_F_SSL3_CTRL = @as(c_int, 0);
pub const SSL_F_SSL3_CTX_CTRL = @as(c_int, 0);
pub const SSL_F_SSL3_DIGEST_CACHED_RECORDS = @as(c_int, 0);
pub const SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC = @as(c_int, 0);
pub const SSL_F_SSL3_ENC = @as(c_int, 0);
pub const SSL_F_SSL3_FINAL_FINISH_MAC = @as(c_int, 0);
pub const SSL_F_SSL3_FINISH_MAC = @as(c_int, 0);
pub const SSL_F_SSL3_GENERATE_KEY_BLOCK = @as(c_int, 0);
pub const SSL_F_SSL3_GENERATE_MASTER_SECRET = @as(c_int, 0);
pub const SSL_F_SSL3_GET_RECORD = @as(c_int, 0);
pub const SSL_F_SSL3_INIT_FINISHED_MAC = @as(c_int, 0);
pub const SSL_F_SSL3_OUTPUT_CERT_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL3_READ_BYTES = @as(c_int, 0);
pub const SSL_F_SSL3_READ_N = @as(c_int, 0);
pub const SSL_F_SSL3_SETUP_KEY_BLOCK = @as(c_int, 0);
pub const SSL_F_SSL3_SETUP_READ_BUFFER = @as(c_int, 0);
pub const SSL_F_SSL3_SETUP_WRITE_BUFFER = @as(c_int, 0);
pub const SSL_F_SSL3_WRITE_BYTES = @as(c_int, 0);
pub const SSL_F_SSL3_WRITE_PENDING = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CERT_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CERT_TO_BUF = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CERT_TO_WPACKET = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CLIENTHELLO_RENEGOTIATE_EXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CLIENTHELLO_USE_SRTP_EXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK = @as(c_int, 0);
pub const SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK = @as(c_int, 0);
pub const SSL_F_SSL_ADD_SERVERHELLO_RENEGOTIATE_EXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_SERVERHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_SERVERHELLO_USE_SRTP_EXT = @as(c_int, 0);
pub const SSL_F_SSL_BUILD_CERT_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL_BYTES_TO_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_SSL_CACHE_CIPHERLIST = @as(c_int, 0);
pub const SSL_F_SSL_CERT_ADD0_CHAIN_CERT = @as(c_int, 0);
pub const SSL_F_SSL_CERT_DUP = @as(c_int, 0);
pub const SSL_F_SSL_CERT_NEW = @as(c_int, 0);
pub const SSL_F_SSL_CERT_SET0_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL_CHECK_PRIVATE_KEY = @as(c_int, 0);
pub const SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_CHECK_SRP_EXT_CLIENTHELLO = @as(c_int, 0);
pub const SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG = @as(c_int, 0);
pub const SSL_F_SSL_CHOOSE_CLIENT_VERSION = @as(c_int, 0);
pub const SSL_F_SSL_CIPHER_DESCRIPTION = @as(c_int, 0);
pub const SSL_F_SSL_CIPHER_LIST_TO_BYTES = @as(c_int, 0);
pub const SSL_F_SSL_CIPHER_PROCESS_RULESTR = @as(c_int, 0);
pub const SSL_F_SSL_CIPHER_STRENGTH_SORT = @as(c_int, 0);
pub const SSL_F_SSL_CLEAR = @as(c_int, 0);
pub const SSL_F_SSL_CLIENT_HELLO_GET1_EXTENSIONS_PRESENT = @as(c_int, 0);
pub const SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD = @as(c_int, 0);
pub const SSL_F_SSL_CONF_CMD = @as(c_int, 0);
pub const SSL_F_SSL_CREATE_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_SSL_CTRL = @as(c_int, 0);
pub const SSL_F_SSL_CTX_CHECK_PRIVATE_KEY = @as(c_int, 0);
pub const SSL_F_SSL_CTX_ENABLE_CT = @as(c_int, 0);
pub const SSL_F_SSL_CTX_MAKE_PROFILES = @as(c_int, 0);
pub const SSL_F_SSL_CTX_NEW = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_ALPN_PROTOS = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_CT_VALIDATION_CALLBACK = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_SSL_VERSION = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_TLSEXT_MAX_FRAGMENT_LENGTH = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_FILE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_SERVERINFO = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_SERVERINFO_EX = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_SERVERINFO_FILE = @as(c_int, 0);
pub const SSL_F_SSL_DANE_DUP = @as(c_int, 0);
pub const SSL_F_SSL_DANE_ENABLE = @as(c_int, 0);
pub const SSL_F_SSL_DERIVE = @as(c_int, 0);
pub const SSL_F_SSL_DO_CONFIG = @as(c_int, 0);
pub const SSL_F_SSL_DO_HANDSHAKE = @as(c_int, 0);
pub const SSL_F_SSL_DUP_CA_LIST = @as(c_int, 0);
pub const SSL_F_SSL_ENABLE_CT = @as(c_int, 0);
pub const SSL_F_SSL_GENERATE_PKEY_GROUP = @as(c_int, 0);
pub const SSL_F_SSL_GENERATE_SESSION_ID = @as(c_int, 0);
pub const SSL_F_SSL_GET_NEW_SESSION = @as(c_int, 0);
pub const SSL_F_SSL_GET_PREV_SESSION = @as(c_int, 0);
pub const SSL_F_SSL_GET_SERVER_CERT_INDEX = @as(c_int, 0);
pub const SSL_F_SSL_GET_SIGN_PKEY = @as(c_int, 0);
pub const SSL_F_SSL_HANDSHAKE_HASH = @as(c_int, 0);
pub const SSL_F_SSL_INIT_WBIO_BUFFER = @as(c_int, 0);
pub const SSL_F_SSL_KEY_UPDATE = @as(c_int, 0);
pub const SSL_F_SSL_LOAD_CLIENT_CA_FILE = @as(c_int, 0);
pub const SSL_F_SSL_LOG_MASTER_SECRET = @as(c_int, 0);
pub const SSL_F_SSL_LOG_RSA_CLIENT_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_SSL_MODULE_INIT = @as(c_int, 0);
pub const SSL_F_SSL_NEW = @as(c_int, 0);
pub const SSL_F_SSL_NEXT_PROTO_VALIDATE = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT = @as(c_int, 0);
pub const SSL_F_SSL_PEEK = @as(c_int, 0);
pub const SSL_F_SSL_PEEK_EX = @as(c_int, 0);
pub const SSL_F_SSL_PEEK_INTERNAL = @as(c_int, 0);
pub const SSL_F_SSL_READ = @as(c_int, 0);
pub const SSL_F_SSL_READ_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_SSL_READ_EX = @as(c_int, 0);
pub const SSL_F_SSL_READ_INTERNAL = @as(c_int, 0);
pub const SSL_F_SSL_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_SSL_RENEGOTIATE_ABBREVIATED = @as(c_int, 0);
pub const SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_DUP = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_NEW = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_PRINT_FP = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_SET1_ID = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_SET1_ID_CONTEXT = @as(c_int, 0);
pub const SSL_F_SSL_SET_ALPN_PROTOS = @as(c_int, 0);
pub const SSL_F_SSL_SET_CERT = @as(c_int, 0);
pub const SSL_F_SSL_SET_CERT_AND_KEY = @as(c_int, 0);
pub const SSL_F_SSL_SET_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_SSL_SET_CT_VALIDATION_CALLBACK = @as(c_int, 0);
pub const SSL_F_SSL_SET_FD = @as(c_int, 0);
pub const SSL_F_SSL_SET_PKEY = @as(c_int, 0);
pub const SSL_F_SSL_SET_RFD = @as(c_int, 0);
pub const SSL_F_SSL_SET_SESSION = @as(c_int, 0);
pub const SSL_F_SSL_SET_SESSION_ID_CONTEXT = @as(c_int, 0);
pub const SSL_F_SSL_SET_SESSION_TICKET_EXT = @as(c_int, 0);
pub const SSL_F_SSL_SET_TLSEXT_MAX_FRAGMENT_LENGTH = @as(c_int, 0);
pub const SSL_F_SSL_SET_WFD = @as(c_int, 0);
pub const SSL_F_SSL_SHUTDOWN = @as(c_int, 0);
pub const SSL_F_SSL_SRP_CTX_INIT = @as(c_int, 0);
pub const SSL_F_SSL_START_ASYNC_JOB = @as(c_int, 0);
pub const SSL_F_SSL_UNDEFINED_FUNCTION = @as(c_int, 0);
pub const SSL_F_SSL_UNDEFINED_VOID_FUNCTION = @as(c_int, 0);
pub const SSL_F_SSL_USE_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_SSL_USE_CERTIFICATE_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_USE_CERTIFICATE_FILE = @as(c_int, 0);
pub const SSL_F_SSL_USE_PRIVATEKEY = @as(c_int, 0);
pub const SSL_F_SSL_USE_PRIVATEKEY_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_USE_PRIVATEKEY_FILE = @as(c_int, 0);
pub const SSL_F_SSL_USE_PSK_IDENTITY_HINT = @as(c_int, 0);
pub const SSL_F_SSL_USE_RSAPRIVATEKEY = @as(c_int, 0);
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_FILE = @as(c_int, 0);
pub const SSL_F_SSL_VALIDATE_CT = @as(c_int, 0);
pub const SSL_F_SSL_VERIFY_CERT_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL_VERIFY_CLIENT_POST_HANDSHAKE = @as(c_int, 0);
pub const SSL_F_SSL_WRITE = @as(c_int, 0);
pub const SSL_F_SSL_WRITE_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_SSL_WRITE_EARLY_FINISH = @as(c_int, 0);
pub const SSL_F_SSL_WRITE_EX = @as(c_int, 0);
pub const SSL_F_SSL_WRITE_INTERNAL = @as(c_int, 0);
pub const SSL_F_STATE_MACHINE = @as(c_int, 0);
pub const SSL_F_TLS12_CHECK_PEER_SIGALG = @as(c_int, 0);
pub const SSL_F_TLS12_COPY_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS13_CHANGE_CIPHER_STATE = @as(c_int, 0);
pub const SSL_F_TLS13_ENC = @as(c_int, 0);
pub const SSL_F_TLS13_FINAL_FINISH_MAC = @as(c_int, 0);
pub const SSL_F_TLS13_GENERATE_SECRET = @as(c_int, 0);
pub const SSL_F_TLS13_HKDF_EXPAND = @as(c_int, 0);
pub const SSL_F_TLS13_RESTORE_HANDSHAKE_DIGEST_FOR_PHA = @as(c_int, 0);
pub const SSL_F_TLS13_SAVE_HANDSHAKE_DIGEST_FOR_PHA = @as(c_int, 0);
pub const SSL_F_TLS13_SETUP_KEY_BLOCK = @as(c_int, 0);
pub const SSL_F_TLS1_CHANGE_CIPHER_STATE = @as(c_int, 0);
pub const SSL_F_TLS1_CHECK_DUPLICATE_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS1_ENC = @as(c_int, 0);
pub const SSL_F_TLS1_EXPORT_KEYING_MATERIAL = @as(c_int, 0);
pub const SSL_F_TLS1_GET_CURVELIST = @as(c_int, 0);
pub const SSL_F_TLS1_PRF = @as(c_int, 0);
pub const SSL_F_TLS1_SAVE_U16 = @as(c_int, 0);
pub const SSL_F_TLS1_SETUP_KEY_BLOCK = @as(c_int, 0);
pub const SSL_F_TLS1_SET_GROUPS = @as(c_int, 0);
pub const SSL_F_TLS1_SET_RAW_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS1_SET_SERVER_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS1_SET_SHARED_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS1_SET_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS_CHOOSE_SIGALG = @as(c_int, 0);
pub const SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK = @as(c_int, 0);
pub const SSL_F_TLS_COLLECT_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERTIFICATE_AUTHORITIES = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERTIFICATE_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERT_STATUS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERT_STATUS_BODY = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERT_VERIFY = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CHANGE_CIPHER_SPEC = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_DHE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_ECDHE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_GOST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_RSA = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_SRP = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CLIENT_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CLIENT_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_COOKIE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_EMS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_ETM = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_NPN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_PADDING = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_POST_HANDSHAKE_AUTH = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_PSK = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_PSK_KEX_MODES = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SCT = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SIG_ALGS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SRP = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_GROUPS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_VERSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_USE_SRTP = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_VERIFY = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_ENCRYPTED_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_END_OF_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_FINISHED = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_HELLO_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_HELLO_RETRY_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_KEY_UPDATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_NEXT_PROTO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_SERVER_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_SERVER_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_COOKIE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_CRYPTOPRO_BUG = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_DONE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_EARLY_DATA_INFO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_EMS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_ETM = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_NEXT_PROTO_NEG = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_PSK = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_SUPPORTED_GROUPS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_SUPPORTED_VERSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_USE_SRTP = @as(c_int, 0);
pub const SSL_F_TLS_EARLY_POST_PROCESS_CLIENT_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_FINISH_HANDSHAKE = @as(c_int, 0);
pub const SSL_F_TLS_GET_MESSAGE_BODY = @as(c_int, 0);
pub const SSL_F_TLS_GET_MESSAGE_HEADER = @as(c_int, 0);
pub const SSL_F_TLS_HANDLE_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_HANDLE_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CERTIFICATE_AUTHORITIES = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_COOKIE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_EMS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_POST_HANDSHAKE_AUTH = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_PSK = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_PSK_KEX_MODES = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SIG_ALGS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SIG_ALGS_CERT = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SRP = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SUPPORTED_GROUPS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_USE_SRTP = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_COOKIE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_EARLY_DATA_INFO = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_NPN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_PSK = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_SCT = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_SUPPORTED_VERSIONS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_USE_SRTP = @as(c_int, 0);
pub const SSL_F_TLS_POST_PROCESS_CLIENT_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_POST_PROCESS_CLIENT_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_PREPARE_CLIENT_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_AS_HELLO_RETRY_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CERT_STATUS = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CERT_STATUS_BODY = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CERT_VERIFY = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_DHE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_ECDHE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_GOST = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_RSA = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_SRP = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CLIENT_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_ENCRYPTED_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_END_OF_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_FINISHED = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_HELLO_REQ = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_HELLO_RETRY_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_INITIAL_SERVER_FLIGHT = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_KEY_UPDATE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_NEW_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_NEXT_PROTO = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SERVER_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SERVER_DONE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SERVER_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SKE_DHE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SKE_ECDHE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SKE_SRP = @as(c_int, 0);
pub const SSL_F_TLS_PSK_DO_BINDER = @as(c_int, 0);
pub const SSL_F_TLS_SCAN_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_TLS_SETUP_HANDSHAKE = @as(c_int, 0);
pub const SSL_F_USE_CERTIFICATE_CHAIN_FILE = @as(c_int, 0);
pub const SSL_F_WPACKET_INTERN_INIT_LEN = @as(c_int, 0);
pub const SSL_F_WPACKET_START_SUB_PACKET_LEN__ = @as(c_int, 0);
pub const SSL_F_WRITE_STATE_MACHINE = @as(c_int, 0);
pub const SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY = @as(c_int, 291);
pub const SSL_R_APP_DATA_IN_HANDSHAKE = @as(c_int, 100);
pub const SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT = @as(c_int, 272);
pub const SSL_R_AT_LEAST_TLS_1_2_NEEDED_IN_SUITEB_MODE = @as(c_int, 158);
pub const SSL_R_BAD_CERTIFICATE = @as(c_int, 348);
pub const SSL_R_BAD_CHANGE_CIPHER_SPEC = @as(c_int, 103);
pub const SSL_R_BAD_CIPHER = @as(c_int, 186);
pub const SSL_R_BAD_COMPRESSION_ALGORITHM = @as(c_int, 326);
pub const SSL_R_BAD_DATA = @as(c_int, 390);
pub const SSL_R_BAD_DATA_RETURNED_BY_CALLBACK = @as(c_int, 106);
pub const SSL_R_BAD_DECOMPRESSION = @as(c_int, 107);
pub const SSL_R_BAD_DH_VALUE = @as(c_int, 102);
pub const SSL_R_BAD_DIGEST_LENGTH = @as(c_int, 111);
pub const SSL_R_BAD_EARLY_DATA = @as(c_int, 233);
pub const SSL_R_BAD_ECC_CERT = @as(c_int, 304);
pub const SSL_R_BAD_ECPOINT = @as(c_int, 306);
pub const SSL_R_BAD_EXTENSION = @as(c_int, 110);
pub const SSL_R_BAD_HANDSHAKE_LENGTH = @as(c_int, 332);
pub const SSL_R_BAD_HANDSHAKE_STATE = @as(c_int, 236);
pub const SSL_R_BAD_HELLO_REQUEST = @as(c_int, 105);
pub const SSL_R_BAD_HRR_VERSION = @as(c_int, 263);
pub const SSL_R_BAD_KEY_SHARE = @as(c_int, 108);
pub const SSL_R_BAD_KEY_UPDATE = @as(c_int, 122);
pub const SSL_R_BAD_LEGACY_VERSION = @as(c_int, 292);
pub const SSL_R_BAD_LENGTH = @as(c_int, 271);
pub const SSL_R_BAD_PACKET = @as(c_int, 240);
pub const SSL_R_BAD_PACKET_LENGTH = @as(c_int, 115);
pub const SSL_R_BAD_PROTOCOL_VERSION_NUMBER = @as(c_int, 116);
pub const SSL_R_BAD_PSK = @as(c_int, 219);
pub const SSL_R_BAD_PSK_IDENTITY = @as(c_int, 114);
pub const SSL_R_BAD_RECORD_TYPE = @as(c_int, 443);
pub const SSL_R_BAD_RSA_ENCRYPT = @as(c_int, 119);
pub const SSL_R_BAD_SIGNATURE = @as(c_int, 123);
pub const SSL_R_BAD_SRP_A_LENGTH = @as(c_int, 347);
pub const SSL_R_BAD_SRP_PARAMETERS = @as(c_int, 371);
pub const SSL_R_BAD_SRTP_MKI_VALUE = @as(c_int, 352);
pub const SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST = @as(c_int, 353);
pub const SSL_R_BAD_SSL_FILETYPE = @as(c_int, 124);
pub const SSL_R_BAD_VALUE = @as(c_int, 384);
pub const SSL_R_BAD_WRITE_RETRY = @as(c_int, 127);
pub const SSL_R_BINDER_DOES_NOT_VERIFY = @as(c_int, 253);
pub const SSL_R_BIO_NOT_SET = @as(c_int, 128);
pub const SSL_R_BLOCK_CIPHER_PAD_IS_WRONG = @as(c_int, 129);
pub const SSL_R_BN_LIB = @as(c_int, 130);
pub const SSL_R_CALLBACK_FAILED = @as(c_int, 234);
pub const SSL_R_CANNOT_CHANGE_CIPHER = @as(c_int, 109);
pub const SSL_R_CANNOT_GET_GROUP_NAME = @as(c_int, 299);
pub const SSL_R_CA_DN_LENGTH_MISMATCH = @as(c_int, 131);
pub const SSL_R_CA_KEY_TOO_SMALL = @as(c_int, 397);
pub const SSL_R_CA_MD_TOO_WEAK = @as(c_int, 398);
pub const SSL_R_CCS_RECEIVED_EARLY = @as(c_int, 133);
pub const SSL_R_CERTIFICATE_VERIFY_FAILED = @as(c_int, 134);
pub const SSL_R_CERT_CB_ERROR = @as(c_int, 377);
pub const SSL_R_CERT_LENGTH_MISMATCH = @as(c_int, 135);
pub const SSL_R_CIPHERSUITE_DIGEST_HAS_CHANGED = @as(c_int, 218);
pub const SSL_R_CIPHER_CODE_WRONG_LENGTH = @as(c_int, 137);
pub const SSL_R_CLIENTHELLO_TLSEXT = @as(c_int, 226);
pub const SSL_R_COMPRESSED_LENGTH_TOO_LONG = @as(c_int, 140);
pub const SSL_R_COMPRESSION_DISABLED = @as(c_int, 343);
pub const SSL_R_COMPRESSION_FAILURE = @as(c_int, 141);
pub const SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE = @as(c_int, 307);
pub const SSL_R_COMPRESSION_LIBRARY_ERROR = @as(c_int, 142);
pub const SSL_R_CONNECTION_TYPE_NOT_SET = @as(c_int, 144);
pub const SSL_R_CONN_USE_ONLY = @as(c_int, 356);
pub const SSL_R_CONTEXT_NOT_DANE_ENABLED = @as(c_int, 167);
pub const SSL_R_COOKIE_GEN_CALLBACK_FAILURE = @as(c_int, 400);
pub const SSL_R_COOKIE_MISMATCH = @as(c_int, 308);
pub const SSL_R_COPY_PARAMETERS_FAILED = @as(c_int, 296);
pub const SSL_R_CUSTOM_EXT_HANDLER_ALREADY_INSTALLED = @as(c_int, 206);
pub const SSL_R_DANE_ALREADY_ENABLED = @as(c_int, 172);
pub const SSL_R_DANE_CANNOT_OVERRIDE_MTYPE_FULL = @as(c_int, 173);
pub const SSL_R_DANE_NOT_ENABLED = @as(c_int, 175);
pub const SSL_R_DANE_TLSA_BAD_CERTIFICATE = @as(c_int, 180);
pub const SSL_R_DANE_TLSA_BAD_CERTIFICATE_USAGE = @as(c_int, 184);
pub const SSL_R_DANE_TLSA_BAD_DATA_LENGTH = @as(c_int, 189);
pub const SSL_R_DANE_TLSA_BAD_DIGEST_LENGTH = @as(c_int, 192);
pub const SSL_R_DANE_TLSA_BAD_MATCHING_TYPE = @as(c_int, 200);
pub const SSL_R_DANE_TLSA_BAD_PUBLIC_KEY = @as(c_int, 201);
pub const SSL_R_DANE_TLSA_BAD_SELECTOR = @as(c_int, 202);
pub const SSL_R_DANE_TLSA_NULL_DATA = @as(c_int, 203);
pub const SSL_R_DATA_BETWEEN_CCS_AND_FINISHED = @as(c_int, 145);
pub const SSL_R_DATA_LENGTH_TOO_LONG = @as(c_int, 146);
pub const SSL_R_DECRYPTION_FAILED = @as(c_int, 147);
pub const SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC = @as(c_int, 281);
pub const SSL_R_DH_KEY_TOO_SMALL = @as(c_int, 394);
pub const SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG = @as(c_int, 148);
pub const SSL_R_DIGEST_CHECK_FAILED = @as(c_int, 149);
pub const SSL_R_DTLS_MESSAGE_TOO_BIG = @as(c_int, 334);
pub const SSL_R_DUPLICATE_COMPRESSION_ID = @as(c_int, 309);
pub const SSL_R_ECC_CERT_NOT_FOR_SIGNING = @as(c_int, 318);
pub const SSL_R_ECDH_REQUIRED_FOR_SUITEB_MODE = @as(c_int, 374);
pub const SSL_R_EE_KEY_TOO_SMALL = @as(c_int, 399);
pub const SSL_R_EMPTY_RAW_PUBLIC_KEY = @as(c_int, 349);
pub const SSL_R_EMPTY_SRTP_PROTECTION_PROFILE_LIST = @as(c_int, 354);
pub const SSL_R_ENCRYPTED_LENGTH_TOO_LONG = @as(c_int, 150);
pub const SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST = @as(c_int, 151);
pub const SSL_R_ERROR_IN_SYSTEM_DEFAULT_CONFIG = @as(c_int, 419);
pub const SSL_R_ERROR_SETTING_TLSA_BASE_DOMAIN = @as(c_int, 204);
pub const SSL_R_EXCEEDS_MAX_FRAGMENT_SIZE = @as(c_int, 194);
pub const SSL_R_EXCESSIVE_MESSAGE_SIZE = @as(c_int, 152);
pub const SSL_R_EXTENSION_NOT_RECEIVED = @as(c_int, 279);
pub const SSL_R_EXTRA_DATA_IN_MESSAGE = @as(c_int, 153);
pub const SSL_R_EXT_LENGTH_MISMATCH = @as(c_int, 163);
pub const SSL_R_FAILED_TO_GET_PARAMETER = @as(c_int, 316);
pub const SSL_R_FAILED_TO_INIT_ASYNC = @as(c_int, 405);
pub const SSL_R_FEATURE_NEGOTIATION_NOT_COMPLETE = @as(c_int, 417);
pub const SSL_R_FEATURE_NOT_RENEGOTIABLE = @as(c_int, 413);
pub const SSL_R_FRAGMENTED_CLIENT_HELLO = @as(c_int, 401);
pub const SSL_R_GOT_A_FIN_BEFORE_A_CCS = @as(c_int, 154);
pub const SSL_R_HTTPS_PROXY_REQUEST = @as(c_int, 155);
pub const SSL_R_HTTP_REQUEST = @as(c_int, 156);
pub const SSL_R_ILLEGAL_POINT_COMPRESSION = @as(c_int, 162);
pub const SSL_R_ILLEGAL_SUITEB_DIGEST = @as(c_int, 380);
pub const SSL_R_INAPPROPRIATE_FALLBACK = @as(c_int, 373);
pub const SSL_R_INCONSISTENT_COMPRESSION = @as(c_int, 340);
pub const SSL_R_INCONSISTENT_EARLY_DATA_ALPN = @as(c_int, 222);
pub const SSL_R_INCONSISTENT_EARLY_DATA_SNI = @as(c_int, 231);
pub const SSL_R_INCONSISTENT_EXTMS = @as(c_int, 104);
pub const SSL_R_INSUFFICIENT_SECURITY = @as(c_int, 241);
pub const SSL_R_INVALID_ALERT = @as(c_int, 205);
pub const SSL_R_INVALID_CCS_MESSAGE = @as(c_int, 260);
pub const SSL_R_INVALID_CERTIFICATE_OR_ALG = @as(c_int, 238);
pub const SSL_R_INVALID_COMMAND = @as(c_int, 280);
pub const SSL_R_INVALID_COMPRESSION_ALGORITHM = @as(c_int, 341);
pub const SSL_R_INVALID_CONFIG = @as(c_int, 283);
pub const SSL_R_INVALID_CONFIGURATION_NAME = @as(c_int, 113);
pub const SSL_R_INVALID_CONTEXT = @as(c_int, 282);
pub const SSL_R_INVALID_CT_VALIDATION_TYPE = @as(c_int, 212);
pub const SSL_R_INVALID_KEY_UPDATE_TYPE = @as(c_int, 120);
pub const SSL_R_INVALID_MAX_EARLY_DATA = @as(c_int, 174);
pub const SSL_R_INVALID_NULL_CMD_NAME = @as(c_int, 385);
pub const SSL_R_INVALID_RAW_PUBLIC_KEY = @as(c_int, 350);
pub const SSL_R_INVALID_RECORD = @as(c_int, 317);
pub const SSL_R_INVALID_SEQUENCE_NUMBER = @as(c_int, 402);
pub const SSL_R_INVALID_SERVERINFO_DATA = @as(c_int, 388);
pub const SSL_R_INVALID_SESSION_ID = @as(c_int, 999);
pub const SSL_R_INVALID_SRP_USERNAME = @as(c_int, 357);
pub const SSL_R_INVALID_STATUS_RESPONSE = @as(c_int, 328);
pub const SSL_R_INVALID_TICKET_KEYS_LENGTH = @as(c_int, 325);
pub const SSL_R_LEGACY_SIGALG_DISALLOWED_OR_UNSUPPORTED = @as(c_int, 333);
pub const SSL_R_LENGTH_MISMATCH = @as(c_int, 159);
pub const SSL_R_LENGTH_TOO_LONG = @as(c_int, 404);
pub const SSL_R_LENGTH_TOO_SHORT = @as(c_int, 160);
pub const SSL_R_LIBRARY_BUG = @as(c_int, 274);
pub const SSL_R_LIBRARY_HAS_NO_CIPHERS = @as(c_int, 161);
pub const SSL_R_MAXIMUM_ENCRYPTED_PKTS_REACHED = @as(c_int, 395);
pub const SSL_R_MISSING_DSA_SIGNING_CERT = @as(c_int, 165);
pub const SSL_R_MISSING_ECDSA_SIGNING_CERT = @as(c_int, 381);
pub const SSL_R_MISSING_FATAL = @as(c_int, 256);
pub const SSL_R_MISSING_PARAMETERS = @as(c_int, 290);
pub const SSL_R_MISSING_PSK_KEX_MODES_EXTENSION = @as(c_int, 310);
pub const SSL_R_MISSING_RSA_CERTIFICATE = @as(c_int, 168);
pub const SSL_R_MISSING_RSA_ENCRYPTING_CERT = @as(c_int, 169);
pub const SSL_R_MISSING_RSA_SIGNING_CERT = @as(c_int, 170);
pub const SSL_R_MISSING_SIGALGS_EXTENSION = @as(c_int, 112);
pub const SSL_R_MISSING_SIGNING_CERT = @as(c_int, 221);
pub const SSL_R_MISSING_SRP_PARAM = @as(c_int, 358);
pub const SSL_R_MISSING_SUPPORTED_GROUPS_EXTENSION = @as(c_int, 209);
pub const SSL_R_MISSING_SUPPORTED_VERSIONS_EXTENSION = @as(c_int, 420);
pub const SSL_R_MISSING_TMP_DH_KEY = @as(c_int, 171);
pub const SSL_R_MISSING_TMP_ECDH_KEY = @as(c_int, 311);
pub const SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA = @as(c_int, 293);
pub const SSL_R_NOT_ON_RECORD_BOUNDARY = @as(c_int, 182);
pub const SSL_R_NOT_REPLACING_CERTIFICATE = @as(c_int, 289);
pub const SSL_R_NOT_SERVER = @as(c_int, 284);
pub const SSL_R_NO_APPLICATION_PROTOCOL = @as(c_int, 235);
pub const SSL_R_NO_CERTIFICATES_RETURNED = @as(c_int, 176);
pub const SSL_R_NO_CERTIFICATE_ASSIGNED = @as(c_int, 177);
pub const SSL_R_NO_CERTIFICATE_SET = @as(c_int, 179);
pub const SSL_R_NO_CHANGE_FOLLOWING_HRR = @as(c_int, 214);
pub const SSL_R_NO_CIPHERS_AVAILABLE = @as(c_int, 181);
pub const SSL_R_NO_CIPHERS_SPECIFIED = @as(c_int, 183);
pub const SSL_R_NO_CIPHER_MATCH = @as(c_int, 185);
pub const SSL_R_NO_CLIENT_CERT_METHOD = @as(c_int, 331);
pub const SSL_R_NO_COMPRESSION_SPECIFIED = @as(c_int, 187);
pub const SSL_R_NO_COOKIE_CALLBACK_SET = @as(c_int, 287);
pub const SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER = @as(c_int, 330);
pub const SSL_R_NO_METHOD_SPECIFIED = @as(c_int, 188);
pub const SSL_R_NO_PEM_EXTENSIONS = @as(c_int, 389);
pub const SSL_R_NO_PRIVATE_KEY_ASSIGNED = @as(c_int, 190);
pub const SSL_R_NO_PROTOCOLS_AVAILABLE = @as(c_int, 191);
pub const SSL_R_NO_RENEGOTIATION = @as(c_int, 339);
pub const SSL_R_NO_REQUIRED_DIGEST = @as(c_int, 324);
pub const SSL_R_NO_SHARED_CIPHER = @as(c_int, 193);
pub const SSL_R_NO_SHARED_GROUPS = @as(c_int, 410);
pub const SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS = @as(c_int, 376);
pub const SSL_R_NO_SRTP_PROFILES = @as(c_int, 359);
pub const SSL_R_NO_STREAM = @as(c_int, 355);
pub const SSL_R_NO_SUITABLE_DIGEST_ALGORITHM = @as(c_int, 297);
pub const SSL_R_NO_SUITABLE_GROUPS = @as(c_int, 295);
pub const SSL_R_NO_SUITABLE_KEY_SHARE = @as(c_int, 101);
pub const SSL_R_NO_SUITABLE_RECORD_LAYER = @as(c_int, 322);
pub const SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM = @as(c_int, 118);
pub const SSL_R_NO_VALID_SCTS = @as(c_int, 216);
pub const SSL_R_NO_VERIFY_COOKIE_CALLBACK = @as(c_int, 403);
pub const SSL_R_NULL_SSL_CTX = @as(c_int, 195);
pub const SSL_R_NULL_SSL_METHOD_PASSED = @as(c_int, 196);
pub const SSL_R_OCSP_CALLBACK_FAILURE = @as(c_int, 305);
pub const SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED = @as(c_int, 197);
pub const SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED = @as(c_int, 344);
pub const SSL_R_OVERFLOW_ERROR = @as(c_int, 237);
pub const SSL_R_PACKET_LENGTH_TOO_LONG = @as(c_int, 198);
pub const SSL_R_PARSE_TLSEXT = @as(c_int, 227);
pub const SSL_R_PATH_TOO_LONG = @as(c_int, 270);
pub const SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE = @as(c_int, 199);
pub const SSL_R_PEM_NAME_BAD_PREFIX = @as(c_int, 391);
pub const SSL_R_PEM_NAME_TOO_SHORT = @as(c_int, 392);
pub const SSL_R_PIPELINE_FAILURE = @as(c_int, 406);
pub const SSL_R_POLL_REQUEST_NOT_SUPPORTED = @as(c_int, 418);
pub const SSL_R_POST_HANDSHAKE_AUTH_ENCODING_ERR = @as(c_int, 278);
pub const SSL_R_PRIVATE_KEY_MISMATCH = @as(c_int, 288);
pub const SSL_R_PROTOCOL_IS_SHUTDOWN = @as(c_int, 207);
pub const SSL_R_PSK_IDENTITY_NOT_FOUND = @as(c_int, 223);
pub const SSL_R_PSK_NO_CLIENT_CB = @as(c_int, 224);
pub const SSL_R_PSK_NO_SERVER_CB = @as(c_int, 225);
pub const SSL_R_QUIC_HANDSHAKE_LAYER_ERROR = @as(c_int, 393);
pub const SSL_R_QUIC_NETWORK_ERROR = @as(c_int, 387);
pub const SSL_R_QUIC_PROTOCOL_ERROR = @as(c_int, 382);
pub const SSL_R_READ_BIO_NOT_SET = @as(c_int, 211);
pub const SSL_R_READ_TIMEOUT_EXPIRED = @as(c_int, 312);
pub const SSL_R_RECORDS_NOT_RELEASED = @as(c_int, 321);
pub const SSL_R_RECORD_LAYER_FAILURE = @as(c_int, 313);
pub const SSL_R_RECORD_LENGTH_MISMATCH = @as(c_int, 213);
pub const SSL_R_RECORD_TOO_SMALL = @as(c_int, 298);
pub const SSL_R_REMOTE_PEER_ADDRESS_NOT_SET = @as(c_int, 346);
pub const SSL_R_RENEGOTIATE_EXT_TOO_LONG = @as(c_int, 335);
pub const SSL_R_RENEGOTIATION_ENCODING_ERR = @as(c_int, 336);
pub const SSL_R_RENEGOTIATION_MISMATCH = @as(c_int, 337);
pub const SSL_R_REQUEST_PENDING = @as(c_int, 285);
pub const SSL_R_REQUEST_SENT = @as(c_int, 286);
pub const SSL_R_REQUIRED_CIPHER_MISSING = @as(c_int, 215);
pub const SSL_R_REQUIRED_COMPRESSION_ALGORITHM_MISSING = @as(c_int, 342);
pub const SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING = @as(c_int, 345);
pub const SSL_R_SCT_VERIFICATION_FAILED = @as(c_int, 208);
pub const SSL_R_SEQUENCE_CTR_WRAPPED = @as(c_int, 327);
pub const SSL_R_SERVERHELLO_TLSEXT = @as(c_int, 275);
pub const SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED = @as(c_int, 277);
pub const SSL_R_SHUTDOWN_WHILE_IN_INIT = @as(c_int, 407);
pub const SSL_R_SIGNATURE_ALGORITHMS_ERROR = @as(c_int, 360);
pub const SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE = @as(c_int, 220);
pub const SSL_R_SRP_A_CALC = @as(c_int, 361);
pub const SSL_R_SRTP_COULD_NOT_ALLOCATE_PROFILES = @as(c_int, 362);
pub const SSL_R_SRTP_PROTECTION_PROFILE_LIST_TOO_LONG = @as(c_int, 363);
pub const SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE = @as(c_int, 364);
pub const SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH = @as(c_int, 232);
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME = @as(c_int, 319);
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE = @as(c_int, 320);
pub const SSL_R_SSL3_SESSION_ID_TOO_LONG = @as(c_int, 300);
pub const SSL_R_SSLV3_ALERT_BAD_CERTIFICATE = @as(c_int, 1042);
pub const SSL_R_SSLV3_ALERT_BAD_RECORD_MAC = @as(c_int, 1020);
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED = @as(c_int, 1045);
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED = @as(c_int, 1044);
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN = @as(c_int, 1046);
pub const SSL_R_SSLV3_ALERT_DECOMPRESSION_FAILURE = @as(c_int, 1030);
pub const SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE = @as(c_int, 1040);
pub const SSL_R_SSLV3_ALERT_ILLEGAL_PARAMETER = @as(c_int, 1047);
pub const SSL_R_SSLV3_ALERT_NO_CERTIFICATE = @as(c_int, 1041);
pub const SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE = @as(c_int, 1010);
pub const SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE = @as(c_int, 1043);
pub const SSL_R_SSL_COMMAND_SECTION_EMPTY = @as(c_int, 117);
pub const SSL_R_SSL_COMMAND_SECTION_NOT_FOUND = @as(c_int, 125);
pub const SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION = @as(c_int, 228);
pub const SSL_R_SSL_HANDSHAKE_FAILURE = @as(c_int, 229);
pub const SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS = @as(c_int, 230);
pub const SSL_R_SSL_NEGATIVE_LENGTH = @as(c_int, 372);
pub const SSL_R_SSL_SECTION_EMPTY = @as(c_int, 126);
pub const SSL_R_SSL_SECTION_NOT_FOUND = @as(c_int, 136);
pub const SSL_R_SSL_SESSION_ID_CALLBACK_FAILED = @as(c_int, 301);
pub const SSL_R_SSL_SESSION_ID_CONFLICT = @as(c_int, 302);
pub const SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG = @as(c_int, 273);
pub const SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH = @as(c_int, 303);
pub const SSL_R_SSL_SESSION_ID_TOO_LONG = @as(c_int, 408);
pub const SSL_R_SSL_SESSION_VERSION_MISMATCH = @as(c_int, 210);
pub const SSL_R_STILL_IN_INIT = @as(c_int, 121);
pub const SSL_R_STREAM_COUNT_LIMITED = @as(c_int, 411);
pub const SSL_R_STREAM_FINISHED = @as(c_int, 365);
pub const SSL_R_STREAM_RECV_ONLY = @as(c_int, 366);
pub const SSL_R_STREAM_RESET = @as(c_int, 375);
pub const SSL_R_STREAM_SEND_ONLY = @as(c_int, 379);
pub const SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED = @as(c_int, 1116);
pub const SSL_R_TLSV13_ALERT_MISSING_EXTENSION = @as(c_int, 1109);
pub const SSL_R_TLSV1_ALERT_ACCESS_DENIED = @as(c_int, 1049);
pub const SSL_R_TLSV1_ALERT_DECODE_ERROR = @as(c_int, 1050);
pub const SSL_R_TLSV1_ALERT_DECRYPTION_FAILED = @as(c_int, 1021);
pub const SSL_R_TLSV1_ALERT_DECRYPT_ERROR = @as(c_int, 1051);
pub const SSL_R_TLSV1_ALERT_EXPORT_RESTRICTION = @as(c_int, 1060);
pub const SSL_R_TLSV1_ALERT_INAPPROPRIATE_FALLBACK = @as(c_int, 1086);
pub const SSL_R_TLSV1_ALERT_INSUFFICIENT_SECURITY = @as(c_int, 1071);
pub const SSL_R_TLSV1_ALERT_INTERNAL_ERROR = @as(c_int, 1080);
pub const SSL_R_TLSV1_ALERT_NO_APPLICATION_PROTOCOL = @as(c_int, 1120);
pub const SSL_R_TLSV1_ALERT_NO_RENEGOTIATION = @as(c_int, 1100);
pub const SSL_R_TLSV1_ALERT_PROTOCOL_VERSION = @as(c_int, 1070);
pub const SSL_R_TLSV1_ALERT_RECORD_OVERFLOW = @as(c_int, 1022);
pub const SSL_R_TLSV1_ALERT_UNKNOWN_CA = @as(c_int, 1048);
pub const SSL_R_TLSV1_ALERT_UNKNOWN_PSK_IDENTITY = @as(c_int, 1115);
pub const SSL_R_TLSV1_ALERT_USER_CANCELLED = @as(c_int, 1090);
pub const SSL_R_TLSV1_BAD_CERTIFICATE_HASH_VALUE = @as(c_int, 1114);
pub const SSL_R_TLSV1_BAD_CERTIFICATE_STATUS_RESPONSE = @as(c_int, 1113);
pub const SSL_R_TLSV1_CERTIFICATE_UNOBTAINABLE = @as(c_int, 1111);
pub const SSL_R_TLSV1_UNRECOGNIZED_NAME = @as(c_int, 1112);
pub const SSL_R_TLSV1_UNSUPPORTED_EXTENSION = @as(c_int, 1110);
pub const SSL_R_TLS_ILLEGAL_EXPORTER_LABEL = @as(c_int, 367);
pub const SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST = @as(c_int, 157);
pub const SSL_R_TOO_MANY_KEY_UPDATES = @as(c_int, 132);
pub const SSL_R_TOO_MANY_WARN_ALERTS = @as(c_int, 409);
pub const SSL_R_TOO_MUCH_EARLY_DATA = @as(c_int, 164);
pub const SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS = @as(c_int, 314);
pub const SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS = @as(c_int, 239);
pub const SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES = @as(c_int, 242);
pub const SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES = @as(c_int, 243);
pub const SSL_R_UNEXPECTED_CCS_MESSAGE = @as(c_int, 262);
pub const SSL_R_UNEXPECTED_END_OF_EARLY_DATA = @as(c_int, 178);
pub const SSL_R_UNEXPECTED_EOF_WHILE_READING = @as(c_int, 294);
pub const SSL_R_UNEXPECTED_MESSAGE = @as(c_int, 244);
pub const SSL_R_UNEXPECTED_RECORD = @as(c_int, 245);
pub const SSL_R_UNINITIALIZED = @as(c_int, 276);
pub const SSL_R_UNKNOWN_ALERT_TYPE = @as(c_int, 246);
pub const SSL_R_UNKNOWN_CERTIFICATE_TYPE = @as(c_int, 247);
pub const SSL_R_UNKNOWN_CIPHER_RETURNED = @as(c_int, 248);
pub const SSL_R_UNKNOWN_CIPHER_TYPE = @as(c_int, 249);
pub const SSL_R_UNKNOWN_CMD_NAME = @as(c_int, 386);
pub const SSL_R_UNKNOWN_COMMAND = @as(c_int, 139);
pub const SSL_R_UNKNOWN_DIGEST = @as(c_int, 368);
pub const SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE = @as(c_int, 250);
pub const SSL_R_UNKNOWN_MANDATORY_PARAMETER = @as(c_int, 323);
pub const SSL_R_UNKNOWN_PKEY_TYPE = @as(c_int, 251);
pub const SSL_R_UNKNOWN_PROTOCOL = @as(c_int, 252);
pub const SSL_R_UNKNOWN_SSL_VERSION = @as(c_int, 254);
pub const SSL_R_UNKNOWN_STATE = @as(c_int, 255);
pub const SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED = @as(c_int, 338);
pub const SSL_R_UNSOLICITED_EXTENSION = @as(c_int, 217);
pub const SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM = @as(c_int, 257);
pub const SSL_R_UNSUPPORTED_CONFIG_VALUE = @as(c_int, 414);
pub const SSL_R_UNSUPPORTED_CONFIG_VALUE_CLASS = @as(c_int, 415);
pub const SSL_R_UNSUPPORTED_CONFIG_VALUE_OP = @as(c_int, 416);
pub const SSL_R_UNSUPPORTED_ELLIPTIC_CURVE = @as(c_int, 315);
pub const SSL_R_UNSUPPORTED_PROTOCOL = @as(c_int, 258);
pub const SSL_R_UNSUPPORTED_SSL_VERSION = @as(c_int, 259);
pub const SSL_R_UNSUPPORTED_STATUS_TYPE = @as(c_int, 329);
pub const SSL_R_UNSUPPORTED_WRITE_FLAG = @as(c_int, 412);
pub const SSL_R_USE_SRTP_NOT_NEGOTIATED = @as(c_int, 369);
pub const SSL_R_VERSION_TOO_HIGH = @as(c_int, 166);
pub const SSL_R_VERSION_TOO_LOW = @as(c_int, 396);
pub const SSL_R_WRONG_CERTIFICATE_TYPE = @as(c_int, 383);
pub const SSL_R_WRONG_CIPHER_RETURNED = @as(c_int, 261);
pub const SSL_R_WRONG_CURVE = @as(c_int, 378);
pub const SSL_R_WRONG_RPK_TYPE = @as(c_int, 351);
pub const SSL_R_WRONG_SIGNATURE_LENGTH = @as(c_int, 264);
pub const SSL_R_WRONG_SIGNATURE_SIZE = @as(c_int, 265);
pub const SSL_R_WRONG_SIGNATURE_TYPE = @as(c_int, 370);
pub const SSL_R_WRONG_SSL_VERSION = @as(c_int, 266);
pub const SSL_R_WRONG_VERSION_NUMBER = @as(c_int, 267);
pub const SSL_R_X509_LIB = @as(c_int, 268);
pub const SSL_R_X509_VERIFICATION_SETUP_PROBLEMS = @as(c_int, 269);
pub const OPENSSL_PROV_SSL_H = "";
pub const SSL_MAX_MASTER_KEY_LENGTH = @as(c_int, 48);
pub const SSL3_VERSION = @as(c_int, 0x0300);
pub const TLS1_VERSION = @as(c_int, 0x0301);
pub const TLS1_1_VERSION = @as(c_int, 0x0302);
pub const TLS1_2_VERSION = @as(c_int, 0x0303);
pub const TLS1_3_VERSION = @as(c_int, 0x0304);
pub const DTLS1_VERSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFEFF, .hex);
pub const DTLS1_2_VERSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFEFD, .hex);
pub const DTLS1_BAD_VER = @as(c_int, 0x0100);
pub const OSSL_QUIC1_VERSION = @as(c_int, 0x0000001);
pub const SSL_SESSION_ASN1_VERSION = @as(c_int, 0x0001);
pub const SSL_MAX_SSL_SESSION_ID_LENGTH = @as(c_int, 32);
pub const SSL_MAX_SID_CTX_LENGTH = @as(c_int, 32);
pub const SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES = @import("std").zig.c_translation.MacroArithmetic.div(@as(c_int, 512), @as(c_int, 8));
pub const SSL_MAX_KEY_ARG_LENGTH = @as(c_int, 8);
pub const SSL_MAX_PIPELINES = @as(c_int, 32);
pub const SSL_TXT_LOW = "LOW";
pub const SSL_TXT_MEDIUM = "MEDIUM";
pub const SSL_TXT_HIGH = "HIGH";
pub const SSL_TXT_FIPS = "FIPS";
pub const SSL_TXT_aNULL = "aNULL";
pub const SSL_TXT_eNULL = "eNULL";
pub const SSL_TXT_NULL = "NULL";
pub const SSL_TXT_kRSA = "kRSA";
pub const SSL_TXT_kDHr = "kDHr";
pub const SSL_TXT_kDHd = "kDHd";
pub const SSL_TXT_kDH = "kDH";
pub const SSL_TXT_kEDH = "kEDH";
pub const SSL_TXT_kDHE = "kDHE";
pub const SSL_TXT_kECDHr = "kECDHr";
pub const SSL_TXT_kECDHe = "kECDHe";
pub const SSL_TXT_kECDH = "kECDH";
pub const SSL_TXT_kEECDH = "kEECDH";
pub const SSL_TXT_kECDHE = "kECDHE";
pub const SSL_TXT_kPSK = "kPSK";
pub const SSL_TXT_kRSAPSK = "kRSAPSK";
pub const SSL_TXT_kECDHEPSK = "kECDHEPSK";
pub const SSL_TXT_kDHEPSK = "kDHEPSK";
pub const SSL_TXT_kGOST = "kGOST";
pub const SSL_TXT_kGOST18 = "kGOST18";
pub const SSL_TXT_kSRP = "kSRP";
pub const SSL_TXT_aRSA = "aRSA";
pub const SSL_TXT_aDSS = "aDSS";
pub const SSL_TXT_aDH = "aDH";
pub const SSL_TXT_aECDH = "aECDH";
pub const SSL_TXT_aECDSA = "aECDSA";
pub const SSL_TXT_aPSK = "aPSK";
pub const SSL_TXT_aGOST94 = "aGOST94";
pub const SSL_TXT_aGOST01 = "aGOST01";
pub const SSL_TXT_aGOST12 = "aGOST12";
pub const SSL_TXT_aGOST = "aGOST";
pub const SSL_TXT_aSRP = "aSRP";
pub const SSL_TXT_DSS = "DSS";
pub const SSL_TXT_DH = "DH";
pub const SSL_TXT_DHE = "DHE";
pub const SSL_TXT_EDH = "EDH";
pub const SSL_TXT_ADH = "ADH";
pub const SSL_TXT_RSA = "RSA";
pub const SSL_TXT_ECDH = "ECDH";
pub const SSL_TXT_EECDH = "EECDH";
pub const SSL_TXT_ECDHE = "ECDHE";
pub const SSL_TXT_AECDH = "AECDH";
pub const SSL_TXT_ECDSA = "ECDSA";
pub const SSL_TXT_PSK = "PSK";
pub const SSL_TXT_SRP = "SRP";
pub const SSL_TXT_DES = "DES";
pub const SSL_TXT_3DES = "3DES";
pub const SSL_TXT_RC4 = "RC4";
pub const SSL_TXT_RC2 = "RC2";
pub const SSL_TXT_IDEA = "IDEA";
pub const SSL_TXT_SEED = "SEED";
pub const SSL_TXT_AES128 = "AES128";
pub const SSL_TXT_AES256 = "AES256";
pub const SSL_TXT_AES = "AES";
pub const SSL_TXT_AES_GCM = "AESGCM";
pub const SSL_TXT_AES_CCM = "AESCCM";
pub const SSL_TXT_AES_CCM_8 = "AESCCM8";
pub const SSL_TXT_CAMELLIA128 = "CAMELLIA128";
pub const SSL_TXT_CAMELLIA256 = "CAMELLIA256";
pub const SSL_TXT_CAMELLIA = "CAMELLIA";
pub const SSL_TXT_CHACHA20 = "CHACHA20";
pub const SSL_TXT_GOST = "GOST89";
pub const SSL_TXT_ARIA = "ARIA";
pub const SSL_TXT_ARIA_GCM = "ARIAGCM";
pub const SSL_TXT_ARIA128 = "ARIA128";
pub const SSL_TXT_ARIA256 = "ARIA256";
pub const SSL_TXT_GOST2012_GOST8912_GOST8912 = "GOST2012-GOST8912-GOST8912";
pub const SSL_TXT_CBC = "CBC";
pub const SSL_TXT_MD5 = "MD5";
pub const SSL_TXT_SHA1 = "SHA1";
pub const SSL_TXT_SHA = "SHA";
pub const SSL_TXT_GOST94 = "GOST94";
pub const SSL_TXT_GOST89MAC = "GOST89MAC";
pub const SSL_TXT_GOST12 = "GOST12";
pub const SSL_TXT_GOST89MAC12 = "GOST89MAC12";
pub const SSL_TXT_SHA256 = "SHA256";
pub const SSL_TXT_SHA384 = "SHA384";
pub const SSL_TXT_SSLV3 = "SSLv3";
pub const SSL_TXT_TLSV1 = "TLSv1";
pub const SSL_TXT_TLSV1_1 = "TLSv1.1";
pub const SSL_TXT_TLSV1_2 = "TLSv1.2";
pub const SSL_TXT_ALL = "ALL";
pub const SSL_TXT_CMPALL = "COMPLEMENTOFALL";
pub const SSL_TXT_CMPDEF = "COMPLEMENTOFDEFAULT";
pub const SSL_DEFAULT_CIPHER_LIST = "ALL:!COMPLEMENTOFDEFAULT:!eNULL";
pub const TLS_DEFAULT_CIPHERSUITES = "TLS_AES_256_GCM_SHA384:" ++ "TLS_CHACHA20_POLY1305_SHA256:" ++ "TLS_AES_128_GCM_SHA256";
pub const SSL_SENT_SHUTDOWN = @as(c_int, 1);
pub const SSL_RECEIVED_SHUTDOWN = @as(c_int, 2);
pub const SSL_FILETYPE_ASN1 = X509_FILETYPE_ASN1;
pub const SSL_FILETYPE_PEM = X509_FILETYPE_PEM;
pub inline fn sk_SRTP_PROTECTION_PROFILE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_value(sk: anytype, idx: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_value(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk), idx));
}
pub const sk_SRTP_PROTECTION_PROFILE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:249:9
pub const sk_SRTP_PROTECTION_PROFILE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:250:9
pub const sk_SRTP_PROTECTION_PROFILE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:251:9
pub inline fn sk_SRTP_PROTECTION_PROFILE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), n);
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_delete(sk: anytype, i: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_delete(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), i));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_delete_ptr(sk: anytype, ptr: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_delete_ptr(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr)));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_pop(sk: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_pop(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk)));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_shift(sk: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_shift(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk)));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_freefunc_type(freefunc));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr), idx);
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_set(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), idx, ossl_check_SRTP_PROTECTION_PROFILE_type(ptr)));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr), pnum);
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub const sk_SRTP_PROTECTION_PROFILE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:269:9
pub const sk_SRTP_PROTECTION_PROFILE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:270:9
pub inline fn sk_SRTP_PROTECTION_PROFILE_set_cmp_func(sk: anytype, cmp: anytype) sk_SRTP_PROTECTION_PROFILE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_SRTP_PROTECTION_PROFILE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_compfunc_type(cmp)));
}
pub const SSL_EXT_TLS_ONLY = @as(c_int, 0x00001);
pub const SSL_EXT_DTLS_ONLY = @as(c_int, 0x00002);
pub const SSL_EXT_TLS_IMPLEMENTATION_ONLY = @as(c_int, 0x00004);
pub const SSL_EXT_SSL3_ALLOWED = @as(c_int, 0x00008);
pub const SSL_EXT_TLS1_2_AND_BELOW_ONLY = @as(c_int, 0x00010);
pub const SSL_EXT_TLS1_3_ONLY = @as(c_int, 0x00020);
pub const SSL_EXT_IGNORE_ON_RESUMPTION = @as(c_int, 0x00040);
pub const SSL_EXT_CLIENT_HELLO = @as(c_int, 0x00080);
pub const SSL_EXT_TLS1_2_SERVER_HELLO = @as(c_int, 0x00100);
pub const SSL_EXT_TLS1_3_SERVER_HELLO = @as(c_int, 0x00200);
pub const SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS = @as(c_int, 0x00400);
pub const SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST = @as(c_int, 0x00800);
pub const SSL_EXT_TLS1_3_CERTIFICATE = @as(c_int, 0x01000);
pub const SSL_EXT_TLS1_3_NEW_SESSION_TICKET = @as(c_int, 0x02000);
pub const SSL_EXT_TLS1_3_CERTIFICATE_REQUEST = @as(c_int, 0x04000);
pub const SSL_EXT_TLS1_3_CERTIFICATE_COMPRESSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000, .hex);
pub const SSL_EXT_TLS1_3_RAW_PUBLIC_KEY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub inline fn SSL_OP_BIT(n: anytype) @TypeOf(@import("std").zig.c_translation.cast(u64, @as(c_int, 1)) << @import("std").zig.c_translation.cast(u64, n)) {
    _ = &n;
    return @import("std").zig.c_translation.cast(u64, @as(c_int, 1)) << @import("std").zig.c_translation.cast(u64, n);
}
pub const SSL_OP_NO_EXTENDED_MASTER_SECRET = SSL_OP_BIT(@as(c_int, 0));
pub const SSL_OP_CLEANSE_PLAINTEXT = SSL_OP_BIT(@as(c_int, 1));
pub const SSL_OP_LEGACY_SERVER_CONNECT = SSL_OP_BIT(@as(c_int, 2));
pub const SSL_OP_ENABLE_KTLS = SSL_OP_BIT(@as(c_int, 3));
pub const SSL_OP_TLSEXT_PADDING = SSL_OP_BIT(@as(c_int, 4));
pub const SSL_OP_SAFARI_ECDHE_ECDSA_BUG = SSL_OP_BIT(@as(c_int, 6));
pub const SSL_OP_IGNORE_UNEXPECTED_EOF = SSL_OP_BIT(@as(c_int, 7));
pub const SSL_OP_ALLOW_CLIENT_RENEGOTIATION = SSL_OP_BIT(@as(c_int, 8));
pub const SSL_OP_DISABLE_TLSEXT_CA_NAMES = SSL_OP_BIT(@as(c_int, 9));
pub const SSL_OP_ALLOW_NO_DHE_KEX = SSL_OP_BIT(@as(c_int, 10));
pub const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = SSL_OP_BIT(@as(c_int, 11));
pub const SSL_OP_NO_QUERY_MTU = SSL_OP_BIT(@as(c_int, 12));
pub const SSL_OP_COOKIE_EXCHANGE = SSL_OP_BIT(@as(c_int, 13));
pub const SSL_OP_NO_TICKET = SSL_OP_BIT(@as(c_int, 14));
pub const SSL_OP_CISCO_ANYCONNECT = SSL_OP_BIT(@as(c_int, 15));
pub const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = SSL_OP_BIT(@as(c_int, 16));
pub const SSL_OP_NO_COMPRESSION = SSL_OP_BIT(@as(c_int, 17));
pub const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = SSL_OP_BIT(@as(c_int, 18));
pub const SSL_OP_NO_ENCRYPT_THEN_MAC = SSL_OP_BIT(@as(c_int, 19));
pub const SSL_OP_ENABLE_MIDDLEBOX_COMPAT = SSL_OP_BIT(@as(c_int, 20));
pub const SSL_OP_PRIORITIZE_CHACHA = SSL_OP_BIT(@as(c_int, 21));
pub const SSL_OP_CIPHER_SERVER_PREFERENCE = SSL_OP_BIT(@as(c_int, 22));
pub const SSL_OP_TLS_ROLLBACK_BUG = SSL_OP_BIT(@as(c_int, 23));
pub const SSL_OP_NO_ANTI_REPLAY = SSL_OP_BIT(@as(c_int, 24));
pub const SSL_OP_NO_SSLv3 = SSL_OP_BIT(@as(c_int, 25));
pub const SSL_OP_NO_TLSv1 = SSL_OP_BIT(@as(c_int, 26));
pub const SSL_OP_NO_TLSv1_2 = SSL_OP_BIT(@as(c_int, 27));
pub const SSL_OP_NO_TLSv1_1 = SSL_OP_BIT(@as(c_int, 28));
pub const SSL_OP_NO_TLSv1_3 = SSL_OP_BIT(@as(c_int, 29));
pub const SSL_OP_NO_DTLSv1 = SSL_OP_BIT(@as(c_int, 26));
pub const SSL_OP_NO_DTLSv1_2 = SSL_OP_BIT(@as(c_int, 27));
pub const SSL_OP_NO_RENEGOTIATION = SSL_OP_BIT(@as(c_int, 30));
pub const SSL_OP_CRYPTOPRO_TLSEXT_BUG = SSL_OP_BIT(@as(c_int, 31));
pub const SSL_OP_NO_TX_CERTIFICATE_COMPRESSION = SSL_OP_BIT(@as(c_int, 32));
pub const SSL_OP_NO_RX_CERTIFICATE_COMPRESSION = SSL_OP_BIT(@as(c_int, 33));
pub const SSL_OP_ENABLE_KTLS_TX_ZEROCOPY_SENDFILE = SSL_OP_BIT(@as(c_int, 34));
pub const SSL_OP_PREFER_NO_DHE_KEX = SSL_OP_BIT(@as(c_int, 35));
pub const SSL_OP_NO_SSL_MASK = (((SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1) | SSL_OP_NO_TLSv1_1) | SSL_OP_NO_TLSv1_2) | SSL_OP_NO_TLSv1_3;
pub const SSL_OP_NO_DTLS_MASK = SSL_OP_NO_DTLSv1 | SSL_OP_NO_DTLSv1_2;
pub const SSL_OP_ALL = ((SSL_OP_CRYPTOPRO_TLSEXT_BUG | SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS) | SSL_OP_TLSEXT_PADDING) | SSL_OP_SAFARI_ECDHE_ECDSA_BUG;
pub const SSL_OP_MICROSOFT_SESS_ID_BUG = @as(c_int, 0x0);
pub const SSL_OP_NETSCAPE_CHALLENGE_BUG = @as(c_int, 0x0);
pub const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = @as(c_int, 0x0);
pub const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = @as(c_int, 0x0);
pub const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = @as(c_int, 0x0);
pub const SSL_OP_MSIE_SSLV2_RSA_PADDING = @as(c_int, 0x0);
pub const SSL_OP_SSLEAY_080_CLIENT_DH_BUG = @as(c_int, 0x0);
pub const SSL_OP_TLS_D5_BUG = @as(c_int, 0x0);
pub const SSL_OP_TLS_BLOCK_PADDING_BUG = @as(c_int, 0x0);
pub const SSL_OP_SINGLE_ECDH_USE = @as(c_int, 0x0);
pub const SSL_OP_SINGLE_DH_USE = @as(c_int, 0x0);
pub const SSL_OP_EPHEMERAL_RSA = @as(c_int, 0x0);
pub const SSL_OP_NO_SSLv2 = @as(c_int, 0x0);
pub const SSL_OP_PKCS1_CHECK_1 = @as(c_int, 0x0);
pub const SSL_OP_PKCS1_CHECK_2 = @as(c_int, 0x0);
pub const SSL_OP_NETSCAPE_CA_DN_BUG = @as(c_int, 0x0);
pub const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = @as(c_int, 0x0);
pub const SSL_MODE_ENABLE_PARTIAL_WRITE = @as(c_uint, 0x00000001);
pub const SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER = @as(c_uint, 0x00000002);
pub const SSL_MODE_AUTO_RETRY = @as(c_uint, 0x00000004);
pub const SSL_MODE_NO_AUTO_CHAIN = @as(c_uint, 0x00000008);
pub const SSL_MODE_RELEASE_BUFFERS = @as(c_uint, 0x00000010);
pub const SSL_MODE_SEND_CLIENTHELLO_TIME = @as(c_uint, 0x00000020);
pub const SSL_MODE_SEND_SERVERHELLO_TIME = @as(c_uint, 0x00000040);
pub const SSL_MODE_SEND_FALLBACK_SCSV = @as(c_uint, 0x00000080);
pub const SSL_MODE_ASYNC = @as(c_uint, 0x00000100);
pub const SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG = @as(c_uint, 0x00000400);
pub const SSL_CERT_FLAG_TLS_STRICT = @as(c_uint, 0x00000001);
pub const SSL_CERT_FLAG_SUITEB_128_LOS_ONLY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const SSL_CERT_FLAG_SUITEB_192_LOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000, .hex);
pub const SSL_CERT_FLAG_SUITEB_128_LOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x30000, .hex);
pub const SSL_CERT_FLAG_BROKEN_PROTOCOL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hex);
pub const SSL_BUILD_CHAIN_FLAG_UNTRUSTED = @as(c_int, 0x1);
pub const SSL_BUILD_CHAIN_FLAG_NO_ROOT = @as(c_int, 0x2);
pub const SSL_BUILD_CHAIN_FLAG_CHECK = @as(c_int, 0x4);
pub const SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR = @as(c_int, 0x8);
pub const SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR = @as(c_int, 0x10);
pub const CERT_PKEY_VALID = @as(c_int, 0x1);
pub const CERT_PKEY_SIGN = @as(c_int, 0x2);
pub const CERT_PKEY_EE_SIGNATURE = @as(c_int, 0x10);
pub const CERT_PKEY_CA_SIGNATURE = @as(c_int, 0x20);
pub const CERT_PKEY_EE_PARAM = @as(c_int, 0x40);
pub const CERT_PKEY_CA_PARAM = @as(c_int, 0x80);
pub const CERT_PKEY_EXPLICIT_SIGN = @as(c_int, 0x100);
pub const CERT_PKEY_ISSUER_NAME = @as(c_int, 0x200);
pub const CERT_PKEY_CERT_TYPE = @as(c_int, 0x400);
pub const CERT_PKEY_SUITEB = @as(c_int, 0x800);
pub const CERT_PKEY_RPK = @as(c_int, 0x1000);
pub const SSL_CONF_FLAG_CMDLINE = @as(c_int, 0x1);
pub const SSL_CONF_FLAG_FILE = @as(c_int, 0x2);
pub const SSL_CONF_FLAG_CLIENT = @as(c_int, 0x4);
pub const SSL_CONF_FLAG_SERVER = @as(c_int, 0x8);
pub const SSL_CONF_FLAG_SHOW_ERRORS = @as(c_int, 0x10);
pub const SSL_CONF_FLAG_CERTIFICATE = @as(c_int, 0x20);
pub const SSL_CONF_FLAG_REQUIRE_PRIVATE = @as(c_int, 0x40);
pub const SSL_CONF_TYPE_UNKNOWN = @as(c_int, 0x0);
pub const SSL_CONF_TYPE_STRING = @as(c_int, 0x1);
pub const SSL_CONF_TYPE_FILE = @as(c_int, 0x2);
pub const SSL_CONF_TYPE_DIR = @as(c_int, 0x3);
pub const SSL_CONF_TYPE_NONE = @as(c_int, 0x4);
pub const SSL_CONF_TYPE_STORE = @as(c_int, 0x5);
pub const SSL_COOKIE_LENGTH = @as(c_int, 4096);
pub inline fn SSL_CTX_set_mode(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, op, NULL);
}
pub inline fn SSL_CTX_clear_mode(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_MODE, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_MODE, op, NULL);
}
pub inline fn SSL_CTX_get_mode(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, @as(c_int, 0), NULL);
}
pub inline fn SSL_clear_mode(ssl: anytype, op: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_CLEAR_MODE, op, NULL)) {
    _ = &ssl;
    _ = &op;
    return SSL_ctrl(ssl, SSL_CTRL_CLEAR_MODE, op, NULL);
}
pub inline fn SSL_set_mode(ssl: anytype, op: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_MODE, op, NULL)) {
    _ = &ssl;
    _ = &op;
    return SSL_ctrl(ssl, SSL_CTRL_MODE, op, NULL);
}
pub inline fn SSL_get_mode(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_MODE, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_MODE, @as(c_int, 0), NULL);
}
pub inline fn SSL_set_mtu(ssl: anytype, mtu: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MTU, mtu, NULL)) {
    _ = &ssl;
    _ = &mtu;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MTU, mtu, NULL);
}
pub inline fn DTLS_set_link_mtu(ssl: anytype, mtu: anytype) @TypeOf(SSL_ctrl(ssl, DTLS_CTRL_SET_LINK_MTU, mtu, NULL)) {
    _ = &ssl;
    _ = &mtu;
    return SSL_ctrl(ssl, DTLS_CTRL_SET_LINK_MTU, mtu, NULL);
}
pub inline fn DTLS_get_link_min_mtu(ssl: anytype) @TypeOf(SSL_ctrl(ssl, DTLS_CTRL_GET_LINK_MIN_MTU, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, DTLS_CTRL_GET_LINK_MIN_MTU, @as(c_int, 0), NULL);
}
pub inline fn SSL_get_secure_renegotiation_support(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_RI_SUPPORT, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_RI_SUPPORT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_cert_flags(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CERT_FLAGS, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CERT_FLAGS, op, NULL);
}
pub inline fn SSL_set_cert_flags(s: anytype, op: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CERT_FLAGS, op, NULL)) {
    _ = &s;
    _ = &op;
    return SSL_ctrl(s, SSL_CTRL_CERT_FLAGS, op, NULL);
}
pub inline fn SSL_CTX_clear_cert_flags(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_CERT_FLAGS, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_CERT_FLAGS, op, NULL);
}
pub inline fn SSL_clear_cert_flags(s: anytype, op: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CLEAR_CERT_FLAGS, op, NULL)) {
    _ = &s;
    _ = &op;
    return SSL_ctrl(s, SSL_CTRL_CLEAR_CERT_FLAGS, op, NULL);
}
pub inline fn SSL_CTX_set_msg_callback_arg(ctx: anytype, arg: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK_ARG, @as(c_int, 0), arg)) {
    _ = &ctx;
    _ = &arg;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_set_msg_callback_arg(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK_ARG, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_get_extms_support(s: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_EXTMS_SUPPORT, @as(c_int, 0), NULL)) {
    _ = &s;
    return SSL_ctrl(s, SSL_CTRL_GET_EXTMS_SUPPORT, @as(c_int, 0), NULL);
}
pub const SSL_MAX_CERT_LIST_DEFAULT = @as(c_int, 1024) * @as(c_int, 100);
pub const SSL_SESSION_CACHE_MAX_SIZE_DEFAULT = @as(c_int, 1024) * @as(c_int, 20);
pub const SSL_SESS_CACHE_OFF = @as(c_int, 0x0000);
pub const SSL_SESS_CACHE_CLIENT = @as(c_int, 0x0001);
pub const SSL_SESS_CACHE_SERVER = @as(c_int, 0x0002);
pub const SSL_SESS_CACHE_BOTH = SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_SERVER;
pub const SSL_SESS_CACHE_NO_AUTO_CLEAR = @as(c_int, 0x0080);
pub const SSL_SESS_CACHE_NO_INTERNAL_LOOKUP = @as(c_int, 0x0100);
pub const SSL_SESS_CACHE_NO_INTERNAL_STORE = @as(c_int, 0x0200);
pub const SSL_SESS_CACHE_NO_INTERNAL = SSL_SESS_CACHE_NO_INTERNAL_LOOKUP | SSL_SESS_CACHE_NO_INTERNAL_STORE;
pub const SSL_SESS_CACHE_UPDATE_TIME = @as(c_int, 0x0400);
pub inline fn SSL_CTX_sess_number(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_NUMBER, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_NUMBER, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_connect(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_connect_good(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_GOOD, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_GOOD, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_connect_renegotiate(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_RENEGOTIATE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_RENEGOTIATE, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_accept(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_accept_renegotiate(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_RENEGOTIATE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_RENEGOTIATE, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_accept_good(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_GOOD, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_GOOD, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_hits(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_HIT, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_HIT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_cb_hits(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CB_HIT, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CB_HIT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_misses(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_MISSES, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_MISSES, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_timeouts(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_TIMEOUTS, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_TIMEOUTS, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_cache_full(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CACHE_FULL, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CACHE_FULL, @as(c_int, 0), NULL);
}
pub const SSL_CTX_set_npn_advertised_cb = SSL_CTX_set_next_protos_advertised_cb;
pub const SSL_CTX_set_npn_select_cb = SSL_CTX_set_next_proto_select_cb;
pub const SSL_get0_npn_negotiated = SSL_get0_next_proto_negotiated;
pub const OPENSSL_NPN_UNSUPPORTED = @as(c_int, 0);
pub const OPENSSL_NPN_NEGOTIATED = @as(c_int, 1);
pub const OPENSSL_NPN_NO_OVERLAP = @as(c_int, 2);
pub const PSK_MAX_IDENTITY_LEN = @as(c_int, 256);
pub const PSK_MAX_PSK_LEN = @as(c_int, 512);
pub const SSL_NOTHING = @as(c_int, 1);
pub const SSL_WRITING = @as(c_int, 2);
pub const SSL_READING = @as(c_int, 3);
pub const SSL_X509_LOOKUP = @as(c_int, 4);
pub const SSL_ASYNC_PAUSED = @as(c_int, 5);
pub const SSL_ASYNC_NO_JOBS = @as(c_int, 6);
pub const SSL_CLIENT_HELLO_CB = @as(c_int, 7);
pub const SSL_RETRY_VERIFY = @as(c_int, 8);
pub inline fn SSL_want_nothing(s: anytype) @TypeOf(SSL_want(s) == SSL_NOTHING) {
    _ = &s;
    return SSL_want(s) == SSL_NOTHING;
}
pub inline fn SSL_want_read(s: anytype) @TypeOf(SSL_want(s) == SSL_READING) {
    _ = &s;
    return SSL_want(s) == SSL_READING;
}
pub inline fn SSL_want_write(s: anytype) @TypeOf(SSL_want(s) == SSL_WRITING) {
    _ = &s;
    return SSL_want(s) == SSL_WRITING;
}
pub inline fn SSL_want_x509_lookup(s: anytype) @TypeOf(SSL_want(s) == SSL_X509_LOOKUP) {
    _ = &s;
    return SSL_want(s) == SSL_X509_LOOKUP;
}
pub inline fn SSL_want_retry_verify(s: anytype) @TypeOf(SSL_want(s) == SSL_RETRY_VERIFY) {
    _ = &s;
    return SSL_want(s) == SSL_RETRY_VERIFY;
}
pub inline fn SSL_want_async(s: anytype) @TypeOf(SSL_want(s) == SSL_ASYNC_PAUSED) {
    _ = &s;
    return SSL_want(s) == SSL_ASYNC_PAUSED;
}
pub inline fn SSL_want_async_job(s: anytype) @TypeOf(SSL_want(s) == SSL_ASYNC_NO_JOBS) {
    _ = &s;
    return SSL_want(s) == SSL_ASYNC_NO_JOBS;
}
pub inline fn SSL_want_client_hello_cb(s: anytype) @TypeOf(SSL_want(s) == SSL_CLIENT_HELLO_CB) {
    _ = &s;
    return SSL_want(s) == SSL_CLIENT_HELLO_CB;
}
pub const SSL_MAC_FLAG_READ_MAC_STREAM = @as(c_int, 1);
pub const SSL_MAC_FLAG_WRITE_MAC_STREAM = @as(c_int, 2);
pub const SSL_MAC_FLAG_READ_MAC_TLSTREE = @as(c_int, 4);
pub const SSL_MAC_FLAG_WRITE_MAC_TLSTREE = @as(c_int, 8);
pub const OPENSSL_SSL2_H = "";
pub const HEADER_SSL2_H = "";
pub const SSL2_VERSION = @as(c_int, 0x0002);
pub const SSL2_MT_CLIENT_HELLO = @as(c_int, 1);
pub const OPENSSL_SSL3_H = "";
pub const HEADER_SSL3_H = "";
pub const SSL3_CK_SCSV = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000FF, .hex);
pub const SSL3_CK_FALLBACK_SCSV = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03005600, .hex);
pub const SSL3_CK_RSA_NULL_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000001, .hex);
pub const SSL3_CK_RSA_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000002, .hex);
pub const SSL3_CK_RSA_RC4_40_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000003, .hex);
pub const SSL3_CK_RSA_RC4_128_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000004, .hex);
pub const SSL3_CK_RSA_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000005, .hex);
pub const SSL3_CK_RSA_RC2_40_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000006, .hex);
pub const SSL3_CK_RSA_IDEA_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000007, .hex);
pub const SSL3_CK_RSA_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000008, .hex);
pub const SSL3_CK_RSA_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000009, .hex);
pub const SSL3_CK_RSA_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000A, .hex);
pub const SSL3_CK_DH_DSS_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000B, .hex);
pub const SSL3_CK_DH_DSS_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000C, .hex);
pub const SSL3_CK_DH_DSS_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000D, .hex);
pub const SSL3_CK_DH_RSA_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000E, .hex);
pub const SSL3_CK_DH_RSA_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000F, .hex);
pub const SSL3_CK_DH_RSA_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000010, .hex);
pub const SSL3_CK_DHE_DSS_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000011, .hex);
pub const SSL3_CK_EDH_DSS_DES_40_CBC_SHA = SSL3_CK_DHE_DSS_DES_40_CBC_SHA;
pub const SSL3_CK_DHE_DSS_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000012, .hex);
pub const SSL3_CK_EDH_DSS_DES_64_CBC_SHA = SSL3_CK_DHE_DSS_DES_64_CBC_SHA;
pub const SSL3_CK_DHE_DSS_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000013, .hex);
pub const SSL3_CK_EDH_DSS_DES_192_CBC3_SHA = SSL3_CK_DHE_DSS_DES_192_CBC3_SHA;
pub const SSL3_CK_DHE_RSA_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000014, .hex);
pub const SSL3_CK_EDH_RSA_DES_40_CBC_SHA = SSL3_CK_DHE_RSA_DES_40_CBC_SHA;
pub const SSL3_CK_DHE_RSA_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000015, .hex);
pub const SSL3_CK_EDH_RSA_DES_64_CBC_SHA = SSL3_CK_DHE_RSA_DES_64_CBC_SHA;
pub const SSL3_CK_DHE_RSA_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000016, .hex);
pub const SSL3_CK_EDH_RSA_DES_192_CBC3_SHA = SSL3_CK_DHE_RSA_DES_192_CBC3_SHA;
pub const SSL3_CK_ADH_RC4_40_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000017, .hex);
pub const SSL3_CK_ADH_RC4_128_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000018, .hex);
pub const SSL3_CK_ADH_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000019, .hex);
pub const SSL3_CK_ADH_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300001A, .hex);
pub const SSL3_CK_ADH_DES_192_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300001B, .hex);
pub const SSL3_RFC_RSA_NULL_MD5 = "TLS_RSA_WITH_NULL_MD5";
pub const SSL3_RFC_RSA_NULL_SHA = "TLS_RSA_WITH_NULL_SHA";
pub const SSL3_RFC_RSA_DES_192_CBC3_SHA = "TLS_RSA_WITH_3DES_EDE_CBC_SHA";
pub const SSL3_RFC_DHE_DSS_DES_192_CBC3_SHA = "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA";
pub const SSL3_RFC_DHE_RSA_DES_192_CBC3_SHA = "TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA";
pub const SSL3_RFC_ADH_DES_192_CBC_SHA = "TLS_DH_anon_WITH_3DES_EDE_CBC_SHA";
pub const SSL3_RFC_RSA_IDEA_128_SHA = "TLS_RSA_WITH_IDEA_CBC_SHA";
pub const SSL3_RFC_RSA_RC4_128_MD5 = "TLS_RSA_WITH_RC4_128_MD5";
pub const SSL3_RFC_RSA_RC4_128_SHA = "TLS_RSA_WITH_RC4_128_SHA";
pub const SSL3_RFC_ADH_RC4_128_MD5 = "TLS_DH_anon_WITH_RC4_128_MD5";
pub const SSL3_TXT_RSA_NULL_MD5 = "NULL-MD5";
pub const SSL3_TXT_RSA_NULL_SHA = "NULL-SHA";
pub const SSL3_TXT_RSA_RC4_40_MD5 = "EXP-RC4-MD5";
pub const SSL3_TXT_RSA_RC4_128_MD5 = "RC4-MD5";
pub const SSL3_TXT_RSA_RC4_128_SHA = "RC4-SHA";
pub const SSL3_TXT_RSA_RC2_40_MD5 = "EXP-RC2-CBC-MD5";
pub const SSL3_TXT_RSA_IDEA_128_SHA = "IDEA-CBC-SHA";
pub const SSL3_TXT_RSA_DES_40_CBC_SHA = "EXP-DES-CBC-SHA";
pub const SSL3_TXT_RSA_DES_64_CBC_SHA = "DES-CBC-SHA";
pub const SSL3_TXT_RSA_DES_192_CBC3_SHA = "DES-CBC3-SHA";
pub const SSL3_TXT_DH_DSS_DES_40_CBC_SHA = "EXP-DH-DSS-DES-CBC-SHA";
pub const SSL3_TXT_DH_DSS_DES_64_CBC_SHA = "DH-DSS-DES-CBC-SHA";
pub const SSL3_TXT_DH_DSS_DES_192_CBC3_SHA = "DH-DSS-DES-CBC3-SHA";
pub const SSL3_TXT_DH_RSA_DES_40_CBC_SHA = "EXP-DH-RSA-DES-CBC-SHA";
pub const SSL3_TXT_DH_RSA_DES_64_CBC_SHA = "DH-RSA-DES-CBC-SHA";
pub const SSL3_TXT_DH_RSA_DES_192_CBC3_SHA = "DH-RSA-DES-CBC3-SHA";
pub const SSL3_TXT_DHE_DSS_DES_40_CBC_SHA = "EXP-DHE-DSS-DES-CBC-SHA";
pub const SSL3_TXT_DHE_DSS_DES_64_CBC_SHA = "DHE-DSS-DES-CBC-SHA";
pub const SSL3_TXT_DHE_DSS_DES_192_CBC3_SHA = "DHE-DSS-DES-CBC3-SHA";
pub const SSL3_TXT_DHE_RSA_DES_40_CBC_SHA = "EXP-DHE-RSA-DES-CBC-SHA";
pub const SSL3_TXT_DHE_RSA_DES_64_CBC_SHA = "DHE-RSA-DES-CBC-SHA";
pub const SSL3_TXT_DHE_RSA_DES_192_CBC3_SHA = "DHE-RSA-DES-CBC3-SHA";
pub const SSL3_TXT_EDH_DSS_DES_40_CBC_SHA = "EXP-EDH-DSS-DES-CBC-SHA";
pub const SSL3_TXT_EDH_DSS_DES_64_CBC_SHA = "EDH-DSS-DES-CBC-SHA";
pub const SSL3_TXT_EDH_DSS_DES_192_CBC3_SHA = "EDH-DSS-DES-CBC3-SHA";
pub const SSL3_TXT_EDH_RSA_DES_40_CBC_SHA = "EXP-EDH-RSA-DES-CBC-SHA";
pub const SSL3_TXT_EDH_RSA_DES_64_CBC_SHA = "EDH-RSA-DES-CBC-SHA";
pub const SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA = "EDH-RSA-DES-CBC3-SHA";
pub const SSL3_TXT_ADH_RC4_40_MD5 = "EXP-ADH-RC4-MD5";
pub const SSL3_TXT_ADH_RC4_128_MD5 = "ADH-RC4-MD5";
pub const SSL3_TXT_ADH_DES_40_CBC_SHA = "EXP-ADH-DES-CBC-SHA";
pub const SSL3_TXT_ADH_DES_64_CBC_SHA = "ADH-DES-CBC-SHA";
pub const SSL3_TXT_ADH_DES_192_CBC_SHA = "ADH-DES-CBC3-SHA";
pub const SSL3_SSL_SESSION_ID_LENGTH = @as(c_int, 32);
pub const SSL3_MAX_SSL_SESSION_ID_LENGTH = @as(c_int, 32);
pub const SSL3_MASTER_SECRET_SIZE = @as(c_int, 48);
pub const SSL3_RANDOM_SIZE = @as(c_int, 32);
pub const SSL3_SESSION_ID_SIZE = @as(c_int, 32);
pub const SSL3_RT_HEADER_LENGTH = @as(c_int, 5);
pub const SSL3_HM_HEADER_LENGTH = @as(c_int, 4);
pub const SSL3_ALIGN_PAYLOAD = @as(c_int, 8);
pub const SSL3_RT_MAX_MD_SIZE = @as(c_int, 64);
pub const SSL_RT_MAX_CIPHER_BLOCK_SIZE = @as(c_int, 16);
pub const SSL3_RT_MAX_EXTRA = @as(c_int, 16384);
pub const SSL3_RT_MAX_PLAIN_LENGTH = @as(c_int, 16384);
pub const SSL3_RT_MAX_COMPRESSED_OVERHEAD = @as(c_int, 1024);
pub const SSL3_RT_MAX_ENCRYPTED_OVERHEAD = @as(c_int, 256) + SSL3_RT_MAX_MD_SIZE;
pub const SSL3_RT_MAX_TLS13_ENCRYPTED_OVERHEAD = @as(c_int, 256);
pub const SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD = SSL_RT_MAX_CIPHER_BLOCK_SIZE + SSL3_RT_MAX_MD_SIZE;
pub const SSL3_RT_MAX_COMPRESSED_LENGTH = SSL3_RT_MAX_PLAIN_LENGTH + SSL3_RT_MAX_COMPRESSED_OVERHEAD;
pub const SSL3_RT_MAX_ENCRYPTED_LENGTH = SSL3_RT_MAX_ENCRYPTED_OVERHEAD + SSL3_RT_MAX_COMPRESSED_LENGTH;
pub const SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH = SSL3_RT_MAX_PLAIN_LENGTH + SSL3_RT_MAX_TLS13_ENCRYPTED_OVERHEAD;
pub const SSL3_RT_MAX_PACKET_SIZE = SSL3_RT_MAX_ENCRYPTED_LENGTH + SSL3_RT_HEADER_LENGTH;
pub const SSL3_MD_CLIENT_FINISHED_CONST = "\x43\x4c\x4e\x54";
pub const SSL3_MD_SERVER_FINISHED_CONST = "\x53\x52\x56\x52";
pub const SSL3_VERSION_MAJOR = @as(c_int, 0x03);
pub const SSL3_VERSION_MINOR = @as(c_int, 0x00);
pub const SSL3_RT_CHANGE_CIPHER_SPEC = @as(c_int, 20);
pub const SSL3_RT_ALERT = @as(c_int, 21);
pub const SSL3_RT_HANDSHAKE = @as(c_int, 22);
pub const SSL3_RT_APPLICATION_DATA = @as(c_int, 23);
pub const TLS1_RT_CRYPTO = @as(c_int, 0x1000);
pub const TLS1_RT_CRYPTO_PREMASTER = TLS1_RT_CRYPTO | @as(c_int, 0x1);
pub const TLS1_RT_CRYPTO_CLIENT_RANDOM = TLS1_RT_CRYPTO | @as(c_int, 0x2);
pub const TLS1_RT_CRYPTO_SERVER_RANDOM = TLS1_RT_CRYPTO | @as(c_int, 0x3);
pub const TLS1_RT_CRYPTO_MASTER = TLS1_RT_CRYPTO | @as(c_int, 0x4);
pub const TLS1_RT_CRYPTO_READ = @as(c_int, 0x0000);
pub const TLS1_RT_CRYPTO_WRITE = @as(c_int, 0x0100);
pub const TLS1_RT_CRYPTO_MAC = TLS1_RT_CRYPTO | @as(c_int, 0x5);
pub const TLS1_RT_CRYPTO_KEY = TLS1_RT_CRYPTO | @as(c_int, 0x6);
pub const TLS1_RT_CRYPTO_IV = TLS1_RT_CRYPTO | @as(c_int, 0x7);
pub const TLS1_RT_CRYPTO_FIXED_IV = TLS1_RT_CRYPTO | @as(c_int, 0x8);
pub const SSL3_RT_HEADER = @as(c_int, 0x100);
pub const SSL3_RT_INNER_CONTENT_TYPE = @as(c_int, 0x101);
pub const SSL3_RT_QUIC_DATAGRAM = @as(c_int, 0x200);
pub const SSL3_RT_QUIC_PACKET = @as(c_int, 0x201);
pub const SSL3_RT_QUIC_FRAME_FULL = @as(c_int, 0x202);
pub const SSL3_RT_QUIC_FRAME_HEADER = @as(c_int, 0x203);
pub const SSL3_RT_QUIC_FRAME_PADDING = @as(c_int, 0x204);
pub const SSL3_AL_WARNING = @as(c_int, 1);
pub const SSL3_AL_FATAL = @as(c_int, 2);
pub const SSL3_AD_CLOSE_NOTIFY = @as(c_int, 0);
pub const SSL3_AD_UNEXPECTED_MESSAGE = @as(c_int, 10);
pub const SSL3_AD_BAD_RECORD_MAC = @as(c_int, 20);
pub const SSL3_AD_DECOMPRESSION_FAILURE = @as(c_int, 30);
pub const SSL3_AD_HANDSHAKE_FAILURE = @as(c_int, 40);
pub const SSL3_AD_NO_CERTIFICATE = @as(c_int, 41);
pub const SSL3_AD_BAD_CERTIFICATE = @as(c_int, 42);
pub const SSL3_AD_UNSUPPORTED_CERTIFICATE = @as(c_int, 43);
pub const SSL3_AD_CERTIFICATE_REVOKED = @as(c_int, 44);
pub const SSL3_AD_CERTIFICATE_EXPIRED = @as(c_int, 45);
pub const SSL3_AD_CERTIFICATE_UNKNOWN = @as(c_int, 46);
pub const SSL3_AD_ILLEGAL_PARAMETER = @as(c_int, 47);
pub const TLS1_HB_REQUEST = @as(c_int, 1);
pub const TLS1_HB_RESPONSE = @as(c_int, 2);
pub const SSL3_CT_RSA_SIGN = @as(c_int, 1);
pub const SSL3_CT_DSS_SIGN = @as(c_int, 2);
pub const SSL3_CT_RSA_FIXED_DH = @as(c_int, 3);
pub const SSL3_CT_DSS_FIXED_DH = @as(c_int, 4);
pub const SSL3_CT_RSA_EPHEMERAL_DH = @as(c_int, 5);
pub const SSL3_CT_DSS_EPHEMERAL_DH = @as(c_int, 6);
pub const SSL3_CT_FORTEZZA_DMS = @as(c_int, 20);
pub const SSL3_CT_NUMBER = @as(c_int, 12);
pub const SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS = @as(c_int, 0x0001);
pub const TLS1_FLAGS_TLS_PADDING_BUG = @as(c_int, 0x0);
pub const TLS1_FLAGS_SKIP_CERT_VERIFY = @as(c_int, 0x0010);
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC_READ = @as(c_int, 0x0100);
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC = TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;
pub const TLS1_FLAGS_RECEIVED_EXTMS = @as(c_int, 0x0200);
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE = @as(c_int, 0x0400);
pub const TLS1_FLAGS_STATELESS = @as(c_int, 0x0800);
pub const TLS1_FLAGS_REQUIRED_EXTMS = @as(c_int, 0x1000);
pub const SSL3_MT_HELLO_REQUEST = @as(c_int, 0);
pub const SSL3_MT_CLIENT_HELLO = @as(c_int, 1);
pub const SSL3_MT_SERVER_HELLO = @as(c_int, 2);
pub const SSL3_MT_NEWSESSION_TICKET = @as(c_int, 4);
pub const SSL3_MT_END_OF_EARLY_DATA = @as(c_int, 5);
pub const SSL3_MT_ENCRYPTED_EXTENSIONS = @as(c_int, 8);
pub const SSL3_MT_CERTIFICATE = @as(c_int, 11);
pub const SSL3_MT_SERVER_KEY_EXCHANGE = @as(c_int, 12);
pub const SSL3_MT_CERTIFICATE_REQUEST = @as(c_int, 13);
pub const SSL3_MT_SERVER_DONE = @as(c_int, 14);
pub const SSL3_MT_CERTIFICATE_VERIFY = @as(c_int, 15);
pub const SSL3_MT_CLIENT_KEY_EXCHANGE = @as(c_int, 16);
pub const SSL3_MT_FINISHED = @as(c_int, 20);
pub const SSL3_MT_CERTIFICATE_URL = @as(c_int, 21);
pub const SSL3_MT_CERTIFICATE_STATUS = @as(c_int, 22);
pub const SSL3_MT_SUPPLEMENTAL_DATA = @as(c_int, 23);
pub const SSL3_MT_KEY_UPDATE = @as(c_int, 24);
pub const SSL3_MT_COMPRESSED_CERTIFICATE = @as(c_int, 25);
pub const SSL3_MT_NEXT_PROTO = @as(c_int, 67);
pub const SSL3_MT_MESSAGE_HASH = @as(c_int, 254);
pub const DTLS1_MT_HELLO_VERIFY_REQUEST = @as(c_int, 3);
pub const SSL3_MT_CHANGE_CIPHER_SPEC = @as(c_int, 0x0101);
pub const SSL3_MT_CCS = @as(c_int, 1);
pub const SSL3_CC_READ = @as(c_int, 0x001);
pub const SSL3_CC_WRITE = @as(c_int, 0x002);
pub const SSL3_CC_CLIENT = @as(c_int, 0x010);
pub const SSL3_CC_SERVER = @as(c_int, 0x020);
pub const SSL3_CC_EARLY = @as(c_int, 0x040);
pub const SSL3_CC_HANDSHAKE = @as(c_int, 0x080);
pub const SSL3_CC_APPLICATION = @as(c_int, 0x100);
pub const SSL3_CHANGE_CIPHER_CLIENT_WRITE = SSL3_CC_CLIENT | SSL3_CC_WRITE;
pub const SSL3_CHANGE_CIPHER_SERVER_READ = SSL3_CC_SERVER | SSL3_CC_READ;
pub const SSL3_CHANGE_CIPHER_CLIENT_READ = SSL3_CC_CLIENT | SSL3_CC_READ;
pub const SSL3_CHANGE_CIPHER_SERVER_WRITE = SSL3_CC_SERVER | SSL3_CC_WRITE;
pub const OPENSSL_TLS1_H = "";
pub const HEADER_TLS1_H = "";
pub const OPENSSL_TLS_SECURITY_LEVEL = @as(c_int, 2);
pub const TLS_MAX_VERSION = TLS1_3_VERSION;
pub const TLS_ANY_VERSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const TLS1_VERSION_MAJOR = @as(c_int, 0x03);
pub const TLS1_VERSION_MINOR = @as(c_int, 0x01);
pub const TLS1_1_VERSION_MAJOR = @as(c_int, 0x03);
pub const TLS1_1_VERSION_MINOR = @as(c_int, 0x02);
pub const TLS1_2_VERSION_MAJOR = @as(c_int, 0x03);
pub const TLS1_2_VERSION_MINOR = @as(c_int, 0x03);
pub inline fn TLS1_get_version(s: anytype) @TypeOf(if ((SSL_version(s) >> @as(c_int, 8)) == TLS1_VERSION_MAJOR) SSL_version(s) else @as(c_int, 0)) {
    _ = &s;
    return if ((SSL_version(s) >> @as(c_int, 8)) == TLS1_VERSION_MAJOR) SSL_version(s) else @as(c_int, 0);
}
pub inline fn TLS1_get_client_version(s: anytype) @TypeOf(if ((SSL_client_version(s) >> @as(c_int, 8)) == TLS1_VERSION_MAJOR) SSL_client_version(s) else @as(c_int, 0)) {
    _ = &s;
    return if ((SSL_client_version(s) >> @as(c_int, 8)) == TLS1_VERSION_MAJOR) SSL_client_version(s) else @as(c_int, 0);
}
pub const TLS1_AD_DECRYPTION_FAILED = @as(c_int, 21);
pub const TLS1_AD_RECORD_OVERFLOW = @as(c_int, 22);
pub const TLS1_AD_UNKNOWN_CA = @as(c_int, 48);
pub const TLS1_AD_ACCESS_DENIED = @as(c_int, 49);
pub const TLS1_AD_DECODE_ERROR = @as(c_int, 50);
pub const TLS1_AD_DECRYPT_ERROR = @as(c_int, 51);
pub const TLS1_AD_EXPORT_RESTRICTION = @as(c_int, 60);
pub const TLS1_AD_PROTOCOL_VERSION = @as(c_int, 70);
pub const TLS1_AD_INSUFFICIENT_SECURITY = @as(c_int, 71);
pub const TLS1_AD_INTERNAL_ERROR = @as(c_int, 80);
pub const TLS1_AD_INAPPROPRIATE_FALLBACK = @as(c_int, 86);
pub const TLS1_AD_USER_CANCELLED = @as(c_int, 90);
pub const TLS1_AD_NO_RENEGOTIATION = @as(c_int, 100);
pub const TLS13_AD_MISSING_EXTENSION = @as(c_int, 109);
pub const TLS13_AD_CERTIFICATE_REQUIRED = @as(c_int, 116);
pub const TLS1_AD_UNSUPPORTED_EXTENSION = @as(c_int, 110);
pub const TLS1_AD_CERTIFICATE_UNOBTAINABLE = @as(c_int, 111);
pub const TLS1_AD_UNRECOGNIZED_NAME = @as(c_int, 112);
pub const TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE = @as(c_int, 113);
pub const TLS1_AD_BAD_CERTIFICATE_HASH_VALUE = @as(c_int, 114);
pub const TLS1_AD_UNKNOWN_PSK_IDENTITY = @as(c_int, 115);
pub const TLS1_AD_NO_APPLICATION_PROTOCOL = @as(c_int, 120);
pub const TLSEXT_TYPE_server_name = @as(c_int, 0);
pub const TLSEXT_TYPE_max_fragment_length = @as(c_int, 1);
pub const TLSEXT_TYPE_client_certificate_url = @as(c_int, 2);
pub const TLSEXT_TYPE_trusted_ca_keys = @as(c_int, 3);
pub const TLSEXT_TYPE_truncated_hmac = @as(c_int, 4);
pub const TLSEXT_TYPE_status_request = @as(c_int, 5);
pub const TLSEXT_TYPE_user_mapping = @as(c_int, 6);
pub const TLSEXT_TYPE_client_authz = @as(c_int, 7);
pub const TLSEXT_TYPE_server_authz = @as(c_int, 8);
pub const TLSEXT_TYPE_cert_type = @as(c_int, 9);
pub const TLSEXT_TYPE_supported_groups = @as(c_int, 10);
pub const TLSEXT_TYPE_elliptic_curves = TLSEXT_TYPE_supported_groups;
pub const TLSEXT_TYPE_ec_point_formats = @as(c_int, 11);
pub const TLSEXT_TYPE_srp = @as(c_int, 12);
pub const TLSEXT_TYPE_signature_algorithms = @as(c_int, 13);
pub const TLSEXT_TYPE_use_srtp = @as(c_int, 14);
pub const TLSEXT_TYPE_application_layer_protocol_negotiation = @as(c_int, 16);
pub const TLSEXT_TYPE_signed_certificate_timestamp = @as(c_int, 18);
pub const TLSEXT_TYPE_client_cert_type = @as(c_int, 19);
pub const TLSEXT_TYPE_server_cert_type = @as(c_int, 20);
pub const TLSEXT_TYPE_padding = @as(c_int, 21);
pub const TLSEXT_TYPE_encrypt_then_mac = @as(c_int, 22);
pub const TLSEXT_TYPE_extended_master_secret = @as(c_int, 23);
pub const TLSEXT_TYPE_compress_certificate = @as(c_int, 27);
pub const TLSEXT_TYPE_session_ticket = @as(c_int, 35);
pub const TLSEXT_TYPE_psk = @as(c_int, 41);
pub const TLSEXT_TYPE_early_data = @as(c_int, 42);
pub const TLSEXT_TYPE_supported_versions = @as(c_int, 43);
pub const TLSEXT_TYPE_cookie = @as(c_int, 44);
pub const TLSEXT_TYPE_psk_kex_modes = @as(c_int, 45);
pub const TLSEXT_TYPE_certificate_authorities = @as(c_int, 47);
pub const TLSEXT_TYPE_post_handshake_auth = @as(c_int, 49);
pub const TLSEXT_TYPE_signature_algorithms_cert = @as(c_int, 50);
pub const TLSEXT_TYPE_key_share = @as(c_int, 51);
pub const TLSEXT_TYPE_quic_transport_parameters = @as(c_int, 57);
pub const TLSEXT_TYPE_renegotiate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff01, .hex);
pub const TLSEXT_TYPE_next_proto_neg = @as(c_int, 13172);
pub const TLSEXT_NAMETYPE_host_name = @as(c_int, 0);
pub const TLSEXT_STATUSTYPE_ocsp = @as(c_int, 1);
pub const TLSEXT_ECPOINTFORMAT_first = @as(c_int, 0);
pub const TLSEXT_ECPOINTFORMAT_uncompressed = @as(c_int, 0);
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime = @as(c_int, 1);
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2 = @as(c_int, 2);
pub const TLSEXT_ECPOINTFORMAT_last = @as(c_int, 2);
pub const TLSEXT_signature_anonymous = @as(c_int, 0);
pub const TLSEXT_signature_rsa = @as(c_int, 1);
pub const TLSEXT_signature_dsa = @as(c_int, 2);
pub const TLSEXT_signature_ecdsa = @as(c_int, 3);
pub const TLSEXT_signature_gostr34102001 = @as(c_int, 237);
pub const TLSEXT_signature_gostr34102012_256 = @as(c_int, 238);
pub const TLSEXT_signature_gostr34102012_512 = @as(c_int, 239);
pub const TLSEXT_signature_num = @as(c_int, 7);
pub const TLSEXT_hash_none = @as(c_int, 0);
pub const TLSEXT_hash_md5 = @as(c_int, 1);
pub const TLSEXT_hash_sha1 = @as(c_int, 2);
pub const TLSEXT_hash_sha224 = @as(c_int, 3);
pub const TLSEXT_hash_sha256 = @as(c_int, 4);
pub const TLSEXT_hash_sha384 = @as(c_int, 5);
pub const TLSEXT_hash_sha512 = @as(c_int, 6);
pub const TLSEXT_hash_gostr3411 = @as(c_int, 237);
pub const TLSEXT_hash_gostr34112012_256 = @as(c_int, 238);
pub const TLSEXT_hash_gostr34112012_512 = @as(c_int, 239);
pub const TLSEXT_hash_num = @as(c_int, 10);
pub const TLSEXT_comp_cert_none = @as(c_int, 0);
pub const TLSEXT_comp_cert_zlib = @as(c_int, 1);
pub const TLSEXT_comp_cert_brotli = @as(c_int, 2);
pub const TLSEXT_comp_cert_zstd = @as(c_int, 3);
pub const TLSEXT_comp_cert_limit = @as(c_int, 4);
pub const TLSEXT_nid_unknown = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000000, .hex);
pub const TLSEXT_curve_P_256 = @as(c_int, 23);
pub const TLSEXT_curve_P_384 = @as(c_int, 24);
pub const TLSEXT_max_fragment_length_DISABLED = @as(c_int, 0);
pub const TLSEXT_max_fragment_length_512 = @as(c_int, 1);
pub const TLSEXT_max_fragment_length_1024 = @as(c_int, 2);
pub const TLSEXT_max_fragment_length_2048 = @as(c_int, 3);
pub const TLSEXT_max_fragment_length_4096 = @as(c_int, 4);
pub const TLSEXT_max_fragment_length_UNSPECIFIED = @as(c_int, 255);
pub const TLSEXT_cert_type_x509 = @as(c_int, 0);
pub const TLSEXT_cert_type_pgp = @as(c_int, 1);
pub const TLSEXT_cert_type_rpk = @as(c_int, 2);
pub const TLSEXT_cert_type_1609dot2 = @as(c_int, 3);
pub const TLSEXT_MAXLEN_host_name = @as(c_int, 255);
pub inline fn SSL_set_tlsext_host_name(s: anytype, name: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_TLSEXT_HOSTNAME, TLSEXT_NAMETYPE_host_name, @import("std").zig.c_translation.cast(?*anyopaque, name))) {
    _ = &s;
    _ = &name;
    return SSL_ctrl(s, SSL_CTRL_SET_TLSEXT_HOSTNAME, TLSEXT_NAMETYPE_host_name, @import("std").zig.c_translation.cast(?*anyopaque, name));
}
pub const SSL_set_tlsext_debug_callback = @compileError("unable to translate C expr: expected ')' instead got '('");
// /opt/homebrew/opt/openssl@3/include/openssl/tls1.h:297:10
pub inline fn SSL_set_tlsext_debug_arg(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_DEBUG_ARG, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_DEBUG_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_get_tlsext_status_type(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE, @as(c_int, 0), NULL);
}
pub inline fn SSL_set_tlsext_status_type(ssl: anytype, @"type": anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE, @"type", NULL)) {
    _ = &ssl;
    _ = &@"type";
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE, @"type", NULL);
}
pub inline fn SSL_get_tlsext_status_exts(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS, @as(c_int, 0), arg);
}
pub inline fn SSL_set_tlsext_status_exts(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS, @as(c_int, 0), arg);
}
pub inline fn SSL_get_tlsext_status_ids(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS, @as(c_int, 0), arg);
}
pub inline fn SSL_set_tlsext_status_ids(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS, @as(c_int, 0), arg);
}
pub inline fn SSL_get_tlsext_status_ocsp_resp(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP, @as(c_int, 0), arg);
}
pub inline fn SSL_set_tlsext_status_ocsp_resp(ssl: anytype, arg: anytype, arglen: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP, arglen, arg)) {
    _ = &ssl;
    _ = &arg;
    _ = &arglen;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP, arglen, arg);
}
pub const SSL_CTX_set_tlsext_servername_callback = @compileError("unable to translate C expr: expected ')' instead got '('");
// /opt/homebrew/opt/openssl@3/include/openssl/tls1.h:328:10
pub const SSL_TLSEXT_ERR_OK = @as(c_int, 0);
pub const SSL_TLSEXT_ERR_ALERT_WARNING = @as(c_int, 1);
pub const SSL_TLSEXT_ERR_ALERT_FATAL = @as(c_int, 2);
pub const SSL_TLSEXT_ERR_NOACK = @as(c_int, 3);
pub inline fn SSL_CTX_set_tlsext_servername_arg(ctx: anytype, arg: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, @as(c_int, 0), arg)) {
    _ = &ctx;
    _ = &arg;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_CTX_get_tlsext_ticket_keys(ctx: anytype, keys: anytype, keylen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_TLSEXT_TICKET_KEYS, keylen, keys)) {
    _ = &ctx;
    _ = &keys;
    _ = &keylen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_TLSEXT_TICKET_KEYS, keylen, keys);
}
pub inline fn SSL_CTX_set_tlsext_ticket_keys(ctx: anytype, keys: anytype, keylen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_TICKET_KEYS, keylen, keys)) {
    _ = &ctx;
    _ = &keys;
    _ = &keylen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_TICKET_KEYS, keylen, keys);
}
pub inline fn SSL_CTX_get_tlsext_status_cb(ssl: anytype, cb: anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, cb))) {
    _ = &ssl;
    _ = &cb;
    return SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, cb));
}
pub const SSL_CTX_set_tlsext_status_cb = @compileError("unable to translate C expr: expected ')' instead got '('");
// /opt/homebrew/opt/openssl@3/include/openssl/tls1.h:347:10
pub inline fn SSL_CTX_get_tlsext_status_arg(ssl: anytype, arg: anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_CTX_set_tlsext_status_arg(ssl: anytype, arg: anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_CTX_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_CTX_set_tlsext_status_type(ssl: anytype, @"type": anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE, @"type", NULL)) {
    _ = &ssl;
    _ = &@"type";
    return SSL_CTX_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE, @"type", NULL);
}
pub inline fn SSL_CTX_get_tlsext_status_type(ssl: anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE, @as(c_int, 0), NULL);
}
pub const SSL_CTX_set_tlsext_ticket_key_cb = @compileError("unable to translate C expr: expected ')' instead got '('");
// /opt/homebrew/opt/openssl@3/include/openssl/tls1.h:363:11
pub const TLS1_CK_PSK_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008A, .hex);
pub const TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008B, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008C, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008D, .hex);
pub const TLS1_CK_DHE_PSK_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008E, .hex);
pub const TLS1_CK_DHE_PSK_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008F, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000090, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000091, .hex);
pub const TLS1_CK_RSA_PSK_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000092, .hex);
pub const TLS1_CK_RSA_PSK_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000093, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000094, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000095, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A8, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A9, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AA, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AB, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AC, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AD, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AE, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AF, .hex);
pub const TLS1_CK_PSK_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B0, .hex);
pub const TLS1_CK_PSK_WITH_NULL_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B1, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B2, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B3, .hex);
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B4, .hex);
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B5, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B6, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B7, .hex);
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B8, .hex);
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B9, .hex);
pub const TLS1_CK_PSK_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300002C, .hex);
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300002D, .hex);
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300002E, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300002F, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000030, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000031, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000032, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000033, .hex);
pub const TLS1_CK_ADH_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000034, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000035, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000036, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000037, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000038, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000039, .hex);
pub const TLS1_CK_ADH_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003A, .hex);
pub const TLS1_CK_RSA_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003B, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003C, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003D, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003E, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003F, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000040, .hex);
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000041, .hex);
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000042, .hex);
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000043, .hex);
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000044, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000045, .hex);
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000046, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000067, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000068, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000069, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300006A, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300006B, .hex);
pub const TLS1_CK_ADH_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300006C, .hex);
pub const TLS1_CK_ADH_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300006D, .hex);
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000084, .hex);
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000085, .hex);
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000086, .hex);
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000087, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000088, .hex);
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000089, .hex);
pub const TLS1_CK_RSA_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000096, .hex);
pub const TLS1_CK_DH_DSS_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000097, .hex);
pub const TLS1_CK_DH_RSA_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000098, .hex);
pub const TLS1_CK_DHE_DSS_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000099, .hex);
pub const TLS1_CK_DHE_RSA_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009A, .hex);
pub const TLS1_CK_ADH_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009B, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009C, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009D, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009E, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009F, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A0, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A1, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A2, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A3, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A4, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A5, .hex);
pub const TLS1_CK_ADH_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A6, .hex);
pub const TLS1_CK_ADH_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A7, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09C, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09D, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09E, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09F, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A0, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A1, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A2, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A3, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A4, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A5, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A6, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A7, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A8, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A9, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AA, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AB, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AC, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AD, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AE, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AF, .hex);
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BA, .hex);
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BB, .hex);
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BC, .hex);
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BD, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BE, .hex);
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BF, .hex);
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C0, .hex);
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C1, .hex);
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C2, .hex);
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C3, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C4, .hex);
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C5, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C001, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C002, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C003, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C004, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C005, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C006, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C007, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C008, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C009, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00A, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00B, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00C, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00D, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00E, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00F, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C010, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C011, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C012, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C013, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C014, .hex);
pub const TLS1_CK_ECDH_anon_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C015, .hex);
pub const TLS1_CK_ECDH_anon_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C016, .hex);
pub const TLS1_CK_ECDH_anon_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C017, .hex);
pub const TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C018, .hex);
pub const TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C019, .hex);
pub const TLS1_CK_SRP_SHA_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01A, .hex);
pub const TLS1_CK_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01B, .hex);
pub const TLS1_CK_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01C, .hex);
pub const TLS1_CK_SRP_SHA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01D, .hex);
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01E, .hex);
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01F, .hex);
pub const TLS1_CK_SRP_SHA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C020, .hex);
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C021, .hex);
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C022, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C023, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C024, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C025, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C026, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C027, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C028, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C029, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02A, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02B, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02C, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02D, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02E, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02F, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C030, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C031, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C032, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C033, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C034, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C035, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C036, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C037, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C038, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C039, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C03A, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C03B, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C072, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C073, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C074, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C075, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C076, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C077, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C078, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C079, .hex);
pub const TLS1_CK_PSK_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C094, .hex);
pub const TLS1_CK_PSK_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C095, .hex);
pub const TLS1_CK_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C096, .hex);
pub const TLS1_CK_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C097, .hex);
pub const TLS1_CK_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C098, .hex);
pub const TLS1_CK_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C099, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09A, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09B, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCA8, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCA9, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAA, .hex);
pub const TLS1_CK_PSK_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAB, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAC, .hex);
pub const TLS1_CK_DHE_PSK_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAD, .hex);
pub const TLS1_CK_RSA_PSK_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAE, .hex);
pub const TLS1_3_CK_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001301, .hex);
pub const TLS1_3_CK_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001302, .hex);
pub const TLS1_3_CK_CHACHA20_POLY1305_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001303, .hex);
pub const TLS1_3_CK_AES_128_CCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001304, .hex);
pub const TLS1_3_CK_AES_128_CCM_8_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001305, .hex);
pub const TLS1_3_CK_SHA256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0B4, .hex);
pub const TLS1_3_CK_SHA384_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0B5, .hex);
pub const TLS1_CK_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C050, .hex);
pub const TLS1_CK_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C051, .hex);
pub const TLS1_CK_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C052, .hex);
pub const TLS1_CK_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C053, .hex);
pub const TLS1_CK_DH_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C054, .hex);
pub const TLS1_CK_DH_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C055, .hex);
pub const TLS1_CK_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C056, .hex);
pub const TLS1_CK_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C057, .hex);
pub const TLS1_CK_DH_DSS_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C058, .hex);
pub const TLS1_CK_DH_DSS_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C059, .hex);
pub const TLS1_CK_DH_anon_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05A, .hex);
pub const TLS1_CK_DH_anon_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05B, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05C, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05D, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05E, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05F, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C060, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C061, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C062, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C063, .hex);
pub const TLS1_CK_PSK_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06A, .hex);
pub const TLS1_CK_PSK_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06B, .hex);
pub const TLS1_CK_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06C, .hex);
pub const TLS1_CK_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06D, .hex);
pub const TLS1_CK_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06E, .hex);
pub const TLS1_CK_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06F, .hex);
pub const TLS1_RFC_RSA_WITH_AES_128_SHA = "TLS_RSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_SHA = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_SHA = "TLS_DHE_RSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_AES_128_SHA = "TLS_DH_anon_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_RSA_WITH_AES_256_SHA = "TLS_RSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_SHA = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_SHA = "TLS_DHE_RSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_AES_256_SHA = "TLS_DH_anon_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_RSA_WITH_NULL_SHA256 = "TLS_RSA_WITH_NULL_SHA256";
pub const TLS1_RFC_RSA_WITH_AES_128_SHA256 = "TLS_RSA_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_RSA_WITH_AES_256_SHA256 = "TLS_RSA_WITH_AES_256_CBC_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_SHA256 = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_SHA256 = "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_SHA256 = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_SHA256 = "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256";
pub const TLS1_RFC_ADH_WITH_AES_128_SHA256 = "TLS_DH_anon_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_ADH_WITH_AES_256_SHA256 = "TLS_DH_anon_WITH_AES_256_CBC_SHA256";
pub const TLS1_RFC_RSA_WITH_AES_128_GCM_SHA256 = "TLS_RSA_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_RSA_WITH_AES_256_GCM_SHA384 = "TLS_RSA_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_GCM_SHA256 = "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_GCM_SHA384 = "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_GCM_SHA256 = "TLS_DHE_DSS_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_GCM_SHA384 = "TLS_DHE_DSS_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_ADH_WITH_AES_128_GCM_SHA256 = "TLS_DH_anon_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_ADH_WITH_AES_256_GCM_SHA384 = "TLS_DH_anon_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_RSA_WITH_AES_128_CCM = "TLS_RSA_WITH_AES_128_CCM";
pub const TLS1_RFC_RSA_WITH_AES_256_CCM = "TLS_RSA_WITH_AES_256_CCM";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_CCM = "TLS_DHE_RSA_WITH_AES_128_CCM";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_CCM = "TLS_DHE_RSA_WITH_AES_256_CCM";
pub const TLS1_RFC_RSA_WITH_AES_128_CCM_8 = "TLS_RSA_WITH_AES_128_CCM_8";
pub const TLS1_RFC_RSA_WITH_AES_256_CCM_8 = "TLS_RSA_WITH_AES_256_CCM_8";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_CCM_8 = "TLS_DHE_RSA_WITH_AES_128_CCM_8";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_CCM_8 = "TLS_DHE_RSA_WITH_AES_256_CCM_8";
pub const TLS1_RFC_PSK_WITH_AES_128_CCM = "TLS_PSK_WITH_AES_128_CCM";
pub const TLS1_RFC_PSK_WITH_AES_256_CCM = "TLS_PSK_WITH_AES_256_CCM";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CCM = "TLS_DHE_PSK_WITH_AES_128_CCM";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CCM = "TLS_DHE_PSK_WITH_AES_256_CCM";
pub const TLS1_RFC_PSK_WITH_AES_128_CCM_8 = "TLS_PSK_WITH_AES_128_CCM_8";
pub const TLS1_RFC_PSK_WITH_AES_256_CCM_8 = "TLS_PSK_WITH_AES_256_CCM_8";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CCM_8 = "TLS_PSK_DHE_WITH_AES_128_CCM_8";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CCM_8 = "TLS_PSK_DHE_WITH_AES_256_CCM_8";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CCM = "TLS_ECDHE_ECDSA_WITH_AES_128_CCM";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CCM = "TLS_ECDHE_ECDSA_WITH_AES_256_CCM";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CCM_8 = "TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CCM_8 = "TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8";
pub const TLS1_3_RFC_AES_128_GCM_SHA256 = "TLS_AES_128_GCM_SHA256";
pub const TLS1_3_RFC_AES_256_GCM_SHA384 = "TLS_AES_256_GCM_SHA384";
pub const TLS1_3_RFC_CHACHA20_POLY1305_SHA256 = "TLS_CHACHA20_POLY1305_SHA256";
pub const TLS1_3_RFC_SHA256_SHA256 = "TLS_SHA256_SHA256";
pub const TLS1_3_RFC_SHA384_SHA384 = "TLS_SHA384_SHA384";
pub const TLS1_3_RFC_AES_128_CCM_SHA256 = "TLS_AES_128_CCM_SHA256";
pub const TLS1_3_RFC_AES_128_CCM_8_SHA256 = "TLS_AES_128_CCM_8_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_NULL_SHA = "TLS_ECDHE_ECDSA_WITH_NULL_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA = "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_NULL_SHA = "TLS_ECDHE_RSA_WITH_NULL_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_DES_192_CBC3_SHA = "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_CBC_SHA = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_CBC_SHA = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_NULL_SHA = "TLS_ECDH_anon_WITH_NULL_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_DES_192_CBC3_SHA = "TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_AES_128_CBC_SHA = "TLS_ECDH_anon_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_AES_256_CBC_SHA = "TLS_ECDH_anon_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_SHA256 = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_SHA384 = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_SHA256 = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_SHA384 = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_PSK_WITH_NULL_SHA = "TLS_PSK_WITH_NULL_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA = "TLS_DHE_PSK_WITH_NULL_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA = "TLS_RSA_PSK_WITH_NULL_SHA";
pub const TLS1_RFC_PSK_WITH_3DES_EDE_CBC_SHA = "TLS_PSK_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_PSK_WITH_AES_128_CBC_SHA = "TLS_PSK_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_PSK_WITH_AES_256_CBC_SHA = "TLS_PSK_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_3DES_EDE_CBC_SHA = "TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CBC_SHA = "TLS_DHE_PSK_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CBC_SHA = "TLS_DHE_PSK_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_3DES_EDE_CBC_SHA = "TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_CBC_SHA = "TLS_RSA_PSK_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_CBC_SHA = "TLS_RSA_PSK_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_PSK_WITH_AES_128_GCM_SHA256 = "TLS_PSK_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_PSK_WITH_AES_256_GCM_SHA384 = "TLS_PSK_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_GCM_SHA256 = "TLS_DHE_PSK_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_GCM_SHA384 = "TLS_DHE_PSK_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_GCM_SHA256 = "TLS_RSA_PSK_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_GCM_SHA384 = "TLS_RSA_PSK_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_PSK_WITH_AES_128_CBC_SHA256 = "TLS_PSK_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_PSK_WITH_AES_256_CBC_SHA384 = "TLS_PSK_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_PSK_WITH_NULL_SHA256 = "TLS_PSK_WITH_NULL_SHA256";
pub const TLS1_RFC_PSK_WITH_NULL_SHA384 = "TLS_PSK_WITH_NULL_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CBC_SHA256 = "TLS_DHE_PSK_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CBC_SHA384 = "TLS_DHE_PSK_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA256 = "TLS_DHE_PSK_WITH_NULL_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA384 = "TLS_DHE_PSK_WITH_NULL_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_CBC_SHA256 = "TLS_RSA_PSK_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_CBC_SHA384 = "TLS_RSA_PSK_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA256 = "TLS_RSA_PSK_WITH_NULL_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA384 = "TLS_RSA_PSK_WITH_NULL_SHA384";
pub const TLS1_RFC_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = "TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_128_CBC_SHA = "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_256_CBC_SHA = "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA = "TLS_ECDHE_PSK_WITH_NULL_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA256 = "TLS_ECDHE_PSK_WITH_NULL_SHA256";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA384 = "TLS_ECDHE_PSK_WITH_NULL_SHA384";
pub const TLS1_RFC_SRP_SHA_WITH_3DES_EDE_CBC_SHA = "TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = "TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = "TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_WITH_AES_128_CBC_SHA = "TLS_SRP_SHA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = "TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = "TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_WITH_AES_256_CBC_SHA = "TLS_SRP_SHA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = "TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = "TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_CHACHA20_POLY1305 = "TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_CHACHA20_POLY1305 = "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_PSK_WITH_CHACHA20_POLY1305 = "TLS_PSK_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_ECDHE_PSK_WITH_CHACHA20_POLY1305 = "TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_CHACHA20_POLY1305 = "TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_CHACHA20_POLY1305 = "TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = "TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_256_CBC_SHA256 = "TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_256_CBC_SHA = "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = "TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = "TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_256_CBC_SHA = "TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_128_CBC_SHA = "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = "TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = "TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_128_CBC_SHA = "TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_RSA_WITH_SEED_SHA = "TLS_RSA_WITH_SEED_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_SEED_SHA = "TLS_DHE_DSS_WITH_SEED_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_SEED_SHA = "TLS_DHE_RSA_WITH_SEED_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_SEED_SHA = "TLS_DH_anon_WITH_SEED_CBC_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_RC4_128_SHA = "TLS_ECDHE_PSK_WITH_RC4_128_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_RC4_128_SHA = "TLS_ECDH_anon_WITH_RC4_128_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_RC4_128_SHA = "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_RC4_128_SHA = "TLS_ECDHE_RSA_WITH_RC4_128_SHA";
pub const TLS1_RFC_PSK_WITH_RC4_128_SHA = "TLS_PSK_WITH_RC4_128_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_RC4_128_SHA = "TLS_RSA_PSK_WITH_RC4_128_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_RC4_128_SHA = "TLS_DHE_PSK_WITH_RC4_128_SHA";
pub const TLS1_RFC_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DH_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DH_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = "TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = "TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DH_DSS_WITH_ARIA_128_GCM_SHA256 = "TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DH_DSS_WITH_ARIA_256_GCM_SHA384 = "TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DH_anon_WITH_ARIA_128_GCM_SHA256 = "TLS_DH_anon_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DH_anon_WITH_ARIA_256_GCM_SHA384 = "TLS_DH_anon_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = "TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = "TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = "TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = "TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_PSK_WITH_ARIA_128_GCM_SHA256 = "TLS_PSK_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_PSK_WITH_ARIA_256_GCM_SHA384 = "TLS_PSK_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = "TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = "TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = "TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = "TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_TXT_DHE_DSS_WITH_RC4_128_SHA = "DHE-DSS-RC4-SHA";
pub const TLS1_TXT_PSK_WITH_NULL_SHA = "PSK-NULL-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA = "DHE-PSK-NULL-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA = "RSA-PSK-NULL-SHA";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA = "AES128-SHA";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA = "DH-DSS-AES128-SHA";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA = "DH-RSA-AES128-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA = "DHE-DSS-AES128-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA = "DHE-RSA-AES128-SHA";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA = "ADH-AES128-SHA";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA = "AES256-SHA";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA = "DH-DSS-AES256-SHA";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA = "DH-RSA-AES256-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA = "DHE-DSS-AES256-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA = "DHE-RSA-AES256-SHA";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA = "ADH-AES256-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_NULL_SHA = "ECDH-ECDSA-NULL-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_RC4_128_SHA = "ECDH-ECDSA-RC4-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_DES_192_CBC3_SHA = "ECDH-ECDSA-DES-CBC3-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_CBC_SHA = "ECDH-ECDSA-AES128-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_CBC_SHA = "ECDH-ECDSA-AES256-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_NULL_SHA = "ECDHE-ECDSA-NULL-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_RC4_128_SHA = "ECDHE-ECDSA-RC4-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA = "ECDHE-ECDSA-DES-CBC3-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = "ECDHE-ECDSA-AES128-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = "ECDHE-ECDSA-AES256-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_NULL_SHA = "ECDH-RSA-NULL-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_RC4_128_SHA = "ECDH-RSA-RC4-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_DES_192_CBC3_SHA = "ECDH-RSA-DES-CBC3-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_CBC_SHA = "ECDH-RSA-AES128-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_CBC_SHA = "ECDH-RSA-AES256-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_NULL_SHA = "ECDHE-RSA-NULL-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_RC4_128_SHA = "ECDHE-RSA-RC4-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA = "ECDHE-RSA-DES-CBC3-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA = "ECDHE-RSA-AES128-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_CBC_SHA = "ECDHE-RSA-AES256-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_NULL_SHA = "AECDH-NULL-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_RC4_128_SHA = "AECDH-RC4-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_DES_192_CBC3_SHA = "AECDH-DES-CBC3-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_AES_128_CBC_SHA = "AECDH-AES128-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_AES_256_CBC_SHA = "AECDH-AES256-SHA";
pub const TLS1_TXT_PSK_WITH_RC4_128_SHA = "PSK-RC4-SHA";
pub const TLS1_TXT_PSK_WITH_3DES_EDE_CBC_SHA = "PSK-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA = "PSK-AES128-CBC-SHA";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA = "PSK-AES256-CBC-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_RC4_128_SHA = "DHE-PSK-RC4-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_3DES_EDE_CBC_SHA = "DHE-PSK-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CBC_SHA = "DHE-PSK-AES128-CBC-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CBC_SHA = "DHE-PSK-AES256-CBC-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_RC4_128_SHA = "RSA-PSK-RC4-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_3DES_EDE_CBC_SHA = "RSA-PSK-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_CBC_SHA = "RSA-PSK-AES128-CBC-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_CBC_SHA = "RSA-PSK-AES256-CBC-SHA";
pub const TLS1_TXT_PSK_WITH_AES_128_GCM_SHA256 = "PSK-AES128-GCM-SHA256";
pub const TLS1_TXT_PSK_WITH_AES_256_GCM_SHA384 = "PSK-AES256-GCM-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_GCM_SHA256 = "DHE-PSK-AES128-GCM-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_GCM_SHA384 = "DHE-PSK-AES256-GCM-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_GCM_SHA256 = "RSA-PSK-AES128-GCM-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_GCM_SHA384 = "RSA-PSK-AES256-GCM-SHA384";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA256 = "PSK-AES128-CBC-SHA256";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA384 = "PSK-AES256-CBC-SHA384";
pub const TLS1_TXT_PSK_WITH_NULL_SHA256 = "PSK-NULL-SHA256";
pub const TLS1_TXT_PSK_WITH_NULL_SHA384 = "PSK-NULL-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CBC_SHA256 = "DHE-PSK-AES128-CBC-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CBC_SHA384 = "DHE-PSK-AES256-CBC-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA256 = "DHE-PSK-NULL-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA384 = "DHE-PSK-NULL-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_CBC_SHA256 = "RSA-PSK-AES128-CBC-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_CBC_SHA384 = "RSA-PSK-AES256-CBC-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA256 = "RSA-PSK-NULL-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA384 = "RSA-PSK-NULL-SHA384";
pub const TLS1_TXT_SRP_SHA_WITH_3DES_EDE_CBC_SHA = "SRP-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = "SRP-RSA-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = "SRP-DSS-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_WITH_AES_128_CBC_SHA = "SRP-AES-128-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = "SRP-RSA-AES-128-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = "SRP-DSS-AES-128-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_WITH_AES_256_CBC_SHA = "SRP-AES-256-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = "SRP-RSA-AES-256-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = "SRP-DSS-AES-256-CBC-SHA";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA = "CAMELLIA128-SHA";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = "DH-DSS-CAMELLIA128-SHA";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = "DH-RSA-CAMELLIA128-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = "DHE-DSS-CAMELLIA128-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = "DHE-RSA-CAMELLIA128-SHA";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA = "ADH-CAMELLIA128-SHA";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA = "CAMELLIA256-SHA";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = "DH-DSS-CAMELLIA256-SHA";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = "DH-RSA-CAMELLIA256-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = "DHE-DSS-CAMELLIA256-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = "DHE-RSA-CAMELLIA256-SHA";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA = "ADH-CAMELLIA256-SHA";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "CAMELLIA128-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = "DH-DSS-CAMELLIA128-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "DH-RSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = "DHE-DSS-CAMELLIA128-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "DHE-RSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA256 = "ADH-CAMELLIA128-SHA256";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "CAMELLIA256-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = "DH-DSS-CAMELLIA256-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "DH-RSA-CAMELLIA256-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = "DHE-DSS-CAMELLIA256-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "DHE-RSA-CAMELLIA256-SHA256";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA256 = "ADH-CAMELLIA256-SHA256";
pub const TLS1_TXT_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "PSK-CAMELLIA128-SHA256";
pub const TLS1_TXT_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "PSK-CAMELLIA256-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "DHE-PSK-CAMELLIA128-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "DHE-PSK-CAMELLIA256-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "RSA-PSK-CAMELLIA128-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "RSA-PSK-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "ECDHE-PSK-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "ECDHE-PSK-CAMELLIA256-SHA384";
pub const TLS1_TXT_RSA_WITH_SEED_SHA = "SEED-SHA";
pub const TLS1_TXT_DH_DSS_WITH_SEED_SHA = "DH-DSS-SEED-SHA";
pub const TLS1_TXT_DH_RSA_WITH_SEED_SHA = "DH-RSA-SEED-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_SEED_SHA = "DHE-DSS-SEED-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_SEED_SHA = "DHE-RSA-SEED-SHA";
pub const TLS1_TXT_ADH_WITH_SEED_SHA = "ADH-SEED-SHA";
pub const TLS1_TXT_RSA_WITH_NULL_SHA256 = "NULL-SHA256";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA256 = "AES128-SHA256";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA256 = "AES256-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA256 = "DH-DSS-AES128-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA256 = "DH-RSA-AES128-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA256 = "DHE-DSS-AES128-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA256 = "DHE-RSA-AES128-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA256 = "DH-DSS-AES256-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA256 = "DH-RSA-AES256-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA256 = "DHE-DSS-AES256-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA256 = "DHE-RSA-AES256-SHA256";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA256 = "ADH-AES128-SHA256";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA256 = "ADH-AES256-SHA256";
pub const TLS1_TXT_RSA_WITH_AES_128_GCM_SHA256 = "AES128-GCM-SHA256";
pub const TLS1_TXT_RSA_WITH_AES_256_GCM_SHA384 = "AES256-GCM-SHA384";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256 = "DHE-RSA-AES128-GCM-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_GCM_SHA384 = "DHE-RSA-AES256-GCM-SHA384";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_GCM_SHA256 = "DH-RSA-AES128-GCM-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_GCM_SHA384 = "DH-RSA-AES256-GCM-SHA384";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_GCM_SHA256 = "DHE-DSS-AES128-GCM-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_GCM_SHA384 = "DHE-DSS-AES256-GCM-SHA384";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_GCM_SHA256 = "DH-DSS-AES128-GCM-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_GCM_SHA384 = "DH-DSS-AES256-GCM-SHA384";
pub const TLS1_TXT_ADH_WITH_AES_128_GCM_SHA256 = "ADH-AES128-GCM-SHA256";
pub const TLS1_TXT_ADH_WITH_AES_256_GCM_SHA384 = "ADH-AES256-GCM-SHA384";
pub const TLS1_TXT_RSA_WITH_AES_128_CCM = "AES128-CCM";
pub const TLS1_TXT_RSA_WITH_AES_256_CCM = "AES256-CCM";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_CCM = "DHE-RSA-AES128-CCM";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_CCM = "DHE-RSA-AES256-CCM";
pub const TLS1_TXT_RSA_WITH_AES_128_CCM_8 = "AES128-CCM8";
pub const TLS1_TXT_RSA_WITH_AES_256_CCM_8 = "AES256-CCM8";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_CCM_8 = "DHE-RSA-AES128-CCM8";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_CCM_8 = "DHE-RSA-AES256-CCM8";
pub const TLS1_TXT_PSK_WITH_AES_128_CCM = "PSK-AES128-CCM";
pub const TLS1_TXT_PSK_WITH_AES_256_CCM = "PSK-AES256-CCM";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CCM = "DHE-PSK-AES128-CCM";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CCM = "DHE-PSK-AES256-CCM";
pub const TLS1_TXT_PSK_WITH_AES_128_CCM_8 = "PSK-AES128-CCM8";
pub const TLS1_TXT_PSK_WITH_AES_256_CCM_8 = "PSK-AES256-CCM8";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CCM_8 = "DHE-PSK-AES128-CCM8";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CCM_8 = "DHE-PSK-AES256-CCM8";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM = "ECDHE-ECDSA-AES128-CCM";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CCM = "ECDHE-ECDSA-AES256-CCM";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM_8 = "ECDHE-ECDSA-AES128-CCM8";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CCM_8 = "ECDHE-ECDSA-AES256-CCM8";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_SHA256 = "ECDHE-ECDSA-AES128-SHA256";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_SHA384 = "ECDHE-ECDSA-AES256-SHA384";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_SHA256 = "ECDH-ECDSA-AES128-SHA256";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_SHA384 = "ECDH-ECDSA-AES256-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_SHA256 = "ECDHE-RSA-AES128-SHA256";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_SHA384 = "ECDHE-RSA-AES256-SHA384";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_SHA256 = "ECDH-RSA-AES128-SHA256";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_SHA384 = "ECDH-RSA-AES256-SHA384";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = "ECDHE-ECDSA-AES128-GCM-SHA256";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = "ECDHE-ECDSA-AES256-GCM-SHA384";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = "ECDH-ECDSA-AES128-GCM-SHA256";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = "ECDH-ECDSA-AES256-GCM-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = "ECDHE-RSA-AES128-GCM-SHA256";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = "ECDHE-RSA-AES256-GCM-SHA384";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_GCM_SHA256 = "ECDH-RSA-AES128-GCM-SHA256";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_GCM_SHA384 = "ECDH-RSA-AES256-GCM-SHA384";
pub const TLS1_TXT_ECDHE_PSK_WITH_RC4_128_SHA = "ECDHE-PSK-RC4-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = "ECDHE-PSK-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_128_CBC_SHA = "ECDHE-PSK-AES128-CBC-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_256_CBC_SHA = "ECDHE-PSK-AES256-CBC-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = "ECDHE-PSK-AES128-CBC-SHA256";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = "ECDHE-PSK-AES256-CBC-SHA384";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA = "ECDHE-PSK-NULL-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA256 = "ECDHE-PSK-NULL-SHA256";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA384 = "ECDHE-PSK-NULL-SHA384";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = "ECDHE-ECDSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = "ECDHE-ECDSA-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = "ECDH-ECDSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = "ECDH-ECDSA-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "ECDHE-RSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = "ECDHE-RSA-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "ECDH-RSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = "ECDH-RSA-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_CHACHA20_POLY1305 = "ECDHE-RSA-CHACHA20-POLY1305";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = "ECDHE-ECDSA-CHACHA20-POLY1305";
pub const TLS1_TXT_DHE_RSA_WITH_CHACHA20_POLY1305 = "DHE-RSA-CHACHA20-POLY1305";
pub const TLS1_TXT_PSK_WITH_CHACHA20_POLY1305 = "PSK-CHACHA20-POLY1305";
pub const TLS1_TXT_ECDHE_PSK_WITH_CHACHA20_POLY1305 = "ECDHE-PSK-CHACHA20-POLY1305";
pub const TLS1_TXT_DHE_PSK_WITH_CHACHA20_POLY1305 = "DHE-PSK-CHACHA20-POLY1305";
pub const TLS1_TXT_RSA_PSK_WITH_CHACHA20_POLY1305 = "RSA-PSK-CHACHA20-POLY1305";
pub const TLS1_TXT_RSA_WITH_ARIA_128_GCM_SHA256 = "ARIA128-GCM-SHA256";
pub const TLS1_TXT_RSA_WITH_ARIA_256_GCM_SHA384 = "ARIA256-GCM-SHA384";
pub const TLS1_TXT_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = "DHE-RSA-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = "DHE-RSA-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DH_RSA_WITH_ARIA_128_GCM_SHA256 = "DH-RSA-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_ARIA_256_GCM_SHA384 = "DH-RSA-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = "DHE-DSS-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = "DHE-DSS-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DH_DSS_WITH_ARIA_128_GCM_SHA256 = "DH-DSS-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_ARIA_256_GCM_SHA384 = "DH-DSS-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DH_anon_WITH_ARIA_128_GCM_SHA256 = "ADH-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DH_anon_WITH_ARIA_256_GCM_SHA384 = "ADH-ARIA256-GCM-SHA384";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = "ECDHE-ECDSA-ARIA128-GCM-SHA256";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = "ECDHE-ECDSA-ARIA256-GCM-SHA384";
pub const TLS1_TXT_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = "ECDH-ECDSA-ARIA128-GCM-SHA256";
pub const TLS1_TXT_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = "ECDH-ECDSA-ARIA256-GCM-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = "ECDHE-ARIA128-GCM-SHA256";
pub const TLS1_TXT_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = "ECDHE-ARIA256-GCM-SHA384";
pub const TLS1_TXT_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = "ECDH-ARIA128-GCM-SHA256";
pub const TLS1_TXT_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = "ECDH-ARIA256-GCM-SHA384";
pub const TLS1_TXT_PSK_WITH_ARIA_128_GCM_SHA256 = "PSK-ARIA128-GCM-SHA256";
pub const TLS1_TXT_PSK_WITH_ARIA_256_GCM_SHA384 = "PSK-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = "DHE-PSK-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = "DHE-PSK-ARIA256-GCM-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = "RSA-PSK-ARIA128-GCM-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = "RSA-PSK-ARIA256-GCM-SHA384";
pub const TLS_CT_RSA_SIGN = @as(c_int, 1);
pub const TLS_CT_DSS_SIGN = @as(c_int, 2);
pub const TLS_CT_RSA_FIXED_DH = @as(c_int, 3);
pub const TLS_CT_DSS_FIXED_DH = @as(c_int, 4);
pub const TLS_CT_ECDSA_SIGN = @as(c_int, 64);
pub const TLS_CT_RSA_FIXED_ECDH = @as(c_int, 65);
pub const TLS_CT_ECDSA_FIXED_ECDH = @as(c_int, 66);
pub const TLS_CT_GOST01_SIGN = @as(c_int, 22);
pub const TLS_CT_GOST12_IANA_SIGN = @as(c_int, 67);
pub const TLS_CT_GOST12_IANA_512_SIGN = @as(c_int, 68);
pub const TLS_CT_GOST12_LEGACY_SIGN = @as(c_int, 238);
pub const TLS_CT_GOST12_LEGACY_512_SIGN = @as(c_int, 239);
pub const TLS_CT_GOST12_SIGN = TLS_CT_GOST12_LEGACY_SIGN;
pub const TLS_CT_GOST12_512_SIGN = TLS_CT_GOST12_LEGACY_512_SIGN;
pub const TLS_CT_NUMBER = @as(c_int, 12);
pub const TLS1_FINISH_MAC_LENGTH = @as(c_int, 12);
pub const TLS_MD_MAX_CONST_SIZE = @as(c_int, 22);
pub const TLS_MD_CLIENT_FINISH_CONST = "\x63\x6c\x69\x65\x6e\x74\x20\x66\x69\x6e\x69\x73\x68\x65\x64";
pub const TLS_MD_CLIENT_FINISH_CONST_SIZE = @as(c_int, 15);
pub const TLS_MD_SERVER_FINISH_CONST = "\x73\x65\x72\x76\x65\x72\x20\x66\x69\x6e\x69\x73\x68\x65\x64";
pub const TLS_MD_SERVER_FINISH_CONST_SIZE = @as(c_int, 15);
pub const TLS_MD_SERVER_WRITE_KEY_CONST = "\x73\x65\x72\x76\x65\x72\x20\x77\x72\x69\x74\x65\x20\x6b\x65\x79";
pub const TLS_MD_SERVER_WRITE_KEY_CONST_SIZE = @as(c_int, 16);
pub const TLS_MD_KEY_EXPANSION_CONST = "\x6b\x65\x79\x20\x65\x78\x70\x61\x6e\x73\x69\x6f\x6e";
pub const TLS_MD_KEY_EXPANSION_CONST_SIZE = @as(c_int, 13);
pub const TLS_MD_CLIENT_WRITE_KEY_CONST = "\x63\x6c\x69\x65\x6e\x74\x20\x77\x72\x69\x74\x65\x20\x6b\x65\x79";
pub const TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE = @as(c_int, 16);
pub const TLS_MD_IV_BLOCK_CONST = "\x49\x56\x20\x62\x6c\x6f\x63\x6b";
pub const TLS_MD_IV_BLOCK_CONST_SIZE = @as(c_int, 8);
pub const TLS_MD_MASTER_SECRET_CONST = "\x6d\x61\x73\x74\x65\x72\x20\x73\x65\x63\x72\x65\x74";
pub const TLS_MD_MASTER_SECRET_CONST_SIZE = @as(c_int, 13);
pub const TLS_MD_EXTENDED_MASTER_SECRET_CONST = "\x65\x78\x74\x65\x6e\x64\x65\x64\x20\x6d\x61\x73\x74\x65\x72\x20\x73\x65\x63\x72\x65\x74";
pub const TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE = @as(c_int, 22);
pub const OPENSSL_DTLS1_H = "";
pub const HEADER_DTLS1_H = "";
pub const DTLS_MIN_VERSION = DTLS1_VERSION;
pub const DTLS_MAX_VERSION = DTLS1_2_VERSION;
pub const DTLS1_VERSION_MAJOR = @as(c_int, 0xFE);
pub const DTLS_ANY_VERSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1FFFF, .hex);
pub const DTLS1_COOKIE_LENGTH = @as(c_int, 255);
pub const DTLS1_RT_HEADER_LENGTH = @as(c_int, 13);
pub const DTLS1_HM_HEADER_LENGTH = @as(c_int, 12);
pub const DTLS1_HM_BAD_FRAGMENT = -@as(c_int, 2);
pub const DTLS1_HM_FRAGMENT_RETRY = -@as(c_int, 3);
pub const DTLS1_CCS_HEADER_LENGTH = @as(c_int, 1);
pub const DTLS1_AL_HEADER_LENGTH = @as(c_int, 2);
pub const DTLS1_TMO_ALERT_COUNT = @as(c_int, 12);
pub const OPENSSL_SRTP_H = "";
pub const HEADER_D1_SRTP_H = "";
pub const SRTP_AES128_CM_SHA1_80 = @as(c_int, 0x0001);
pub const SRTP_AES128_CM_SHA1_32 = @as(c_int, 0x0002);
pub const SRTP_AES128_F8_SHA1_80 = @as(c_int, 0x0003);
pub const SRTP_AES128_F8_SHA1_32 = @as(c_int, 0x0004);
pub const SRTP_NULL_SHA1_80 = @as(c_int, 0x0005);
pub const SRTP_NULL_SHA1_32 = @as(c_int, 0x0006);
pub const SRTP_AEAD_AES_128_GCM = @as(c_int, 0x0007);
pub const SRTP_AEAD_AES_256_GCM = @as(c_int, 0x0008);
pub const SRTP_DOUBLE_AEAD_AES_128_GCM_AEAD_AES_128_GCM = @as(c_int, 0x0009);
pub const SRTP_DOUBLE_AEAD_AES_256_GCM_AEAD_AES_256_GCM = @as(c_int, 0x000A);
pub const SRTP_ARIA_128_CTR_HMAC_SHA1_80 = @as(c_int, 0x000B);
pub const SRTP_ARIA_128_CTR_HMAC_SHA1_32 = @as(c_int, 0x000C);
pub const SRTP_ARIA_256_CTR_HMAC_SHA1_80 = @as(c_int, 0x000D);
pub const SRTP_ARIA_256_CTR_HMAC_SHA1_32 = @as(c_int, 0x000E);
pub const SRTP_AEAD_ARIA_128_GCM = @as(c_int, 0x000F);
pub const SRTP_AEAD_ARIA_256_GCM = @as(c_int, 0x0010);
pub const OPENSSL_QUIC_H = "";
pub const OSSL_QUIC_ERR_NO_ERROR = @as(c_int, 0x00);
pub const OSSL_QUIC_ERR_INTERNAL_ERROR = @as(c_int, 0x01);
pub const OSSL_QUIC_ERR_CONNECTION_REFUSED = @as(c_int, 0x02);
pub const OSSL_QUIC_ERR_FLOW_CONTROL_ERROR = @as(c_int, 0x03);
pub const OSSL_QUIC_ERR_STREAM_LIMIT_ERROR = @as(c_int, 0x04);
pub const OSSL_QUIC_ERR_STREAM_STATE_ERROR = @as(c_int, 0x05);
pub const OSSL_QUIC_ERR_FINAL_SIZE_ERROR = @as(c_int, 0x06);
pub const OSSL_QUIC_ERR_FRAME_ENCODING_ERROR = @as(c_int, 0x07);
pub const OSSL_QUIC_ERR_TRANSPORT_PARAMETER_ERROR = @as(c_int, 0x08);
pub const OSSL_QUIC_ERR_CONNECTION_ID_LIMIT_ERROR = @as(c_int, 0x09);
pub const OSSL_QUIC_ERR_PROTOCOL_VIOLATION = @as(c_int, 0x0A);
pub const OSSL_QUIC_ERR_INVALID_TOKEN = @as(c_int, 0x0B);
pub const OSSL_QUIC_ERR_APPLICATION_ERROR = @as(c_int, 0x0C);
pub const OSSL_QUIC_ERR_CRYPTO_BUFFER_EXCEEDED = @as(c_int, 0x0D);
pub const OSSL_QUIC_ERR_KEY_UPDATE_ERROR = @as(c_int, 0x0E);
pub const OSSL_QUIC_ERR_AEAD_LIMIT_REACHED = @as(c_int, 0x0F);
pub const OSSL_QUIC_ERR_NO_VIABLE_PATH = @as(c_int, 0x10);
pub const OSSL_QUIC_ERR_CRYPTO_ERR_BEGIN = @as(c_int, 0x0100);
pub const OSSL_QUIC_ERR_CRYPTO_ERR_END = @as(c_int, 0x01FF);
pub inline fn OSSL_QUIC_ERR_CRYPTO_ERR(X: anytype) @TypeOf(OSSL_QUIC_ERR_CRYPTO_ERR_BEGIN + X) {
    _ = &X;
    return OSSL_QUIC_ERR_CRYPTO_ERR_BEGIN + X;
}
pub const OSSL_QUIC_LOCAL_ERR_IDLE_TIMEOUT = @import("std").zig.c_translation.cast(u64, @as(c_ulonglong, 0xFFFFFFFFFFFFFFFF));
pub inline fn sk_SSL_CIPHER_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_SSL_CIPHER_sk_type(sk));
}
pub const sk_SSL_CIPHER_value = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1000:9
pub const sk_SSL_CIPHER_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1001:9
pub const sk_SSL_CIPHER_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1002:9
pub const sk_SSL_CIPHER_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1003:9
pub inline fn sk_SSL_CIPHER_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_SSL_CIPHER_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_SSL_CIPHER_sk_type(sk), n);
}
pub inline fn sk_SSL_CIPHER_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_SSL_CIPHER_sk_type(sk));
}
pub inline fn sk_SSL_CIPHER_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_SSL_CIPHER_sk_type(sk));
}
pub const sk_SSL_CIPHER_delete = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1007:9
pub const sk_SSL_CIPHER_delete_ptr = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1008:9
pub inline fn sk_SSL_CIPHER_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr));
}
pub inline fn sk_SSL_CIPHER_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr));
}
pub const sk_SSL_CIPHER_pop = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1011:9
pub const sk_SSL_CIPHER_shift = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1012:9
pub inline fn sk_SSL_CIPHER_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_freefunc_type(freefunc));
}
pub inline fn sk_SSL_CIPHER_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr), idx);
}
pub const sk_SSL_CIPHER_set = @compileError("unable to translate C expr: unexpected token 'const'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1015:9
pub inline fn sk_SSL_CIPHER_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr));
}
pub inline fn sk_SSL_CIPHER_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr));
}
pub inline fn sk_SSL_CIPHER_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr), pnum);
}
pub inline fn sk_SSL_CIPHER_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_SSL_CIPHER_sk_type(sk));
}
pub inline fn sk_SSL_CIPHER_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_SSL_CIPHER_sk_type(sk));
}
pub const sk_SSL_CIPHER_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1021:9
pub const sk_SSL_CIPHER_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1022:9
pub inline fn sk_SSL_CIPHER_set_cmp_func(sk: anytype, cmp: anytype) sk_SSL_CIPHER_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_SSL_CIPHER_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_compfunc_type(cmp)));
}
pub inline fn SSL_set_app_data(s: anytype, arg: anytype) @TypeOf(SSL_set_ex_data(s, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, arg))) {
    _ = &s;
    _ = &arg;
    return SSL_set_ex_data(s, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, arg));
}
pub inline fn SSL_get_app_data(s: anytype) @TypeOf(SSL_get_ex_data(s, @as(c_int, 0))) {
    _ = &s;
    return SSL_get_ex_data(s, @as(c_int, 0));
}
pub inline fn SSL_SESSION_set_app_data(s: anytype, a: anytype) @TypeOf(SSL_SESSION_set_ex_data(s, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, a))) {
    _ = &s;
    _ = &a;
    return SSL_SESSION_set_ex_data(s, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, a));
}
pub inline fn SSL_SESSION_get_app_data(s: anytype) @TypeOf(SSL_SESSION_get_ex_data(s, @as(c_int, 0))) {
    _ = &s;
    return SSL_SESSION_get_ex_data(s, @as(c_int, 0));
}
pub inline fn SSL_CTX_get_app_data(ctx: anytype) @TypeOf(SSL_CTX_get_ex_data(ctx, @as(c_int, 0))) {
    _ = &ctx;
    return SSL_CTX_get_ex_data(ctx, @as(c_int, 0));
}
pub inline fn SSL_CTX_set_app_data(ctx: anytype, arg: anytype) @TypeOf(SSL_CTX_set_ex_data(ctx, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, arg))) {
    _ = &ctx;
    _ = &arg;
    return SSL_CTX_set_ex_data(ctx, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, arg));
}
pub const SSL_KEY_UPDATE_NONE = -@as(c_int, 1);
pub const SSL_KEY_UPDATE_NOT_REQUESTED = @as(c_int, 0);
pub const SSL_KEY_UPDATE_REQUESTED = @as(c_int, 1);
pub const SSL_ST_CONNECT = @as(c_int, 0x1000);
pub const SSL_ST_ACCEPT = @as(c_int, 0x2000);
pub const SSL_ST_MASK = @as(c_int, 0x0FFF);
pub const SSL_CB_LOOP = @as(c_int, 0x01);
pub const SSL_CB_EXIT = @as(c_int, 0x02);
pub const SSL_CB_READ = @as(c_int, 0x04);
pub const SSL_CB_WRITE = @as(c_int, 0x08);
pub const SSL_CB_ALERT = @as(c_int, 0x4000);
pub const SSL_CB_READ_ALERT = SSL_CB_ALERT | SSL_CB_READ;
pub const SSL_CB_WRITE_ALERT = SSL_CB_ALERT | SSL_CB_WRITE;
pub const SSL_CB_ACCEPT_LOOP = SSL_ST_ACCEPT | SSL_CB_LOOP;
pub const SSL_CB_ACCEPT_EXIT = SSL_ST_ACCEPT | SSL_CB_EXIT;
pub const SSL_CB_CONNECT_LOOP = SSL_ST_CONNECT | SSL_CB_LOOP;
pub const SSL_CB_CONNECT_EXIT = SSL_ST_CONNECT | SSL_CB_EXIT;
pub const SSL_CB_HANDSHAKE_START = @as(c_int, 0x10);
pub const SSL_CB_HANDSHAKE_DONE = @as(c_int, 0x20);
pub inline fn SSL_in_connect_init(a: anytype) @TypeOf((SSL_in_init(a) != 0) and !(SSL_is_server(a) != 0)) {
    _ = &a;
    return (SSL_in_init(a) != 0) and !(SSL_is_server(a) != 0);
}
pub inline fn SSL_in_accept_init(a: anytype) @TypeOf((SSL_in_init(a) != 0) and (SSL_is_server(a) != 0)) {
    _ = &a;
    return (SSL_in_init(a) != 0) and (SSL_is_server(a) != 0);
}
pub const SSL_ST_READ_HEADER = @as(c_int, 0xF0);
pub const SSL_ST_READ_BODY = @as(c_int, 0xF1);
pub const SSL_ST_READ_DONE = @as(c_int, 0xF2);
pub const SSL_VERIFY_NONE = @as(c_int, 0x00);
pub const SSL_VERIFY_PEER = @as(c_int, 0x01);
pub const SSL_VERIFY_FAIL_IF_NO_PEER_CERT = @as(c_int, 0x02);
pub const SSL_VERIFY_CLIENT_ONCE = @as(c_int, 0x04);
pub const SSL_VERIFY_POST_HANDSHAKE = @as(c_int, 0x08);
pub inline fn OpenSSL_add_ssl_algorithms() @TypeOf(SSL_library_init()) {
    return SSL_library_init();
}
pub inline fn SSLeay_add_ssl_algorithms() @TypeOf(SSL_library_init()) {
    return SSL_library_init();
}
pub inline fn SSL_get_cipher(s: anytype) @TypeOf(SSL_CIPHER_get_name(SSL_get_current_cipher(s))) {
    _ = &s;
    return SSL_CIPHER_get_name(SSL_get_current_cipher(s));
}
pub inline fn SSL_get_cipher_bits(s: anytype, np: anytype) @TypeOf(SSL_CIPHER_get_bits(SSL_get_current_cipher(s), np)) {
    _ = &s;
    _ = &np;
    return SSL_CIPHER_get_bits(SSL_get_current_cipher(s), np);
}
pub inline fn SSL_get_cipher_version(s: anytype) @TypeOf(SSL_CIPHER_get_version(SSL_get_current_cipher(s))) {
    _ = &s;
    return SSL_CIPHER_get_version(SSL_get_current_cipher(s));
}
pub inline fn SSL_get_cipher_name(s: anytype) @TypeOf(SSL_CIPHER_get_name(SSL_get_current_cipher(s))) {
    _ = &s;
    return SSL_CIPHER_get_name(SSL_get_current_cipher(s));
}
pub inline fn SSL_get_time(a: anytype) @TypeOf(SSL_SESSION_get_time(a)) {
    _ = &a;
    return SSL_SESSION_get_time(a);
}
pub inline fn SSL_set_time(a: anytype, b: anytype) @TypeOf(SSL_SESSION_set_time(a, b)) {
    _ = &a;
    _ = &b;
    return SSL_SESSION_set_time(a, b);
}
pub inline fn SSL_get_timeout(a: anytype) @TypeOf(SSL_SESSION_get_timeout(a)) {
    _ = &a;
    return SSL_SESSION_get_timeout(a);
}
pub inline fn SSL_set_timeout(a: anytype, b: anytype) @TypeOf(SSL_SESSION_set_timeout(a, b)) {
    _ = &a;
    _ = &b;
    return SSL_SESSION_set_timeout(a, b);
}
pub inline fn d2i_SSL_SESSION_bio(bp: anytype, s_id: anytype) @TypeOf(ASN1_d2i_bio_of(SSL_SESSION, SSL_SESSION_new, d2i_SSL_SESSION, bp, s_id)) {
    _ = &bp;
    _ = &s_id;
    return ASN1_d2i_bio_of(SSL_SESSION, SSL_SESSION_new, d2i_SSL_SESSION, bp, s_id);
}
pub inline fn i2d_SSL_SESSION_bio(bp: anytype, s_id: anytype) @TypeOf(ASN1_i2d_bio_of(SSL_SESSION, i2d_SSL_SESSION, bp, s_id)) {
    _ = &bp;
    _ = &s_id;
    return ASN1_i2d_bio_of(SSL_SESSION, i2d_SSL_SESSION, bp, s_id);
}
pub const SSL_AD_REASON_OFFSET = @as(c_int, 1000);
pub const SSL_AD_CLOSE_NOTIFY = SSL3_AD_CLOSE_NOTIFY;
pub const SSL_AD_UNEXPECTED_MESSAGE = SSL3_AD_UNEXPECTED_MESSAGE;
pub const SSL_AD_BAD_RECORD_MAC = SSL3_AD_BAD_RECORD_MAC;
pub const SSL_AD_DECRYPTION_FAILED = TLS1_AD_DECRYPTION_FAILED;
pub const SSL_AD_RECORD_OVERFLOW = TLS1_AD_RECORD_OVERFLOW;
pub const SSL_AD_DECOMPRESSION_FAILURE = SSL3_AD_DECOMPRESSION_FAILURE;
pub const SSL_AD_HANDSHAKE_FAILURE = SSL3_AD_HANDSHAKE_FAILURE;
pub const SSL_AD_NO_CERTIFICATE = SSL3_AD_NO_CERTIFICATE;
pub const SSL_AD_BAD_CERTIFICATE = SSL3_AD_BAD_CERTIFICATE;
pub const SSL_AD_UNSUPPORTED_CERTIFICATE = SSL3_AD_UNSUPPORTED_CERTIFICATE;
pub const SSL_AD_CERTIFICATE_REVOKED = SSL3_AD_CERTIFICATE_REVOKED;
pub const SSL_AD_CERTIFICATE_EXPIRED = SSL3_AD_CERTIFICATE_EXPIRED;
pub const SSL_AD_CERTIFICATE_UNKNOWN = SSL3_AD_CERTIFICATE_UNKNOWN;
pub const SSL_AD_ILLEGAL_PARAMETER = SSL3_AD_ILLEGAL_PARAMETER;
pub const SSL_AD_UNKNOWN_CA = TLS1_AD_UNKNOWN_CA;
pub const SSL_AD_ACCESS_DENIED = TLS1_AD_ACCESS_DENIED;
pub const SSL_AD_DECODE_ERROR = TLS1_AD_DECODE_ERROR;
pub const SSL_AD_DECRYPT_ERROR = TLS1_AD_DECRYPT_ERROR;
pub const SSL_AD_EXPORT_RESTRICTION = TLS1_AD_EXPORT_RESTRICTION;
pub const SSL_AD_PROTOCOL_VERSION = TLS1_AD_PROTOCOL_VERSION;
pub const SSL_AD_INSUFFICIENT_SECURITY = TLS1_AD_INSUFFICIENT_SECURITY;
pub const SSL_AD_INTERNAL_ERROR = TLS1_AD_INTERNAL_ERROR;
pub const SSL_AD_USER_CANCELLED = TLS1_AD_USER_CANCELLED;
pub const SSL_AD_NO_RENEGOTIATION = TLS1_AD_NO_RENEGOTIATION;
pub const SSL_AD_MISSING_EXTENSION = TLS13_AD_MISSING_EXTENSION;
pub const SSL_AD_CERTIFICATE_REQUIRED = TLS13_AD_CERTIFICATE_REQUIRED;
pub const SSL_AD_UNSUPPORTED_EXTENSION = TLS1_AD_UNSUPPORTED_EXTENSION;
pub const SSL_AD_CERTIFICATE_UNOBTAINABLE = TLS1_AD_CERTIFICATE_UNOBTAINABLE;
pub const SSL_AD_UNRECOGNIZED_NAME = TLS1_AD_UNRECOGNIZED_NAME;
pub const SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE = TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE;
pub const SSL_AD_BAD_CERTIFICATE_HASH_VALUE = TLS1_AD_BAD_CERTIFICATE_HASH_VALUE;
pub const SSL_AD_UNKNOWN_PSK_IDENTITY = TLS1_AD_UNKNOWN_PSK_IDENTITY;
pub const SSL_AD_INAPPROPRIATE_FALLBACK = TLS1_AD_INAPPROPRIATE_FALLBACK;
pub const SSL_AD_NO_APPLICATION_PROTOCOL = TLS1_AD_NO_APPLICATION_PROTOCOL;
pub const SSL_ERROR_NONE = @as(c_int, 0);
pub const SSL_ERROR_SSL = @as(c_int, 1);
pub const SSL_ERROR_WANT_READ = @as(c_int, 2);
pub const SSL_ERROR_WANT_WRITE = @as(c_int, 3);
pub const SSL_ERROR_WANT_X509_LOOKUP = @as(c_int, 4);
pub const SSL_ERROR_SYSCALL = @as(c_int, 5);
pub const SSL_ERROR_ZERO_RETURN = @as(c_int, 6);
pub const SSL_ERROR_WANT_CONNECT = @as(c_int, 7);
pub const SSL_ERROR_WANT_ACCEPT = @as(c_int, 8);
pub const SSL_ERROR_WANT_ASYNC = @as(c_int, 9);
pub const SSL_ERROR_WANT_ASYNC_JOB = @as(c_int, 10);
pub const SSL_ERROR_WANT_CLIENT_HELLO_CB = @as(c_int, 11);
pub const SSL_ERROR_WANT_RETRY_VERIFY = @as(c_int, 12);
pub const SSL_CTRL_SET_TMP_DH = @as(c_int, 3);
pub const SSL_CTRL_SET_TMP_ECDH = @as(c_int, 4);
pub const SSL_CTRL_SET_TMP_DH_CB = @as(c_int, 6);
pub const SSL_CTRL_GET_CLIENT_CERT_REQUEST = @as(c_int, 9);
pub const SSL_CTRL_GET_NUM_RENEGOTIATIONS = @as(c_int, 10);
pub const SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS = @as(c_int, 11);
pub const SSL_CTRL_GET_TOTAL_RENEGOTIATIONS = @as(c_int, 12);
pub const SSL_CTRL_GET_FLAGS = @as(c_int, 13);
pub const SSL_CTRL_EXTRA_CHAIN_CERT = @as(c_int, 14);
pub const SSL_CTRL_SET_MSG_CALLBACK = @as(c_int, 15);
pub const SSL_CTRL_SET_MSG_CALLBACK_ARG = @as(c_int, 16);
pub const SSL_CTRL_SET_MTU = @as(c_int, 17);
pub const SSL_CTRL_SESS_NUMBER = @as(c_int, 20);
pub const SSL_CTRL_SESS_CONNECT = @as(c_int, 21);
pub const SSL_CTRL_SESS_CONNECT_GOOD = @as(c_int, 22);
pub const SSL_CTRL_SESS_CONNECT_RENEGOTIATE = @as(c_int, 23);
pub const SSL_CTRL_SESS_ACCEPT = @as(c_int, 24);
pub const SSL_CTRL_SESS_ACCEPT_GOOD = @as(c_int, 25);
pub const SSL_CTRL_SESS_ACCEPT_RENEGOTIATE = @as(c_int, 26);
pub const SSL_CTRL_SESS_HIT = @as(c_int, 27);
pub const SSL_CTRL_SESS_CB_HIT = @as(c_int, 28);
pub const SSL_CTRL_SESS_MISSES = @as(c_int, 29);
pub const SSL_CTRL_SESS_TIMEOUTS = @as(c_int, 30);
pub const SSL_CTRL_SESS_CACHE_FULL = @as(c_int, 31);
pub const SSL_CTRL_MODE = @as(c_int, 33);
pub const SSL_CTRL_GET_READ_AHEAD = @as(c_int, 40);
pub const SSL_CTRL_SET_READ_AHEAD = @as(c_int, 41);
pub const SSL_CTRL_SET_SESS_CACHE_SIZE = @as(c_int, 42);
pub const SSL_CTRL_GET_SESS_CACHE_SIZE = @as(c_int, 43);
pub const SSL_CTRL_SET_SESS_CACHE_MODE = @as(c_int, 44);
pub const SSL_CTRL_GET_SESS_CACHE_MODE = @as(c_int, 45);
pub const SSL_CTRL_GET_MAX_CERT_LIST = @as(c_int, 50);
pub const SSL_CTRL_SET_MAX_CERT_LIST = @as(c_int, 51);
pub const SSL_CTRL_SET_MAX_SEND_FRAGMENT = @as(c_int, 52);
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_CB = @as(c_int, 53);
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG = @as(c_int, 54);
pub const SSL_CTRL_SET_TLSEXT_HOSTNAME = @as(c_int, 55);
pub const SSL_CTRL_SET_TLSEXT_DEBUG_CB = @as(c_int, 56);
pub const SSL_CTRL_SET_TLSEXT_DEBUG_ARG = @as(c_int, 57);
pub const SSL_CTRL_GET_TLSEXT_TICKET_KEYS = @as(c_int, 58);
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEYS = @as(c_int, 59);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB = @as(c_int, 63);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG = @as(c_int, 64);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE = @as(c_int, 65);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS = @as(c_int, 66);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS = @as(c_int, 67);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS = @as(c_int, 68);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS = @as(c_int, 69);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP = @as(c_int, 70);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP = @as(c_int, 71);
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB = @as(c_int, 72);
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB = @as(c_int, 75);
pub const SSL_CTRL_SET_SRP_VERIFY_PARAM_CB = @as(c_int, 76);
pub const SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB = @as(c_int, 77);
pub const SSL_CTRL_SET_SRP_ARG = @as(c_int, 78);
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME = @as(c_int, 79);
pub const SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH = @as(c_int, 80);
pub const SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD = @as(c_int, 81);
pub const DTLS_CTRL_GET_TIMEOUT = @as(c_int, 73);
pub const DTLS_CTRL_HANDLE_TIMEOUT = @as(c_int, 74);
pub const SSL_CTRL_GET_RI_SUPPORT = @as(c_int, 76);
pub const SSL_CTRL_CLEAR_MODE = @as(c_int, 78);
pub const SSL_CTRL_SET_NOT_RESUMABLE_SESS_CB = @as(c_int, 79);
pub const SSL_CTRL_GET_EXTRA_CHAIN_CERTS = @as(c_int, 82);
pub const SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS = @as(c_int, 83);
pub const SSL_CTRL_CHAIN = @as(c_int, 88);
pub const SSL_CTRL_CHAIN_CERT = @as(c_int, 89);
pub const SSL_CTRL_GET_GROUPS = @as(c_int, 90);
pub const SSL_CTRL_SET_GROUPS = @as(c_int, 91);
pub const SSL_CTRL_SET_GROUPS_LIST = @as(c_int, 92);
pub const SSL_CTRL_GET_SHARED_GROUP = @as(c_int, 93);
pub const SSL_CTRL_SET_SIGALGS = @as(c_int, 97);
pub const SSL_CTRL_SET_SIGALGS_LIST = @as(c_int, 98);
pub const SSL_CTRL_CERT_FLAGS = @as(c_int, 99);
pub const SSL_CTRL_CLEAR_CERT_FLAGS = @as(c_int, 100);
pub const SSL_CTRL_SET_CLIENT_SIGALGS = @as(c_int, 101);
pub const SSL_CTRL_SET_CLIENT_SIGALGS_LIST = @as(c_int, 102);
pub const SSL_CTRL_GET_CLIENT_CERT_TYPES = @as(c_int, 103);
pub const SSL_CTRL_SET_CLIENT_CERT_TYPES = @as(c_int, 104);
pub const SSL_CTRL_BUILD_CERT_CHAIN = @as(c_int, 105);
pub const SSL_CTRL_SET_VERIFY_CERT_STORE = @as(c_int, 106);
pub const SSL_CTRL_SET_CHAIN_CERT_STORE = @as(c_int, 107);
pub const SSL_CTRL_GET_PEER_SIGNATURE_NID = @as(c_int, 108);
pub const SSL_CTRL_GET_PEER_TMP_KEY = @as(c_int, 109);
pub const SSL_CTRL_GET_RAW_CIPHERLIST = @as(c_int, 110);
pub const SSL_CTRL_GET_EC_POINT_FORMATS = @as(c_int, 111);
pub const SSL_CTRL_GET_CHAIN_CERTS = @as(c_int, 115);
pub const SSL_CTRL_SELECT_CURRENT_CERT = @as(c_int, 116);
pub const SSL_CTRL_SET_CURRENT_CERT = @as(c_int, 117);
pub const SSL_CTRL_SET_DH_AUTO = @as(c_int, 118);
pub const DTLS_CTRL_SET_LINK_MTU = @as(c_int, 120);
pub const DTLS_CTRL_GET_LINK_MIN_MTU = @as(c_int, 121);
pub const SSL_CTRL_GET_EXTMS_SUPPORT = @as(c_int, 122);
pub const SSL_CTRL_SET_MIN_PROTO_VERSION = @as(c_int, 123);
pub const SSL_CTRL_SET_MAX_PROTO_VERSION = @as(c_int, 124);
pub const SSL_CTRL_SET_SPLIT_SEND_FRAGMENT = @as(c_int, 125);
pub const SSL_CTRL_SET_MAX_PIPELINES = @as(c_int, 126);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE = @as(c_int, 127);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB = @as(c_int, 128);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG = @as(c_int, 129);
pub const SSL_CTRL_GET_MIN_PROTO_VERSION = @as(c_int, 130);
pub const SSL_CTRL_GET_MAX_PROTO_VERSION = @as(c_int, 131);
pub const SSL_CTRL_GET_SIGNATURE_NID = @as(c_int, 132);
pub const SSL_CTRL_GET_TMP_KEY = @as(c_int, 133);
pub const SSL_CTRL_GET_NEGOTIATED_GROUP = @as(c_int, 134);
pub const SSL_CTRL_GET_IANA_GROUPS = @as(c_int, 135);
pub const SSL_CTRL_SET_RETRY_VERIFY = @as(c_int, 136);
pub const SSL_CTRL_GET_VERIFY_CERT_STORE = @as(c_int, 137);
pub const SSL_CTRL_GET_CHAIN_CERT_STORE = @as(c_int, 138);
pub const SSL_CERT_SET_FIRST = @as(c_int, 1);
pub const SSL_CERT_SET_NEXT = @as(c_int, 2);
pub const SSL_CERT_SET_SERVER = @as(c_int, 3);
pub inline fn DTLSv1_get_timeout(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, DTLS_CTRL_GET_TIMEOUT, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, arg))) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, DTLS_CTRL_GET_TIMEOUT, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, arg));
}
pub inline fn DTLSv1_handle_timeout(ssl: anytype) @TypeOf(SSL_ctrl(ssl, DTLS_CTRL_HANDLE_TIMEOUT, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, DTLS_CTRL_HANDLE_TIMEOUT, @as(c_int, 0), NULL);
}
pub inline fn SSL_num_renegotiations(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_NUM_RENEGOTIATIONS, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_NUM_RENEGOTIATIONS, @as(c_int, 0), NULL);
}
pub inline fn SSL_clear_num_renegotiations(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS, @as(c_int, 0), NULL);
}
pub inline fn SSL_total_renegotiations(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TOTAL_RENEGOTIATIONS, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TOTAL_RENEGOTIATIONS, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_tmp_dh(ctx: anytype, dh: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_DH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, dh))) {
    _ = &ctx;
    _ = &dh;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_DH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, dh));
}
pub inline fn SSL_CTX_set_dh_auto(ctx: anytype, onoff: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_DH_AUTO, onoff, NULL)) {
    _ = &ctx;
    _ = &onoff;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_DH_AUTO, onoff, NULL);
}
pub inline fn SSL_set_dh_auto(s: anytype, onoff: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_DH_AUTO, onoff, NULL)) {
    _ = &s;
    _ = &onoff;
    return SSL_ctrl(s, SSL_CTRL_SET_DH_AUTO, onoff, NULL);
}
pub inline fn SSL_set_tmp_dh(ssl: anytype, dh: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TMP_DH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, dh))) {
    _ = &ssl;
    _ = &dh;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TMP_DH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, dh));
}
pub inline fn SSL_CTX_set_tmp_ecdh(ctx: anytype, ecdh: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_ECDH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ecdh))) {
    _ = &ctx;
    _ = &ecdh;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_ECDH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ecdh));
}
pub inline fn SSL_set_tmp_ecdh(ssl: anytype, ecdh: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TMP_ECDH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ecdh))) {
    _ = &ssl;
    _ = &ecdh;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TMP_ECDH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ecdh));
}
pub inline fn SSL_CTX_add_extra_chain_cert(ctx: anytype, x509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_EXTRA_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &ctx;
    _ = &x509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_EXTRA_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_CTX_get_extra_chain_certs(ctx: anytype, px509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_EXTRA_CHAIN_CERTS, @as(c_int, 0), px509)) {
    _ = &ctx;
    _ = &px509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_EXTRA_CHAIN_CERTS, @as(c_int, 0), px509);
}
pub inline fn SSL_CTX_get_extra_chain_certs_only(ctx: anytype, px509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_EXTRA_CHAIN_CERTS, @as(c_int, 1), px509)) {
    _ = &ctx;
    _ = &px509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_EXTRA_CHAIN_CERTS, @as(c_int, 1), px509);
}
pub inline fn SSL_CTX_clear_extra_chain_certs(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set0_chain(ctx: anytype, sk: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sk))) {
    _ = &ctx;
    _ = &sk;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sk));
}
pub inline fn SSL_CTX_set1_chain(ctx: anytype, sk: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, sk))) {
    _ = &ctx;
    _ = &sk;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, sk));
}
pub inline fn SSL_CTX_add0_chain_cert(ctx: anytype, x509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &ctx;
    _ = &x509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_CTX_add1_chain_cert(ctx: anytype, x509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN_CERT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &ctx;
    _ = &x509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN_CERT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_CTX_get0_chain_certs(ctx: anytype, px509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_CHAIN_CERTS, @as(c_int, 0), px509)) {
    _ = &ctx;
    _ = &px509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_CHAIN_CERTS, @as(c_int, 0), px509);
}
pub inline fn SSL_CTX_clear_chain_certs(ctx: anytype) @TypeOf(SSL_CTX_set0_chain(ctx, NULL)) {
    _ = &ctx;
    return SSL_CTX_set0_chain(ctx, NULL);
}
pub inline fn SSL_CTX_build_cert_chain(ctx: anytype, flags: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL)) {
    _ = &ctx;
    _ = &flags;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL);
}
pub inline fn SSL_CTX_select_current_cert(ctx: anytype, x509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SELECT_CURRENT_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &ctx;
    _ = &x509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SELECT_CURRENT_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_CTX_set_current_cert(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CURRENT_CERT, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CURRENT_CERT, op, NULL);
}
pub inline fn SSL_CTX_set0_verify_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_set1_verify_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_get0_verify_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_set0_chain_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_set1_chain_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_get0_chain_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_set0_chain(s: anytype, sk: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CHAIN, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sk))) {
    _ = &s;
    _ = &sk;
    return SSL_ctrl(s, SSL_CTRL_CHAIN, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sk));
}
pub inline fn SSL_set1_chain(s: anytype, sk: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CHAIN, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, sk))) {
    _ = &s;
    _ = &sk;
    return SSL_ctrl(s, SSL_CTRL_CHAIN, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, sk));
}
pub inline fn SSL_add0_chain_cert(s: anytype, x509: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &s;
    _ = &x509;
    return SSL_ctrl(s, SSL_CTRL_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_add1_chain_cert(s: anytype, x509: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CHAIN_CERT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &s;
    _ = &x509;
    return SSL_ctrl(s, SSL_CTRL_CHAIN_CERT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_get0_chain_certs(s: anytype, px509: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_CHAIN_CERTS, @as(c_int, 0), px509)) {
    _ = &s;
    _ = &px509;
    return SSL_ctrl(s, SSL_CTRL_GET_CHAIN_CERTS, @as(c_int, 0), px509);
}
pub inline fn SSL_clear_chain_certs(s: anytype) @TypeOf(SSL_set0_chain(s, NULL)) {
    _ = &s;
    return SSL_set0_chain(s, NULL);
}
pub inline fn SSL_build_cert_chain(s: anytype, flags: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL)) {
    _ = &s;
    _ = &flags;
    return SSL_ctrl(s, SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL);
}
pub inline fn SSL_select_current_cert(s: anytype, x509: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SELECT_CURRENT_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &s;
    _ = &x509;
    return SSL_ctrl(s, SSL_CTRL_SELECT_CURRENT_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_set_current_cert(s: anytype, op: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CURRENT_CERT, op, NULL)) {
    _ = &s;
    _ = &op;
    return SSL_ctrl(s, SSL_CTRL_SET_CURRENT_CERT, op, NULL);
}
pub inline fn SSL_set0_verify_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_set1_verify_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_get0_verify_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_GET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_set0_chain_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_set1_chain_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_get0_chain_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_GET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_get1_groups(s: anytype, glist: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_GROUPS, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]c_int, glist))) {
    _ = &s;
    _ = &glist;
    return SSL_ctrl(s, SSL_CTRL_GET_GROUPS, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]c_int, glist));
}
pub const SSL_get0_iana_groups = @compileError("unable to translate C expr: expected ')' instead got '*'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1488:10
pub inline fn SSL_CTX_set1_groups(ctx: anytype, glist: anytype, glistlen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_GROUPS, glistlen, @import("std").zig.c_translation.cast([*c]c_int, glist))) {
    _ = &ctx;
    _ = &glist;
    _ = &glistlen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_GROUPS, glistlen, @import("std").zig.c_translation.cast([*c]c_int, glist));
}
pub inline fn SSL_CTX_set1_groups_list(ctx: anytype, s: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_GROUPS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s))) {
    _ = &ctx;
    _ = &s;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_GROUPS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s));
}
pub inline fn SSL_set1_groups(s: anytype, glist: anytype, glistlen: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_GROUPS, glistlen, @import("std").zig.c_translation.cast([*c]u8, glist))) {
    _ = &s;
    _ = &glist;
    _ = &glistlen;
    return SSL_ctrl(s, SSL_CTRL_SET_GROUPS, glistlen, @import("std").zig.c_translation.cast([*c]u8, glist));
}
pub inline fn SSL_set1_groups_list(s: anytype, str: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_GROUPS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str))) {
    _ = &s;
    _ = &str;
    return SSL_ctrl(s, SSL_CTRL_SET_GROUPS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str));
}
pub inline fn SSL_get_shared_group(s: anytype, n: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_SHARED_GROUP, n, NULL)) {
    _ = &s;
    _ = &n;
    return SSL_ctrl(s, SSL_CTRL_GET_SHARED_GROUP, n, NULL);
}
pub inline fn SSL_get_negotiated_group(s: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_NEGOTIATED_GROUP, @as(c_int, 0), NULL)) {
    _ = &s;
    return SSL_ctrl(s, SSL_CTRL_GET_NEGOTIATED_GROUP, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set1_sigalgs(ctx: anytype, slist: anytype, slistlen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist))) {
    _ = &ctx;
    _ = &slist;
    _ = &slistlen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist));
}
pub inline fn SSL_CTX_set1_sigalgs_list(ctx: anytype, s: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s))) {
    _ = &ctx;
    _ = &s;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s));
}
pub inline fn SSL_set1_sigalgs(s: anytype, slist: anytype, slistlen: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist))) {
    _ = &s;
    _ = &slist;
    _ = &slistlen;
    return SSL_ctrl(s, SSL_CTRL_SET_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist));
}
pub inline fn SSL_set1_sigalgs_list(s: anytype, str: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str))) {
    _ = &s;
    _ = &str;
    return SSL_ctrl(s, SSL_CTRL_SET_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str));
}
pub inline fn SSL_CTX_set1_client_sigalgs(ctx: anytype, slist: anytype, slistlen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist))) {
    _ = &ctx;
    _ = &slist;
    _ = &slistlen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist));
}
pub inline fn SSL_CTX_set1_client_sigalgs_list(ctx: anytype, s: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s))) {
    _ = &ctx;
    _ = &s;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s));
}
pub inline fn SSL_set1_client_sigalgs(s: anytype, slist: anytype, slistlen: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CLIENT_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist))) {
    _ = &s;
    _ = &slist;
    _ = &slistlen;
    return SSL_ctrl(s, SSL_CTRL_SET_CLIENT_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist));
}
pub inline fn SSL_set1_client_sigalgs_list(s: anytype, str: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CLIENT_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str))) {
    _ = &s;
    _ = &str;
    return SSL_ctrl(s, SSL_CTRL_SET_CLIENT_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str));
}
pub inline fn SSL_get0_certificate_types(s: anytype, clist: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_CLIENT_CERT_TYPES, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, clist))) {
    _ = &s;
    _ = &clist;
    return SSL_ctrl(s, SSL_CTRL_GET_CLIENT_CERT_TYPES, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, clist));
}
pub inline fn SSL_CTX_set1_client_certificate_types(ctx: anytype, clist: anytype, clistlen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_CERT_TYPES, clistlen, @import("std").zig.c_translation.cast([*c]u8, clist))) {
    _ = &ctx;
    _ = &clist;
    _ = &clistlen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_CERT_TYPES, clistlen, @import("std").zig.c_translation.cast([*c]u8, clist));
}
pub inline fn SSL_set1_client_certificate_types(s: anytype, clist: anytype, clistlen: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CLIENT_CERT_TYPES, clistlen, @import("std").zig.c_translation.cast([*c]u8, clist))) {
    _ = &s;
    _ = &clist;
    _ = &clistlen;
    return SSL_ctrl(s, SSL_CTRL_SET_CLIENT_CERT_TYPES, clistlen, @import("std").zig.c_translation.cast([*c]u8, clist));
}
pub inline fn SSL_get_signature_nid(s: anytype, pn: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_SIGNATURE_NID, @as(c_int, 0), pn)) {
    _ = &s;
    _ = &pn;
    return SSL_ctrl(s, SSL_CTRL_GET_SIGNATURE_NID, @as(c_int, 0), pn);
}
pub inline fn SSL_get_peer_signature_nid(s: anytype, pn: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_PEER_SIGNATURE_NID, @as(c_int, 0), pn)) {
    _ = &s;
    _ = &pn;
    return SSL_ctrl(s, SSL_CTRL_GET_PEER_SIGNATURE_NID, @as(c_int, 0), pn);
}
pub inline fn SSL_get_peer_tmp_key(s: anytype, pk: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_PEER_TMP_KEY, @as(c_int, 0), pk)) {
    _ = &s;
    _ = &pk;
    return SSL_ctrl(s, SSL_CTRL_GET_PEER_TMP_KEY, @as(c_int, 0), pk);
}
pub inline fn SSL_get_tmp_key(s: anytype, pk: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_TMP_KEY, @as(c_int, 0), pk)) {
    _ = &s;
    _ = &pk;
    return SSL_ctrl(s, SSL_CTRL_GET_TMP_KEY, @as(c_int, 0), pk);
}
pub inline fn SSL_get0_raw_cipherlist(s: anytype, plst: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_RAW_CIPHERLIST, @as(c_int, 0), plst)) {
    _ = &s;
    _ = &plst;
    return SSL_ctrl(s, SSL_CTRL_GET_RAW_CIPHERLIST, @as(c_int, 0), plst);
}
pub inline fn SSL_get0_ec_point_formats(s: anytype, plst: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_EC_POINT_FORMATS, @as(c_int, 0), plst)) {
    _ = &s;
    _ = &plst;
    return SSL_ctrl(s, SSL_CTRL_GET_EC_POINT_FORMATS, @as(c_int, 0), plst);
}
pub inline fn SSL_CTX_set_min_proto_version(ctx: anytype, version: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)) {
    _ = &ctx;
    _ = &version;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL);
}
pub inline fn SSL_CTX_set_max_proto_version(ctx: anytype, version: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)) {
    _ = &ctx;
    _ = &version;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL);
}
pub inline fn SSL_CTX_get_min_proto_version(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MIN_PROTO_VERSION, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MIN_PROTO_VERSION, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_get_max_proto_version(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_PROTO_VERSION, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_PROTO_VERSION, @as(c_int, 0), NULL);
}
pub inline fn SSL_set_min_proto_version(s: anytype, version: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)) {
    _ = &s;
    _ = &version;
    return SSL_ctrl(s, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL);
}
pub inline fn SSL_set_max_proto_version(s: anytype, version: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)) {
    _ = &s;
    _ = &version;
    return SSL_ctrl(s, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL);
}
pub inline fn SSL_get_min_proto_version(s: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_MIN_PROTO_VERSION, @as(c_int, 0), NULL)) {
    _ = &s;
    return SSL_ctrl(s, SSL_CTRL_GET_MIN_PROTO_VERSION, @as(c_int, 0), NULL);
}
pub inline fn SSL_get_max_proto_version(s: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_MAX_PROTO_VERSION, @as(c_int, 0), NULL)) {
    _ = &s;
    return SSL_ctrl(s, SSL_CTRL_GET_MAX_PROTO_VERSION, @as(c_int, 0), NULL);
}
pub const SSL_CTRL_GET_SERVER_TMP_KEY = SSL_CTRL_GET_PEER_TMP_KEY;
pub inline fn SSL_get_server_tmp_key(s: anytype, pk: anytype) @TypeOf(SSL_get_peer_tmp_key(s, pk)) {
    _ = &s;
    _ = &pk;
    return SSL_get_peer_tmp_key(s, pk);
}
pub const SSL_CTRL_GET_CURVES = SSL_CTRL_GET_GROUPS;
pub const SSL_CTRL_SET_CURVES = SSL_CTRL_SET_GROUPS;
pub const SSL_CTRL_SET_CURVES_LIST = SSL_CTRL_SET_GROUPS_LIST;
pub const SSL_CTRL_GET_SHARED_CURVE = SSL_CTRL_GET_SHARED_GROUP;
pub const SSL_get1_curves = SSL_get1_groups;
pub const SSL_CTX_set1_curves = SSL_CTX_set1_groups;
pub const SSL_CTX_set1_curves_list = SSL_CTX_set1_groups_list;
pub const SSL_set1_curves = SSL_set1_groups;
pub const SSL_set1_curves_list = SSL_set1_groups_list;
pub const SSL_get_shared_curve = SSL_get_shared_group;
pub inline fn SSL_CTX_need_tmp_RSA(ctx: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &ctx;
    return @as(c_int, 0);
}
pub inline fn SSL_CTX_set_tmp_rsa(ctx: anytype, rsa: anytype) @TypeOf(@as(c_int, 1)) {
    _ = &ctx;
    _ = &rsa;
    return @as(c_int, 1);
}
pub inline fn SSL_need_tmp_RSA(ssl: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &ssl;
    return @as(c_int, 0);
}
pub inline fn SSL_set_tmp_rsa(ssl: anytype, rsa: anytype) @TypeOf(@as(c_int, 1)) {
    _ = &ssl;
    _ = &rsa;
    return @as(c_int, 1);
}
pub inline fn SSL_CTX_set_ecdh_auto(dummy: anytype, onoff: anytype) @TypeOf(onoff != @as(c_int, 0)) {
    _ = &dummy;
    _ = &onoff;
    return onoff != @as(c_int, 0);
}
pub inline fn SSL_set_ecdh_auto(dummy: anytype, onoff: anytype) @TypeOf(onoff != @as(c_int, 0)) {
    _ = &dummy;
    _ = &onoff;
    return onoff != @as(c_int, 0);
}
pub const SSL_CTX_set_tmp_rsa_callback = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1595:11
pub const SSL_set_tmp_rsa_callback = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:1596:11
pub const SSL_SERVERINFOV1 = @as(c_int, 1);
pub const SSL_SERVERINFOV2 = @as(c_int, 2);
pub inline fn SSL_load_error_strings() @TypeOf(OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL)) {
    return OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
}
pub const SSL_get_peer_certificate = SSL_get1_peer_certificate;
pub const SSL_CLIENT_HELLO_SUCCESS = @as(c_int, 1);
pub const SSL_CLIENT_HELLO_ERROR = @as(c_int, 0);
pub const SSL_CLIENT_HELLO_RETRY = -@as(c_int, 1);
pub const SSL_READ_EARLY_DATA_ERROR = @as(c_int, 0);
pub const SSL_READ_EARLY_DATA_SUCCESS = @as(c_int, 1);
pub const SSL_READ_EARLY_DATA_FINISH = @as(c_int, 2);
pub const SSL_WRITE_FLAG_CONCLUDE = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_EARLY_DATA_NOT_SENT = @as(c_int, 0);
pub const SSL_EARLY_DATA_REJECTED = @as(c_int, 1);
pub const SSL_EARLY_DATA_ACCEPTED = @as(c_int, 2);
pub const SSLv23_method = TLS_method;
pub const SSLv23_server_method = TLS_server_method;
pub const SSLv23_client_method = TLS_client_method;
pub inline fn SSL_library_init() @TypeOf(OPENSSL_init_ssl(@as(c_int, 0), NULL)) {
    return OPENSSL_init_ssl(@as(c_int, 0), NULL);
}
pub const SSL_get0_session = SSL_get_session;
pub inline fn SSL_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, l, p, newf, dupf, freef);
}
pub inline fn SSL_SESSION_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION, l, p, newf, dupf, freef);
}
pub inline fn SSL_CTX_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, l, p, newf, dupf, freef);
}
pub inline fn SSL_CTX_sess_set_cache_size(ctx: anytype, t: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_SIZE, t, NULL)) {
    _ = &ctx;
    _ = &t;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_SIZE, t, NULL);
}
pub inline fn SSL_CTX_sess_get_cache_size(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_SESS_CACHE_SIZE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_SESS_CACHE_SIZE, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_session_cache_mode(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_MODE, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_MODE, m, NULL);
}
pub inline fn SSL_CTX_get_session_cache_mode(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_SESS_CACHE_MODE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_SESS_CACHE_MODE, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_get_default_read_ahead(ctx: anytype) @TypeOf(SSL_CTX_get_read_ahead(ctx)) {
    _ = &ctx;
    return SSL_CTX_get_read_ahead(ctx);
}
pub inline fn SSL_CTX_set_default_read_ahead(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_set_read_ahead(ctx, m)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_set_read_ahead(ctx, m);
}
pub inline fn SSL_CTX_get_read_ahead(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_READ_AHEAD, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_READ_AHEAD, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_read_ahead(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_READ_AHEAD, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_READ_AHEAD, m, NULL);
}
pub inline fn SSL_CTX_get_max_cert_list(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_CERT_LIST, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_CERT_LIST, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_max_cert_list(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_CERT_LIST, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_CERT_LIST, m, NULL);
}
pub inline fn SSL_get_max_cert_list(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_MAX_CERT_LIST, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_MAX_CERT_LIST, @as(c_int, 0), NULL);
}
pub inline fn SSL_set_max_cert_list(ssl: anytype, m: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MAX_CERT_LIST, m, NULL)) {
    _ = &ssl;
    _ = &m;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MAX_CERT_LIST, m, NULL);
}
pub inline fn SSL_CTX_set_max_send_fragment(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_SEND_FRAGMENT, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_SEND_FRAGMENT, m, NULL);
}
pub inline fn SSL_set_max_send_fragment(ssl: anytype, m: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MAX_SEND_FRAGMENT, m, NULL)) {
    _ = &ssl;
    _ = &m;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MAX_SEND_FRAGMENT, m, NULL);
}
pub inline fn SSL_CTX_set_split_send_fragment(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SPLIT_SEND_FRAGMENT, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SPLIT_SEND_FRAGMENT, m, NULL);
}
pub inline fn SSL_set_split_send_fragment(ssl: anytype, m: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_SPLIT_SEND_FRAGMENT, m, NULL)) {
    _ = &ssl;
    _ = &m;
    return SSL_ctrl(ssl, SSL_CTRL_SET_SPLIT_SEND_FRAGMENT, m, NULL);
}
pub inline fn SSL_CTX_set_max_pipelines(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PIPELINES, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PIPELINES, m, NULL);
}
pub inline fn SSL_set_max_pipelines(ssl: anytype, m: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MAX_PIPELINES, m, NULL)) {
    _ = &ssl;
    _ = &m;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MAX_PIPELINES, m, NULL);
}
pub inline fn SSL_set_retry_verify(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_RETRY_VERIFY, @as(c_int, 0), NULL) > @as(c_int, 0)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_SET_RETRY_VERIFY, @as(c_int, 0), NULL) > @as(c_int, 0);
}
pub const SSL_COMP_free_compression_methods = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:2275:11
pub const SSL_STREAM_TYPE_NONE = @as(c_int, 0);
pub const SSL_STREAM_TYPE_READ = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_STREAM_TYPE_WRITE = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_STREAM_TYPE_BIDI = SSL_STREAM_TYPE_READ | SSL_STREAM_TYPE_WRITE;
pub const SSL_DEFAULT_STREAM_MODE_NONE = @as(c_int, 0);
pub const SSL_DEFAULT_STREAM_MODE_AUTO_BIDI = @as(c_int, 1);
pub const SSL_DEFAULT_STREAM_MODE_AUTO_UNI = @as(c_int, 2);
pub const SSL_STREAM_FLAG_UNI = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_STREAM_FLAG_NO_BLOCK = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_STREAM_FLAG_ADVANCE = @as(c_uint, 1) << @as(c_int, 2);
pub const SSL_INCOMING_STREAM_POLICY_AUTO = @as(c_int, 0);
pub const SSL_INCOMING_STREAM_POLICY_ACCEPT = @as(c_int, 1);
pub const SSL_INCOMING_STREAM_POLICY_REJECT = @as(c_int, 2);
pub const SSL_ACCEPT_STREAM_NO_BLOCK = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_SHUTDOWN_FLAG_RAPID = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_SHUTDOWN_FLAG_NO_STREAM_FLUSH = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_SHUTDOWN_FLAG_NO_BLOCK = @as(c_uint, 1) << @as(c_int, 2);
pub const SSL_SHUTDOWN_FLAG_WAIT_PEER = @as(c_uint, 1) << @as(c_int, 3);
pub const SSL_STREAM_STATE_NONE = @as(c_int, 0);
pub const SSL_STREAM_STATE_OK = @as(c_int, 1);
pub const SSL_STREAM_STATE_WRONG_DIR = @as(c_int, 2);
pub const SSL_STREAM_STATE_FINISHED = @as(c_int, 3);
pub const SSL_STREAM_STATE_RESET_LOCAL = @as(c_int, 4);
pub const SSL_STREAM_STATE_RESET_REMOTE = @as(c_int, 5);
pub const SSL_STREAM_STATE_CONN_CLOSED = @as(c_int, 6);
pub const SSL_CONN_CLOSE_FLAG_LOCAL = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_CONN_CLOSE_FLAG_TRANSPORT = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_VALUE_CLASS_GENERIC = @as(c_int, 0);
pub const SSL_VALUE_CLASS_FEATURE_REQUEST = @as(c_int, 1);
pub const SSL_VALUE_CLASS_FEATURE_PEER_REQUEST = @as(c_int, 2);
pub const SSL_VALUE_CLASS_FEATURE_NEGOTIATED = @as(c_int, 3);
pub const SSL_VALUE_NONE = @as(c_int, 0);
pub const SSL_VALUE_QUIC_STREAM_BIDI_LOCAL_AVAIL = @as(c_int, 1);
pub const SSL_VALUE_QUIC_STREAM_BIDI_REMOTE_AVAIL = @as(c_int, 2);
pub const SSL_VALUE_QUIC_STREAM_UNI_LOCAL_AVAIL = @as(c_int, 3);
pub const SSL_VALUE_QUIC_STREAM_UNI_REMOTE_AVAIL = @as(c_int, 4);
pub const SSL_VALUE_QUIC_IDLE_TIMEOUT = @as(c_int, 5);
pub const SSL_VALUE_EVENT_HANDLING_MODE = @as(c_int, 6);
pub const SSL_VALUE_STREAM_WRITE_BUF_SIZE = @as(c_int, 7);
pub const SSL_VALUE_STREAM_WRITE_BUF_USED = @as(c_int, 8);
pub const SSL_VALUE_STREAM_WRITE_BUF_AVAIL = @as(c_int, 9);
pub const SSL_VALUE_EVENT_HANDLING_MODE_INHERIT = @as(c_int, 0);
pub const SSL_VALUE_EVENT_HANDLING_MODE_IMPLICIT = @as(c_int, 1);
pub const SSL_VALUE_EVENT_HANDLING_MODE_EXPLICIT = @as(c_int, 2);
pub inline fn SSL_get_generic_value_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_get_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_get_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, v);
}
pub inline fn SSL_set_generic_value_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_set_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_set_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, v);
}
pub inline fn SSL_get_feature_request_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, v);
}
pub inline fn SSL_set_feature_request_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_set_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_set_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, v);
}
pub inline fn SSL_get_feature_peer_request_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_PEER_REQUEST, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_PEER_REQUEST, id, v);
}
pub inline fn SSL_get_feature_negotiated_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_NEGOTIATED, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_NEGOTIATED, id, v);
}
pub inline fn SSL_get_quic_stream_bidi_local_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_LOCAL_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_LOCAL_AVAIL, value);
}
pub inline fn SSL_get_quic_stream_bidi_remote_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_REMOTE_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_REMOTE_AVAIL, value);
}
pub inline fn SSL_get_quic_stream_uni_local_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_LOCAL_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_LOCAL_AVAIL, value);
}
pub inline fn SSL_get_quic_stream_uni_remote_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_REMOTE_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_REMOTE_AVAIL, value);
}
pub inline fn SSL_get_event_handling_mode(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value);
}
pub inline fn SSL_set_event_handling_mode(ssl: anytype, value: anytype) @TypeOf(SSL_set_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_set_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value);
}
pub inline fn SSL_get_stream_write_buf_size(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_SIZE, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_SIZE, value);
}
pub inline fn SSL_get_stream_write_buf_used(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_USED, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_USED, value);
}
pub inline fn SSL_get_stream_write_buf_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_AVAIL, value);
}
pub const SSL_POLL_EVENT_NONE = @as(c_int, 0);
pub const SSL_POLL_EVENT_F = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_POLL_EVENT_EL = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_POLL_EVENT_EC = @as(c_uint, 1) << @as(c_int, 2);
pub const SSL_POLL_EVENT_ECD = @as(c_uint, 1) << @as(c_int, 3);
pub const SSL_POLL_EVENT_ER = @as(c_uint, 1) << @as(c_int, 4);
pub const SSL_POLL_EVENT_EW = @as(c_uint, 1) << @as(c_int, 5);
pub const SSL_POLL_EVENT_R = @as(c_uint, 1) << @as(c_int, 6);
pub const SSL_POLL_EVENT_W = @as(c_uint, 1) << @as(c_int, 7);
pub const SSL_POLL_EVENT_IC = @as(c_uint, 1) << @as(c_int, 8);
pub const SSL_POLL_EVENT_ISB = @as(c_uint, 1) << @as(c_int, 9);
pub const SSL_POLL_EVENT_ISU = @as(c_uint, 1) << @as(c_int, 10);
pub const SSL_POLL_EVENT_OSB = @as(c_uint, 1) << @as(c_int, 11);
pub const SSL_POLL_EVENT_OSU = @as(c_uint, 1) << @as(c_int, 12);
pub const SSL_POLL_EVENT_RW = SSL_POLL_EVENT_R | SSL_POLL_EVENT_W;
pub const SSL_POLL_EVENT_RE = SSL_POLL_EVENT_R | SSL_POLL_EVENT_ER;
pub const SSL_POLL_EVENT_WE = SSL_POLL_EVENT_W | SSL_POLL_EVENT_EW;
pub const SSL_POLL_EVENT_RWE = SSL_POLL_EVENT_RE | SSL_POLL_EVENT_WE;
pub const SSL_POLL_EVENT_E = ((SSL_POLL_EVENT_EL | SSL_POLL_EVENT_EC) | SSL_POLL_EVENT_ER) | SSL_POLL_EVENT_EW;
pub const SSL_POLL_EVENT_IS = SSL_POLL_EVENT_ISB | SSL_POLL_EVENT_ISU;
pub const SSL_POLL_EVENT_ISE = SSL_POLL_EVENT_IS | SSL_POLL_EVENT_EC;
pub const SSL_POLL_EVENT_I = SSL_POLL_EVENT_IS | SSL_POLL_EVENT_IC;
pub const SSL_POLL_EVENT_OS = SSL_POLL_EVENT_OSB | SSL_POLL_EVENT_OSU;
pub const SSL_POLL_EVENT_OSE = SSL_POLL_EVENT_OS | SSL_POLL_EVENT_EC;
pub const SSL_POLL_FLAG_NO_HANDLE_EVENTS = @as(c_uint, 1) << @as(c_int, 0);
pub inline fn SSL_cache_hit(s: anytype) @TypeOf(SSL_session_reused(s)) {
    _ = &s;
    return SSL_session_reused(s);
}
pub const SSL_disable_ct = @compileError("unable to translate macro: undefined identifier `SSL_set_validation_callback`");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:2609:9
pub const SSL_CTX_disable_ct = @compileError("unable to translate macro: undefined identifier `SSL_CTX_set_validation_callback`");
// /opt/homebrew/opt/openssl@3/include/openssl/ssl.h:2611:9
pub const SSL_SECOP_OTHER_TYPE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff0000, .hex);
pub const SSL_SECOP_OTHER_NONE = @as(c_int, 0);
pub const SSL_SECOP_OTHER_CIPHER = @as(c_int, 1) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_CURVE = @as(c_int, 2) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_DH = @as(c_int, 3) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_PKEY = @as(c_int, 4) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_SIGALG = @as(c_int, 5) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_CERT = @as(c_int, 6) << @as(c_int, 16);
pub const SSL_SECOP_PEER = @as(c_int, 0x1000);
pub const SSL_SECOP_CIPHER_SUPPORTED = @as(c_int, 1) | SSL_SECOP_OTHER_CIPHER;
pub const SSL_SECOP_CIPHER_SHARED = @as(c_int, 2) | SSL_SECOP_OTHER_CIPHER;
pub const SSL_SECOP_CIPHER_CHECK = @as(c_int, 3) | SSL_SECOP_OTHER_CIPHER;
pub const SSL_SECOP_CURVE_SUPPORTED = @as(c_int, 4) | SSL_SECOP_OTHER_CURVE;
pub const SSL_SECOP_CURVE_SHARED = @as(c_int, 5) | SSL_SECOP_OTHER_CURVE;
pub const SSL_SECOP_CURVE_CHECK = @as(c_int, 6) | SSL_SECOP_OTHER_CURVE;
pub const SSL_SECOP_TMP_DH = @as(c_int, 7) | SSL_SECOP_OTHER_PKEY;
pub const SSL_SECOP_VERSION = @as(c_int, 9) | SSL_SECOP_OTHER_NONE;
pub const SSL_SECOP_TICKET = @as(c_int, 10) | SSL_SECOP_OTHER_NONE;
pub const SSL_SECOP_SIGALG_SUPPORTED = @as(c_int, 11) | SSL_SECOP_OTHER_SIGALG;
pub const SSL_SECOP_SIGALG_SHARED = @as(c_int, 12) | SSL_SECOP_OTHER_SIGALG;
pub const SSL_SECOP_SIGALG_CHECK = @as(c_int, 13) | SSL_SECOP_OTHER_SIGALG;
pub const SSL_SECOP_SIGALG_MASK = @as(c_int, 14) | SSL_SECOP_OTHER_SIGALG;
pub const SSL_SECOP_COMPRESSION = @as(c_int, 15) | SSL_SECOP_OTHER_NONE;
pub const SSL_SECOP_EE_KEY = @as(c_int, 16) | SSL_SECOP_OTHER_CERT;
pub const SSL_SECOP_CA_KEY = @as(c_int, 17) | SSL_SECOP_OTHER_CERT;
pub const SSL_SECOP_CA_MD = @as(c_int, 18) | SSL_SECOP_OTHER_CERT;
pub const SSL_SECOP_PEER_EE_KEY = SSL_SECOP_EE_KEY | SSL_SECOP_PEER;
pub const SSL_SECOP_PEER_CA_KEY = SSL_SECOP_CA_KEY | SSL_SECOP_PEER;
pub const SSL_SECOP_PEER_CA_MD = SSL_SECOP_CA_MD | SSL_SECOP_PEER;
pub const OPENSSL_INIT_NO_LOAD_SSL_STRINGS = @as(c_long, 0x00100000);
pub const OPENSSL_INIT_LOAD_SSL_STRINGS = @as(c_long, 0x00200000);
pub const OPENSSL_INIT_SSL_DEFAULT = OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS;
pub const SSL_TICKET_FATAL_ERR_MALLOC = @as(c_int, 0);
pub const SSL_TICKET_FATAL_ERR_OTHER = @as(c_int, 1);
pub const SSL_TICKET_NONE = @as(c_int, 2);
pub const SSL_TICKET_EMPTY = @as(c_int, 3);
pub const SSL_TICKET_NO_DECRYPT = @as(c_int, 4);
pub const SSL_TICKET_SUCCESS = @as(c_int, 5);
pub const SSL_TICKET_SUCCESS_RENEW = @as(c_int, 6);
pub const SSL_TICKET_RETURN_ABORT = @as(c_int, 0);
pub const SSL_TICKET_RETURN_IGNORE = @as(c_int, 1);
pub const SSL_TICKET_RETURN_IGNORE_RENEW = @as(c_int, 2);
pub const SSL_TICKET_RETURN_USE = @as(c_int, 3);
pub const SSL_TICKET_RETURN_USE_RENEW = @as(c_int, 4);
pub const OPENSSL_ERR_H = "";
pub const HEADER_ERR_H = "";
pub inline fn ERR_PUT_error(l: anytype, f: anytype, r: anytype, @"fn": anytype, ln: anytype) @TypeOf(ERR_put_error(l, f, r, @"fn", ln)) {
    _ = &l;
    _ = &f;
    _ = &r;
    _ = &@"fn";
    _ = &ln;
    return ERR_put_error(l, f, r, @"fn", ln);
}
pub const _SYS_ERRNO_H_ = "";
pub const errno = __error().*;
pub const EPERM = @as(c_int, 1);
pub const ENOENT = @as(c_int, 2);
pub const ESRCH = @as(c_int, 3);
pub const EINTR = @as(c_int, 4);
pub const EIO = @as(c_int, 5);
pub const ENXIO = @as(c_int, 6);
pub const E2BIG = @as(c_int, 7);
pub const ENOEXEC = @as(c_int, 8);
pub const EBADF = @as(c_int, 9);
pub const ECHILD = @as(c_int, 10);
pub const EDEADLK = @as(c_int, 11);
pub const ENOMEM = @as(c_int, 12);
pub const EACCES = @as(c_int, 13);
pub const EFAULT = @as(c_int, 14);
pub const ENOTBLK = @as(c_int, 15);
pub const EBUSY = @as(c_int, 16);
pub const EEXIST = @as(c_int, 17);
pub const EXDEV = @as(c_int, 18);
pub const ENODEV = @as(c_int, 19);
pub const ENOTDIR = @as(c_int, 20);
pub const EISDIR = @as(c_int, 21);
pub const EINVAL = @as(c_int, 22);
pub const ENFILE = @as(c_int, 23);
pub const EMFILE = @as(c_int, 24);
pub const ENOTTY = @as(c_int, 25);
pub const ETXTBSY = @as(c_int, 26);
pub const EFBIG = @as(c_int, 27);
pub const ENOSPC = @as(c_int, 28);
pub const ESPIPE = @as(c_int, 29);
pub const EROFS = @as(c_int, 30);
pub const EMLINK = @as(c_int, 31);
pub const EPIPE = @as(c_int, 32);
pub const EDOM = @as(c_int, 33);
pub const ERANGE = @as(c_int, 34);
pub const EAGAIN = @as(c_int, 35);
pub const EWOULDBLOCK = EAGAIN;
pub const EINPROGRESS = @as(c_int, 36);
pub const EALREADY = @as(c_int, 37);
pub const ENOTSOCK = @as(c_int, 38);
pub const EDESTADDRREQ = @as(c_int, 39);
pub const EMSGSIZE = @as(c_int, 40);
pub const EPROTOTYPE = @as(c_int, 41);
pub const ENOPROTOOPT = @as(c_int, 42);
pub const EPROTONOSUPPORT = @as(c_int, 43);
pub const ESOCKTNOSUPPORT = @as(c_int, 44);
pub const ENOTSUP = @as(c_int, 45);
pub const EPFNOSUPPORT = @as(c_int, 46);
pub const EAFNOSUPPORT = @as(c_int, 47);
pub const EADDRINUSE = @as(c_int, 48);
pub const EADDRNOTAVAIL = @as(c_int, 49);
pub const ENETDOWN = @as(c_int, 50);
pub const ENETUNREACH = @as(c_int, 51);
pub const ENETRESET = @as(c_int, 52);
pub const ECONNABORTED = @as(c_int, 53);
pub const ECONNRESET = @as(c_int, 54);
pub const ENOBUFS = @as(c_int, 55);
pub const EISCONN = @as(c_int, 56);
pub const ENOTCONN = @as(c_int, 57);
pub const ESHUTDOWN = @as(c_int, 58);
pub const ETOOMANYREFS = @as(c_int, 59);
pub const ETIMEDOUT = @as(c_int, 60);
pub const ECONNREFUSED = @as(c_int, 61);
pub const ELOOP = @as(c_int, 62);
pub const ENAMETOOLONG = @as(c_int, 63);
pub const EHOSTDOWN = @as(c_int, 64);
pub const EHOSTUNREACH = @as(c_int, 65);
pub const ENOTEMPTY = @as(c_int, 66);
pub const EPROCLIM = @as(c_int, 67);
pub const EUSERS = @as(c_int, 68);
pub const EDQUOT = @as(c_int, 69);
pub const ESTALE = @as(c_int, 70);
pub const EREMOTE = @as(c_int, 71);
pub const EBADRPC = @as(c_int, 72);
pub const ERPCMISMATCH = @as(c_int, 73);
pub const EPROGUNAVAIL = @as(c_int, 74);
pub const EPROGMISMATCH = @as(c_int, 75);
pub const EPROCUNAVAIL = @as(c_int, 76);
pub const ENOLCK = @as(c_int, 77);
pub const ENOSYS = @as(c_int, 78);
pub const EFTYPE = @as(c_int, 79);
pub const EAUTH = @as(c_int, 80);
pub const ENEEDAUTH = @as(c_int, 81);
pub const EPWROFF = @as(c_int, 82);
pub const EDEVERR = @as(c_int, 83);
pub const EOVERFLOW = @as(c_int, 84);
pub const EBADEXEC = @as(c_int, 85);
pub const EBADARCH = @as(c_int, 86);
pub const ESHLIBVERS = @as(c_int, 87);
pub const EBADMACHO = @as(c_int, 88);
pub const ECANCELED = @as(c_int, 89);
pub const EIDRM = @as(c_int, 90);
pub const ENOMSG = @as(c_int, 91);
pub const EILSEQ = @as(c_int, 92);
pub const ENOATTR = @as(c_int, 93);
pub const EBADMSG = @as(c_int, 94);
pub const EMULTIHOP = @as(c_int, 95);
pub const ENODATA = @as(c_int, 96);
pub const ENOLINK = @as(c_int, 97);
pub const ENOSR = @as(c_int, 98);
pub const ENOSTR = @as(c_int, 99);
pub const EPROTO = @as(c_int, 100);
pub const ETIME = @as(c_int, 101);
pub const EOPNOTSUPP = @as(c_int, 102);
pub const ENOPOLICY = @as(c_int, 103);
pub const ENOTRECOVERABLE = @as(c_int, 104);
pub const EOWNERDEAD = @as(c_int, 105);
pub const EQFULL = @as(c_int, 106);
pub const ELAST = @as(c_int, 106);
pub const ERR_TXT_MALLOCED = @as(c_int, 0x01);
pub const ERR_TXT_STRING = @as(c_int, 0x02);
pub const ERR_FLAG_MARK = @as(c_int, 0x01);
pub const ERR_FLAG_CLEAR = @as(c_int, 0x02);
pub const ERR_NUM_ERRORS = @as(c_int, 16);
pub const ERR_LIB_NONE = @as(c_int, 1);
pub const ERR_LIB_SYS = @as(c_int, 2);
pub const ERR_LIB_BN = @as(c_int, 3);
pub const ERR_LIB_RSA = @as(c_int, 4);
pub const ERR_LIB_DH = @as(c_int, 5);
pub const ERR_LIB_EVP = @as(c_int, 6);
pub const ERR_LIB_BUF = @as(c_int, 7);
pub const ERR_LIB_OBJ = @as(c_int, 8);
pub const ERR_LIB_PEM = @as(c_int, 9);
pub const ERR_LIB_DSA = @as(c_int, 10);
pub const ERR_LIB_X509 = @as(c_int, 11);
pub const ERR_LIB_ASN1 = @as(c_int, 13);
pub const ERR_LIB_CONF = @as(c_int, 14);
pub const ERR_LIB_CRYPTO = @as(c_int, 15);
pub const ERR_LIB_EC = @as(c_int, 16);
pub const ERR_LIB_SSL = @as(c_int, 20);
pub const ERR_LIB_BIO = @as(c_int, 32);
pub const ERR_LIB_PKCS7 = @as(c_int, 33);
pub const ERR_LIB_X509V3 = @as(c_int, 34);
pub const ERR_LIB_PKCS12 = @as(c_int, 35);
pub const ERR_LIB_RAND = @as(c_int, 36);
pub const ERR_LIB_DSO = @as(c_int, 37);
pub const ERR_LIB_ENGINE = @as(c_int, 38);
pub const ERR_LIB_OCSP = @as(c_int, 39);
pub const ERR_LIB_UI = @as(c_int, 40);
pub const ERR_LIB_COMP = @as(c_int, 41);
pub const ERR_LIB_ECDSA = @as(c_int, 42);
pub const ERR_LIB_ECDH = @as(c_int, 43);
pub const ERR_LIB_OSSL_STORE = @as(c_int, 44);
pub const ERR_LIB_FIPS = @as(c_int, 45);
pub const ERR_LIB_CMS = @as(c_int, 46);
pub const ERR_LIB_TS = @as(c_int, 47);
pub const ERR_LIB_HMAC = @as(c_int, 48);
pub const ERR_LIB_CT = @as(c_int, 50);
pub const ERR_LIB_ASYNC = @as(c_int, 51);
pub const ERR_LIB_KDF = @as(c_int, 52);
pub const ERR_LIB_SM2 = @as(c_int, 53);
pub const ERR_LIB_ESS = @as(c_int, 54);
pub const ERR_LIB_PROP = @as(c_int, 55);
pub const ERR_LIB_CRMF = @as(c_int, 56);
pub const ERR_LIB_PROV = @as(c_int, 57);
pub const ERR_LIB_CMP = @as(c_int, 58);
pub const ERR_LIB_OSSL_ENCODER = @as(c_int, 59);
pub const ERR_LIB_OSSL_DECODER = @as(c_int, 60);
pub const ERR_LIB_HTTP = @as(c_int, 61);
pub const ERR_LIB_USER = @as(c_int, 128);
pub inline fn ASN1err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ASN1, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ASN1, r, NULL);
}
pub inline fn ASYNCerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ASYNC, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ASYNC, r, NULL);
}
pub inline fn BIOerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_BIO, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_BIO, r, NULL);
}
pub inline fn BNerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_BN, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_BN, r, NULL);
}
pub inline fn BUFerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_BUF, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_BUF, r, NULL);
}
pub inline fn CMPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CMP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CMP, r, NULL);
}
pub inline fn CMSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CMS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CMS, r, NULL);
}
pub inline fn COMPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_COMP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_COMP, r, NULL);
}
pub inline fn CONFerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CONF, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CONF, r, NULL);
}
pub inline fn CRMFerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CRMF, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CRMF, r, NULL);
}
pub inline fn CRYPTOerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CRYPTO, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CRYPTO, r, NULL);
}
pub inline fn CTerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CT, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CT, r, NULL);
}
pub inline fn DHerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_DH, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_DH, r, NULL);
}
pub inline fn DSAerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_DSA, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_DSA, r, NULL);
}
pub inline fn DSOerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_DSO, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_DSO, r, NULL);
}
pub inline fn ECDHerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ECDH, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ECDH, r, NULL);
}
pub inline fn ECDSAerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ECDSA, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ECDSA, r, NULL);
}
pub inline fn ECerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_EC, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_EC, r, NULL);
}
pub inline fn ENGINEerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ENGINE, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ENGINE, r, NULL);
}
pub inline fn ESSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ESS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ESS, r, NULL);
}
pub inline fn EVPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_EVP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_EVP, r, NULL);
}
pub inline fn FIPSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_FIPS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_FIPS, r, NULL);
}
pub inline fn HMACerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_HMAC, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_HMAC, r, NULL);
}
pub inline fn HTTPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_HTTP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_HTTP, r, NULL);
}
pub inline fn KDFerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_KDF, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_KDF, r, NULL);
}
pub inline fn OBJerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_OBJ, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_OBJ, r, NULL);
}
pub inline fn OCSPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_OCSP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_OCSP, r, NULL);
}
pub inline fn OSSL_STOREerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_OSSL_STORE, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_OSSL_STORE, r, NULL);
}
pub inline fn PEMerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PEM, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PEM, r, NULL);
}
pub inline fn PKCS12err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PKCS12, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PKCS12, r, NULL);
}
pub inline fn PKCS7err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PKCS7, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PKCS7, r, NULL);
}
pub inline fn PROPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PROP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PROP, r, NULL);
}
pub inline fn PROVerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PROV, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PROV, r, NULL);
}
pub inline fn RANDerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_RAND, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_RAND, r, NULL);
}
pub inline fn RSAerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_RSA, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_RSA, r, NULL);
}
pub inline fn SM2err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_SM2, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_SM2, r, NULL);
}
pub inline fn SSLerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_SSL, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_SSL, r, NULL);
}
pub inline fn SYSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_SYS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_SYS, r, NULL);
}
pub inline fn TSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_TS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_TS, r, NULL);
}
pub inline fn UIerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_UI, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_UI, r, NULL);
}
pub inline fn X509V3err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_X509V3, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_X509V3, r, NULL);
}
pub inline fn X509err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_X509, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_X509, r, NULL);
}
pub const ERR_SYSTEM_FLAG = @import("std").zig.c_translation.cast(c_uint, INT_MAX) + @as(c_int, 1);
pub const ERR_SYSTEM_MASK = @import("std").zig.c_translation.cast(c_uint, INT_MAX);
pub const ERR_LIB_OFFSET = @as(c_long, 23);
pub const ERR_LIB_MASK = @as(c_int, 0xFF);
pub const ERR_RFLAGS_OFFSET = @as(c_long, 18);
pub const ERR_RFLAGS_MASK = @as(c_int, 0x1F);
pub const ERR_REASON_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7FFFFF, .hex);
pub const ERR_RFLAG_FATAL = @as(c_int, 0x1) << ERR_RFLAGS_OFFSET;
pub const ERR_RFLAG_COMMON = @as(c_int, 0x2) << ERR_RFLAGS_OFFSET;
pub inline fn ERR_SYSTEM_ERROR(errcode: anytype) @TypeOf((errcode & ERR_SYSTEM_FLAG) != @as(c_int, 0)) {
    _ = &errcode;
    return (errcode & ERR_SYSTEM_FLAG) != @as(c_int, 0);
}
pub inline fn ERR_PACK(lib: anytype, func: anytype, reason: anytype) @TypeOf(((@import("std").zig.c_translation.cast(c_ulong, lib) & ERR_LIB_MASK) << ERR_LIB_OFFSET) | (@import("std").zig.c_translation.cast(c_ulong, reason) & ERR_REASON_MASK)) {
    _ = &lib;
    _ = &func;
    _ = &reason;
    return ((@import("std").zig.c_translation.cast(c_ulong, lib) & ERR_LIB_MASK) << ERR_LIB_OFFSET) | (@import("std").zig.c_translation.cast(c_ulong, reason) & ERR_REASON_MASK);
}
pub const SYS_F_FOPEN = @as(c_int, 0);
pub const SYS_F_CONNECT = @as(c_int, 0);
pub const SYS_F_GETSERVBYNAME = @as(c_int, 0);
pub const SYS_F_SOCKET = @as(c_int, 0);
pub const SYS_F_IOCTLSOCKET = @as(c_int, 0);
pub const SYS_F_BIND = @as(c_int, 0);
pub const SYS_F_LISTEN = @as(c_int, 0);
pub const SYS_F_ACCEPT = @as(c_int, 0);
pub const SYS_F_WSASTARTUP = @as(c_int, 0);
pub const SYS_F_OPENDIR = @as(c_int, 0);
pub const SYS_F_FREAD = @as(c_int, 0);
pub const SYS_F_GETADDRINFO = @as(c_int, 0);
pub const SYS_F_GETNAMEINFO = @as(c_int, 0);
pub const SYS_F_SETSOCKOPT = @as(c_int, 0);
pub const SYS_F_GETSOCKOPT = @as(c_int, 0);
pub const SYS_F_GETSOCKNAME = @as(c_int, 0);
pub const SYS_F_GETHOSTBYNAME = @as(c_int, 0);
pub const SYS_F_FFLUSH = @as(c_int, 0);
pub const SYS_F_OPEN = @as(c_int, 0);
pub const SYS_F_CLOSE = @as(c_int, 0);
pub const SYS_F_IOCTL = @as(c_int, 0);
pub const SYS_F_STAT = @as(c_int, 0);
pub const SYS_F_FCNTL = @as(c_int, 0);
pub const SYS_F_FSTAT = @as(c_int, 0);
pub const SYS_F_SENDFILE = @as(c_int, 0);
pub const ERR_R_SYS_LIB = ERR_LIB_SYS | ERR_RFLAG_COMMON;
pub const ERR_R_BN_LIB = ERR_LIB_BN | ERR_RFLAG_COMMON;
pub const ERR_R_RSA_LIB = ERR_LIB_RSA | ERR_RFLAG_COMMON;
pub const ERR_R_DH_LIB = ERR_LIB_DH | ERR_RFLAG_COMMON;
pub const ERR_R_EVP_LIB = ERR_LIB_EVP | ERR_RFLAG_COMMON;
pub const ERR_R_BUF_LIB = ERR_LIB_BUF | ERR_RFLAG_COMMON;
pub const ERR_R_OBJ_LIB = ERR_LIB_OBJ | ERR_RFLAG_COMMON;
pub const ERR_R_PEM_LIB = ERR_LIB_PEM | ERR_RFLAG_COMMON;
pub const ERR_R_DSA_LIB = ERR_LIB_DSA | ERR_RFLAG_COMMON;
pub const ERR_R_X509_LIB = ERR_LIB_X509 | ERR_RFLAG_COMMON;
pub const ERR_R_ASN1_LIB = ERR_LIB_ASN1 | ERR_RFLAG_COMMON;
pub const ERR_R_CONF_LIB = ERR_LIB_CONF | ERR_RFLAG_COMMON;
pub const ERR_R_CRYPTO_LIB = ERR_LIB_CRYPTO | ERR_RFLAG_COMMON;
pub const ERR_R_EC_LIB = ERR_LIB_EC | ERR_RFLAG_COMMON;
pub const ERR_R_SSL_LIB = ERR_LIB_SSL | ERR_RFLAG_COMMON;
pub const ERR_R_BIO_LIB = ERR_LIB_BIO | ERR_RFLAG_COMMON;
pub const ERR_R_PKCS7_LIB = ERR_LIB_PKCS7 | ERR_RFLAG_COMMON;
pub const ERR_R_X509V3_LIB = ERR_LIB_X509V3 | ERR_RFLAG_COMMON;
pub const ERR_R_PKCS12_LIB = ERR_LIB_PKCS12 | ERR_RFLAG_COMMON;
pub const ERR_R_RAND_LIB = ERR_LIB_RAND | ERR_RFLAG_COMMON;
pub const ERR_R_DSO_LIB = ERR_LIB_DSO | ERR_RFLAG_COMMON;
pub const ERR_R_ENGINE_LIB = ERR_LIB_ENGINE | ERR_RFLAG_COMMON;
pub const ERR_R_UI_LIB = ERR_LIB_UI | ERR_RFLAG_COMMON;
pub const ERR_R_ECDSA_LIB = ERR_LIB_ECDSA | ERR_RFLAG_COMMON;
pub const ERR_R_OSSL_STORE_LIB = ERR_LIB_OSSL_STORE | ERR_RFLAG_COMMON;
pub const ERR_R_CMS_LIB = ERR_LIB_CMS | ERR_RFLAG_COMMON;
pub const ERR_R_TS_LIB = ERR_LIB_TS | ERR_RFLAG_COMMON;
pub const ERR_R_CT_LIB = ERR_LIB_CT | ERR_RFLAG_COMMON;
pub const ERR_R_PROV_LIB = ERR_LIB_PROV | ERR_RFLAG_COMMON;
pub const ERR_R_ESS_LIB = ERR_LIB_ESS | ERR_RFLAG_COMMON;
pub const ERR_R_CMP_LIB = ERR_LIB_CMP | ERR_RFLAG_COMMON;
pub const ERR_R_OSSL_ENCODER_LIB = ERR_LIB_OSSL_ENCODER | ERR_RFLAG_COMMON;
pub const ERR_R_OSSL_DECODER_LIB = ERR_LIB_OSSL_DECODER | ERR_RFLAG_COMMON;
pub const ERR_R_FATAL = ERR_RFLAG_FATAL | ERR_RFLAG_COMMON;
pub const ERR_R_MALLOC_FAILURE = @as(c_int, 256) | ERR_R_FATAL;
pub const ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED = @as(c_int, 257) | ERR_R_FATAL;
pub const ERR_R_PASSED_NULL_PARAMETER = @as(c_int, 258) | ERR_R_FATAL;
pub const ERR_R_INTERNAL_ERROR = @as(c_int, 259) | ERR_R_FATAL;
pub const ERR_R_DISABLED = @as(c_int, 260) | ERR_R_FATAL;
pub const ERR_R_INIT_FAIL = @as(c_int, 261) | ERR_R_FATAL;
pub const ERR_R_PASSED_INVALID_ARGUMENT = @as(c_int, 262) | ERR_RFLAG_COMMON;
pub const ERR_R_OPERATION_FAIL = @as(c_int, 263) | ERR_R_FATAL;
pub const ERR_R_INVALID_PROVIDER_FUNCTIONS = @as(c_int, 264) | ERR_R_FATAL;
pub const ERR_R_INTERRUPTED_OR_CANCELLED = @as(c_int, 265) | ERR_RFLAG_COMMON;
pub const ERR_R_NESTED_ASN1_ERROR = @as(c_int, 266) | ERR_RFLAG_COMMON;
pub const ERR_R_MISSING_ASN1_EOS = @as(c_int, 267) | ERR_RFLAG_COMMON;
pub const ERR_R_UNSUPPORTED = @as(c_int, 268) | ERR_RFLAG_COMMON;
pub const ERR_R_FETCH_FAILED = @as(c_int, 269) | ERR_RFLAG_COMMON;
pub const ERR_R_INVALID_PROPERTY_DEFINITION = @as(c_int, 270) | ERR_RFLAG_COMMON;
pub const ERR_R_UNABLE_TO_GET_READ_LOCK = @as(c_int, 271) | ERR_R_FATAL;
pub const ERR_R_UNABLE_TO_GET_WRITE_LOCK = @as(c_int, 272) | ERR_R_FATAL;
pub const lh_ERR_STRING_DATA_new = @compileError("unable to translate C expr: unexpected token ')'");
// /opt/homebrew/opt/openssl@3/include/openssl/err.h:375:9
pub inline fn lh_ERR_STRING_DATA_free(lh: anytype) @TypeOf(OPENSSL_LH_free(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_free(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_flush(lh: anytype) @TypeOf(OPENSSL_LH_flush(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_flush(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_insert(lh: anytype, ptr: anytype) [*c]ERR_STRING_DATA {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ERR_STRING_DATA, OPENSSL_LH_insert(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_ERR_STRING_DATA_lh_plain_type(ptr)));
}
pub inline fn lh_ERR_STRING_DATA_delete(lh: anytype, ptr: anytype) [*c]ERR_STRING_DATA {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ERR_STRING_DATA, OPENSSL_LH_delete(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_const_ERR_STRING_DATA_lh_plain_type(ptr)));
}
pub inline fn lh_ERR_STRING_DATA_retrieve(lh: anytype, ptr: anytype) [*c]ERR_STRING_DATA {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ERR_STRING_DATA, OPENSSL_LH_retrieve(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_const_ERR_STRING_DATA_lh_plain_type(ptr)));
}
pub inline fn lh_ERR_STRING_DATA_error(lh: anytype) @TypeOf(OPENSSL_LH_error(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_error(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_num_items(lh: anytype) @TypeOf(OPENSSL_LH_num_items(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_num_items(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_node_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out);
}
pub inline fn lh_ERR_STRING_DATA_node_usage_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_usage_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_usage_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out);
}
pub inline fn lh_ERR_STRING_DATA_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out);
}
pub inline fn lh_ERR_STRING_DATA_get_down_load(lh: anytype) @TypeOf(OPENSSL_LH_get_down_load(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_get_down_load(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_set_down_load(lh: anytype, dl: anytype) @TypeOf(OPENSSL_LH_set_down_load(ossl_check_ERR_STRING_DATA_lh_type(lh), dl)) {
    _ = &lh;
    _ = &dl;
    return OPENSSL_LH_set_down_load(ossl_check_ERR_STRING_DATA_lh_type(lh), dl);
}
pub inline fn lh_ERR_STRING_DATA_doall(lh: anytype, dfn: anytype) @TypeOf(OPENSSL_LH_doall(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_ERR_STRING_DATA_lh_doallfunc_type(dfn))) {
    _ = &lh;
    _ = &dfn;
    return OPENSSL_LH_doall(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_ERR_STRING_DATA_lh_doallfunc_type(dfn));
}
pub const ERR_MAX_DATA_SIZE = @as(c_int, 1024);
pub inline fn ERR_raise(lib: anytype, reason: anytype) @TypeOf(ERR_raise_data(lib, reason, NULL)) {
    _ = &lib;
    _ = &reason;
    return ERR_raise_data(lib, reason, NULL);
}
pub const ERR_raise_data = blk_1: {
    _ = ERR_new();
    _ = ERR_set_debug(OPENSSL_FILE, OPENSSL_LINE, OPENSSL_FUNC);
    break :blk_1 ERR_set_error;
};
pub const ERR_put_error = @compileError("unable to translate C expr: expected ')' instead got 'line'");
// /opt/homebrew/opt/openssl@3/include/openssl/err.h:409:11
pub inline fn ERR_load_crypto_strings() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
}
pub const ERR_free_strings = @compileError("unable to translate C expr: unexpected token 'while'");
// /opt/homebrew/opt/openssl@3/include/openssl/err.h:482:10
pub const TLSSERVER_H = "";
pub const __darwin_pthread_handler_rec = struct___darwin_pthread_handler_rec;
pub const _opaque_pthread_attr_t = struct__opaque_pthread_attr_t;
pub const _opaque_pthread_cond_t = struct__opaque_pthread_cond_t;
pub const _opaque_pthread_condattr_t = struct__opaque_pthread_condattr_t;
pub const _opaque_pthread_mutex_t = struct__opaque_pthread_mutex_t;
pub const _opaque_pthread_mutexattr_t = struct__opaque_pthread_mutexattr_t;
pub const _opaque_pthread_once_t = struct__opaque_pthread_once_t;
pub const _opaque_pthread_rwlock_t = struct__opaque_pthread_rwlock_t;
pub const _opaque_pthread_rwlockattr_t = struct__opaque_pthread_rwlockattr_t;
pub const _opaque_pthread_t = struct__opaque_pthread_t;
pub const _OSUnalignedU16 = struct__OSUnalignedU16;
pub const _OSUnalignedU32 = struct__OSUnalignedU32;
pub const _OSUnalignedU64 = struct__OSUnalignedU64;
pub const timespec = struct_timespec;
pub const timeval = struct_timeval;
pub const timeval64 = struct_timeval64;
pub const itimerval = struct_itimerval;
pub const clockinfo = struct_clockinfo;
pub const tm = struct_tm;
pub const __darwin_arm_exception_state = struct___darwin_arm_exception_state;
pub const __darwin_arm_exception_state64 = struct___darwin_arm_exception_state64;
pub const __darwin_arm_thread_state = struct___darwin_arm_thread_state;
pub const __darwin_arm_thread_state64 = struct___darwin_arm_thread_state64;
pub const __darwin_arm_vfp_state = struct___darwin_arm_vfp_state;
pub const __darwin_arm_neon_state64 = struct___darwin_arm_neon_state64;
pub const __darwin_arm_neon_state = struct___darwin_arm_neon_state;
pub const __arm_pagein_state = struct___arm_pagein_state;
pub const __arm_legacy_debug_state = struct___arm_legacy_debug_state;
pub const __darwin_arm_debug_state32 = struct___darwin_arm_debug_state32;
pub const __darwin_arm_debug_state64 = struct___darwin_arm_debug_state64;
pub const __darwin_arm_cpmu_state64 = struct___darwin_arm_cpmu_state64;
pub const __darwin_mcontext32 = struct___darwin_mcontext32;
pub const __darwin_mcontext64 = struct___darwin_mcontext64;
pub const __darwin_sigaltstack = struct___darwin_sigaltstack;
pub const __darwin_ucontext = struct___darwin_ucontext;
pub const sigval = union_sigval;
pub const sigevent = struct_sigevent;
pub const __siginfo = struct___siginfo;
pub const __sigaction_u = union___sigaction_u;
pub const __sigaction = struct___sigaction;
pub const sigaction = struct_sigaction;
pub const sigvec = struct_sigvec;
pub const sigstack = struct_sigstack;
pub const rusage = struct_rusage;
pub const rusage_info_v0 = struct_rusage_info_v0;
pub const rusage_info_v1 = struct_rusage_info_v1;
pub const rusage_info_v2 = struct_rusage_info_v2;
pub const rusage_info_v3 = struct_rusage_info_v3;
pub const rusage_info_v4 = struct_rusage_info_v4;
pub const rusage_info_v5 = struct_rusage_info_v5;
pub const rusage_info_v6 = struct_rusage_info_v6;
pub const rlimit = struct_rlimit;
pub const proc_rlimit_control_wakeupmon = struct_proc_rlimit_control_wakeupmon;
pub const _malloc_zone_t = struct__malloc_zone_t;
pub const __sbuf = struct___sbuf;
pub const __sFILEX = struct___sFILEX;
pub const __sFILE = struct___sFILE;
pub const stack_st = struct_stack_st;
pub const stack_st_OPENSSL_STRING = struct_stack_st_OPENSSL_STRING;
pub const stack_st_OPENSSL_CSTRING = struct_stack_st_OPENSSL_CSTRING;
pub const stack_st_OPENSSL_BLOCK = struct_stack_st_OPENSSL_BLOCK;
pub const ossl_provider_st = struct_ossl_provider_st;
pub const asn1_string_st = struct_asn1_string_st;
pub const asn1_object_st = struct_asn1_object_st;
pub const ASN1_VALUE_st = struct_ASN1_VALUE_st;
pub const asn1_type_st = struct_asn1_type_st;
pub const asn1_string_table_st = struct_asn1_string_table_st;
pub const ASN1_ITEM_st = struct_ASN1_ITEM_st;
pub const asn1_pctx_st = struct_asn1_pctx_st;
pub const asn1_sctx_st = struct_asn1_sctx_st;
pub const bio_st = struct_bio_st;
pub const bignum_st = struct_bignum_st;
pub const bignum_ctx = struct_bignum_ctx;
pub const bn_blinding_st = struct_bn_blinding_st;
pub const bn_mont_ctx_st = struct_bn_mont_ctx_st;
pub const bn_recp_ctx_st = struct_bn_recp_ctx_st;
pub const bn_gencb_st = struct_bn_gencb_st;
pub const buf_mem_st = struct_buf_mem_st;
pub const stack_st_BIGNUM = struct_stack_st_BIGNUM;
pub const stack_st_BIGNUM_const = struct_stack_st_BIGNUM_const;
pub const err_state_st = struct_err_state_st;
pub const evp_cipher_st = struct_evp_cipher_st;
pub const evp_cipher_ctx_st = struct_evp_cipher_ctx_st;
pub const evp_md_st = struct_evp_md_st;
pub const evp_md_ctx_st = struct_evp_md_ctx_st;
pub const evp_mac_st = struct_evp_mac_st;
pub const evp_mac_ctx_st = struct_evp_mac_ctx_st;
pub const evp_pkey_st = struct_evp_pkey_st;
pub const evp_pkey_asn1_method_st = struct_evp_pkey_asn1_method_st;
pub const evp_pkey_method_st = struct_evp_pkey_method_st;
pub const evp_pkey_ctx_st = struct_evp_pkey_ctx_st;
pub const evp_keymgmt_st = struct_evp_keymgmt_st;
pub const evp_kdf_st = struct_evp_kdf_st;
pub const evp_kdf_ctx_st = struct_evp_kdf_ctx_st;
pub const evp_rand_st = struct_evp_rand_st;
pub const evp_rand_ctx_st = struct_evp_rand_ctx_st;
pub const evp_keyexch_st = struct_evp_keyexch_st;
pub const evp_signature_st = struct_evp_signature_st;
pub const evp_asym_cipher_st = struct_evp_asym_cipher_st;
pub const evp_kem_st = struct_evp_kem_st;
pub const evp_Encode_Ctx_st = struct_evp_Encode_Ctx_st;
pub const hmac_ctx_st = struct_hmac_ctx_st;
pub const dh_st = struct_dh_st;
pub const dh_method = struct_dh_method;
pub const dsa_st = struct_dsa_st;
pub const dsa_method = struct_dsa_method;
pub const rsa_st = struct_rsa_st;
pub const rsa_meth_st = struct_rsa_meth_st;
pub const X509_algor_st = struct_X509_algor_st;
pub const rsa_pss_params_st = struct_rsa_pss_params_st;
pub const ec_key_st = struct_ec_key_st;
pub const ec_key_method_st = struct_ec_key_method_st;
pub const rand_meth_st = struct_rand_meth_st;
pub const rand_drbg_st = struct_rand_drbg_st;
pub const ssl_dane_st = struct_ssl_dane_st;
pub const x509_st = struct_x509_st;
pub const X509_crl_st = struct_X509_crl_st;
pub const x509_crl_method_st = struct_x509_crl_method_st;
pub const x509_revoked_st = struct_x509_revoked_st;
pub const X509_name_st = struct_X509_name_st;
pub const X509_pubkey_st = struct_X509_pubkey_st;
pub const x509_store_st = struct_x509_store_st;
pub const x509_store_ctx_st = struct_x509_store_ctx_st;
pub const x509_object_st = struct_x509_object_st;
pub const x509_lookup_st = struct_x509_lookup_st;
pub const x509_lookup_method_st = struct_x509_lookup_method_st;
pub const X509_VERIFY_PARAM_st = struct_X509_VERIFY_PARAM_st;
pub const x509_sig_info_st = struct_x509_sig_info_st;
pub const pkcs8_priv_key_info_st = struct_pkcs8_priv_key_info_st;
pub const v3_ext_ctx = struct_v3_ext_ctx;
pub const conf_method_st = struct_conf_method_st;
pub const lhash_st_CONF_VALUE = struct_lhash_st_CONF_VALUE;
pub const ossl_lib_ctx_st = struct_ossl_lib_ctx_st;
pub const conf_st = struct_conf_st;
pub const ossl_init_settings_st = struct_ossl_init_settings_st;
pub const ui_st = struct_ui_st;
pub const ui_method_st = struct_ui_method_st;
pub const engine_st = struct_engine_st;
pub const ssl_st = struct_ssl_st;
pub const ssl_ctx_st = struct_ssl_ctx_st;
pub const comp_ctx_st = struct_comp_ctx_st;
pub const comp_method_st = struct_comp_method_st;
pub const X509_POLICY_NODE_st = struct_X509_POLICY_NODE_st;
pub const X509_POLICY_LEVEL_st = struct_X509_POLICY_LEVEL_st;
pub const X509_POLICY_TREE_st = struct_X509_POLICY_TREE_st;
pub const X509_POLICY_CACHE_st = struct_X509_POLICY_CACHE_st;
pub const AUTHORITY_KEYID_st = struct_AUTHORITY_KEYID_st;
pub const DIST_POINT_st = struct_DIST_POINT_st;
pub const ISSUING_DIST_POINT_st = struct_ISSUING_DIST_POINT_st;
pub const NAME_CONSTRAINTS_st = struct_NAME_CONSTRAINTS_st;
pub const stack_st_void = struct_stack_st_void;
pub const crypto_ex_data_st = struct_crypto_ex_data_st;
pub const ossl_http_req_ctx_st = struct_ossl_http_req_ctx_st;
pub const ocsp_response_st = struct_ocsp_response_st;
pub const ocsp_responder_id_st = struct_ocsp_responder_id_st;
pub const sct_st = struct_sct_st;
pub const sct_ctx_st = struct_sct_ctx_st;
pub const ctlog_st = struct_ctlog_st;
pub const ctlog_store_st = struct_ctlog_store_st;
pub const ct_policy_eval_ctx_st = struct_ct_policy_eval_ctx_st;
pub const ossl_store_info_st = struct_ossl_store_info_st;
pub const ossl_store_search_st = struct_ossl_store_search_st;
pub const ossl_dispatch_st = struct_ossl_dispatch_st;
pub const ossl_item_st = struct_ossl_item_st;
pub const ossl_algorithm_st = struct_ossl_algorithm_st;
pub const ossl_param_st = struct_ossl_param_st;
pub const ossl_param_bld_st = struct_ossl_param_bld_st;
pub const ossl_encoder_st = struct_ossl_encoder_st;
pub const ossl_encoder_ctx_st = struct_ossl_encoder_ctx_st;
pub const ossl_decoder_st = struct_ossl_decoder_st;
pub const ossl_decoder_ctx_st = struct_ossl_decoder_ctx_st;
pub const ossl_self_test_st = struct_ossl_self_test_st;
pub const ossl_core_handle_st = struct_ossl_core_handle_st;
pub const openssl_core_ctx_st = struct_openssl_core_ctx_st;
pub const ossl_core_bio_st = struct_ossl_core_bio_st;
pub const crypto_threadid_st = struct_crypto_threadid_st;
pub const sched_param = struct_sched_param;
pub const pthread_override_s = struct_pthread_override_s;
pub const ssl_comp_st = struct_ssl_comp_st;
pub const stack_st_SSL_COMP = struct_stack_st_SSL_COMP;
pub const bio_addr_st = union_bio_addr_st;
pub const bio_addrinfo_st = struct_bio_addrinfo_st;
pub const bio_method_st = struct_bio_method_st;
pub const stack_st_BIO = struct_stack_st_BIO;
pub const bio_msg_st = struct_bio_msg_st;
pub const bio_mmsg_cb_args_st = struct_bio_mmsg_cb_args_st;
pub const bio_poll_descriptor_st = struct_bio_poll_descriptor_st;
pub const BIO_hostserv_priorities = enum_BIO_hostserv_priorities;
pub const BIO_lookup_type = enum_BIO_lookup_type;
pub const hostent = struct_hostent;
pub const BIO_sock_info_u = union_BIO_sock_info_u;
pub const BIO_sock_info_type = enum_BIO_sock_info_type;
pub const stack_st_X509_ALGOR = struct_stack_st_X509_ALGOR;
pub const ASN1_ENCODING_st = struct_ASN1_ENCODING_st;
pub const stack_st_ASN1_STRING_TABLE = struct_stack_st_ASN1_STRING_TABLE;
pub const ASN1_TEMPLATE_st = struct_ASN1_TEMPLATE_st;
pub const ASN1_TLC_st = struct_ASN1_TLC_st;
pub const stack_st_ASN1_TYPE = struct_stack_st_ASN1_TYPE;
pub const BIT_STRING_BITNAME_st = struct_BIT_STRING_BITNAME_st;
pub const stack_st_ASN1_OBJECT = struct_stack_st_ASN1_OBJECT;
pub const stack_st_ASN1_INTEGER = struct_stack_st_ASN1_INTEGER;
pub const stack_st_ASN1_UTF8STRING = struct_stack_st_ASN1_UTF8STRING;
pub const stack_st_ASN1_GENERALSTRING = struct_stack_st_ASN1_GENERALSTRING;
pub const obj_name_st = struct_obj_name_st;
pub const evp_cipher_info_st = struct_evp_cipher_info_st;
pub const ec_method_st = struct_ec_method_st;
pub const ec_group_st = struct_ec_group_st;
pub const ec_point_st = struct_ec_point_st;
pub const ecpk_parameters_st = struct_ecpk_parameters_st;
pub const ec_parameters_st = struct_ec_parameters_st;
pub const ECDSA_SIG_st = struct_ECDSA_SIG_st;
pub const rsa_oaep_params_st = struct_rsa_oaep_params_st;
pub const DSA_SIG_st = struct_DSA_SIG_st;
pub const SHAstate_st = struct_SHAstate_st;
pub const SHA256state_st = struct_SHA256state_st;
pub const SHA512state_st = struct_SHA512state_st;
pub const stack_st_X509_NAME = struct_stack_st_X509_NAME;
pub const stack_st_X509 = struct_stack_st_X509;
pub const stack_st_X509_REVOKED = struct_stack_st_X509_REVOKED;
pub const stack_st_X509_CRL = struct_stack_st_X509_CRL;
pub const X509_val_st = struct_X509_val_st;
pub const X509_sig_st = struct_X509_sig_st;
pub const X509_name_entry_st = struct_X509_name_entry_st;
pub const stack_st_X509_NAME_ENTRY = struct_stack_st_X509_NAME_ENTRY;
pub const X509_extension_st = struct_X509_extension_st;
pub const stack_st_X509_EXTENSION = struct_stack_st_X509_EXTENSION;
pub const x509_attributes_st = struct_x509_attributes_st;
pub const stack_st_X509_ATTRIBUTE = struct_stack_st_X509_ATTRIBUTE;
pub const X509_req_info_st = struct_X509_req_info_st;
pub const X509_req_st = struct_X509_req_st;
pub const x509_cert_aux_st = struct_x509_cert_aux_st;
pub const x509_cinf_st = struct_x509_cinf_st;
pub const X509_crl_info_st = struct_X509_crl_info_st;
pub const private_key_st = struct_private_key_st;
pub const X509_info_st = struct_X509_info_st;
pub const stack_st_X509_INFO = struct_stack_st_X509_INFO;
pub const Netscape_spkac_st = struct_Netscape_spkac_st;
pub const Netscape_spki_st = struct_Netscape_spki_st;
pub const Netscape_certificate_sequence = struct_Netscape_certificate_sequence;
pub const PBEPARAM_st = struct_PBEPARAM_st;
pub const PBE2PARAM_st = struct_PBE2PARAM_st;
pub const PBKDF2PARAM_st = struct_PBKDF2PARAM_st;
pub const SCRYPT_PARAMS_st = struct_SCRYPT_PARAMS_st;
pub const lhash_node_st = struct_lhash_node_st;
pub const lhash_st = struct_lhash_st;
pub const lhash_st_OPENSSL_STRING = struct_lhash_st_OPENSSL_STRING;
pub const lhash_st_OPENSSL_CSTRING = struct_lhash_st_OPENSSL_CSTRING;
pub const stack_st_X509_LOOKUP = struct_stack_st_X509_LOOKUP;
pub const stack_st_X509_OBJECT = struct_stack_st_X509_OBJECT;
pub const stack_st_X509_VERIFY_PARAM = struct_stack_st_X509_VERIFY_PARAM;
pub const x509_trust_st = struct_x509_trust_st;
pub const stack_st_X509_TRUST = struct_stack_st_X509_TRUST;
pub const stack_st_X509_POLICY_NODE = struct_stack_st_X509_POLICY_NODE;
pub const stack_st_POLICYQUALINFO = struct_stack_st_POLICYQUALINFO;
pub const PKCS7_CTX_st = struct_PKCS7_CTX_st;
pub const pkcs7_issuer_and_serial_st = struct_pkcs7_issuer_and_serial_st;
pub const pkcs7_signer_info_st = struct_pkcs7_signer_info_st;
pub const stack_st_PKCS7_SIGNER_INFO = struct_stack_st_PKCS7_SIGNER_INFO;
pub const pkcs7_recip_info_st = struct_pkcs7_recip_info_st;
pub const stack_st_PKCS7_RECIP_INFO = struct_stack_st_PKCS7_RECIP_INFO;
pub const pkcs7_enc_content_st = struct_pkcs7_enc_content_st;
pub const pkcs7_enveloped_st = struct_pkcs7_enveloped_st;
pub const pkcs7_signedandenveloped_st = struct_pkcs7_signedandenveloped_st;
pub const pkcs7_digest_st = struct_pkcs7_digest_st;
pub const pkcs7_encrypted_st = struct_pkcs7_encrypted_st;
pub const pkcs7_st = struct_pkcs7_st;
pub const pkcs7_signed_st = struct_pkcs7_signed_st;
pub const stack_st_PKCS7 = struct_stack_st_PKCS7;
pub const stack_st_CONF_VALUE = struct_stack_st_CONF_VALUE;
pub const conf_imodule_st = struct_conf_imodule_st;
pub const conf_module_st = struct_conf_module_st;
pub const stack_st_CONF_MODULE = struct_stack_st_CONF_MODULE;
pub const stack_st_CONF_IMODULE = struct_stack_st_CONF_IMODULE;
pub const async_job_st = struct_async_job_st;
pub const async_wait_ctx_st = struct_async_wait_ctx_st;
pub const stack_st_SCT = struct_stack_st_SCT;
pub const stack_st_CTLOG = struct_stack_st_CTLOG;
pub const tls_session_ticket_ext_st = struct_tls_session_ticket_ext_st;
pub const ssl_method_st = struct_ssl_method_st;
pub const ssl_cipher_st = struct_ssl_cipher_st;
pub const ssl_session_st = struct_ssl_session_st;
pub const tls_sigalgs_st = struct_tls_sigalgs_st;
pub const ssl_conf_ctx_st = struct_ssl_conf_ctx_st;
pub const stack_st_SSL_CIPHER = struct_stack_st_SSL_CIPHER;
pub const srtp_protection_profile_st = struct_srtp_protection_profile_st;
pub const stack_st_SRTP_PROTECTION_PROFILE = struct_stack_st_SRTP_PROTECTION_PROFILE;
pub const lhash_st_SSL_SESSION = struct_lhash_st_SSL_SESSION;
pub const ssl_shutdown_ex_args_st = struct_ssl_shutdown_ex_args_st;
pub const ssl_stream_reset_args_st = struct_ssl_stream_reset_args_st;
pub const ssl_conn_close_info_st = struct_ssl_conn_close_info_st;
pub const ssl_poll_item_st = struct_ssl_poll_item_st;
pub const ERR_string_data_st = struct_ERR_string_data_st;
pub const lhash_st_ERR_STRING_DATA = struct_lhash_st_ERR_STRING_DATA;
